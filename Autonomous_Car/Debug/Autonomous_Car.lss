
Autonomous_Car.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008eca  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000122  00800060  00008eca  00008f5e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004a1  00800182  00800182  00009080  2**0
                  ALLOC
  3 .stab         0000cef4  00000000  00000000  00009080  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000060e6  00000000  00000000  00015f74  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  0001c05a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000232  00000000  00000000  0001c23a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002891  00000000  00000000  0001c46c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001628  00000000  00000000  0001ecfd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000013de  00000000  00000000  00020325  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000200  00000000  00000000  00021704  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000030f  00000000  00000000  00021904  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000a56  00000000  00000000  00021c13  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00022669  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 2b 18 	jmp	0x3056	; 0x3056 <__vector_1>
       8:	0c 94 5e 18 	jmp	0x30bc	; 0x30bc <__vector_2>
       c:	0c 94 91 18 	jmp	0x3122	; 0x3122 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 6a 10 	jmp	0x20d4	; 0x20d4 <__vector_6>
      1c:	0c 94 db 30 	jmp	0x61b6	; 0x61b6 <__vector_7>
      20:	0c 94 37 10 	jmp	0x206e	; 0x206e <__vector_8>
      24:	0c 94 04 10 	jmp	0x2008	; 0x2008 <__vector_9>
      28:	0c 94 57 14 	jmp	0x28ae	; 0x28ae <__vector_10>
      2c:	0c 94 24 14 	jmp	0x2848	; 0x2848 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 d7 1e 	jmp	0x3dae	; 0x3dae <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ec       	ldi	r30, 0xCA	; 202
      68:	fe e8       	ldi	r31, 0x8E	; 142
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 32       	cpi	r26, 0x23	; 35
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6a 46 	call	0x8cd4	; 0x8cd4 <main>
      8a:	0c 94 63 47 	jmp	0x8ec6	; 0x8ec6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 de 46 	jmp	0x8dbc	; 0x8dbc <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e6       	ldi	r26, 0x65	; 101
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 fa 46 	jmp	0x8df4	; 0x8df4 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 ea 46 	jmp	0x8dd4	; 0x8dd4 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 06 47 	jmp	0x8e0c	; 0x8e0c <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 ea 46 	jmp	0x8dd4	; 0x8dd4 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 06 47 	jmp	0x8e0c	; 0x8e0c <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 de 46 	jmp	0x8dbc	; 0x8dbc <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e6       	ldi	r24, 0x65	; 101
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 fa 46 	jmp	0x8df4	; 0x8df4 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 e6 46 	jmp	0x8dcc	; 0x8dcc <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	65 e6       	ldi	r22, 0x65	; 101
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 02 47 	jmp	0x8e04	; 0x8e04 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 ea 46 	jmp	0x8dd4	; 0x8dd4 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 06 47 	jmp	0x8e0c	; 0x8e0c <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 ea 46 	jmp	0x8dd4	; 0x8dd4 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 06 47 	jmp	0x8e0c	; 0x8e0c <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 ea 46 	jmp	0x8dd4	; 0x8dd4 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 06 47 	jmp	0x8e0c	; 0x8e0c <__epilogue_restores__+0x18>

000008aa <__lesf2>:
     8aa:	a8 e1       	ldi	r26, 0x18	; 24
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 ea 46 	jmp	0x8dd4	; 0x8dd4 <__prologue_saves__+0x18>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	2d 83       	std	Y+5, r18	; 0x05
     8c0:	3e 83       	std	Y+6, r19	; 0x06
     8c2:	4f 83       	std	Y+7, r20	; 0x07
     8c4:	58 87       	std	Y+8, r21	; 0x08
     8c6:	89 e0       	ldi	r24, 0x09	; 9
     8c8:	e8 2e       	mov	r14, r24
     8ca:	f1 2c       	mov	r15, r1
     8cc:	ec 0e       	add	r14, r28
     8ce:	fd 1e       	adc	r15, r29
     8d0:	ce 01       	movw	r24, r28
     8d2:	01 96       	adiw	r24, 0x01	; 1
     8d4:	b7 01       	movw	r22, r14
     8d6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     8da:	8e 01       	movw	r16, r28
     8dc:	0f 5e       	subi	r16, 0xEF	; 239
     8de:	1f 4f       	sbci	r17, 0xFF	; 255
     8e0:	ce 01       	movw	r24, r28
     8e2:	05 96       	adiw	r24, 0x05	; 5
     8e4:	b8 01       	movw	r22, r16
     8e6:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     8ea:	89 85       	ldd	r24, Y+9	; 0x09
     8ec:	82 30       	cpi	r24, 0x02	; 2
     8ee:	40 f0       	brcs	.+16     	; 0x900 <__lesf2+0x56>
     8f0:	89 89       	ldd	r24, Y+17	; 0x11
     8f2:	82 30       	cpi	r24, 0x02	; 2
     8f4:	28 f0       	brcs	.+10     	; 0x900 <__lesf2+0x56>
     8f6:	c7 01       	movw	r24, r14
     8f8:	b8 01       	movw	r22, r16
     8fa:	0e 94 4c 07 	call	0xe98	; 0xe98 <__fpcmp_parts_f>
     8fe:	01 c0       	rjmp	.+2      	; 0x902 <__lesf2+0x58>
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	68 96       	adiw	r28, 0x18	; 24
     904:	e6 e0       	ldi	r30, 0x06	; 6
     906:	0c 94 06 47 	jmp	0x8e0c	; 0x8e0c <__epilogue_restores__+0x18>

0000090a <__floatsisf>:
     90a:	a8 e0       	ldi	r26, 0x08	; 8
     90c:	b0 e0       	ldi	r27, 0x00	; 0
     90e:	eb e8       	ldi	r30, 0x8B	; 139
     910:	f4 e0       	ldi	r31, 0x04	; 4
     912:	0c 94 e7 46 	jmp	0x8dce	; 0x8dce <__prologue_saves__+0x12>
     916:	9b 01       	movw	r18, r22
     918:	ac 01       	movw	r20, r24
     91a:	83 e0       	ldi	r24, 0x03	; 3
     91c:	89 83       	std	Y+1, r24	; 0x01
     91e:	da 01       	movw	r26, r20
     920:	c9 01       	movw	r24, r18
     922:	88 27       	eor	r24, r24
     924:	b7 fd       	sbrc	r27, 7
     926:	83 95       	inc	r24
     928:	99 27       	eor	r25, r25
     92a:	aa 27       	eor	r26, r26
     92c:	bb 27       	eor	r27, r27
     92e:	b8 2e       	mov	r11, r24
     930:	21 15       	cp	r18, r1
     932:	31 05       	cpc	r19, r1
     934:	41 05       	cpc	r20, r1
     936:	51 05       	cpc	r21, r1
     938:	19 f4       	brne	.+6      	; 0x940 <__floatsisf+0x36>
     93a:	82 e0       	ldi	r24, 0x02	; 2
     93c:	89 83       	std	Y+1, r24	; 0x01
     93e:	3a c0       	rjmp	.+116    	; 0x9b4 <__floatsisf+0xaa>
     940:	88 23       	and	r24, r24
     942:	a9 f0       	breq	.+42     	; 0x96e <__floatsisf+0x64>
     944:	20 30       	cpi	r18, 0x00	; 0
     946:	80 e0       	ldi	r24, 0x00	; 0
     948:	38 07       	cpc	r19, r24
     94a:	80 e0       	ldi	r24, 0x00	; 0
     94c:	48 07       	cpc	r20, r24
     94e:	80 e8       	ldi	r24, 0x80	; 128
     950:	58 07       	cpc	r21, r24
     952:	29 f4       	brne	.+10     	; 0x95e <__floatsisf+0x54>
     954:	60 e0       	ldi	r22, 0x00	; 0
     956:	70 e0       	ldi	r23, 0x00	; 0
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	9f ec       	ldi	r25, 0xCF	; 207
     95c:	30 c0       	rjmp	.+96     	; 0x9be <__floatsisf+0xb4>
     95e:	ee 24       	eor	r14, r14
     960:	ff 24       	eor	r15, r15
     962:	87 01       	movw	r16, r14
     964:	e2 1a       	sub	r14, r18
     966:	f3 0a       	sbc	r15, r19
     968:	04 0b       	sbc	r16, r20
     96a:	15 0b       	sbc	r17, r21
     96c:	02 c0       	rjmp	.+4      	; 0x972 <__floatsisf+0x68>
     96e:	79 01       	movw	r14, r18
     970:	8a 01       	movw	r16, r20
     972:	8e e1       	ldi	r24, 0x1E	; 30
     974:	c8 2e       	mov	r12, r24
     976:	d1 2c       	mov	r13, r1
     978:	dc 82       	std	Y+4, r13	; 0x04
     97a:	cb 82       	std	Y+3, r12	; 0x03
     97c:	ed 82       	std	Y+5, r14	; 0x05
     97e:	fe 82       	std	Y+6, r15	; 0x06
     980:	0f 83       	std	Y+7, r16	; 0x07
     982:	18 87       	std	Y+8, r17	; 0x08
     984:	c8 01       	movw	r24, r16
     986:	b7 01       	movw	r22, r14
     988:	0e 94 b0 05 	call	0xb60	; 0xb60 <__clzsi2>
     98c:	01 97       	sbiw	r24, 0x01	; 1
     98e:	18 16       	cp	r1, r24
     990:	19 06       	cpc	r1, r25
     992:	84 f4       	brge	.+32     	; 0x9b4 <__floatsisf+0xaa>
     994:	08 2e       	mov	r0, r24
     996:	04 c0       	rjmp	.+8      	; 0x9a0 <__floatsisf+0x96>
     998:	ee 0c       	add	r14, r14
     99a:	ff 1c       	adc	r15, r15
     99c:	00 1f       	adc	r16, r16
     99e:	11 1f       	adc	r17, r17
     9a0:	0a 94       	dec	r0
     9a2:	d2 f7       	brpl	.-12     	; 0x998 <__floatsisf+0x8e>
     9a4:	ed 82       	std	Y+5, r14	; 0x05
     9a6:	fe 82       	std	Y+6, r15	; 0x06
     9a8:	0f 83       	std	Y+7, r16	; 0x07
     9aa:	18 87       	std	Y+8, r17	; 0x08
     9ac:	c8 1a       	sub	r12, r24
     9ae:	d9 0a       	sbc	r13, r25
     9b0:	dc 82       	std	Y+4, r13	; 0x04
     9b2:	cb 82       	std	Y+3, r12	; 0x03
     9b4:	ba 82       	std	Y+2, r11	; 0x02
     9b6:	ce 01       	movw	r24, r28
     9b8:	01 96       	adiw	r24, 0x01	; 1
     9ba:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     9be:	28 96       	adiw	r28, 0x08	; 8
     9c0:	e9 e0       	ldi	r30, 0x09	; 9
     9c2:	0c 94 03 47 	jmp	0x8e06	; 0x8e06 <__epilogue_restores__+0x12>

000009c6 <__fixsfsi>:
     9c6:	ac e0       	ldi	r26, 0x0C	; 12
     9c8:	b0 e0       	ldi	r27, 0x00	; 0
     9ca:	e9 ee       	ldi	r30, 0xE9	; 233
     9cc:	f4 e0       	ldi	r31, 0x04	; 4
     9ce:	0c 94 ee 46 	jmp	0x8ddc	; 0x8ddc <__prologue_saves__+0x20>
     9d2:	69 83       	std	Y+1, r22	; 0x01
     9d4:	7a 83       	std	Y+2, r23	; 0x02
     9d6:	8b 83       	std	Y+3, r24	; 0x03
     9d8:	9c 83       	std	Y+4, r25	; 0x04
     9da:	ce 01       	movw	r24, r28
     9dc:	01 96       	adiw	r24, 0x01	; 1
     9de:	be 01       	movw	r22, r28
     9e0:	6b 5f       	subi	r22, 0xFB	; 251
     9e2:	7f 4f       	sbci	r23, 0xFF	; 255
     9e4:	0e 94 d4 06 	call	0xda8	; 0xda8 <__unpack_f>
     9e8:	8d 81       	ldd	r24, Y+5	; 0x05
     9ea:	82 30       	cpi	r24, 0x02	; 2
     9ec:	61 f1       	breq	.+88     	; 0xa46 <__fixsfsi+0x80>
     9ee:	82 30       	cpi	r24, 0x02	; 2
     9f0:	50 f1       	brcs	.+84     	; 0xa46 <__fixsfsi+0x80>
     9f2:	84 30       	cpi	r24, 0x04	; 4
     9f4:	21 f4       	brne	.+8      	; 0x9fe <__fixsfsi+0x38>
     9f6:	8e 81       	ldd	r24, Y+6	; 0x06
     9f8:	88 23       	and	r24, r24
     9fa:	51 f1       	breq	.+84     	; 0xa50 <__fixsfsi+0x8a>
     9fc:	2e c0       	rjmp	.+92     	; 0xa5a <__fixsfsi+0x94>
     9fe:	2f 81       	ldd	r18, Y+7	; 0x07
     a00:	38 85       	ldd	r19, Y+8	; 0x08
     a02:	37 fd       	sbrc	r19, 7
     a04:	20 c0       	rjmp	.+64     	; 0xa46 <__fixsfsi+0x80>
     a06:	6e 81       	ldd	r22, Y+6	; 0x06
     a08:	2f 31       	cpi	r18, 0x1F	; 31
     a0a:	31 05       	cpc	r19, r1
     a0c:	1c f0       	brlt	.+6      	; 0xa14 <__fixsfsi+0x4e>
     a0e:	66 23       	and	r22, r22
     a10:	f9 f0       	breq	.+62     	; 0xa50 <__fixsfsi+0x8a>
     a12:	23 c0       	rjmp	.+70     	; 0xa5a <__fixsfsi+0x94>
     a14:	8e e1       	ldi	r24, 0x1E	; 30
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	82 1b       	sub	r24, r18
     a1a:	93 0b       	sbc	r25, r19
     a1c:	29 85       	ldd	r18, Y+9	; 0x09
     a1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     a20:	4b 85       	ldd	r20, Y+11	; 0x0b
     a22:	5c 85       	ldd	r21, Y+12	; 0x0c
     a24:	04 c0       	rjmp	.+8      	; 0xa2e <__fixsfsi+0x68>
     a26:	56 95       	lsr	r21
     a28:	47 95       	ror	r20
     a2a:	37 95       	ror	r19
     a2c:	27 95       	ror	r18
     a2e:	8a 95       	dec	r24
     a30:	d2 f7       	brpl	.-12     	; 0xa26 <__fixsfsi+0x60>
     a32:	66 23       	and	r22, r22
     a34:	b1 f0       	breq	.+44     	; 0xa62 <__fixsfsi+0x9c>
     a36:	50 95       	com	r21
     a38:	40 95       	com	r20
     a3a:	30 95       	com	r19
     a3c:	21 95       	neg	r18
     a3e:	3f 4f       	sbci	r19, 0xFF	; 255
     a40:	4f 4f       	sbci	r20, 0xFF	; 255
     a42:	5f 4f       	sbci	r21, 0xFF	; 255
     a44:	0e c0       	rjmp	.+28     	; 0xa62 <__fixsfsi+0x9c>
     a46:	20 e0       	ldi	r18, 0x00	; 0
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	40 e0       	ldi	r20, 0x00	; 0
     a4c:	50 e0       	ldi	r21, 0x00	; 0
     a4e:	09 c0       	rjmp	.+18     	; 0xa62 <__fixsfsi+0x9c>
     a50:	2f ef       	ldi	r18, 0xFF	; 255
     a52:	3f ef       	ldi	r19, 0xFF	; 255
     a54:	4f ef       	ldi	r20, 0xFF	; 255
     a56:	5f e7       	ldi	r21, 0x7F	; 127
     a58:	04 c0       	rjmp	.+8      	; 0xa62 <__fixsfsi+0x9c>
     a5a:	20 e0       	ldi	r18, 0x00	; 0
     a5c:	30 e0       	ldi	r19, 0x00	; 0
     a5e:	40 e0       	ldi	r20, 0x00	; 0
     a60:	50 e8       	ldi	r21, 0x80	; 128
     a62:	b9 01       	movw	r22, r18
     a64:	ca 01       	movw	r24, r20
     a66:	2c 96       	adiw	r28, 0x0c	; 12
     a68:	e2 e0       	ldi	r30, 0x02	; 2
     a6a:	0c 94 0a 47 	jmp	0x8e14	; 0x8e14 <__epilogue_restores__+0x20>

00000a6e <__floatunsisf>:
     a6e:	a8 e0       	ldi	r26, 0x08	; 8
     a70:	b0 e0       	ldi	r27, 0x00	; 0
     a72:	ed e3       	ldi	r30, 0x3D	; 61
     a74:	f5 e0       	ldi	r31, 0x05	; 5
     a76:	0c 94 e6 46 	jmp	0x8dcc	; 0x8dcc <__prologue_saves__+0x10>
     a7a:	7b 01       	movw	r14, r22
     a7c:	8c 01       	movw	r16, r24
     a7e:	61 15       	cp	r22, r1
     a80:	71 05       	cpc	r23, r1
     a82:	81 05       	cpc	r24, r1
     a84:	91 05       	cpc	r25, r1
     a86:	19 f4       	brne	.+6      	; 0xa8e <__floatunsisf+0x20>
     a88:	82 e0       	ldi	r24, 0x02	; 2
     a8a:	89 83       	std	Y+1, r24	; 0x01
     a8c:	60 c0       	rjmp	.+192    	; 0xb4e <__floatunsisf+0xe0>
     a8e:	83 e0       	ldi	r24, 0x03	; 3
     a90:	89 83       	std	Y+1, r24	; 0x01
     a92:	8e e1       	ldi	r24, 0x1E	; 30
     a94:	c8 2e       	mov	r12, r24
     a96:	d1 2c       	mov	r13, r1
     a98:	dc 82       	std	Y+4, r13	; 0x04
     a9a:	cb 82       	std	Y+3, r12	; 0x03
     a9c:	ed 82       	std	Y+5, r14	; 0x05
     a9e:	fe 82       	std	Y+6, r15	; 0x06
     aa0:	0f 83       	std	Y+7, r16	; 0x07
     aa2:	18 87       	std	Y+8, r17	; 0x08
     aa4:	c8 01       	movw	r24, r16
     aa6:	b7 01       	movw	r22, r14
     aa8:	0e 94 b0 05 	call	0xb60	; 0xb60 <__clzsi2>
     aac:	fc 01       	movw	r30, r24
     aae:	31 97       	sbiw	r30, 0x01	; 1
     ab0:	f7 ff       	sbrs	r31, 7
     ab2:	3b c0       	rjmp	.+118    	; 0xb2a <__floatunsisf+0xbc>
     ab4:	22 27       	eor	r18, r18
     ab6:	33 27       	eor	r19, r19
     ab8:	2e 1b       	sub	r18, r30
     aba:	3f 0b       	sbc	r19, r31
     abc:	57 01       	movw	r10, r14
     abe:	68 01       	movw	r12, r16
     ac0:	02 2e       	mov	r0, r18
     ac2:	04 c0       	rjmp	.+8      	; 0xacc <__floatunsisf+0x5e>
     ac4:	d6 94       	lsr	r13
     ac6:	c7 94       	ror	r12
     ac8:	b7 94       	ror	r11
     aca:	a7 94       	ror	r10
     acc:	0a 94       	dec	r0
     ace:	d2 f7       	brpl	.-12     	; 0xac4 <__floatunsisf+0x56>
     ad0:	40 e0       	ldi	r20, 0x00	; 0
     ad2:	50 e0       	ldi	r21, 0x00	; 0
     ad4:	60 e0       	ldi	r22, 0x00	; 0
     ad6:	70 e0       	ldi	r23, 0x00	; 0
     ad8:	81 e0       	ldi	r24, 0x01	; 1
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	a0 e0       	ldi	r26, 0x00	; 0
     ade:	b0 e0       	ldi	r27, 0x00	; 0
     ae0:	04 c0       	rjmp	.+8      	; 0xaea <__floatunsisf+0x7c>
     ae2:	88 0f       	add	r24, r24
     ae4:	99 1f       	adc	r25, r25
     ae6:	aa 1f       	adc	r26, r26
     ae8:	bb 1f       	adc	r27, r27
     aea:	2a 95       	dec	r18
     aec:	d2 f7       	brpl	.-12     	; 0xae2 <__floatunsisf+0x74>
     aee:	01 97       	sbiw	r24, 0x01	; 1
     af0:	a1 09       	sbc	r26, r1
     af2:	b1 09       	sbc	r27, r1
     af4:	8e 21       	and	r24, r14
     af6:	9f 21       	and	r25, r15
     af8:	a0 23       	and	r26, r16
     afa:	b1 23       	and	r27, r17
     afc:	00 97       	sbiw	r24, 0x00	; 0
     afe:	a1 05       	cpc	r26, r1
     b00:	b1 05       	cpc	r27, r1
     b02:	21 f0       	breq	.+8      	; 0xb0c <__floatunsisf+0x9e>
     b04:	41 e0       	ldi	r20, 0x01	; 1
     b06:	50 e0       	ldi	r21, 0x00	; 0
     b08:	60 e0       	ldi	r22, 0x00	; 0
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	4a 29       	or	r20, r10
     b0e:	5b 29       	or	r21, r11
     b10:	6c 29       	or	r22, r12
     b12:	7d 29       	or	r23, r13
     b14:	4d 83       	std	Y+5, r20	; 0x05
     b16:	5e 83       	std	Y+6, r21	; 0x06
     b18:	6f 83       	std	Y+7, r22	; 0x07
     b1a:	78 87       	std	Y+8, r23	; 0x08
     b1c:	8e e1       	ldi	r24, 0x1E	; 30
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	8e 1b       	sub	r24, r30
     b22:	9f 0b       	sbc	r25, r31
     b24:	9c 83       	std	Y+4, r25	; 0x04
     b26:	8b 83       	std	Y+3, r24	; 0x03
     b28:	12 c0       	rjmp	.+36     	; 0xb4e <__floatunsisf+0xe0>
     b2a:	30 97       	sbiw	r30, 0x00	; 0
     b2c:	81 f0       	breq	.+32     	; 0xb4e <__floatunsisf+0xe0>
     b2e:	0e 2e       	mov	r0, r30
     b30:	04 c0       	rjmp	.+8      	; 0xb3a <__floatunsisf+0xcc>
     b32:	ee 0c       	add	r14, r14
     b34:	ff 1c       	adc	r15, r15
     b36:	00 1f       	adc	r16, r16
     b38:	11 1f       	adc	r17, r17
     b3a:	0a 94       	dec	r0
     b3c:	d2 f7       	brpl	.-12     	; 0xb32 <__floatunsisf+0xc4>
     b3e:	ed 82       	std	Y+5, r14	; 0x05
     b40:	fe 82       	std	Y+6, r15	; 0x06
     b42:	0f 83       	std	Y+7, r16	; 0x07
     b44:	18 87       	std	Y+8, r17	; 0x08
     b46:	ce 1a       	sub	r12, r30
     b48:	df 0a       	sbc	r13, r31
     b4a:	dc 82       	std	Y+4, r13	; 0x04
     b4c:	cb 82       	std	Y+3, r12	; 0x03
     b4e:	1a 82       	std	Y+2, r1	; 0x02
     b50:	ce 01       	movw	r24, r28
     b52:	01 96       	adiw	r24, 0x01	; 1
     b54:	0e 94 ff 05 	call	0xbfe	; 0xbfe <__pack_f>
     b58:	28 96       	adiw	r28, 0x08	; 8
     b5a:	ea e0       	ldi	r30, 0x0A	; 10
     b5c:	0c 94 02 47 	jmp	0x8e04	; 0x8e04 <__epilogue_restores__+0x10>

00000b60 <__clzsi2>:
     b60:	ef 92       	push	r14
     b62:	ff 92       	push	r15
     b64:	0f 93       	push	r16
     b66:	1f 93       	push	r17
     b68:	7b 01       	movw	r14, r22
     b6a:	8c 01       	movw	r16, r24
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	e8 16       	cp	r14, r24
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	f8 06       	cpc	r15, r24
     b74:	81 e0       	ldi	r24, 0x01	; 1
     b76:	08 07       	cpc	r16, r24
     b78:	80 e0       	ldi	r24, 0x00	; 0
     b7a:	18 07       	cpc	r17, r24
     b7c:	88 f4       	brcc	.+34     	; 0xba0 <__clzsi2+0x40>
     b7e:	8f ef       	ldi	r24, 0xFF	; 255
     b80:	e8 16       	cp	r14, r24
     b82:	f1 04       	cpc	r15, r1
     b84:	01 05       	cpc	r16, r1
     b86:	11 05       	cpc	r17, r1
     b88:	31 f0       	breq	.+12     	; 0xb96 <__clzsi2+0x36>
     b8a:	28 f0       	brcs	.+10     	; 0xb96 <__clzsi2+0x36>
     b8c:	88 e0       	ldi	r24, 0x08	; 8
     b8e:	90 e0       	ldi	r25, 0x00	; 0
     b90:	a0 e0       	ldi	r26, 0x00	; 0
     b92:	b0 e0       	ldi	r27, 0x00	; 0
     b94:	17 c0       	rjmp	.+46     	; 0xbc4 <__clzsi2+0x64>
     b96:	80 e0       	ldi	r24, 0x00	; 0
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	a0 e0       	ldi	r26, 0x00	; 0
     b9c:	b0 e0       	ldi	r27, 0x00	; 0
     b9e:	12 c0       	rjmp	.+36     	; 0xbc4 <__clzsi2+0x64>
     ba0:	80 e0       	ldi	r24, 0x00	; 0
     ba2:	e8 16       	cp	r14, r24
     ba4:	80 e0       	ldi	r24, 0x00	; 0
     ba6:	f8 06       	cpc	r15, r24
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	08 07       	cpc	r16, r24
     bac:	81 e0       	ldi	r24, 0x01	; 1
     bae:	18 07       	cpc	r17, r24
     bb0:	28 f0       	brcs	.+10     	; 0xbbc <__clzsi2+0x5c>
     bb2:	88 e1       	ldi	r24, 0x18	; 24
     bb4:	90 e0       	ldi	r25, 0x00	; 0
     bb6:	a0 e0       	ldi	r26, 0x00	; 0
     bb8:	b0 e0       	ldi	r27, 0x00	; 0
     bba:	04 c0       	rjmp	.+8      	; 0xbc4 <__clzsi2+0x64>
     bbc:	80 e1       	ldi	r24, 0x10	; 16
     bbe:	90 e0       	ldi	r25, 0x00	; 0
     bc0:	a0 e0       	ldi	r26, 0x00	; 0
     bc2:	b0 e0       	ldi	r27, 0x00	; 0
     bc4:	20 e2       	ldi	r18, 0x20	; 32
     bc6:	30 e0       	ldi	r19, 0x00	; 0
     bc8:	40 e0       	ldi	r20, 0x00	; 0
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	28 1b       	sub	r18, r24
     bce:	39 0b       	sbc	r19, r25
     bd0:	4a 0b       	sbc	r20, r26
     bd2:	5b 0b       	sbc	r21, r27
     bd4:	04 c0       	rjmp	.+8      	; 0xbde <__clzsi2+0x7e>
     bd6:	16 95       	lsr	r17
     bd8:	07 95       	ror	r16
     bda:	f7 94       	ror	r15
     bdc:	e7 94       	ror	r14
     bde:	8a 95       	dec	r24
     be0:	d2 f7       	brpl	.-12     	; 0xbd6 <__clzsi2+0x76>
     be2:	f7 01       	movw	r30, r14
     be4:	e3 59       	subi	r30, 0x93	; 147
     be6:	ff 4f       	sbci	r31, 0xFF	; 255
     be8:	80 81       	ld	r24, Z
     bea:	28 1b       	sub	r18, r24
     bec:	31 09       	sbc	r19, r1
     bee:	41 09       	sbc	r20, r1
     bf0:	51 09       	sbc	r21, r1
     bf2:	c9 01       	movw	r24, r18
     bf4:	1f 91       	pop	r17
     bf6:	0f 91       	pop	r16
     bf8:	ff 90       	pop	r15
     bfa:	ef 90       	pop	r14
     bfc:	08 95       	ret

00000bfe <__pack_f>:
     bfe:	df 92       	push	r13
     c00:	ef 92       	push	r14
     c02:	ff 92       	push	r15
     c04:	0f 93       	push	r16
     c06:	1f 93       	push	r17
     c08:	fc 01       	movw	r30, r24
     c0a:	e4 80       	ldd	r14, Z+4	; 0x04
     c0c:	f5 80       	ldd	r15, Z+5	; 0x05
     c0e:	06 81       	ldd	r16, Z+6	; 0x06
     c10:	17 81       	ldd	r17, Z+7	; 0x07
     c12:	d1 80       	ldd	r13, Z+1	; 0x01
     c14:	80 81       	ld	r24, Z
     c16:	82 30       	cpi	r24, 0x02	; 2
     c18:	48 f4       	brcc	.+18     	; 0xc2c <__pack_f+0x2e>
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	a0 e1       	ldi	r26, 0x10	; 16
     c20:	b0 e0       	ldi	r27, 0x00	; 0
     c22:	e8 2a       	or	r14, r24
     c24:	f9 2a       	or	r15, r25
     c26:	0a 2b       	or	r16, r26
     c28:	1b 2b       	or	r17, r27
     c2a:	a5 c0       	rjmp	.+330    	; 0xd76 <__pack_f+0x178>
     c2c:	84 30       	cpi	r24, 0x04	; 4
     c2e:	09 f4       	brne	.+2      	; 0xc32 <__pack_f+0x34>
     c30:	9f c0       	rjmp	.+318    	; 0xd70 <__pack_f+0x172>
     c32:	82 30       	cpi	r24, 0x02	; 2
     c34:	21 f4       	brne	.+8      	; 0xc3e <__pack_f+0x40>
     c36:	ee 24       	eor	r14, r14
     c38:	ff 24       	eor	r15, r15
     c3a:	87 01       	movw	r16, r14
     c3c:	05 c0       	rjmp	.+10     	; 0xc48 <__pack_f+0x4a>
     c3e:	e1 14       	cp	r14, r1
     c40:	f1 04       	cpc	r15, r1
     c42:	01 05       	cpc	r16, r1
     c44:	11 05       	cpc	r17, r1
     c46:	19 f4       	brne	.+6      	; 0xc4e <__pack_f+0x50>
     c48:	e0 e0       	ldi	r30, 0x00	; 0
     c4a:	f0 e0       	ldi	r31, 0x00	; 0
     c4c:	96 c0       	rjmp	.+300    	; 0xd7a <__pack_f+0x17c>
     c4e:	62 81       	ldd	r22, Z+2	; 0x02
     c50:	73 81       	ldd	r23, Z+3	; 0x03
     c52:	9f ef       	ldi	r25, 0xFF	; 255
     c54:	62 38       	cpi	r22, 0x82	; 130
     c56:	79 07       	cpc	r23, r25
     c58:	0c f0       	brlt	.+2      	; 0xc5c <__pack_f+0x5e>
     c5a:	5b c0       	rjmp	.+182    	; 0xd12 <__pack_f+0x114>
     c5c:	22 e8       	ldi	r18, 0x82	; 130
     c5e:	3f ef       	ldi	r19, 0xFF	; 255
     c60:	26 1b       	sub	r18, r22
     c62:	37 0b       	sbc	r19, r23
     c64:	2a 31       	cpi	r18, 0x1A	; 26
     c66:	31 05       	cpc	r19, r1
     c68:	2c f0       	brlt	.+10     	; 0xc74 <__pack_f+0x76>
     c6a:	20 e0       	ldi	r18, 0x00	; 0
     c6c:	30 e0       	ldi	r19, 0x00	; 0
     c6e:	40 e0       	ldi	r20, 0x00	; 0
     c70:	50 e0       	ldi	r21, 0x00	; 0
     c72:	2a c0       	rjmp	.+84     	; 0xcc8 <__pack_f+0xca>
     c74:	b8 01       	movw	r22, r16
     c76:	a7 01       	movw	r20, r14
     c78:	02 2e       	mov	r0, r18
     c7a:	04 c0       	rjmp	.+8      	; 0xc84 <__pack_f+0x86>
     c7c:	76 95       	lsr	r23
     c7e:	67 95       	ror	r22
     c80:	57 95       	ror	r21
     c82:	47 95       	ror	r20
     c84:	0a 94       	dec	r0
     c86:	d2 f7       	brpl	.-12     	; 0xc7c <__pack_f+0x7e>
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	a0 e0       	ldi	r26, 0x00	; 0
     c8e:	b0 e0       	ldi	r27, 0x00	; 0
     c90:	04 c0       	rjmp	.+8      	; 0xc9a <__pack_f+0x9c>
     c92:	88 0f       	add	r24, r24
     c94:	99 1f       	adc	r25, r25
     c96:	aa 1f       	adc	r26, r26
     c98:	bb 1f       	adc	r27, r27
     c9a:	2a 95       	dec	r18
     c9c:	d2 f7       	brpl	.-12     	; 0xc92 <__pack_f+0x94>
     c9e:	01 97       	sbiw	r24, 0x01	; 1
     ca0:	a1 09       	sbc	r26, r1
     ca2:	b1 09       	sbc	r27, r1
     ca4:	8e 21       	and	r24, r14
     ca6:	9f 21       	and	r25, r15
     ca8:	a0 23       	and	r26, r16
     caa:	b1 23       	and	r27, r17
     cac:	00 97       	sbiw	r24, 0x00	; 0
     cae:	a1 05       	cpc	r26, r1
     cb0:	b1 05       	cpc	r27, r1
     cb2:	21 f0       	breq	.+8      	; 0xcbc <__pack_f+0xbe>
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	a0 e0       	ldi	r26, 0x00	; 0
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	9a 01       	movw	r18, r20
     cbe:	ab 01       	movw	r20, r22
     cc0:	28 2b       	or	r18, r24
     cc2:	39 2b       	or	r19, r25
     cc4:	4a 2b       	or	r20, r26
     cc6:	5b 2b       	or	r21, r27
     cc8:	da 01       	movw	r26, r20
     cca:	c9 01       	movw	r24, r18
     ccc:	8f 77       	andi	r24, 0x7F	; 127
     cce:	90 70       	andi	r25, 0x00	; 0
     cd0:	a0 70       	andi	r26, 0x00	; 0
     cd2:	b0 70       	andi	r27, 0x00	; 0
     cd4:	80 34       	cpi	r24, 0x40	; 64
     cd6:	91 05       	cpc	r25, r1
     cd8:	a1 05       	cpc	r26, r1
     cda:	b1 05       	cpc	r27, r1
     cdc:	39 f4       	brne	.+14     	; 0xcec <__pack_f+0xee>
     cde:	27 ff       	sbrs	r18, 7
     ce0:	09 c0       	rjmp	.+18     	; 0xcf4 <__pack_f+0xf6>
     ce2:	20 5c       	subi	r18, 0xC0	; 192
     ce4:	3f 4f       	sbci	r19, 0xFF	; 255
     ce6:	4f 4f       	sbci	r20, 0xFF	; 255
     ce8:	5f 4f       	sbci	r21, 0xFF	; 255
     cea:	04 c0       	rjmp	.+8      	; 0xcf4 <__pack_f+0xf6>
     cec:	21 5c       	subi	r18, 0xC1	; 193
     cee:	3f 4f       	sbci	r19, 0xFF	; 255
     cf0:	4f 4f       	sbci	r20, 0xFF	; 255
     cf2:	5f 4f       	sbci	r21, 0xFF	; 255
     cf4:	e0 e0       	ldi	r30, 0x00	; 0
     cf6:	f0 e0       	ldi	r31, 0x00	; 0
     cf8:	20 30       	cpi	r18, 0x00	; 0
     cfa:	a0 e0       	ldi	r26, 0x00	; 0
     cfc:	3a 07       	cpc	r19, r26
     cfe:	a0 e0       	ldi	r26, 0x00	; 0
     d00:	4a 07       	cpc	r20, r26
     d02:	a0 e4       	ldi	r26, 0x40	; 64
     d04:	5a 07       	cpc	r21, r26
     d06:	10 f0       	brcs	.+4      	; 0xd0c <__pack_f+0x10e>
     d08:	e1 e0       	ldi	r30, 0x01	; 1
     d0a:	f0 e0       	ldi	r31, 0x00	; 0
     d0c:	79 01       	movw	r14, r18
     d0e:	8a 01       	movw	r16, r20
     d10:	27 c0       	rjmp	.+78     	; 0xd60 <__pack_f+0x162>
     d12:	60 38       	cpi	r22, 0x80	; 128
     d14:	71 05       	cpc	r23, r1
     d16:	64 f5       	brge	.+88     	; 0xd70 <__pack_f+0x172>
     d18:	fb 01       	movw	r30, r22
     d1a:	e1 58       	subi	r30, 0x81	; 129
     d1c:	ff 4f       	sbci	r31, 0xFF	; 255
     d1e:	d8 01       	movw	r26, r16
     d20:	c7 01       	movw	r24, r14
     d22:	8f 77       	andi	r24, 0x7F	; 127
     d24:	90 70       	andi	r25, 0x00	; 0
     d26:	a0 70       	andi	r26, 0x00	; 0
     d28:	b0 70       	andi	r27, 0x00	; 0
     d2a:	80 34       	cpi	r24, 0x40	; 64
     d2c:	91 05       	cpc	r25, r1
     d2e:	a1 05       	cpc	r26, r1
     d30:	b1 05       	cpc	r27, r1
     d32:	39 f4       	brne	.+14     	; 0xd42 <__pack_f+0x144>
     d34:	e7 fe       	sbrs	r14, 7
     d36:	0d c0       	rjmp	.+26     	; 0xd52 <__pack_f+0x154>
     d38:	80 e4       	ldi	r24, 0x40	; 64
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	a0 e0       	ldi	r26, 0x00	; 0
     d3e:	b0 e0       	ldi	r27, 0x00	; 0
     d40:	04 c0       	rjmp	.+8      	; 0xd4a <__pack_f+0x14c>
     d42:	8f e3       	ldi	r24, 0x3F	; 63
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	a0 e0       	ldi	r26, 0x00	; 0
     d48:	b0 e0       	ldi	r27, 0x00	; 0
     d4a:	e8 0e       	add	r14, r24
     d4c:	f9 1e       	adc	r15, r25
     d4e:	0a 1f       	adc	r16, r26
     d50:	1b 1f       	adc	r17, r27
     d52:	17 ff       	sbrs	r17, 7
     d54:	05 c0       	rjmp	.+10     	; 0xd60 <__pack_f+0x162>
     d56:	16 95       	lsr	r17
     d58:	07 95       	ror	r16
     d5a:	f7 94       	ror	r15
     d5c:	e7 94       	ror	r14
     d5e:	31 96       	adiw	r30, 0x01	; 1
     d60:	87 e0       	ldi	r24, 0x07	; 7
     d62:	16 95       	lsr	r17
     d64:	07 95       	ror	r16
     d66:	f7 94       	ror	r15
     d68:	e7 94       	ror	r14
     d6a:	8a 95       	dec	r24
     d6c:	d1 f7       	brne	.-12     	; 0xd62 <__pack_f+0x164>
     d6e:	05 c0       	rjmp	.+10     	; 0xd7a <__pack_f+0x17c>
     d70:	ee 24       	eor	r14, r14
     d72:	ff 24       	eor	r15, r15
     d74:	87 01       	movw	r16, r14
     d76:	ef ef       	ldi	r30, 0xFF	; 255
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	6e 2f       	mov	r22, r30
     d7c:	67 95       	ror	r22
     d7e:	66 27       	eor	r22, r22
     d80:	67 95       	ror	r22
     d82:	90 2f       	mov	r25, r16
     d84:	9f 77       	andi	r25, 0x7F	; 127
     d86:	d7 94       	ror	r13
     d88:	dd 24       	eor	r13, r13
     d8a:	d7 94       	ror	r13
     d8c:	8e 2f       	mov	r24, r30
     d8e:	86 95       	lsr	r24
     d90:	49 2f       	mov	r20, r25
     d92:	46 2b       	or	r20, r22
     d94:	58 2f       	mov	r21, r24
     d96:	5d 29       	or	r21, r13
     d98:	b7 01       	movw	r22, r14
     d9a:	ca 01       	movw	r24, r20
     d9c:	1f 91       	pop	r17
     d9e:	0f 91       	pop	r16
     da0:	ff 90       	pop	r15
     da2:	ef 90       	pop	r14
     da4:	df 90       	pop	r13
     da6:	08 95       	ret

00000da8 <__unpack_f>:
     da8:	fc 01       	movw	r30, r24
     daa:	db 01       	movw	r26, r22
     dac:	40 81       	ld	r20, Z
     dae:	51 81       	ldd	r21, Z+1	; 0x01
     db0:	22 81       	ldd	r18, Z+2	; 0x02
     db2:	62 2f       	mov	r22, r18
     db4:	6f 77       	andi	r22, 0x7F	; 127
     db6:	70 e0       	ldi	r23, 0x00	; 0
     db8:	22 1f       	adc	r18, r18
     dba:	22 27       	eor	r18, r18
     dbc:	22 1f       	adc	r18, r18
     dbe:	93 81       	ldd	r25, Z+3	; 0x03
     dc0:	89 2f       	mov	r24, r25
     dc2:	88 0f       	add	r24, r24
     dc4:	82 2b       	or	r24, r18
     dc6:	28 2f       	mov	r18, r24
     dc8:	30 e0       	ldi	r19, 0x00	; 0
     dca:	99 1f       	adc	r25, r25
     dcc:	99 27       	eor	r25, r25
     dce:	99 1f       	adc	r25, r25
     dd0:	11 96       	adiw	r26, 0x01	; 1
     dd2:	9c 93       	st	X, r25
     dd4:	11 97       	sbiw	r26, 0x01	; 1
     dd6:	21 15       	cp	r18, r1
     dd8:	31 05       	cpc	r19, r1
     dda:	a9 f5       	brne	.+106    	; 0xe46 <__unpack_f+0x9e>
     ddc:	41 15       	cp	r20, r1
     dde:	51 05       	cpc	r21, r1
     de0:	61 05       	cpc	r22, r1
     de2:	71 05       	cpc	r23, r1
     de4:	11 f4       	brne	.+4      	; 0xdea <__unpack_f+0x42>
     de6:	82 e0       	ldi	r24, 0x02	; 2
     de8:	37 c0       	rjmp	.+110    	; 0xe58 <__unpack_f+0xb0>
     dea:	82 e8       	ldi	r24, 0x82	; 130
     dec:	9f ef       	ldi	r25, 0xFF	; 255
     dee:	13 96       	adiw	r26, 0x03	; 3
     df0:	9c 93       	st	X, r25
     df2:	8e 93       	st	-X, r24
     df4:	12 97       	sbiw	r26, 0x02	; 2
     df6:	9a 01       	movw	r18, r20
     df8:	ab 01       	movw	r20, r22
     dfa:	67 e0       	ldi	r22, 0x07	; 7
     dfc:	22 0f       	add	r18, r18
     dfe:	33 1f       	adc	r19, r19
     e00:	44 1f       	adc	r20, r20
     e02:	55 1f       	adc	r21, r21
     e04:	6a 95       	dec	r22
     e06:	d1 f7       	brne	.-12     	; 0xdfc <__unpack_f+0x54>
     e08:	83 e0       	ldi	r24, 0x03	; 3
     e0a:	8c 93       	st	X, r24
     e0c:	0d c0       	rjmp	.+26     	; 0xe28 <__unpack_f+0x80>
     e0e:	22 0f       	add	r18, r18
     e10:	33 1f       	adc	r19, r19
     e12:	44 1f       	adc	r20, r20
     e14:	55 1f       	adc	r21, r21
     e16:	12 96       	adiw	r26, 0x02	; 2
     e18:	8d 91       	ld	r24, X+
     e1a:	9c 91       	ld	r25, X
     e1c:	13 97       	sbiw	r26, 0x03	; 3
     e1e:	01 97       	sbiw	r24, 0x01	; 1
     e20:	13 96       	adiw	r26, 0x03	; 3
     e22:	9c 93       	st	X, r25
     e24:	8e 93       	st	-X, r24
     e26:	12 97       	sbiw	r26, 0x02	; 2
     e28:	20 30       	cpi	r18, 0x00	; 0
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	38 07       	cpc	r19, r24
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	48 07       	cpc	r20, r24
     e32:	80 e4       	ldi	r24, 0x40	; 64
     e34:	58 07       	cpc	r21, r24
     e36:	58 f3       	brcs	.-42     	; 0xe0e <__unpack_f+0x66>
     e38:	14 96       	adiw	r26, 0x04	; 4
     e3a:	2d 93       	st	X+, r18
     e3c:	3d 93       	st	X+, r19
     e3e:	4d 93       	st	X+, r20
     e40:	5c 93       	st	X, r21
     e42:	17 97       	sbiw	r26, 0x07	; 7
     e44:	08 95       	ret
     e46:	2f 3f       	cpi	r18, 0xFF	; 255
     e48:	31 05       	cpc	r19, r1
     e4a:	79 f4       	brne	.+30     	; 0xe6a <__unpack_f+0xc2>
     e4c:	41 15       	cp	r20, r1
     e4e:	51 05       	cpc	r21, r1
     e50:	61 05       	cpc	r22, r1
     e52:	71 05       	cpc	r23, r1
     e54:	19 f4       	brne	.+6      	; 0xe5c <__unpack_f+0xb4>
     e56:	84 e0       	ldi	r24, 0x04	; 4
     e58:	8c 93       	st	X, r24
     e5a:	08 95       	ret
     e5c:	64 ff       	sbrs	r22, 4
     e5e:	03 c0       	rjmp	.+6      	; 0xe66 <__unpack_f+0xbe>
     e60:	81 e0       	ldi	r24, 0x01	; 1
     e62:	8c 93       	st	X, r24
     e64:	12 c0       	rjmp	.+36     	; 0xe8a <__unpack_f+0xe2>
     e66:	1c 92       	st	X, r1
     e68:	10 c0       	rjmp	.+32     	; 0xe8a <__unpack_f+0xe2>
     e6a:	2f 57       	subi	r18, 0x7F	; 127
     e6c:	30 40       	sbci	r19, 0x00	; 0
     e6e:	13 96       	adiw	r26, 0x03	; 3
     e70:	3c 93       	st	X, r19
     e72:	2e 93       	st	-X, r18
     e74:	12 97       	sbiw	r26, 0x02	; 2
     e76:	83 e0       	ldi	r24, 0x03	; 3
     e78:	8c 93       	st	X, r24
     e7a:	87 e0       	ldi	r24, 0x07	; 7
     e7c:	44 0f       	add	r20, r20
     e7e:	55 1f       	adc	r21, r21
     e80:	66 1f       	adc	r22, r22
     e82:	77 1f       	adc	r23, r23
     e84:	8a 95       	dec	r24
     e86:	d1 f7       	brne	.-12     	; 0xe7c <__unpack_f+0xd4>
     e88:	70 64       	ori	r23, 0x40	; 64
     e8a:	14 96       	adiw	r26, 0x04	; 4
     e8c:	4d 93       	st	X+, r20
     e8e:	5d 93       	st	X+, r21
     e90:	6d 93       	st	X+, r22
     e92:	7c 93       	st	X, r23
     e94:	17 97       	sbiw	r26, 0x07	; 7
     e96:	08 95       	ret

00000e98 <__fpcmp_parts_f>:
     e98:	1f 93       	push	r17
     e9a:	dc 01       	movw	r26, r24
     e9c:	fb 01       	movw	r30, r22
     e9e:	9c 91       	ld	r25, X
     ea0:	92 30       	cpi	r25, 0x02	; 2
     ea2:	08 f4       	brcc	.+2      	; 0xea6 <__fpcmp_parts_f+0xe>
     ea4:	47 c0       	rjmp	.+142    	; 0xf34 <__fpcmp_parts_f+0x9c>
     ea6:	80 81       	ld	r24, Z
     ea8:	82 30       	cpi	r24, 0x02	; 2
     eaa:	08 f4       	brcc	.+2      	; 0xeae <__fpcmp_parts_f+0x16>
     eac:	43 c0       	rjmp	.+134    	; 0xf34 <__fpcmp_parts_f+0x9c>
     eae:	94 30       	cpi	r25, 0x04	; 4
     eb0:	51 f4       	brne	.+20     	; 0xec6 <__fpcmp_parts_f+0x2e>
     eb2:	11 96       	adiw	r26, 0x01	; 1
     eb4:	1c 91       	ld	r17, X
     eb6:	84 30       	cpi	r24, 0x04	; 4
     eb8:	99 f5       	brne	.+102    	; 0xf20 <__fpcmp_parts_f+0x88>
     eba:	81 81       	ldd	r24, Z+1	; 0x01
     ebc:	68 2f       	mov	r22, r24
     ebe:	70 e0       	ldi	r23, 0x00	; 0
     ec0:	61 1b       	sub	r22, r17
     ec2:	71 09       	sbc	r23, r1
     ec4:	3f c0       	rjmp	.+126    	; 0xf44 <__fpcmp_parts_f+0xac>
     ec6:	84 30       	cpi	r24, 0x04	; 4
     ec8:	21 f0       	breq	.+8      	; 0xed2 <__fpcmp_parts_f+0x3a>
     eca:	92 30       	cpi	r25, 0x02	; 2
     ecc:	31 f4       	brne	.+12     	; 0xeda <__fpcmp_parts_f+0x42>
     ece:	82 30       	cpi	r24, 0x02	; 2
     ed0:	b9 f1       	breq	.+110    	; 0xf40 <__fpcmp_parts_f+0xa8>
     ed2:	81 81       	ldd	r24, Z+1	; 0x01
     ed4:	88 23       	and	r24, r24
     ed6:	89 f1       	breq	.+98     	; 0xf3a <__fpcmp_parts_f+0xa2>
     ed8:	2d c0       	rjmp	.+90     	; 0xf34 <__fpcmp_parts_f+0x9c>
     eda:	11 96       	adiw	r26, 0x01	; 1
     edc:	1c 91       	ld	r17, X
     ede:	11 97       	sbiw	r26, 0x01	; 1
     ee0:	82 30       	cpi	r24, 0x02	; 2
     ee2:	f1 f0       	breq	.+60     	; 0xf20 <__fpcmp_parts_f+0x88>
     ee4:	81 81       	ldd	r24, Z+1	; 0x01
     ee6:	18 17       	cp	r17, r24
     ee8:	d9 f4       	brne	.+54     	; 0xf20 <__fpcmp_parts_f+0x88>
     eea:	12 96       	adiw	r26, 0x02	; 2
     eec:	2d 91       	ld	r18, X+
     eee:	3c 91       	ld	r19, X
     ef0:	13 97       	sbiw	r26, 0x03	; 3
     ef2:	82 81       	ldd	r24, Z+2	; 0x02
     ef4:	93 81       	ldd	r25, Z+3	; 0x03
     ef6:	82 17       	cp	r24, r18
     ef8:	93 07       	cpc	r25, r19
     efa:	94 f0       	brlt	.+36     	; 0xf20 <__fpcmp_parts_f+0x88>
     efc:	28 17       	cp	r18, r24
     efe:	39 07       	cpc	r19, r25
     f00:	bc f0       	brlt	.+46     	; 0xf30 <__fpcmp_parts_f+0x98>
     f02:	14 96       	adiw	r26, 0x04	; 4
     f04:	8d 91       	ld	r24, X+
     f06:	9d 91       	ld	r25, X+
     f08:	0d 90       	ld	r0, X+
     f0a:	bc 91       	ld	r27, X
     f0c:	a0 2d       	mov	r26, r0
     f0e:	24 81       	ldd	r18, Z+4	; 0x04
     f10:	35 81       	ldd	r19, Z+5	; 0x05
     f12:	46 81       	ldd	r20, Z+6	; 0x06
     f14:	57 81       	ldd	r21, Z+7	; 0x07
     f16:	28 17       	cp	r18, r24
     f18:	39 07       	cpc	r19, r25
     f1a:	4a 07       	cpc	r20, r26
     f1c:	5b 07       	cpc	r21, r27
     f1e:	18 f4       	brcc	.+6      	; 0xf26 <__fpcmp_parts_f+0x8e>
     f20:	11 23       	and	r17, r17
     f22:	41 f0       	breq	.+16     	; 0xf34 <__fpcmp_parts_f+0x9c>
     f24:	0a c0       	rjmp	.+20     	; 0xf3a <__fpcmp_parts_f+0xa2>
     f26:	82 17       	cp	r24, r18
     f28:	93 07       	cpc	r25, r19
     f2a:	a4 07       	cpc	r26, r20
     f2c:	b5 07       	cpc	r27, r21
     f2e:	40 f4       	brcc	.+16     	; 0xf40 <__fpcmp_parts_f+0xa8>
     f30:	11 23       	and	r17, r17
     f32:	19 f0       	breq	.+6      	; 0xf3a <__fpcmp_parts_f+0xa2>
     f34:	61 e0       	ldi	r22, 0x01	; 1
     f36:	70 e0       	ldi	r23, 0x00	; 0
     f38:	05 c0       	rjmp	.+10     	; 0xf44 <__fpcmp_parts_f+0xac>
     f3a:	6f ef       	ldi	r22, 0xFF	; 255
     f3c:	7f ef       	ldi	r23, 0xFF	; 255
     f3e:	02 c0       	rjmp	.+4      	; 0xf44 <__fpcmp_parts_f+0xac>
     f40:	60 e0       	ldi	r22, 0x00	; 0
     f42:	70 e0       	ldi	r23, 0x00	; 0
     f44:	cb 01       	movw	r24, r22
     f46:	1f 91       	pop	r17
     f48:	08 95       	ret

00000f4a <ICU_SW_init>:
#include "../MCAL/DIO/DIO.h"
#include "ICU_Interface.h"
static volatile u8 LOC_u8counter = NUMBER_0;
static volatile u16 period_Ticks = NUMBER_0;
static volatile u16 on_Ticks = NUMBER_0;
void ICU_SW_init(u16 * copy_pu16period_Ticks, u16 * copy_pu16on_Ticks) {
     f4a:	df 93       	push	r29
     f4c:	cf 93       	push	r28
     f4e:	cd b7       	in	r28, 0x3d	; 61
     f50:	de b7       	in	r29, 0x3e	; 62
     f52:	28 97       	sbiw	r28, 0x08	; 8
     f54:	0f b6       	in	r0, 0x3f	; 63
     f56:	f8 94       	cli
     f58:	de bf       	out	0x3e, r29	; 62
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	cd bf       	out	0x3d, r28	; 61
     f5e:	9e 83       	std	Y+6, r25	; 0x06
     f60:	8d 83       	std	Y+5, r24	; 0x05
     f62:	78 87       	std	Y+8, r23	; 0x08
     f64:	6f 83       	std	Y+7, r22	; 0x07
	f32 y = NUMBER_0;
     f66:	80 e0       	ldi	r24, 0x00	; 0
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	a0 e0       	ldi	r26, 0x00	; 0
     f6c:	b0 e0       	ldi	r27, 0x00	; 0
     f6e:	89 83       	std	Y+1, r24	; 0x01
     f70:	9a 83       	std	Y+2, r25	; 0x02
     f72:	ab 83       	std	Y+3, r26	; 0x03
     f74:	bc 83       	std	Y+4, r27	; 0x04
	MCAL_DIO_u8SetPinDirection(PortD, Pin2, Pin_Low);
     f76:	83 e0       	ldi	r24, 0x03	; 3
     f78:	62 e0       	ldi	r22, 0x02	; 2
     f7a:	40 e0       	ldi	r20, 0x00	; 0
     f7c:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	//Timer 1
	MCAL_T1_u8T1Init(NORMAL_MODE);
     f80:	80 e0       	ldi	r24, 0x00	; 0
     f82:	0e 94 bb 09 	call	0x1376	; 0x1376 <MCAL_T1_u8T1Init>
	MCAL_T1_u8T1Prescaler(PRESCALLING_8, &y);
     f86:	82 e0       	ldi	r24, 0x02	; 2
     f88:	9e 01       	movw	r18, r28
     f8a:	2f 5f       	subi	r18, 0xFF	; 255
     f8c:	3f 4f       	sbci	r19, 0xFF	; 255
     f8e:	b9 01       	movw	r22, r18
     f90:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <MCAL_T1_u8T1Prescaler>
	//Int0
	MCAL_Interrupt_InterruptInit();
     f94:	0e 94 1a 18 	call	0x3034	; 0x3034 <MCAL_Interrupt_InterruptInit>
	SET_BIT(MCUCR, Pin1);
     f98:	a5 e5       	ldi	r26, 0x55	; 85
     f9a:	b0 e0       	ldi	r27, 0x00	; 0
     f9c:	e5 e5       	ldi	r30, 0x55	; 85
     f9e:	f0 e0       	ldi	r31, 0x00	; 0
     fa0:	80 81       	ld	r24, Z
     fa2:	82 60       	ori	r24, 0x02	; 2
     fa4:	8c 93       	st	X, r24
	SET_BIT(MCUCR, Pin0);
     fa6:	a5 e5       	ldi	r26, 0x55	; 85
     fa8:	b0 e0       	ldi	r27, 0x00	; 0
     faa:	e5 e5       	ldi	r30, 0x55	; 85
     fac:	f0 e0       	ldi	r31, 0x00	; 0
     fae:	80 81       	ld	r24, Z
     fb0:	81 60       	ori	r24, 0x01	; 1
     fb2:	8c 93       	st	X, r24
	MCAL_Interrupt_EXIT_CallBack_0(ICU_SW);
     fb4:	8b e0       	ldi	r24, 0x0B	; 11
     fb6:	98 e0       	ldi	r25, 0x08	; 8
     fb8:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <MCAL_Interrupt_EXIT_CallBack_0>
	//Bsy wait the ICU measure value
	while ((period_Ticks == 0) && (on_Ticks == 0))
     fbc:	80 91 83 01 	lds	r24, 0x0183
     fc0:	90 91 84 01 	lds	r25, 0x0184
     fc4:	00 97       	sbiw	r24, 0x00	; 0
     fc6:	31 f4       	brne	.+12     	; 0xfd4 <ICU_SW_init+0x8a>
     fc8:	80 91 85 01 	lds	r24, 0x0185
     fcc:	90 91 86 01 	lds	r25, 0x0186
     fd0:	00 97       	sbiw	r24, 0x00	; 0
     fd2:	a1 f3       	breq	.-24     	; 0xfbc <ICU_SW_init+0x72>
		;
	if ((copy_pu16on_Ticks != '\0') && (copy_pu16period_Ticks != '\0')) {
     fd4:	8f 81       	ldd	r24, Y+7	; 0x07
     fd6:	98 85       	ldd	r25, Y+8	; 0x08
     fd8:	00 97       	sbiw	r24, 0x00	; 0
     fda:	a1 f0       	breq	.+40     	; 0x1004 <ICU_SW_init+0xba>
     fdc:	8d 81       	ldd	r24, Y+5	; 0x05
     fde:	9e 81       	ldd	r25, Y+6	; 0x06
     fe0:	00 97       	sbiw	r24, 0x00	; 0
     fe2:	81 f0       	breq	.+32     	; 0x1004 <ICU_SW_init+0xba>
		*copy_pu16period_Ticks = period_Ticks;
     fe4:	80 91 83 01 	lds	r24, 0x0183
     fe8:	90 91 84 01 	lds	r25, 0x0184
     fec:	ed 81       	ldd	r30, Y+5	; 0x05
     fee:	fe 81       	ldd	r31, Y+6	; 0x06
     ff0:	91 83       	std	Z+1, r25	; 0x01
     ff2:	80 83       	st	Z, r24
		*copy_pu16on_Ticks = on_Ticks;
     ff4:	80 91 85 01 	lds	r24, 0x0185
     ff8:	90 91 86 01 	lds	r25, 0x0186
     ffc:	ef 81       	ldd	r30, Y+7	; 0x07
     ffe:	f8 85       	ldd	r31, Y+8	; 0x08
    1000:	91 83       	std	Z+1, r25	; 0x01
    1002:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1004:	28 96       	adiw	r28, 0x08	; 8
    1006:	0f b6       	in	r0, 0x3f	; 63
    1008:	f8 94       	cli
    100a:	de bf       	out	0x3e, r29	; 62
    100c:	0f be       	out	0x3f, r0	; 63
    100e:	cd bf       	out	0x3d, r28	; 61
    1010:	cf 91       	pop	r28
    1012:	df 91       	pop	r29
    1014:	08 95       	ret

00001016 <ICU_SW>:
void ICU_SW(void) {
    1016:	df 93       	push	r29
    1018:	cf 93       	push	r28
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
	LOC_u8counter++;
    101e:	80 91 82 01 	lds	r24, 0x0182
    1022:	8f 5f       	subi	r24, 0xFF	; 255
    1024:	80 93 82 01 	sts	0x0182, r24
	//Frist Rising Edge
	if (LOC_u8counter == 1) {
    1028:	80 91 82 01 	lds	r24, 0x0182
    102c:	81 30       	cpi	r24, 0x01	; 1
    102e:	99 f4       	brne	.+38     	; 0x1056 <ICU_SW+0x40>
		//Timer Starts counter
		MCAL_T1_voidSetTCNT1Value(NUMBER_0);
    1030:	80 e0       	ldi	r24, 0x00	; 0
    1032:	90 e0       	ldi	r25, 0x00	; 0
    1034:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <MCAL_T1_voidSetTCNT1Value>
		SET_BIT(MCUCR, Pin1);
    1038:	a5 e5       	ldi	r26, 0x55	; 85
    103a:	b0 e0       	ldi	r27, 0x00	; 0
    103c:	e5 e5       	ldi	r30, 0x55	; 85
    103e:	f0 e0       	ldi	r31, 0x00	; 0
    1040:	80 81       	ld	r24, Z
    1042:	82 60       	ori	r24, 0x02	; 2
    1044:	8c 93       	st	X, r24
		CLR_BIT(MCUCR, Pin0);
    1046:	a5 e5       	ldi	r26, 0x55	; 85
    1048:	b0 e0       	ldi	r27, 0x00	; 0
    104a:	e5 e5       	ldi	r30, 0x55	; 85
    104c:	f0 e0       	ldi	r31, 0x00	; 0
    104e:	80 81       	ld	r24, Z
    1050:	8e 7f       	andi	r24, 0xFE	; 254
    1052:	8c 93       	st	X, r24
    1054:	34 c0       	rjmp	.+104    	; 0x10be <ICU_SW+0xa8>
	} else if (LOC_u8counter == 2) {
    1056:	80 91 82 01 	lds	r24, 0x0182
    105a:	82 30       	cpi	r24, 0x02	; 2
    105c:	e1 f4       	brne	.+56     	; 0x1096 <ICU_SW+0x80>
		//second rising edge
		MCAL_T1_voidGetTCNT1Value(&on_Ticks);
    105e:	85 e8       	ldi	r24, 0x85	; 133
    1060:	91 e0       	ldi	r25, 0x01	; 1
    1062:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <MCAL_T1_voidGetTCNT1Value>
		on_Ticks--;
    1066:	80 91 85 01 	lds	r24, 0x0185
    106a:	90 91 86 01 	lds	r25, 0x0186
    106e:	01 97       	sbiw	r24, 0x01	; 1
    1070:	90 93 86 01 	sts	0x0186, r25
    1074:	80 93 85 01 	sts	0x0185, r24
		//Change Int0 to Trigger to falling edge
		SET_BIT(MCUCR, Pin1);
    1078:	a5 e5       	ldi	r26, 0x55	; 85
    107a:	b0 e0       	ldi	r27, 0x00	; 0
    107c:	e5 e5       	ldi	r30, 0x55	; 85
    107e:	f0 e0       	ldi	r31, 0x00	; 0
    1080:	80 81       	ld	r24, Z
    1082:	82 60       	ori	r24, 0x02	; 2
    1084:	8c 93       	st	X, r24
		SET_BIT(MCUCR, Pin0);
    1086:	a5 e5       	ldi	r26, 0x55	; 85
    1088:	b0 e0       	ldi	r27, 0x00	; 0
    108a:	e5 e5       	ldi	r30, 0x55	; 85
    108c:	f0 e0       	ldi	r31, 0x00	; 0
    108e:	80 81       	ld	r24, Z
    1090:	81 60       	ori	r24, 0x01	; 1
    1092:	8c 93       	st	X, r24
    1094:	14 c0       	rjmp	.+40     	; 0x10be <ICU_SW+0xa8>
	} else if (LOC_u8counter == 3) {
    1096:	80 91 82 01 	lds	r24, 0x0182
    109a:	83 30       	cpi	r24, 0x03	; 3
    109c:	81 f4       	brne	.+32     	; 0x10be <ICU_SW+0xa8>
		//Falling edge to get on time
		MCAL_T1_voidGetTCNT1Value(&period_Ticks);
    109e:	83 e8       	ldi	r24, 0x83	; 131
    10a0:	91 e0       	ldi	r25, 0x01	; 1
    10a2:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <MCAL_T1_voidGetTCNT1Value>
		period_Ticks--;
    10a6:	80 91 83 01 	lds	r24, 0x0183
    10aa:	90 91 84 01 	lds	r25, 0x0184
    10ae:	01 97       	sbiw	r24, 0x01	; 1
    10b0:	90 93 84 01 	sts	0x0184, r25
    10b4:	80 93 83 01 	sts	0x0183, r24
		MCAL_Interrupt_EnableGIE(Disable);
    10b8:	80 e0       	ldi	r24, 0x00	; 0
    10ba:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <MCAL_Interrupt_EnableGIE>
	}
}
    10be:	cf 91       	pop	r28
    10c0:	df 91       	pop	r29
    10c2:	08 95       	ret

000010c4 <MCAL_WDT_u8Enable>:
 *      Author: Mohamed
 */

#include "WDT.h"

void MCAL_WDT_u8Enable(void) {
    10c4:	df 93       	push	r29
    10c6:	cf 93       	push	r28
    10c8:	cd b7       	in	r28, 0x3d	; 61
    10ca:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(WDTCR, WDTCR_Pin3);
    10cc:	a1 e4       	ldi	r26, 0x41	; 65
    10ce:	b0 e0       	ldi	r27, 0x00	; 0
    10d0:	e1 e4       	ldi	r30, 0x41	; 65
    10d2:	f0 e0       	ldi	r31, 0x00	; 0
    10d4:	80 81       	ld	r24, Z
    10d6:	88 60       	ori	r24, 0x08	; 8
    10d8:	8c 93       	st	X, r24
	SET_BIT(WDTCR, WDTCR_Pin4);
    10da:	a1 e4       	ldi	r26, 0x41	; 65
    10dc:	b0 e0       	ldi	r27, 0x00	; 0
    10de:	e1 e4       	ldi	r30, 0x41	; 65
    10e0:	f0 e0       	ldi	r31, 0x00	; 0
    10e2:	80 81       	ld	r24, Z
    10e4:	80 61       	ori	r24, 0x10	; 16
    10e6:	8c 93       	st	X, r24
}
    10e8:	cf 91       	pop	r28
    10ea:	df 91       	pop	r29
    10ec:	08 95       	ret

000010ee <MCAL_WDT_u8SetTime>:
void MCAL_WDT_u8SetTime(u8 Loc_u8Time) {
    10ee:	df 93       	push	r29
    10f0:	cf 93       	push	r28
    10f2:	0f 92       	push	r0
    10f4:	cd b7       	in	r28, 0x3d	; 61
    10f6:	de b7       	in	r29, 0x3e	; 62
    10f8:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8Time == Time_16_3_ms) {
    10fa:	89 81       	ldd	r24, Y+1	; 0x01
    10fc:	88 23       	and	r24, r24
    10fe:	b1 f4       	brne	.+44     	; 0x112c <MCAL_WDT_u8SetTime+0x3e>
		CLR_BIT(WDTCR, WDTCR_Pin0);
    1100:	a1 e4       	ldi	r26, 0x41	; 65
    1102:	b0 e0       	ldi	r27, 0x00	; 0
    1104:	e1 e4       	ldi	r30, 0x41	; 65
    1106:	f0 e0       	ldi	r31, 0x00	; 0
    1108:	80 81       	ld	r24, Z
    110a:	8e 7f       	andi	r24, 0xFE	; 254
    110c:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin1);
    110e:	a1 e4       	ldi	r26, 0x41	; 65
    1110:	b0 e0       	ldi	r27, 0x00	; 0
    1112:	e1 e4       	ldi	r30, 0x41	; 65
    1114:	f0 e0       	ldi	r31, 0x00	; 0
    1116:	80 81       	ld	r24, Z
    1118:	8d 7f       	andi	r24, 0xFD	; 253
    111a:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin2);
    111c:	a1 e4       	ldi	r26, 0x41	; 65
    111e:	b0 e0       	ldi	r27, 0x00	; 0
    1120:	e1 e4       	ldi	r30, 0x41	; 65
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	80 81       	ld	r24, Z
    1126:	8b 7f       	andi	r24, 0xFB	; 251
    1128:	8c 93       	st	X, r24
    112a:	ae c0       	rjmp	.+348    	; 0x1288 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_32_5_ms) {
    112c:	89 81       	ldd	r24, Y+1	; 0x01
    112e:	81 30       	cpi	r24, 0x01	; 1
    1130:	b1 f4       	brne	.+44     	; 0x115e <MCAL_WDT_u8SetTime+0x70>
		SET_BIT(WDTCR, WDTCR_Pin0);
    1132:	a1 e4       	ldi	r26, 0x41	; 65
    1134:	b0 e0       	ldi	r27, 0x00	; 0
    1136:	e1 e4       	ldi	r30, 0x41	; 65
    1138:	f0 e0       	ldi	r31, 0x00	; 0
    113a:	80 81       	ld	r24, Z
    113c:	81 60       	ori	r24, 0x01	; 1
    113e:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin1);
    1140:	a1 e4       	ldi	r26, 0x41	; 65
    1142:	b0 e0       	ldi	r27, 0x00	; 0
    1144:	e1 e4       	ldi	r30, 0x41	; 65
    1146:	f0 e0       	ldi	r31, 0x00	; 0
    1148:	80 81       	ld	r24, Z
    114a:	8d 7f       	andi	r24, 0xFD	; 253
    114c:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin2);
    114e:	a1 e4       	ldi	r26, 0x41	; 65
    1150:	b0 e0       	ldi	r27, 0x00	; 0
    1152:	e1 e4       	ldi	r30, 0x41	; 65
    1154:	f0 e0       	ldi	r31, 0x00	; 0
    1156:	80 81       	ld	r24, Z
    1158:	8b 7f       	andi	r24, 0xFB	; 251
    115a:	8c 93       	st	X, r24
    115c:	95 c0       	rjmp	.+298    	; 0x1288 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_65_0_ms) {
    115e:	89 81       	ldd	r24, Y+1	; 0x01
    1160:	82 30       	cpi	r24, 0x02	; 2
    1162:	b1 f4       	brne	.+44     	; 0x1190 <MCAL_WDT_u8SetTime+0xa2>
		CLR_BIT(WDTCR, WDTCR_Pin0);
    1164:	a1 e4       	ldi	r26, 0x41	; 65
    1166:	b0 e0       	ldi	r27, 0x00	; 0
    1168:	e1 e4       	ldi	r30, 0x41	; 65
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	80 81       	ld	r24, Z
    116e:	8e 7f       	andi	r24, 0xFE	; 254
    1170:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin1);
    1172:	a1 e4       	ldi	r26, 0x41	; 65
    1174:	b0 e0       	ldi	r27, 0x00	; 0
    1176:	e1 e4       	ldi	r30, 0x41	; 65
    1178:	f0 e0       	ldi	r31, 0x00	; 0
    117a:	80 81       	ld	r24, Z
    117c:	82 60       	ori	r24, 0x02	; 2
    117e:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin2);
    1180:	a1 e4       	ldi	r26, 0x41	; 65
    1182:	b0 e0       	ldi	r27, 0x00	; 0
    1184:	e1 e4       	ldi	r30, 0x41	; 65
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	80 81       	ld	r24, Z
    118a:	8b 7f       	andi	r24, 0xFB	; 251
    118c:	8c 93       	st	X, r24
    118e:	7c c0       	rjmp	.+248    	; 0x1288 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_0_13_s) {
    1190:	89 81       	ldd	r24, Y+1	; 0x01
    1192:	83 30       	cpi	r24, 0x03	; 3
    1194:	b1 f4       	brne	.+44     	; 0x11c2 <MCAL_WDT_u8SetTime+0xd4>
		SET_BIT(WDTCR, WDTCR_Pin0);
    1196:	a1 e4       	ldi	r26, 0x41	; 65
    1198:	b0 e0       	ldi	r27, 0x00	; 0
    119a:	e1 e4       	ldi	r30, 0x41	; 65
    119c:	f0 e0       	ldi	r31, 0x00	; 0
    119e:	80 81       	ld	r24, Z
    11a0:	81 60       	ori	r24, 0x01	; 1
    11a2:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin1);
    11a4:	a1 e4       	ldi	r26, 0x41	; 65
    11a6:	b0 e0       	ldi	r27, 0x00	; 0
    11a8:	e1 e4       	ldi	r30, 0x41	; 65
    11aa:	f0 e0       	ldi	r31, 0x00	; 0
    11ac:	80 81       	ld	r24, Z
    11ae:	82 60       	ori	r24, 0x02	; 2
    11b0:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin2);
    11b2:	a1 e4       	ldi	r26, 0x41	; 65
    11b4:	b0 e0       	ldi	r27, 0x00	; 0
    11b6:	e1 e4       	ldi	r30, 0x41	; 65
    11b8:	f0 e0       	ldi	r31, 0x00	; 0
    11ba:	80 81       	ld	r24, Z
    11bc:	8b 7f       	andi	r24, 0xFB	; 251
    11be:	8c 93       	st	X, r24
    11c0:	63 c0       	rjmp	.+198    	; 0x1288 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_0_26_s) {
    11c2:	89 81       	ldd	r24, Y+1	; 0x01
    11c4:	84 30       	cpi	r24, 0x04	; 4
    11c6:	b1 f4       	brne	.+44     	; 0x11f4 <MCAL_WDT_u8SetTime+0x106>
		CLR_BIT(WDTCR, WDTCR_Pin0);
    11c8:	a1 e4       	ldi	r26, 0x41	; 65
    11ca:	b0 e0       	ldi	r27, 0x00	; 0
    11cc:	e1 e4       	ldi	r30, 0x41	; 65
    11ce:	f0 e0       	ldi	r31, 0x00	; 0
    11d0:	80 81       	ld	r24, Z
    11d2:	8e 7f       	andi	r24, 0xFE	; 254
    11d4:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin1);
    11d6:	a1 e4       	ldi	r26, 0x41	; 65
    11d8:	b0 e0       	ldi	r27, 0x00	; 0
    11da:	e1 e4       	ldi	r30, 0x41	; 65
    11dc:	f0 e0       	ldi	r31, 0x00	; 0
    11de:	80 81       	ld	r24, Z
    11e0:	8d 7f       	andi	r24, 0xFD	; 253
    11e2:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin2);
    11e4:	a1 e4       	ldi	r26, 0x41	; 65
    11e6:	b0 e0       	ldi	r27, 0x00	; 0
    11e8:	e1 e4       	ldi	r30, 0x41	; 65
    11ea:	f0 e0       	ldi	r31, 0x00	; 0
    11ec:	80 81       	ld	r24, Z
    11ee:	84 60       	ori	r24, 0x04	; 4
    11f0:	8c 93       	st	X, r24
    11f2:	4a c0       	rjmp	.+148    	; 0x1288 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_0_52_s) {
    11f4:	89 81       	ldd	r24, Y+1	; 0x01
    11f6:	85 30       	cpi	r24, 0x05	; 5
    11f8:	b1 f4       	brne	.+44     	; 0x1226 <MCAL_WDT_u8SetTime+0x138>
		SET_BIT(WDTCR, WDTCR_Pin0);
    11fa:	a1 e4       	ldi	r26, 0x41	; 65
    11fc:	b0 e0       	ldi	r27, 0x00	; 0
    11fe:	e1 e4       	ldi	r30, 0x41	; 65
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	80 81       	ld	r24, Z
    1204:	81 60       	ori	r24, 0x01	; 1
    1206:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin1);
    1208:	a1 e4       	ldi	r26, 0x41	; 65
    120a:	b0 e0       	ldi	r27, 0x00	; 0
    120c:	e1 e4       	ldi	r30, 0x41	; 65
    120e:	f0 e0       	ldi	r31, 0x00	; 0
    1210:	80 81       	ld	r24, Z
    1212:	8d 7f       	andi	r24, 0xFD	; 253
    1214:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin2);
    1216:	a1 e4       	ldi	r26, 0x41	; 65
    1218:	b0 e0       	ldi	r27, 0x00	; 0
    121a:	e1 e4       	ldi	r30, 0x41	; 65
    121c:	f0 e0       	ldi	r31, 0x00	; 0
    121e:	80 81       	ld	r24, Z
    1220:	84 60       	ori	r24, 0x04	; 4
    1222:	8c 93       	st	X, r24
    1224:	31 c0       	rjmp	.+98     	; 0x1288 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_1_0_s) {
    1226:	89 81       	ldd	r24, Y+1	; 0x01
    1228:	86 30       	cpi	r24, 0x06	; 6
    122a:	b1 f4       	brne	.+44     	; 0x1258 <MCAL_WDT_u8SetTime+0x16a>
		CLR_BIT(WDTCR, WDTCR_Pin0);
    122c:	a1 e4       	ldi	r26, 0x41	; 65
    122e:	b0 e0       	ldi	r27, 0x00	; 0
    1230:	e1 e4       	ldi	r30, 0x41	; 65
    1232:	f0 e0       	ldi	r31, 0x00	; 0
    1234:	80 81       	ld	r24, Z
    1236:	8e 7f       	andi	r24, 0xFE	; 254
    1238:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin1);
    123a:	a1 e4       	ldi	r26, 0x41	; 65
    123c:	b0 e0       	ldi	r27, 0x00	; 0
    123e:	e1 e4       	ldi	r30, 0x41	; 65
    1240:	f0 e0       	ldi	r31, 0x00	; 0
    1242:	80 81       	ld	r24, Z
    1244:	82 60       	ori	r24, 0x02	; 2
    1246:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin2);
    1248:	a1 e4       	ldi	r26, 0x41	; 65
    124a:	b0 e0       	ldi	r27, 0x00	; 0
    124c:	e1 e4       	ldi	r30, 0x41	; 65
    124e:	f0 e0       	ldi	r31, 0x00	; 0
    1250:	80 81       	ld	r24, Z
    1252:	84 60       	ori	r24, 0x04	; 4
    1254:	8c 93       	st	X, r24
    1256:	18 c0       	rjmp	.+48     	; 0x1288 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_2_1_s) {
    1258:	89 81       	ldd	r24, Y+1	; 0x01
    125a:	87 30       	cpi	r24, 0x07	; 7
    125c:	a9 f4       	brne	.+42     	; 0x1288 <MCAL_WDT_u8SetTime+0x19a>
		SET_BIT(WDTCR, WDTCR_Pin0);
    125e:	a1 e4       	ldi	r26, 0x41	; 65
    1260:	b0 e0       	ldi	r27, 0x00	; 0
    1262:	e1 e4       	ldi	r30, 0x41	; 65
    1264:	f0 e0       	ldi	r31, 0x00	; 0
    1266:	80 81       	ld	r24, Z
    1268:	81 60       	ori	r24, 0x01	; 1
    126a:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin1);
    126c:	a1 e4       	ldi	r26, 0x41	; 65
    126e:	b0 e0       	ldi	r27, 0x00	; 0
    1270:	e1 e4       	ldi	r30, 0x41	; 65
    1272:	f0 e0       	ldi	r31, 0x00	; 0
    1274:	80 81       	ld	r24, Z
    1276:	82 60       	ori	r24, 0x02	; 2
    1278:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin2);
    127a:	a1 e4       	ldi	r26, 0x41	; 65
    127c:	b0 e0       	ldi	r27, 0x00	; 0
    127e:	e1 e4       	ldi	r30, 0x41	; 65
    1280:	f0 e0       	ldi	r31, 0x00	; 0
    1282:	80 81       	ld	r24, Z
    1284:	84 60       	ori	r24, 0x04	; 4
    1286:	8c 93       	st	X, r24
	}
}
    1288:	0f 90       	pop	r0
    128a:	cf 91       	pop	r28
    128c:	df 91       	pop	r29
    128e:	08 95       	ret

00001290 <MCAL_WDT_u8Disable>:
void MCAL_WDT_u8Disable(void) {
    1290:	df 93       	push	r29
    1292:	cf 93       	push	r28
    1294:	cd b7       	in	r28, 0x3d	; 61
    1296:	de b7       	in	r29, 0x3e	; 62
	WDTCR = WDTCR_Disable;
    1298:	e1 e4       	ldi	r30, 0x41	; 65
    129a:	f0 e0       	ldi	r31, 0x00	; 0
    129c:	88 e1       	ldi	r24, 0x18	; 24
    129e:	80 83       	st	Z, r24
	WDTCR = WDTCR_Zero;
    12a0:	e1 e4       	ldi	r30, 0x41	; 65
    12a2:	f0 e0       	ldi	r31, 0x00	; 0
    12a4:	10 82       	st	Z, r1
}
    12a6:	cf 91       	pop	r28
    12a8:	df 91       	pop	r29
    12aa:	08 95       	ret

000012ac <MCAL_UART_UARTInit>:
 */

#include "UART.h"
//#include "avr/interrupt.h"

void MCAL_UART_UARTInit(void) {
    12ac:	df 93       	push	r29
    12ae:	cf 93       	push	r28
    12b0:	cd b7       	in	r28, 0x3d	; 61
    12b2:	de b7       	in	r29, 0x3e	; 62
	/* Set baud rate */
	UBRRH = (u8) (Baud_Rate >> Shift_8_bit);
    12b4:	e0 e4       	ldi	r30, 0x40	; 64
    12b6:	f0 e0       	ldi	r31, 0x00	; 0
    12b8:	10 82       	st	Z, r1
	UBRRL = (u8) Baud_Rate;
    12ba:	e9 e2       	ldi	r30, 0x29	; 41
    12bc:	f0 e0       	ldi	r31, 0x00	; 0
    12be:	87 e6       	ldi	r24, 0x67	; 103
    12c0:	80 83       	st	Z, r24

	/* Enable RX and TX */
//	UCSRB = (1 << RXEN) | (1 << TXEN);
	SET_BIT(UCSRB,RXEN_PIN);
    12c2:	aa e2       	ldi	r26, 0x2A	; 42
    12c4:	b0 e0       	ldi	r27, 0x00	; 0
    12c6:	ea e2       	ldi	r30, 0x2A	; 42
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	80 81       	ld	r24, Z
    12cc:	80 61       	ori	r24, 0x10	; 16
    12ce:	8c 93       	st	X, r24
	SET_BIT(UCSRB,TXEN_PIN);
    12d0:	aa e2       	ldi	r26, 0x2A	; 42
    12d2:	b0 e0       	ldi	r27, 0x00	; 0
    12d4:	ea e2       	ldi	r30, 0x2A	; 42
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	80 81       	ld	r24, Z
    12da:	88 60       	ori	r24, 0x08	; 8
    12dc:	8c 93       	st	X, r24

	/* Set frame format: 8data, 2stop bit */
//	UCSRC = (1 << URSEL) | (1 << USBS) | (3 << UCSZ0);
	UCSRC = UCSRC_Size;
    12de:	e0 e4       	ldi	r30, 0x40	; 64
    12e0:	f0 e0       	ldi	r31, 0x00	; 0
    12e2:	8e e8       	ldi	r24, 0x8E	; 142
    12e4:	80 83       	st	Z, r24
	//Logical Error
//	SET_BIT(UCSRC,URSEL_PIN);
//	SET_BIT(UCSRC,USBS_PIN);
//	SET_BIT(UCSRC,UCSZ0_PIN);
//	SET_BIT(UCSRC,UCSZ1_PIN);
}
    12e6:	cf 91       	pop	r28
    12e8:	df 91       	pop	r29
    12ea:	08 95       	ret

000012ec <MCAL_UART_UARTTransmit>:

void MCAL_UART_UARTTransmit(u8 Loc_u8data) {
    12ec:	df 93       	push	r29
    12ee:	cf 93       	push	r28
    12f0:	0f 92       	push	r0
    12f2:	cd b7       	in	r28, 0x3d	; 61
    12f4:	de b7       	in	r29, 0x3e	; 62
    12f6:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
//	while (!( UCSRA & (1 << UDRE_PIN)));
	while (GET_BIT(UCSRA,UDRE_PIN)==0);
    12f8:	eb e2       	ldi	r30, 0x2B	; 43
    12fa:	f0 e0       	ldi	r31, 0x00	; 0
    12fc:	80 81       	ld	r24, Z
    12fe:	82 95       	swap	r24
    1300:	86 95       	lsr	r24
    1302:	87 70       	andi	r24, 0x07	; 7
    1304:	88 2f       	mov	r24, r24
    1306:	90 e0       	ldi	r25, 0x00	; 0
    1308:	81 70       	andi	r24, 0x01	; 1
    130a:	90 70       	andi	r25, 0x00	; 0
    130c:	00 97       	sbiw	r24, 0x00	; 0
    130e:	a1 f3       	breq	.-24     	; 0x12f8 <MCAL_UART_UARTTransmit+0xc>

	/* Put data into buffer, sends the data */
	UDR = Loc_u8data;
    1310:	ec e2       	ldi	r30, 0x2C	; 44
    1312:	f0 e0       	ldi	r31, 0x00	; 0
    1314:	89 81       	ldd	r24, Y+1	; 0x01
    1316:	80 83       	st	Z, r24

	/* Wait for data to be transmitted */
	while (GET_BIT(UCSRA,TXC_PIN)==0);
    1318:	eb e2       	ldi	r30, 0x2B	; 43
    131a:	f0 e0       	ldi	r31, 0x00	; 0
    131c:	80 81       	ld	r24, Z
    131e:	82 95       	swap	r24
    1320:	86 95       	lsr	r24
    1322:	86 95       	lsr	r24
    1324:	83 70       	andi	r24, 0x03	; 3
    1326:	88 2f       	mov	r24, r24
    1328:	90 e0       	ldi	r25, 0x00	; 0
    132a:	81 70       	andi	r24, 0x01	; 1
    132c:	90 70       	andi	r25, 0x00	; 0
    132e:	00 97       	sbiw	r24, 0x00	; 0
    1330:	99 f3       	breq	.-26     	; 0x1318 <MCAL_UART_UARTTransmit+0x2c>
	SET_BIT(UCSRA,TXC_PIN);
    1332:	ab e2       	ldi	r26, 0x2B	; 43
    1334:	b0 e0       	ldi	r27, 0x00	; 0
    1336:	eb e2       	ldi	r30, 0x2B	; 43
    1338:	f0 e0       	ldi	r31, 0x00	; 0
    133a:	80 81       	ld	r24, Z
    133c:	80 64       	ori	r24, 0x40	; 64
    133e:	8c 93       	st	X, r24

}
    1340:	0f 90       	pop	r0
    1342:	cf 91       	pop	r28
    1344:	df 91       	pop	r29
    1346:	08 95       	ret

00001348 <MCAL_UART_UARTReceive>:
//		MCAL_UART_UARTTransmit(Loc_u8data[i]);
//	}
//
//}

void MCAL_UART_UARTReceive(u8* Loc_u8data) {
    1348:	df 93       	push	r29
    134a:	cf 93       	push	r28
    134c:	00 d0       	rcall	.+0      	; 0x134e <MCAL_UART_UARTReceive+0x6>
    134e:	cd b7       	in	r28, 0x3d	; 61
    1350:	de b7       	in	r29, 0x3e	; 62
    1352:	9a 83       	std	Y+2, r25	; 0x02
    1354:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for data to be received */
//	while (!(UCSRA & (1 << RXC_PIN)));
	while (GET_BIT(UCSRA,RXC_PIN)==0);
    1356:	eb e2       	ldi	r30, 0x2B	; 43
    1358:	f0 e0       	ldi	r31, 0x00	; 0
    135a:	80 81       	ld	r24, Z
    135c:	88 23       	and	r24, r24
    135e:	dc f7       	brge	.-10     	; 0x1356 <MCAL_UART_UARTReceive+0xe>

	/* 	Save Received Data in Var-Loc_u8data */
	*Loc_u8data=UDR;
    1360:	ec e2       	ldi	r30, 0x2C	; 44
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	80 81       	ld	r24, Z
    1366:	e9 81       	ldd	r30, Y+1	; 0x01
    1368:	fa 81       	ldd	r31, Y+2	; 0x02
    136a:	80 83       	st	Z, r24
}
    136c:	0f 90       	pop	r0
    136e:	0f 90       	pop	r0
    1370:	cf 91       	pop	r28
    1372:	df 91       	pop	r29
    1374:	08 95       	ret

00001376 <MCAL_T1_u8T1Init>:
 *  Created on: Oct 22, 2023
 *      Author: TOP_WORLD
 */
#include "Timer1.h"
void (*Gptr_3)(void)='\0';
u8 MCAL_T1_u8T1Init(u8 LOC_u8Timer1Mode) {
    1376:	df 93       	push	r29
    1378:	cf 93       	push	r28
    137a:	00 d0       	rcall	.+0      	; 0x137c <MCAL_T1_u8T1Init+0x6>
    137c:	cd b7       	in	r28, 0x3d	; 61
    137e:	de b7       	in	r29, 0x3e	; 62
    1380:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1382:	81 e0       	ldi	r24, 0x01	; 1
    1384:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8Timer1Mode <= FAST_PWM_OCR1A) {
    1386:	8a 81       	ldd	r24, Y+2	; 0x02
    1388:	80 31       	cpi	r24, 0x10	; 16
    138a:	08 f0       	brcs	.+2      	; 0x138e <MCAL_T1_u8T1Init+0x18>
    138c:	0f c2       	rjmp	.+1054   	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		if (LOC_u8Timer1Mode == NORMAL_MODE) {
    138e:	8a 81       	ldd	r24, Y+2	; 0x02
    1390:	88 23       	and	r24, r24
    1392:	f1 f4       	brne	.+60     	; 0x13d0 <MCAL_T1_u8T1Init+0x5a>
			CLR_BIT(TCCR1A, Pin0);
    1394:	af e4       	ldi	r26, 0x4F	; 79
    1396:	b0 e0       	ldi	r27, 0x00	; 0
    1398:	ef e4       	ldi	r30, 0x4F	; 79
    139a:	f0 e0       	ldi	r31, 0x00	; 0
    139c:	80 81       	ld	r24, Z
    139e:	8e 7f       	andi	r24, 0xFE	; 254
    13a0:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, Pin1);
    13a2:	af e4       	ldi	r26, 0x4F	; 79
    13a4:	b0 e0       	ldi	r27, 0x00	; 0
    13a6:	ef e4       	ldi	r30, 0x4F	; 79
    13a8:	f0 e0       	ldi	r31, 0x00	; 0
    13aa:	80 81       	ld	r24, Z
    13ac:	8d 7f       	andi	r24, 0xFD	; 253
    13ae:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin3);
    13b0:	ae e4       	ldi	r26, 0x4E	; 78
    13b2:	b0 e0       	ldi	r27, 0x00	; 0
    13b4:	ee e4       	ldi	r30, 0x4E	; 78
    13b6:	f0 e0       	ldi	r31, 0x00	; 0
    13b8:	80 81       	ld	r24, Z
    13ba:	87 7f       	andi	r24, 0xF7	; 247
    13bc:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin4);
    13be:	ae e4       	ldi	r26, 0x4E	; 78
    13c0:	b0 e0       	ldi	r27, 0x00	; 0
    13c2:	ee e4       	ldi	r30, 0x4E	; 78
    13c4:	f0 e0       	ldi	r31, 0x00	; 0
    13c6:	80 81       	ld	r24, Z
    13c8:	8f 7e       	andi	r24, 0xEF	; 239
    13ca:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    13cc:	19 82       	std	Y+1, r1	; 0x01
    13ce:	ee c1       	rjmp	.+988    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_8bit) {
    13d0:	8a 81       	ldd	r24, Y+2	; 0x02
    13d2:	81 30       	cpi	r24, 0x01	; 1
    13d4:	f1 f4       	brne	.+60     	; 0x1412 <MCAL_T1_u8T1Init+0x9c>
			SET_BIT(TCCR1A, Pin0);
    13d6:	af e4       	ldi	r26, 0x4F	; 79
    13d8:	b0 e0       	ldi	r27, 0x00	; 0
    13da:	ef e4       	ldi	r30, 0x4F	; 79
    13dc:	f0 e0       	ldi	r31, 0x00	; 0
    13de:	80 81       	ld	r24, Z
    13e0:	81 60       	ori	r24, 0x01	; 1
    13e2:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, Pin1);
    13e4:	af e4       	ldi	r26, 0x4F	; 79
    13e6:	b0 e0       	ldi	r27, 0x00	; 0
    13e8:	ef e4       	ldi	r30, 0x4F	; 79
    13ea:	f0 e0       	ldi	r31, 0x00	; 0
    13ec:	80 81       	ld	r24, Z
    13ee:	8d 7f       	andi	r24, 0xFD	; 253
    13f0:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin3);
    13f2:	ae e4       	ldi	r26, 0x4E	; 78
    13f4:	b0 e0       	ldi	r27, 0x00	; 0
    13f6:	ee e4       	ldi	r30, 0x4E	; 78
    13f8:	f0 e0       	ldi	r31, 0x00	; 0
    13fa:	80 81       	ld	r24, Z
    13fc:	87 7f       	andi	r24, 0xF7	; 247
    13fe:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin4);
    1400:	ae e4       	ldi	r26, 0x4E	; 78
    1402:	b0 e0       	ldi	r27, 0x00	; 0
    1404:	ee e4       	ldi	r30, 0x4E	; 78
    1406:	f0 e0       	ldi	r31, 0x00	; 0
    1408:	80 81       	ld	r24, Z
    140a:	8f 7e       	andi	r24, 0xEF	; 239
    140c:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    140e:	19 82       	std	Y+1, r1	; 0x01
    1410:	cd c1       	rjmp	.+922    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_9bit) {
    1412:	8a 81       	ldd	r24, Y+2	; 0x02
    1414:	82 30       	cpi	r24, 0x02	; 2
    1416:	f1 f4       	brne	.+60     	; 0x1454 <MCAL_T1_u8T1Init+0xde>
			CLR_BIT(TCCR1A, Pin0);
    1418:	af e4       	ldi	r26, 0x4F	; 79
    141a:	b0 e0       	ldi	r27, 0x00	; 0
    141c:	ef e4       	ldi	r30, 0x4F	; 79
    141e:	f0 e0       	ldi	r31, 0x00	; 0
    1420:	80 81       	ld	r24, Z
    1422:	8e 7f       	andi	r24, 0xFE	; 254
    1424:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, Pin1);
    1426:	af e4       	ldi	r26, 0x4F	; 79
    1428:	b0 e0       	ldi	r27, 0x00	; 0
    142a:	ef e4       	ldi	r30, 0x4F	; 79
    142c:	f0 e0       	ldi	r31, 0x00	; 0
    142e:	80 81       	ld	r24, Z
    1430:	82 60       	ori	r24, 0x02	; 2
    1432:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin3);
    1434:	ae e4       	ldi	r26, 0x4E	; 78
    1436:	b0 e0       	ldi	r27, 0x00	; 0
    1438:	ee e4       	ldi	r30, 0x4E	; 78
    143a:	f0 e0       	ldi	r31, 0x00	; 0
    143c:	80 81       	ld	r24, Z
    143e:	87 7f       	andi	r24, 0xF7	; 247
    1440:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin4);
    1442:	ae e4       	ldi	r26, 0x4E	; 78
    1444:	b0 e0       	ldi	r27, 0x00	; 0
    1446:	ee e4       	ldi	r30, 0x4E	; 78
    1448:	f0 e0       	ldi	r31, 0x00	; 0
    144a:	80 81       	ld	r24, Z
    144c:	8f 7e       	andi	r24, 0xEF	; 239
    144e:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1450:	19 82       	std	Y+1, r1	; 0x01
    1452:	ac c1       	rjmp	.+856    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_10bit) {
    1454:	8a 81       	ldd	r24, Y+2	; 0x02
    1456:	83 30       	cpi	r24, 0x03	; 3
    1458:	f1 f4       	brne	.+60     	; 0x1496 <MCAL_T1_u8T1Init+0x120>
			SET_BIT(TCCR1A, Pin0);
    145a:	af e4       	ldi	r26, 0x4F	; 79
    145c:	b0 e0       	ldi	r27, 0x00	; 0
    145e:	ef e4       	ldi	r30, 0x4F	; 79
    1460:	f0 e0       	ldi	r31, 0x00	; 0
    1462:	80 81       	ld	r24, Z
    1464:	81 60       	ori	r24, 0x01	; 1
    1466:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, Pin1);
    1468:	af e4       	ldi	r26, 0x4F	; 79
    146a:	b0 e0       	ldi	r27, 0x00	; 0
    146c:	ef e4       	ldi	r30, 0x4F	; 79
    146e:	f0 e0       	ldi	r31, 0x00	; 0
    1470:	80 81       	ld	r24, Z
    1472:	82 60       	ori	r24, 0x02	; 2
    1474:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin3);
    1476:	ae e4       	ldi	r26, 0x4E	; 78
    1478:	b0 e0       	ldi	r27, 0x00	; 0
    147a:	ee e4       	ldi	r30, 0x4E	; 78
    147c:	f0 e0       	ldi	r31, 0x00	; 0
    147e:	80 81       	ld	r24, Z
    1480:	87 7f       	andi	r24, 0xF7	; 247
    1482:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin4);
    1484:	ae e4       	ldi	r26, 0x4E	; 78
    1486:	b0 e0       	ldi	r27, 0x00	; 0
    1488:	ee e4       	ldi	r30, 0x4E	; 78
    148a:	f0 e0       	ldi	r31, 0x00	; 0
    148c:	80 81       	ld	r24, Z
    148e:	8f 7e       	andi	r24, 0xEF	; 239
    1490:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1492:	19 82       	std	Y+1, r1	; 0x01
    1494:	8b c1       	rjmp	.+790    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == CTC_OCR1A) {
    1496:	8a 81       	ldd	r24, Y+2	; 0x02
    1498:	84 30       	cpi	r24, 0x04	; 4
    149a:	f1 f4       	brne	.+60     	; 0x14d8 <MCAL_T1_u8T1Init+0x162>
			CLR_BIT(TCCR1A, Pin0);
    149c:	af e4       	ldi	r26, 0x4F	; 79
    149e:	b0 e0       	ldi	r27, 0x00	; 0
    14a0:	ef e4       	ldi	r30, 0x4F	; 79
    14a2:	f0 e0       	ldi	r31, 0x00	; 0
    14a4:	80 81       	ld	r24, Z
    14a6:	8e 7f       	andi	r24, 0xFE	; 254
    14a8:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, Pin1);
    14aa:	af e4       	ldi	r26, 0x4F	; 79
    14ac:	b0 e0       	ldi	r27, 0x00	; 0
    14ae:	ef e4       	ldi	r30, 0x4F	; 79
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	80 81       	ld	r24, Z
    14b4:	8d 7f       	andi	r24, 0xFD	; 253
    14b6:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin3);
    14b8:	ae e4       	ldi	r26, 0x4E	; 78
    14ba:	b0 e0       	ldi	r27, 0x00	; 0
    14bc:	ee e4       	ldi	r30, 0x4E	; 78
    14be:	f0 e0       	ldi	r31, 0x00	; 0
    14c0:	80 81       	ld	r24, Z
    14c2:	88 60       	ori	r24, 0x08	; 8
    14c4:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin4);
    14c6:	ae e4       	ldi	r26, 0x4E	; 78
    14c8:	b0 e0       	ldi	r27, 0x00	; 0
    14ca:	ee e4       	ldi	r30, 0x4E	; 78
    14cc:	f0 e0       	ldi	r31, 0x00	; 0
    14ce:	80 81       	ld	r24, Z
    14d0:	8f 7e       	andi	r24, 0xEF	; 239
    14d2:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    14d4:	19 82       	std	Y+1, r1	; 0x01
    14d6:	6a c1       	rjmp	.+724    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_8bit) {
    14d8:	8a 81       	ldd	r24, Y+2	; 0x02
    14da:	85 30       	cpi	r24, 0x05	; 5
    14dc:	f1 f4       	brne	.+60     	; 0x151a <MCAL_T1_u8T1Init+0x1a4>
			SET_BIT(TCCR1A, Pin0);
    14de:	af e4       	ldi	r26, 0x4F	; 79
    14e0:	b0 e0       	ldi	r27, 0x00	; 0
    14e2:	ef e4       	ldi	r30, 0x4F	; 79
    14e4:	f0 e0       	ldi	r31, 0x00	; 0
    14e6:	80 81       	ld	r24, Z
    14e8:	81 60       	ori	r24, 0x01	; 1
    14ea:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, Pin1);
    14ec:	af e4       	ldi	r26, 0x4F	; 79
    14ee:	b0 e0       	ldi	r27, 0x00	; 0
    14f0:	ef e4       	ldi	r30, 0x4F	; 79
    14f2:	f0 e0       	ldi	r31, 0x00	; 0
    14f4:	80 81       	ld	r24, Z
    14f6:	8d 7f       	andi	r24, 0xFD	; 253
    14f8:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin3);
    14fa:	ae e4       	ldi	r26, 0x4E	; 78
    14fc:	b0 e0       	ldi	r27, 0x00	; 0
    14fe:	ee e4       	ldi	r30, 0x4E	; 78
    1500:	f0 e0       	ldi	r31, 0x00	; 0
    1502:	80 81       	ld	r24, Z
    1504:	88 60       	ori	r24, 0x08	; 8
    1506:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin4);
    1508:	ae e4       	ldi	r26, 0x4E	; 78
    150a:	b0 e0       	ldi	r27, 0x00	; 0
    150c:	ee e4       	ldi	r30, 0x4E	; 78
    150e:	f0 e0       	ldi	r31, 0x00	; 0
    1510:	80 81       	ld	r24, Z
    1512:	8f 7e       	andi	r24, 0xEF	; 239
    1514:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1516:	19 82       	std	Y+1, r1	; 0x01
    1518:	49 c1       	rjmp	.+658    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_9bit) {
    151a:	8a 81       	ldd	r24, Y+2	; 0x02
    151c:	86 30       	cpi	r24, 0x06	; 6
    151e:	f1 f4       	brne	.+60     	; 0x155c <MCAL_T1_u8T1Init+0x1e6>
			CLR_BIT(TCCR1A, Pin0);
    1520:	af e4       	ldi	r26, 0x4F	; 79
    1522:	b0 e0       	ldi	r27, 0x00	; 0
    1524:	ef e4       	ldi	r30, 0x4F	; 79
    1526:	f0 e0       	ldi	r31, 0x00	; 0
    1528:	80 81       	ld	r24, Z
    152a:	8e 7f       	andi	r24, 0xFE	; 254
    152c:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, Pin1);
    152e:	af e4       	ldi	r26, 0x4F	; 79
    1530:	b0 e0       	ldi	r27, 0x00	; 0
    1532:	ef e4       	ldi	r30, 0x4F	; 79
    1534:	f0 e0       	ldi	r31, 0x00	; 0
    1536:	80 81       	ld	r24, Z
    1538:	82 60       	ori	r24, 0x02	; 2
    153a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin3);
    153c:	ae e4       	ldi	r26, 0x4E	; 78
    153e:	b0 e0       	ldi	r27, 0x00	; 0
    1540:	ee e4       	ldi	r30, 0x4E	; 78
    1542:	f0 e0       	ldi	r31, 0x00	; 0
    1544:	80 81       	ld	r24, Z
    1546:	88 60       	ori	r24, 0x08	; 8
    1548:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin4);
    154a:	ae e4       	ldi	r26, 0x4E	; 78
    154c:	b0 e0       	ldi	r27, 0x00	; 0
    154e:	ee e4       	ldi	r30, 0x4E	; 78
    1550:	f0 e0       	ldi	r31, 0x00	; 0
    1552:	80 81       	ld	r24, Z
    1554:	8f 7e       	andi	r24, 0xEF	; 239
    1556:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1558:	19 82       	std	Y+1, r1	; 0x01
    155a:	28 c1       	rjmp	.+592    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_10bit) {
    155c:	8a 81       	ldd	r24, Y+2	; 0x02
    155e:	87 30       	cpi	r24, 0x07	; 7
    1560:	f1 f4       	brne	.+60     	; 0x159e <MCAL_T1_u8T1Init+0x228>
			SET_BIT(TCCR1A, Pin0);
    1562:	af e4       	ldi	r26, 0x4F	; 79
    1564:	b0 e0       	ldi	r27, 0x00	; 0
    1566:	ef e4       	ldi	r30, 0x4F	; 79
    1568:	f0 e0       	ldi	r31, 0x00	; 0
    156a:	80 81       	ld	r24, Z
    156c:	81 60       	ori	r24, 0x01	; 1
    156e:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, Pin1);
    1570:	af e4       	ldi	r26, 0x4F	; 79
    1572:	b0 e0       	ldi	r27, 0x00	; 0
    1574:	ef e4       	ldi	r30, 0x4F	; 79
    1576:	f0 e0       	ldi	r31, 0x00	; 0
    1578:	80 81       	ld	r24, Z
    157a:	82 60       	ori	r24, 0x02	; 2
    157c:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin3);
    157e:	ae e4       	ldi	r26, 0x4E	; 78
    1580:	b0 e0       	ldi	r27, 0x00	; 0
    1582:	ee e4       	ldi	r30, 0x4E	; 78
    1584:	f0 e0       	ldi	r31, 0x00	; 0
    1586:	80 81       	ld	r24, Z
    1588:	88 60       	ori	r24, 0x08	; 8
    158a:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin4);
    158c:	ae e4       	ldi	r26, 0x4E	; 78
    158e:	b0 e0       	ldi	r27, 0x00	; 0
    1590:	ee e4       	ldi	r30, 0x4E	; 78
    1592:	f0 e0       	ldi	r31, 0x00	; 0
    1594:	80 81       	ld	r24, Z
    1596:	8f 7e       	andi	r24, 0xEF	; 239
    1598:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    159a:	19 82       	std	Y+1, r1	; 0x01
    159c:	07 c1       	rjmp	.+526    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_AND_FREQUANCY_CORRECT_ICR1) {
    159e:	8a 81       	ldd	r24, Y+2	; 0x02
    15a0:	88 30       	cpi	r24, 0x08	; 8
    15a2:	f1 f4       	brne	.+60     	; 0x15e0 <MCAL_T1_u8T1Init+0x26a>
			CLR_BIT(TCCR1A, Pin0);
    15a4:	af e4       	ldi	r26, 0x4F	; 79
    15a6:	b0 e0       	ldi	r27, 0x00	; 0
    15a8:	ef e4       	ldi	r30, 0x4F	; 79
    15aa:	f0 e0       	ldi	r31, 0x00	; 0
    15ac:	80 81       	ld	r24, Z
    15ae:	8e 7f       	andi	r24, 0xFE	; 254
    15b0:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, Pin1);
    15b2:	af e4       	ldi	r26, 0x4F	; 79
    15b4:	b0 e0       	ldi	r27, 0x00	; 0
    15b6:	ef e4       	ldi	r30, 0x4F	; 79
    15b8:	f0 e0       	ldi	r31, 0x00	; 0
    15ba:	80 81       	ld	r24, Z
    15bc:	8d 7f       	andi	r24, 0xFD	; 253
    15be:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin3);
    15c0:	ae e4       	ldi	r26, 0x4E	; 78
    15c2:	b0 e0       	ldi	r27, 0x00	; 0
    15c4:	ee e4       	ldi	r30, 0x4E	; 78
    15c6:	f0 e0       	ldi	r31, 0x00	; 0
    15c8:	80 81       	ld	r24, Z
    15ca:	87 7f       	andi	r24, 0xF7	; 247
    15cc:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin4);
    15ce:	ae e4       	ldi	r26, 0x4E	; 78
    15d0:	b0 e0       	ldi	r27, 0x00	; 0
    15d2:	ee e4       	ldi	r30, 0x4E	; 78
    15d4:	f0 e0       	ldi	r31, 0x00	; 0
    15d6:	80 81       	ld	r24, Z
    15d8:	80 61       	ori	r24, 0x10	; 16
    15da:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    15dc:	19 82       	std	Y+1, r1	; 0x01
    15de:	e6 c0       	rjmp	.+460    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_AND_FREQUANCY_CORRECT_OCR1A) {
    15e0:	8a 81       	ldd	r24, Y+2	; 0x02
    15e2:	89 30       	cpi	r24, 0x09	; 9
    15e4:	f1 f4       	brne	.+60     	; 0x1622 <MCAL_T1_u8T1Init+0x2ac>
			SET_BIT(TCCR1A, Pin0);
    15e6:	af e4       	ldi	r26, 0x4F	; 79
    15e8:	b0 e0       	ldi	r27, 0x00	; 0
    15ea:	ef e4       	ldi	r30, 0x4F	; 79
    15ec:	f0 e0       	ldi	r31, 0x00	; 0
    15ee:	80 81       	ld	r24, Z
    15f0:	81 60       	ori	r24, 0x01	; 1
    15f2:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, Pin1);
    15f4:	af e4       	ldi	r26, 0x4F	; 79
    15f6:	b0 e0       	ldi	r27, 0x00	; 0
    15f8:	ef e4       	ldi	r30, 0x4F	; 79
    15fa:	f0 e0       	ldi	r31, 0x00	; 0
    15fc:	80 81       	ld	r24, Z
    15fe:	8d 7f       	andi	r24, 0xFD	; 253
    1600:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin3);
    1602:	ae e4       	ldi	r26, 0x4E	; 78
    1604:	b0 e0       	ldi	r27, 0x00	; 0
    1606:	ee e4       	ldi	r30, 0x4E	; 78
    1608:	f0 e0       	ldi	r31, 0x00	; 0
    160a:	80 81       	ld	r24, Z
    160c:	87 7f       	andi	r24, 0xF7	; 247
    160e:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin4);
    1610:	ae e4       	ldi	r26, 0x4E	; 78
    1612:	b0 e0       	ldi	r27, 0x00	; 0
    1614:	ee e4       	ldi	r30, 0x4E	; 78
    1616:	f0 e0       	ldi	r31, 0x00	; 0
    1618:	80 81       	ld	r24, Z
    161a:	80 61       	ori	r24, 0x10	; 16
    161c:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    161e:	19 82       	std	Y+1, r1	; 0x01
    1620:	c5 c0       	rjmp	.+394    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_ICR1) {
    1622:	8a 81       	ldd	r24, Y+2	; 0x02
    1624:	8a 30       	cpi	r24, 0x0A	; 10
    1626:	f1 f4       	brne	.+60     	; 0x1664 <MCAL_T1_u8T1Init+0x2ee>
			CLR_BIT(TCCR1A, Pin0);
    1628:	af e4       	ldi	r26, 0x4F	; 79
    162a:	b0 e0       	ldi	r27, 0x00	; 0
    162c:	ef e4       	ldi	r30, 0x4F	; 79
    162e:	f0 e0       	ldi	r31, 0x00	; 0
    1630:	80 81       	ld	r24, Z
    1632:	8e 7f       	andi	r24, 0xFE	; 254
    1634:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, Pin1);
    1636:	af e4       	ldi	r26, 0x4F	; 79
    1638:	b0 e0       	ldi	r27, 0x00	; 0
    163a:	ef e4       	ldi	r30, 0x4F	; 79
    163c:	f0 e0       	ldi	r31, 0x00	; 0
    163e:	80 81       	ld	r24, Z
    1640:	82 60       	ori	r24, 0x02	; 2
    1642:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin3);
    1644:	ae e4       	ldi	r26, 0x4E	; 78
    1646:	b0 e0       	ldi	r27, 0x00	; 0
    1648:	ee e4       	ldi	r30, 0x4E	; 78
    164a:	f0 e0       	ldi	r31, 0x00	; 0
    164c:	80 81       	ld	r24, Z
    164e:	87 7f       	andi	r24, 0xF7	; 247
    1650:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin4);
    1652:	ae e4       	ldi	r26, 0x4E	; 78
    1654:	b0 e0       	ldi	r27, 0x00	; 0
    1656:	ee e4       	ldi	r30, 0x4E	; 78
    1658:	f0 e0       	ldi	r31, 0x00	; 0
    165a:	80 81       	ld	r24, Z
    165c:	80 61       	ori	r24, 0x10	; 16
    165e:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1660:	19 82       	std	Y+1, r1	; 0x01
    1662:	a4 c0       	rjmp	.+328    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == PWM_PHASE_CORRECT_OCR1A) {
    1664:	8a 81       	ldd	r24, Y+2	; 0x02
    1666:	8b 30       	cpi	r24, 0x0B	; 11
    1668:	f1 f4       	brne	.+60     	; 0x16a6 <MCAL_T1_u8T1Init+0x330>
			SET_BIT(TCCR1A, Pin0);
    166a:	af e4       	ldi	r26, 0x4F	; 79
    166c:	b0 e0       	ldi	r27, 0x00	; 0
    166e:	ef e4       	ldi	r30, 0x4F	; 79
    1670:	f0 e0       	ldi	r31, 0x00	; 0
    1672:	80 81       	ld	r24, Z
    1674:	81 60       	ori	r24, 0x01	; 1
    1676:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, Pin1);
    1678:	af e4       	ldi	r26, 0x4F	; 79
    167a:	b0 e0       	ldi	r27, 0x00	; 0
    167c:	ef e4       	ldi	r30, 0x4F	; 79
    167e:	f0 e0       	ldi	r31, 0x00	; 0
    1680:	80 81       	ld	r24, Z
    1682:	82 60       	ori	r24, 0x02	; 2
    1684:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin3);
    1686:	ae e4       	ldi	r26, 0x4E	; 78
    1688:	b0 e0       	ldi	r27, 0x00	; 0
    168a:	ee e4       	ldi	r30, 0x4E	; 78
    168c:	f0 e0       	ldi	r31, 0x00	; 0
    168e:	80 81       	ld	r24, Z
    1690:	87 7f       	andi	r24, 0xF7	; 247
    1692:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin4);
    1694:	ae e4       	ldi	r26, 0x4E	; 78
    1696:	b0 e0       	ldi	r27, 0x00	; 0
    1698:	ee e4       	ldi	r30, 0x4E	; 78
    169a:	f0 e0       	ldi	r31, 0x00	; 0
    169c:	80 81       	ld	r24, Z
    169e:	80 61       	ori	r24, 0x10	; 16
    16a0:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    16a2:	19 82       	std	Y+1, r1	; 0x01
    16a4:	83 c0       	rjmp	.+262    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == CTC_ICR1) {
    16a6:	8a 81       	ldd	r24, Y+2	; 0x02
    16a8:	8c 30       	cpi	r24, 0x0C	; 12
    16aa:	f1 f4       	brne	.+60     	; 0x16e8 <MCAL_T1_u8T1Init+0x372>
			CLR_BIT(TCCR1A, Pin0);
    16ac:	af e4       	ldi	r26, 0x4F	; 79
    16ae:	b0 e0       	ldi	r27, 0x00	; 0
    16b0:	ef e4       	ldi	r30, 0x4F	; 79
    16b2:	f0 e0       	ldi	r31, 0x00	; 0
    16b4:	80 81       	ld	r24, Z
    16b6:	8e 7f       	andi	r24, 0xFE	; 254
    16b8:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, Pin1);
    16ba:	af e4       	ldi	r26, 0x4F	; 79
    16bc:	b0 e0       	ldi	r27, 0x00	; 0
    16be:	ef e4       	ldi	r30, 0x4F	; 79
    16c0:	f0 e0       	ldi	r31, 0x00	; 0
    16c2:	80 81       	ld	r24, Z
    16c4:	8d 7f       	andi	r24, 0xFD	; 253
    16c6:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin3);
    16c8:	ae e4       	ldi	r26, 0x4E	; 78
    16ca:	b0 e0       	ldi	r27, 0x00	; 0
    16cc:	ee e4       	ldi	r30, 0x4E	; 78
    16ce:	f0 e0       	ldi	r31, 0x00	; 0
    16d0:	80 81       	ld	r24, Z
    16d2:	88 60       	ori	r24, 0x08	; 8
    16d4:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin4);
    16d6:	ae e4       	ldi	r26, 0x4E	; 78
    16d8:	b0 e0       	ldi	r27, 0x00	; 0
    16da:	ee e4       	ldi	r30, 0x4E	; 78
    16dc:	f0 e0       	ldi	r31, 0x00	; 0
    16de:	80 81       	ld	r24, Z
    16e0:	80 61       	ori	r24, 0x10	; 16
    16e2:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    16e4:	19 82       	std	Y+1, r1	; 0x01
    16e6:	62 c0       	rjmp	.+196    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == REVERSED_MODE) {
    16e8:	8a 81       	ldd	r24, Y+2	; 0x02
    16ea:	8d 30       	cpi	r24, 0x0D	; 13
    16ec:	f1 f4       	brne	.+60     	; 0x172a <MCAL_T1_u8T1Init+0x3b4>
			SET_BIT(TCCR1A, Pin0);
    16ee:	af e4       	ldi	r26, 0x4F	; 79
    16f0:	b0 e0       	ldi	r27, 0x00	; 0
    16f2:	ef e4       	ldi	r30, 0x4F	; 79
    16f4:	f0 e0       	ldi	r31, 0x00	; 0
    16f6:	80 81       	ld	r24, Z
    16f8:	81 60       	ori	r24, 0x01	; 1
    16fa:	8c 93       	st	X, r24
			CLR_BIT(TCCR1A, Pin1);
    16fc:	af e4       	ldi	r26, 0x4F	; 79
    16fe:	b0 e0       	ldi	r27, 0x00	; 0
    1700:	ef e4       	ldi	r30, 0x4F	; 79
    1702:	f0 e0       	ldi	r31, 0x00	; 0
    1704:	80 81       	ld	r24, Z
    1706:	8d 7f       	andi	r24, 0xFD	; 253
    1708:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin3);
    170a:	ae e4       	ldi	r26, 0x4E	; 78
    170c:	b0 e0       	ldi	r27, 0x00	; 0
    170e:	ee e4       	ldi	r30, 0x4E	; 78
    1710:	f0 e0       	ldi	r31, 0x00	; 0
    1712:	80 81       	ld	r24, Z
    1714:	88 60       	ori	r24, 0x08	; 8
    1716:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin4);
    1718:	ae e4       	ldi	r26, 0x4E	; 78
    171a:	b0 e0       	ldi	r27, 0x00	; 0
    171c:	ee e4       	ldi	r30, 0x4E	; 78
    171e:	f0 e0       	ldi	r31, 0x00	; 0
    1720:	80 81       	ld	r24, Z
    1722:	80 61       	ori	r24, 0x10	; 16
    1724:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1726:	19 82       	std	Y+1, r1	; 0x01
    1728:	41 c0       	rjmp	.+130    	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_ICR1) {
    172a:	8a 81       	ldd	r24, Y+2	; 0x02
    172c:	8e 30       	cpi	r24, 0x0E	; 14
    172e:	f1 f4       	brne	.+60     	; 0x176c <MCAL_T1_u8T1Init+0x3f6>
			CLR_BIT(TCCR1A, Pin0);
    1730:	af e4       	ldi	r26, 0x4F	; 79
    1732:	b0 e0       	ldi	r27, 0x00	; 0
    1734:	ef e4       	ldi	r30, 0x4F	; 79
    1736:	f0 e0       	ldi	r31, 0x00	; 0
    1738:	80 81       	ld	r24, Z
    173a:	8e 7f       	andi	r24, 0xFE	; 254
    173c:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, Pin1);
    173e:	af e4       	ldi	r26, 0x4F	; 79
    1740:	b0 e0       	ldi	r27, 0x00	; 0
    1742:	ef e4       	ldi	r30, 0x4F	; 79
    1744:	f0 e0       	ldi	r31, 0x00	; 0
    1746:	80 81       	ld	r24, Z
    1748:	82 60       	ori	r24, 0x02	; 2
    174a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin3);
    174c:	ae e4       	ldi	r26, 0x4E	; 78
    174e:	b0 e0       	ldi	r27, 0x00	; 0
    1750:	ee e4       	ldi	r30, 0x4E	; 78
    1752:	f0 e0       	ldi	r31, 0x00	; 0
    1754:	80 81       	ld	r24, Z
    1756:	88 60       	ori	r24, 0x08	; 8
    1758:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin4);
    175a:	ae e4       	ldi	r26, 0x4E	; 78
    175c:	b0 e0       	ldi	r27, 0x00	; 0
    175e:	ee e4       	ldi	r30, 0x4E	; 78
    1760:	f0 e0       	ldi	r31, 0x00	; 0
    1762:	80 81       	ld	r24, Z
    1764:	80 61       	ori	r24, 0x10	; 16
    1766:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1768:	19 82       	std	Y+1, r1	; 0x01
    176a:	20 c0       	rjmp	.+64     	; 0x17ac <MCAL_T1_u8T1Init+0x436>
		} else if (LOC_u8Timer1Mode == FAST_PWM_OCR1A) {
    176c:	8a 81       	ldd	r24, Y+2	; 0x02
    176e:	8f 30       	cpi	r24, 0x0F	; 15
    1770:	e9 f4       	brne	.+58     	; 0x17ac <MCAL_T1_u8T1Init+0x436>
			SET_BIT(TCCR1A, Pin0);
    1772:	af e4       	ldi	r26, 0x4F	; 79
    1774:	b0 e0       	ldi	r27, 0x00	; 0
    1776:	ef e4       	ldi	r30, 0x4F	; 79
    1778:	f0 e0       	ldi	r31, 0x00	; 0
    177a:	80 81       	ld	r24, Z
    177c:	81 60       	ori	r24, 0x01	; 1
    177e:	8c 93       	st	X, r24
			SET_BIT(TCCR1A, Pin1);
    1780:	af e4       	ldi	r26, 0x4F	; 79
    1782:	b0 e0       	ldi	r27, 0x00	; 0
    1784:	ef e4       	ldi	r30, 0x4F	; 79
    1786:	f0 e0       	ldi	r31, 0x00	; 0
    1788:	80 81       	ld	r24, Z
    178a:	82 60       	ori	r24, 0x02	; 2
    178c:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin3);
    178e:	ae e4       	ldi	r26, 0x4E	; 78
    1790:	b0 e0       	ldi	r27, 0x00	; 0
    1792:	ee e4       	ldi	r30, 0x4E	; 78
    1794:	f0 e0       	ldi	r31, 0x00	; 0
    1796:	80 81       	ld	r24, Z
    1798:	88 60       	ori	r24, 0x08	; 8
    179a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin4);
    179c:	ae e4       	ldi	r26, 0x4E	; 78
    179e:	b0 e0       	ldi	r27, 0x00	; 0
    17a0:	ee e4       	ldi	r30, 0x4E	; 78
    17a2:	f0 e0       	ldi	r31, 0x00	; 0
    17a4:	80 81       	ld	r24, Z
    17a6:	80 61       	ori	r24, 0x10	; 16
    17a8:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    17aa:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    17ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    17ae:	0f 90       	pop	r0
    17b0:	0f 90       	pop	r0
    17b2:	cf 91       	pop	r28
    17b4:	df 91       	pop	r29
    17b6:	08 95       	ret

000017b8 <MCAL_T1_u8T1Prescaler>:
u8 MCAL_T1_u8T1Prescaler(u8 LOC_u8Clock_Selection, f32 *LOC_pf32TickTime) {
    17b8:	df 93       	push	r29
    17ba:	cf 93       	push	r28
    17bc:	00 d0       	rcall	.+0      	; 0x17be <MCAL_T1_u8T1Prescaler+0x6>
    17be:	00 d0       	rcall	.+0      	; 0x17c0 <MCAL_T1_u8T1Prescaler+0x8>
    17c0:	cd b7       	in	r28, 0x3d	; 61
    17c2:	de b7       	in	r29, 0x3e	; 62
    17c4:	8a 83       	std	Y+2, r24	; 0x02
    17c6:	7c 83       	std	Y+4, r23	; 0x04
    17c8:	6b 83       	std	Y+3, r22	; 0x03
	u8 LOC_u8ReturnValue = E_NOT_OK;
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8Clock_Selection <= EXTERNAL_RISING_EDGE) {
    17ce:	8a 81       	ldd	r24, Y+2	; 0x02
    17d0:	88 30       	cpi	r24, 0x08	; 8
    17d2:	08 f0       	brcs	.+2      	; 0x17d6 <MCAL_T1_u8T1Prescaler+0x1e>
    17d4:	01 c1       	rjmp	.+514    	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
		if (LOC_u8Clock_Selection == COUNTER_STOP) {
    17d6:	8a 81       	ldd	r24, Y+2	; 0x02
    17d8:	88 23       	and	r24, r24
    17da:	b9 f4       	brne	.+46     	; 0x180a <MCAL_T1_u8T1Prescaler+0x52>
			CLR_BIT(TCCR1B, Pin0);
    17dc:	ae e4       	ldi	r26, 0x4E	; 78
    17de:	b0 e0       	ldi	r27, 0x00	; 0
    17e0:	ee e4       	ldi	r30, 0x4E	; 78
    17e2:	f0 e0       	ldi	r31, 0x00	; 0
    17e4:	80 81       	ld	r24, Z
    17e6:	8e 7f       	andi	r24, 0xFE	; 254
    17e8:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin1);
    17ea:	ae e4       	ldi	r26, 0x4E	; 78
    17ec:	b0 e0       	ldi	r27, 0x00	; 0
    17ee:	ee e4       	ldi	r30, 0x4E	; 78
    17f0:	f0 e0       	ldi	r31, 0x00	; 0
    17f2:	80 81       	ld	r24, Z
    17f4:	8d 7f       	andi	r24, 0xFD	; 253
    17f6:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin2);
    17f8:	ae e4       	ldi	r26, 0x4E	; 78
    17fa:	b0 e0       	ldi	r27, 0x00	; 0
    17fc:	ee e4       	ldi	r30, 0x4E	; 78
    17fe:	f0 e0       	ldi	r31, 0x00	; 0
    1800:	80 81       	ld	r24, Z
    1802:	8b 7f       	andi	r24, 0xFB	; 251
    1804:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    1806:	19 82       	std	Y+1, r1	; 0x01
    1808:	e7 c0       	rjmp	.+462    	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_0) {
    180a:	8a 81       	ldd	r24, Y+2	; 0x02
    180c:	81 30       	cpi	r24, 0x01	; 1
    180e:	09 f5       	brne	.+66     	; 0x1852 <MCAL_T1_u8T1Prescaler+0x9a>
			SET_BIT(TCCR1B, Pin0);
    1810:	ae e4       	ldi	r26, 0x4E	; 78
    1812:	b0 e0       	ldi	r27, 0x00	; 0
    1814:	ee e4       	ldi	r30, 0x4E	; 78
    1816:	f0 e0       	ldi	r31, 0x00	; 0
    1818:	80 81       	ld	r24, Z
    181a:	81 60       	ori	r24, 0x01	; 1
    181c:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin1);
    181e:	ae e4       	ldi	r26, 0x4E	; 78
    1820:	b0 e0       	ldi	r27, 0x00	; 0
    1822:	ee e4       	ldi	r30, 0x4E	; 78
    1824:	f0 e0       	ldi	r31, 0x00	; 0
    1826:	80 81       	ld	r24, Z
    1828:	8d 7f       	andi	r24, 0xFD	; 253
    182a:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin2);
    182c:	ae e4       	ldi	r26, 0x4E	; 78
    182e:	b0 e0       	ldi	r27, 0x00	; 0
    1830:	ee e4       	ldi	r30, 0x4E	; 78
    1832:	f0 e0       	ldi	r31, 0x00	; 0
    1834:	80 81       	ld	r24, Z
    1836:	8b 7f       	andi	r24, 0xFB	; 251
    1838:	8c 93       	st	X, r24
			*LOC_pf32TickTime = PRESCALLING0 / (f32) CPU_FREQUNCY;
    183a:	eb 81       	ldd	r30, Y+3	; 0x03
    183c:	fc 81       	ldd	r31, Y+4	; 0x04
    183e:	8d eb       	ldi	r24, 0xBD	; 189
    1840:	97 e3       	ldi	r25, 0x37	; 55
    1842:	a6 e8       	ldi	r26, 0x86	; 134
    1844:	b3 e3       	ldi	r27, 0x33	; 51
    1846:	80 83       	st	Z, r24
    1848:	91 83       	std	Z+1, r25	; 0x01
    184a:	a2 83       	std	Z+2, r26	; 0x02
    184c:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    184e:	19 82       	std	Y+1, r1	; 0x01
    1850:	c3 c0       	rjmp	.+390    	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_8) {
    1852:	8a 81       	ldd	r24, Y+2	; 0x02
    1854:	82 30       	cpi	r24, 0x02	; 2
    1856:	09 f5       	brne	.+66     	; 0x189a <MCAL_T1_u8T1Prescaler+0xe2>
			CLR_BIT(TCCR1B, Pin0);
    1858:	ae e4       	ldi	r26, 0x4E	; 78
    185a:	b0 e0       	ldi	r27, 0x00	; 0
    185c:	ee e4       	ldi	r30, 0x4E	; 78
    185e:	f0 e0       	ldi	r31, 0x00	; 0
    1860:	80 81       	ld	r24, Z
    1862:	8e 7f       	andi	r24, 0xFE	; 254
    1864:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin1);
    1866:	ae e4       	ldi	r26, 0x4E	; 78
    1868:	b0 e0       	ldi	r27, 0x00	; 0
    186a:	ee e4       	ldi	r30, 0x4E	; 78
    186c:	f0 e0       	ldi	r31, 0x00	; 0
    186e:	80 81       	ld	r24, Z
    1870:	82 60       	ori	r24, 0x02	; 2
    1872:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin2);
    1874:	ae e4       	ldi	r26, 0x4E	; 78
    1876:	b0 e0       	ldi	r27, 0x00	; 0
    1878:	ee e4       	ldi	r30, 0x4E	; 78
    187a:	f0 e0       	ldi	r31, 0x00	; 0
    187c:	80 81       	ld	r24, Z
    187e:	8b 7f       	andi	r24, 0xFB	; 251
    1880:	8c 93       	st	X, r24
			*LOC_pf32TickTime = PRESCALLING8 / (f32) CPU_FREQUNCY;
    1882:	eb 81       	ldd	r30, Y+3	; 0x03
    1884:	fc 81       	ldd	r31, Y+4	; 0x04
    1886:	8d eb       	ldi	r24, 0xBD	; 189
    1888:	97 e3       	ldi	r25, 0x37	; 55
    188a:	a6 e0       	ldi	r26, 0x06	; 6
    188c:	b5 e3       	ldi	r27, 0x35	; 53
    188e:	80 83       	st	Z, r24
    1890:	91 83       	std	Z+1, r25	; 0x01
    1892:	a2 83       	std	Z+2, r26	; 0x02
    1894:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    1896:	19 82       	std	Y+1, r1	; 0x01
    1898:	9f c0       	rjmp	.+318    	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_64) {
    189a:	8a 81       	ldd	r24, Y+2	; 0x02
    189c:	83 30       	cpi	r24, 0x03	; 3
    189e:	09 f5       	brne	.+66     	; 0x18e2 <MCAL_T1_u8T1Prescaler+0x12a>
			SET_BIT(TCCR1B, Pin0);
    18a0:	ae e4       	ldi	r26, 0x4E	; 78
    18a2:	b0 e0       	ldi	r27, 0x00	; 0
    18a4:	ee e4       	ldi	r30, 0x4E	; 78
    18a6:	f0 e0       	ldi	r31, 0x00	; 0
    18a8:	80 81       	ld	r24, Z
    18aa:	81 60       	ori	r24, 0x01	; 1
    18ac:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin1);
    18ae:	ae e4       	ldi	r26, 0x4E	; 78
    18b0:	b0 e0       	ldi	r27, 0x00	; 0
    18b2:	ee e4       	ldi	r30, 0x4E	; 78
    18b4:	f0 e0       	ldi	r31, 0x00	; 0
    18b6:	80 81       	ld	r24, Z
    18b8:	82 60       	ori	r24, 0x02	; 2
    18ba:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin2);
    18bc:	ae e4       	ldi	r26, 0x4E	; 78
    18be:	b0 e0       	ldi	r27, 0x00	; 0
    18c0:	ee e4       	ldi	r30, 0x4E	; 78
    18c2:	f0 e0       	ldi	r31, 0x00	; 0
    18c4:	80 81       	ld	r24, Z
    18c6:	8b 7f       	andi	r24, 0xFB	; 251
    18c8:	8c 93       	st	X, r24
			*LOC_pf32TickTime = PRESCALLING64 / (f32) CPU_FREQUNCY;
    18ca:	eb 81       	ldd	r30, Y+3	; 0x03
    18cc:	fc 81       	ldd	r31, Y+4	; 0x04
    18ce:	8d eb       	ldi	r24, 0xBD	; 189
    18d0:	97 e3       	ldi	r25, 0x37	; 55
    18d2:	a6 e8       	ldi	r26, 0x86	; 134
    18d4:	b6 e3       	ldi	r27, 0x36	; 54
    18d6:	80 83       	st	Z, r24
    18d8:	91 83       	std	Z+1, r25	; 0x01
    18da:	a2 83       	std	Z+2, r26	; 0x02
    18dc:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    18de:	19 82       	std	Y+1, r1	; 0x01
    18e0:	7b c0       	rjmp	.+246    	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_256) {
    18e2:	8a 81       	ldd	r24, Y+2	; 0x02
    18e4:	84 30       	cpi	r24, 0x04	; 4
    18e6:	09 f5       	brne	.+66     	; 0x192a <MCAL_T1_u8T1Prescaler+0x172>
			CLR_BIT(TCCR1B, Pin0);
    18e8:	ae e4       	ldi	r26, 0x4E	; 78
    18ea:	b0 e0       	ldi	r27, 0x00	; 0
    18ec:	ee e4       	ldi	r30, 0x4E	; 78
    18ee:	f0 e0       	ldi	r31, 0x00	; 0
    18f0:	80 81       	ld	r24, Z
    18f2:	8e 7f       	andi	r24, 0xFE	; 254
    18f4:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin1);
    18f6:	ae e4       	ldi	r26, 0x4E	; 78
    18f8:	b0 e0       	ldi	r27, 0x00	; 0
    18fa:	ee e4       	ldi	r30, 0x4E	; 78
    18fc:	f0 e0       	ldi	r31, 0x00	; 0
    18fe:	80 81       	ld	r24, Z
    1900:	8d 7f       	andi	r24, 0xFD	; 253
    1902:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin2);
    1904:	ae e4       	ldi	r26, 0x4E	; 78
    1906:	b0 e0       	ldi	r27, 0x00	; 0
    1908:	ee e4       	ldi	r30, 0x4E	; 78
    190a:	f0 e0       	ldi	r31, 0x00	; 0
    190c:	80 81       	ld	r24, Z
    190e:	84 60       	ori	r24, 0x04	; 4
    1910:	8c 93       	st	X, r24
			*LOC_pf32TickTime = PRESCALLING256 / (f32) CPU_FREQUNCY;
    1912:	eb 81       	ldd	r30, Y+3	; 0x03
    1914:	fc 81       	ldd	r31, Y+4	; 0x04
    1916:	8d eb       	ldi	r24, 0xBD	; 189
    1918:	97 e3       	ldi	r25, 0x37	; 55
    191a:	a6 e8       	ldi	r26, 0x86	; 134
    191c:	b7 e3       	ldi	r27, 0x37	; 55
    191e:	80 83       	st	Z, r24
    1920:	91 83       	std	Z+1, r25	; 0x01
    1922:	a2 83       	std	Z+2, r26	; 0x02
    1924:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    1926:	19 82       	std	Y+1, r1	; 0x01
    1928:	57 c0       	rjmp	.+174    	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == PRESCALLING_1024) {
    192a:	8a 81       	ldd	r24, Y+2	; 0x02
    192c:	85 30       	cpi	r24, 0x05	; 5
    192e:	09 f5       	brne	.+66     	; 0x1972 <MCAL_T1_u8T1Prescaler+0x1ba>
			SET_BIT(TCCR1B, Pin0);
    1930:	ae e4       	ldi	r26, 0x4E	; 78
    1932:	b0 e0       	ldi	r27, 0x00	; 0
    1934:	ee e4       	ldi	r30, 0x4E	; 78
    1936:	f0 e0       	ldi	r31, 0x00	; 0
    1938:	80 81       	ld	r24, Z
    193a:	81 60       	ori	r24, 0x01	; 1
    193c:	8c 93       	st	X, r24
			CLR_BIT(TCCR1B, Pin1);
    193e:	ae e4       	ldi	r26, 0x4E	; 78
    1940:	b0 e0       	ldi	r27, 0x00	; 0
    1942:	ee e4       	ldi	r30, 0x4E	; 78
    1944:	f0 e0       	ldi	r31, 0x00	; 0
    1946:	80 81       	ld	r24, Z
    1948:	8d 7f       	andi	r24, 0xFD	; 253
    194a:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin2);
    194c:	ae e4       	ldi	r26, 0x4E	; 78
    194e:	b0 e0       	ldi	r27, 0x00	; 0
    1950:	ee e4       	ldi	r30, 0x4E	; 78
    1952:	f0 e0       	ldi	r31, 0x00	; 0
    1954:	80 81       	ld	r24, Z
    1956:	84 60       	ori	r24, 0x04	; 4
    1958:	8c 93       	st	X, r24
			*LOC_pf32TickTime = PRESCALLING1024 / (f32) CPU_FREQUNCY;
    195a:	eb 81       	ldd	r30, Y+3	; 0x03
    195c:	fc 81       	ldd	r31, Y+4	; 0x04
    195e:	8d eb       	ldi	r24, 0xBD	; 189
    1960:	97 e3       	ldi	r25, 0x37	; 55
    1962:	a6 e8       	ldi	r26, 0x86	; 134
    1964:	b8 e3       	ldi	r27, 0x38	; 56
    1966:	80 83       	st	Z, r24
    1968:	91 83       	std	Z+1, r25	; 0x01
    196a:	a2 83       	std	Z+2, r26	; 0x02
    196c:	b3 83       	std	Z+3, r27	; 0x03
			LOC_u8ReturnValue = E_OK;
    196e:	19 82       	std	Y+1, r1	; 0x01
    1970:	33 c0       	rjmp	.+102    	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == EXTERNAL_FALLING_EDGE) {
    1972:	8a 81       	ldd	r24, Y+2	; 0x02
    1974:	86 30       	cpi	r24, 0x06	; 6
    1976:	b9 f4       	brne	.+46     	; 0x19a6 <MCAL_T1_u8T1Prescaler+0x1ee>
			CLR_BIT(TCCR1B, Pin0);
    1978:	ae e4       	ldi	r26, 0x4E	; 78
    197a:	b0 e0       	ldi	r27, 0x00	; 0
    197c:	ee e4       	ldi	r30, 0x4E	; 78
    197e:	f0 e0       	ldi	r31, 0x00	; 0
    1980:	80 81       	ld	r24, Z
    1982:	8e 7f       	andi	r24, 0xFE	; 254
    1984:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin1);
    1986:	ae e4       	ldi	r26, 0x4E	; 78
    1988:	b0 e0       	ldi	r27, 0x00	; 0
    198a:	ee e4       	ldi	r30, 0x4E	; 78
    198c:	f0 e0       	ldi	r31, 0x00	; 0
    198e:	80 81       	ld	r24, Z
    1990:	82 60       	ori	r24, 0x02	; 2
    1992:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin2);
    1994:	ae e4       	ldi	r26, 0x4E	; 78
    1996:	b0 e0       	ldi	r27, 0x00	; 0
    1998:	ee e4       	ldi	r30, 0x4E	; 78
    199a:	f0 e0       	ldi	r31, 0x00	; 0
    199c:	80 81       	ld	r24, Z
    199e:	84 60       	ori	r24, 0x04	; 4
    19a0:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    19a2:	19 82       	std	Y+1, r1	; 0x01
    19a4:	19 c0       	rjmp	.+50     	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
		} else if (LOC_u8Clock_Selection == EXTERNAL_RISING_EDGE) {
    19a6:	8a 81       	ldd	r24, Y+2	; 0x02
    19a8:	87 30       	cpi	r24, 0x07	; 7
    19aa:	b1 f4       	brne	.+44     	; 0x19d8 <MCAL_T1_u8T1Prescaler+0x220>
			SET_BIT(TCCR1B, Pin0);
    19ac:	ae e4       	ldi	r26, 0x4E	; 78
    19ae:	b0 e0       	ldi	r27, 0x00	; 0
    19b0:	ee e4       	ldi	r30, 0x4E	; 78
    19b2:	f0 e0       	ldi	r31, 0x00	; 0
    19b4:	80 81       	ld	r24, Z
    19b6:	81 60       	ori	r24, 0x01	; 1
    19b8:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin1);
    19ba:	ae e4       	ldi	r26, 0x4E	; 78
    19bc:	b0 e0       	ldi	r27, 0x00	; 0
    19be:	ee e4       	ldi	r30, 0x4E	; 78
    19c0:	f0 e0       	ldi	r31, 0x00	; 0
    19c2:	80 81       	ld	r24, Z
    19c4:	82 60       	ori	r24, 0x02	; 2
    19c6:	8c 93       	st	X, r24
			SET_BIT(TCCR1B, Pin2);
    19c8:	ae e4       	ldi	r26, 0x4E	; 78
    19ca:	b0 e0       	ldi	r27, 0x00	; 0
    19cc:	ee e4       	ldi	r30, 0x4E	; 78
    19ce:	f0 e0       	ldi	r31, 0x00	; 0
    19d0:	80 81       	ld	r24, Z
    19d2:	84 60       	ori	r24, 0x04	; 4
    19d4:	8c 93       	st	X, r24
			LOC_u8ReturnValue = E_OK;
    19d6:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    19d8:	89 81       	ldd	r24, Y+1	; 0x01
}
    19da:	0f 90       	pop	r0
    19dc:	0f 90       	pop	r0
    19de:	0f 90       	pop	r0
    19e0:	0f 90       	pop	r0
    19e2:	cf 91       	pop	r28
    19e4:	df 91       	pop	r29
    19e6:	08 95       	ret

000019e8 <MCAL_T1_u8T1CompareOutputMode>:
//Fast MODE PWM & PHASE CORRECT
u8 MCAL_T1_u8T1CompareOutputMode(u8 LOC_u8OutputMode, u8 LOC_u8Channel) {
    19e8:	df 93       	push	r29
    19ea:	cf 93       	push	r28
    19ec:	00 d0       	rcall	.+0      	; 0x19ee <MCAL_T1_u8T1CompareOutputMode+0x6>
    19ee:	0f 92       	push	r0
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
    19f4:	8a 83       	std	Y+2, r24	; 0x02
    19f6:	6b 83       	std	Y+3, r22	; 0x03
	u8 LOC_u8ReturnValue = E_NOT_OK;
    19f8:	81 e0       	ldi	r24, 0x01	; 1
    19fa:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8OutputMode <= INVERTING_MODE && LOC_u8Channel <= CHENNEL_B) {
    19fc:	8a 81       	ldd	r24, Y+2	; 0x02
    19fe:	82 30       	cpi	r24, 0x02	; 2
    1a00:	08 f0       	brcs	.+2      	; 0x1a04 <MCAL_T1_u8T1CompareOutputMode+0x1c>
    1a02:	72 c0       	rjmp	.+228    	; 0x1ae8 <MCAL_T1_u8T1CompareOutputMode+0x100>
    1a04:	8b 81       	ldd	r24, Y+3	; 0x03
    1a06:	82 30       	cpi	r24, 0x02	; 2
    1a08:	08 f0       	brcs	.+2      	; 0x1a0c <MCAL_T1_u8T1CompareOutputMode+0x24>
    1a0a:	6e c0       	rjmp	.+220    	; 0x1ae8 <MCAL_T1_u8T1CompareOutputMode+0x100>
		if (LOC_u8Channel == CHENNEL_A) {
    1a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0e:	88 23       	and	r24, r24
    1a10:	a9 f5       	brne	.+106    	; 0x1a7c <MCAL_T1_u8T1CompareOutputMode+0x94>
			if (LOC_u8OutputMode == NON_INVERTING_MODE) {
    1a12:	8a 81       	ldd	r24, Y+2	; 0x02
    1a14:	88 23       	and	r24, r24
    1a16:	b9 f4       	brne	.+46     	; 0x1a46 <MCAL_T1_u8T1CompareOutputMode+0x5e>
				CLR_BIT(TCCR1A, Pin6);
    1a18:	af e4       	ldi	r26, 0x4F	; 79
    1a1a:	b0 e0       	ldi	r27, 0x00	; 0
    1a1c:	ef e4       	ldi	r30, 0x4F	; 79
    1a1e:	f0 e0       	ldi	r31, 0x00	; 0
    1a20:	80 81       	ld	r24, Z
    1a22:	8f 7b       	andi	r24, 0xBF	; 191
    1a24:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, Pin7);
    1a26:	af e4       	ldi	r26, 0x4F	; 79
    1a28:	b0 e0       	ldi	r27, 0x00	; 0
    1a2a:	ef e4       	ldi	r30, 0x4F	; 79
    1a2c:	f0 e0       	ldi	r31, 0x00	; 0
    1a2e:	80 81       	ld	r24, Z
    1a30:	80 68       	ori	r24, 0x80	; 128
    1a32:	8c 93       	st	X, r24
				SET_BIT(DDRD, Pin5);
    1a34:	a1 e3       	ldi	r26, 0x31	; 49
    1a36:	b0 e0       	ldi	r27, 0x00	; 0
    1a38:	e1 e3       	ldi	r30, 0x31	; 49
    1a3a:	f0 e0       	ldi	r31, 0x00	; 0
    1a3c:	80 81       	ld	r24, Z
    1a3e:	80 62       	ori	r24, 0x20	; 32
    1a40:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1a42:	19 82       	std	Y+1, r1	; 0x01
    1a44:	51 c0       	rjmp	.+162    	; 0x1ae8 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else if (LOC_u8OutputMode == INVERTING_MODE) {
    1a46:	8a 81       	ldd	r24, Y+2	; 0x02
    1a48:	81 30       	cpi	r24, 0x01	; 1
    1a4a:	09 f0       	breq	.+2      	; 0x1a4e <MCAL_T1_u8T1CompareOutputMode+0x66>
    1a4c:	4d c0       	rjmp	.+154    	; 0x1ae8 <MCAL_T1_u8T1CompareOutputMode+0x100>
				SET_BIT(TCCR1A, Pin6);
    1a4e:	af e4       	ldi	r26, 0x4F	; 79
    1a50:	b0 e0       	ldi	r27, 0x00	; 0
    1a52:	ef e4       	ldi	r30, 0x4F	; 79
    1a54:	f0 e0       	ldi	r31, 0x00	; 0
    1a56:	80 81       	ld	r24, Z
    1a58:	80 64       	ori	r24, 0x40	; 64
    1a5a:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, Pin7);
    1a5c:	af e4       	ldi	r26, 0x4F	; 79
    1a5e:	b0 e0       	ldi	r27, 0x00	; 0
    1a60:	ef e4       	ldi	r30, 0x4F	; 79
    1a62:	f0 e0       	ldi	r31, 0x00	; 0
    1a64:	80 81       	ld	r24, Z
    1a66:	80 68       	ori	r24, 0x80	; 128
    1a68:	8c 93       	st	X, r24
				SET_BIT(DDRD, Pin5);
    1a6a:	a1 e3       	ldi	r26, 0x31	; 49
    1a6c:	b0 e0       	ldi	r27, 0x00	; 0
    1a6e:	e1 e3       	ldi	r30, 0x31	; 49
    1a70:	f0 e0       	ldi	r31, 0x00	; 0
    1a72:	80 81       	ld	r24, Z
    1a74:	80 62       	ori	r24, 0x20	; 32
    1a76:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1a78:	19 82       	std	Y+1, r1	; 0x01
    1a7a:	36 c0       	rjmp	.+108    	; 0x1ae8 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else {
				//NOTHING
			}
		} else if (LOC_u8Channel == CHENNEL_B) {
    1a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a7e:	81 30       	cpi	r24, 0x01	; 1
    1a80:	99 f5       	brne	.+102    	; 0x1ae8 <MCAL_T1_u8T1CompareOutputMode+0x100>
			if (LOC_u8OutputMode == NON_INVERTING_MODE) {
    1a82:	8a 81       	ldd	r24, Y+2	; 0x02
    1a84:	88 23       	and	r24, r24
    1a86:	b9 f4       	brne	.+46     	; 0x1ab6 <MCAL_T1_u8T1CompareOutputMode+0xce>
				CLR_BIT(TCCR1A, Pin4);
    1a88:	af e4       	ldi	r26, 0x4F	; 79
    1a8a:	b0 e0       	ldi	r27, 0x00	; 0
    1a8c:	ef e4       	ldi	r30, 0x4F	; 79
    1a8e:	f0 e0       	ldi	r31, 0x00	; 0
    1a90:	80 81       	ld	r24, Z
    1a92:	8f 7e       	andi	r24, 0xEF	; 239
    1a94:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, Pin5);
    1a96:	af e4       	ldi	r26, 0x4F	; 79
    1a98:	b0 e0       	ldi	r27, 0x00	; 0
    1a9a:	ef e4       	ldi	r30, 0x4F	; 79
    1a9c:	f0 e0       	ldi	r31, 0x00	; 0
    1a9e:	80 81       	ld	r24, Z
    1aa0:	80 62       	ori	r24, 0x20	; 32
    1aa2:	8c 93       	st	X, r24
				SET_BIT(DDRD, Pin4);
    1aa4:	a1 e3       	ldi	r26, 0x31	; 49
    1aa6:	b0 e0       	ldi	r27, 0x00	; 0
    1aa8:	e1 e3       	ldi	r30, 0x31	; 49
    1aaa:	f0 e0       	ldi	r31, 0x00	; 0
    1aac:	80 81       	ld	r24, Z
    1aae:	80 61       	ori	r24, 0x10	; 16
    1ab0:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1ab2:	19 82       	std	Y+1, r1	; 0x01
    1ab4:	19 c0       	rjmp	.+50     	; 0x1ae8 <MCAL_T1_u8T1CompareOutputMode+0x100>
			} else if (LOC_u8OutputMode == INVERTING_MODE) {
    1ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab8:	81 30       	cpi	r24, 0x01	; 1
    1aba:	b1 f4       	brne	.+44     	; 0x1ae8 <MCAL_T1_u8T1CompareOutputMode+0x100>
				SET_BIT(TCCR1A, Pin4);
    1abc:	af e4       	ldi	r26, 0x4F	; 79
    1abe:	b0 e0       	ldi	r27, 0x00	; 0
    1ac0:	ef e4       	ldi	r30, 0x4F	; 79
    1ac2:	f0 e0       	ldi	r31, 0x00	; 0
    1ac4:	80 81       	ld	r24, Z
    1ac6:	80 61       	ori	r24, 0x10	; 16
    1ac8:	8c 93       	st	X, r24
				SET_BIT(TCCR1A, Pin5);
    1aca:	af e4       	ldi	r26, 0x4F	; 79
    1acc:	b0 e0       	ldi	r27, 0x00	; 0
    1ace:	ef e4       	ldi	r30, 0x4F	; 79
    1ad0:	f0 e0       	ldi	r31, 0x00	; 0
    1ad2:	80 81       	ld	r24, Z
    1ad4:	80 62       	ori	r24, 0x20	; 32
    1ad6:	8c 93       	st	X, r24
				SET_BIT(DDRD, Pin4);
    1ad8:	a1 e3       	ldi	r26, 0x31	; 49
    1ada:	b0 e0       	ldi	r27, 0x00	; 0
    1adc:	e1 e3       	ldi	r30, 0x31	; 49
    1ade:	f0 e0       	ldi	r31, 0x00	; 0
    1ae0:	80 81       	ld	r24, Z
    1ae2:	80 61       	ori	r24, 0x10	; 16
    1ae4:	8c 93       	st	X, r24
				LOC_u8ReturnValue = E_OK;
    1ae6:	19 82       	std	Y+1, r1	; 0x01
			//NOTHING
		}
	} else {
		//NOTHING
	}
	return LOC_u8ReturnValue;
    1ae8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1aea:	0f 90       	pop	r0
    1aec:	0f 90       	pop	r0
    1aee:	0f 90       	pop	r0
    1af0:	cf 91       	pop	r28
    1af2:	df 91       	pop	r29
    1af4:	08 95       	ret

00001af6 <MCAL_T1_voidNoiseCancller>:
//NOISE CANCLLER
void MCAL_T1_voidNoiseCancller(void) {
    1af6:	df 93       	push	r29
    1af8:	cf 93       	push	r28
    1afa:	cd b7       	in	r28, 0x3d	; 61
    1afc:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR1B, Pin7);
    1afe:	ae e4       	ldi	r26, 0x4E	; 78
    1b00:	b0 e0       	ldi	r27, 0x00	; 0
    1b02:	ee e4       	ldi	r30, 0x4E	; 78
    1b04:	f0 e0       	ldi	r31, 0x00	; 0
    1b06:	80 81       	ld	r24, Z
    1b08:	80 68       	ori	r24, 0x80	; 128
    1b0a:	8c 93       	st	X, r24
}
    1b0c:	cf 91       	pop	r28
    1b0e:	df 91       	pop	r29
    1b10:	08 95       	ret

00001b12 <MCAL_T1_voidSetTCNT1Value>:
//Set TCNT1 Value
void MCAL_T1_voidSetTCNT1Value(u16 LOC_u16Value) {
    1b12:	df 93       	push	r29
    1b14:	cf 93       	push	r28
    1b16:	00 d0       	rcall	.+0      	; 0x1b18 <MCAL_T1_voidSetTCNT1Value+0x6>
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	9a 83       	std	Y+2, r25	; 0x02
    1b1e:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		TCNT1 = LOC_u16Value;
    1b20:	ec e4       	ldi	r30, 0x4C	; 76
    1b22:	f0 e0       	ldi	r31, 0x00	; 0
    1b24:	89 81       	ldd	r24, Y+1	; 0x01
    1b26:	9a 81       	ldd	r25, Y+2	; 0x02
    1b28:	91 83       	std	Z+1, r25	; 0x01
    1b2a:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1b2c:	0f 90       	pop	r0
    1b2e:	0f 90       	pop	r0
    1b30:	cf 91       	pop	r28
    1b32:	df 91       	pop	r29
    1b34:	08 95       	ret

00001b36 <MCAL_T1_voidGetTCNT1Value>:
//GIT TCNT1
void MCAL_T1_voidGetTCNT1Value(u16 *LOC_pu16Value) {
    1b36:	df 93       	push	r29
    1b38:	cf 93       	push	r28
    1b3a:	00 d0       	rcall	.+0      	; 0x1b3c <MCAL_T1_voidGetTCNT1Value+0x6>
    1b3c:	cd b7       	in	r28, 0x3d	; 61
    1b3e:	de b7       	in	r29, 0x3e	; 62
    1b40:	9a 83       	std	Y+2, r25	; 0x02
    1b42:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_pu16Value) {
    1b44:	89 81       	ldd	r24, Y+1	; 0x01
    1b46:	9a 81       	ldd	r25, Y+2	; 0x02
    1b48:	00 97       	sbiw	r24, 0x00	; 0
    1b4a:	41 f0       	breq	.+16     	; 0x1b5c <MCAL_T1_voidGetTCNT1Value+0x26>
		*LOC_pu16Value = TCNT1;
    1b4c:	ec e4       	ldi	r30, 0x4C	; 76
    1b4e:	f0 e0       	ldi	r31, 0x00	; 0
    1b50:	80 81       	ld	r24, Z
    1b52:	91 81       	ldd	r25, Z+1	; 0x01
    1b54:	e9 81       	ldd	r30, Y+1	; 0x01
    1b56:	fa 81       	ldd	r31, Y+2	; 0x02
    1b58:	91 83       	std	Z+1, r25	; 0x01
    1b5a:	80 83       	st	Z, r24
	}
}
    1b5c:	0f 90       	pop	r0
    1b5e:	0f 90       	pop	r0
    1b60:	cf 91       	pop	r28
    1b62:	df 91       	pop	r29
    1b64:	08 95       	ret

00001b66 <MCAL_T1_voidSetOCR1AValue>:
//Set OCR1A
void MCAL_T1_voidSetOCR1AValue(u16 LOC_u16Value) {
    1b66:	df 93       	push	r29
    1b68:	cf 93       	push	r28
    1b6a:	00 d0       	rcall	.+0      	; 0x1b6c <MCAL_T1_voidSetOCR1AValue+0x6>
    1b6c:	cd b7       	in	r28, 0x3d	; 61
    1b6e:	de b7       	in	r29, 0x3e	; 62
    1b70:	9a 83       	std	Y+2, r25	; 0x02
    1b72:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		OCR1A = LOC_u16Value;
    1b74:	ea e4       	ldi	r30, 0x4A	; 74
    1b76:	f0 e0       	ldi	r31, 0x00	; 0
    1b78:	89 81       	ldd	r24, Y+1	; 0x01
    1b7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b7c:	91 83       	std	Z+1, r25	; 0x01
    1b7e:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1b80:	0f 90       	pop	r0
    1b82:	0f 90       	pop	r0
    1b84:	cf 91       	pop	r28
    1b86:	df 91       	pop	r29
    1b88:	08 95       	ret

00001b8a <MCAL_T1_voidSetOCR1BValue>:
//SET OCR1B
void MCAL_T1_voidSetOCR1BValue(u16 LOC_u16Value) {
    1b8a:	df 93       	push	r29
    1b8c:	cf 93       	push	r28
    1b8e:	00 d0       	rcall	.+0      	; 0x1b90 <MCAL_T1_voidSetOCR1BValue+0x6>
    1b90:	cd b7       	in	r28, 0x3d	; 61
    1b92:	de b7       	in	r29, 0x3e	; 62
    1b94:	9a 83       	std	Y+2, r25	; 0x02
    1b96:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		OCR1B = LOC_u16Value;
    1b98:	e8 e4       	ldi	r30, 0x48	; 72
    1b9a:	f0 e0       	ldi	r31, 0x00	; 0
    1b9c:	89 81       	ldd	r24, Y+1	; 0x01
    1b9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba0:	91 83       	std	Z+1, r25	; 0x01
    1ba2:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1ba4:	0f 90       	pop	r0
    1ba6:	0f 90       	pop	r0
    1ba8:	cf 91       	pop	r28
    1baa:	df 91       	pop	r29
    1bac:	08 95       	ret

00001bae <MCAL_T1_voidSetICR1Value>:
//SET ICR1
void MCAL_T1_voidSetICR1Value(u16 LOC_u16Value) {
    1bae:	df 93       	push	r29
    1bb0:	cf 93       	push	r28
    1bb2:	00 d0       	rcall	.+0      	; 0x1bb4 <MCAL_T1_voidSetICR1Value+0x6>
    1bb4:	cd b7       	in	r28, 0x3d	; 61
    1bb6:	de b7       	in	r29, 0x3e	; 62
    1bb8:	9a 83       	std	Y+2, r25	; 0x02
    1bba:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u16Value <= SIXTEEN_BIT_MAX_VALUE) {
		ICR1 = LOC_u16Value;
    1bbc:	e6 e4       	ldi	r30, 0x46	; 70
    1bbe:	f0 e0       	ldi	r31, 0x00	; 0
    1bc0:	89 81       	ldd	r24, Y+1	; 0x01
    1bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc4:	91 83       	std	Z+1, r25	; 0x01
    1bc6:	80 83       	st	Z, r24
	} else {
		//NOTHING
	}
}
    1bc8:	0f 90       	pop	r0
    1bca:	0f 90       	pop	r0
    1bcc:	cf 91       	pop	r28
    1bce:	df 91       	pop	r29
    1bd0:	08 95       	ret

00001bd2 <MCAL_T1_voidGetICR1Value>:
//Get ICR1
void MCAL_T1_voidGetICR1Value(u16 *LOC_pu16Value) {
    1bd2:	df 93       	push	r29
    1bd4:	cf 93       	push	r28
    1bd6:	00 d0       	rcall	.+0      	; 0x1bd8 <MCAL_T1_voidGetICR1Value+0x6>
    1bd8:	cd b7       	in	r28, 0x3d	; 61
    1bda:	de b7       	in	r29, 0x3e	; 62
    1bdc:	9a 83       	std	Y+2, r25	; 0x02
    1bde:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_pu16Value) {
    1be0:	89 81       	ldd	r24, Y+1	; 0x01
    1be2:	9a 81       	ldd	r25, Y+2	; 0x02
    1be4:	00 97       	sbiw	r24, 0x00	; 0
    1be6:	41 f0       	breq	.+16     	; 0x1bf8 <MCAL_T1_voidGetICR1Value+0x26>
		*LOC_pu16Value = ICR1;
    1be8:	e6 e4       	ldi	r30, 0x46	; 70
    1bea:	f0 e0       	ldi	r31, 0x00	; 0
    1bec:	80 81       	ld	r24, Z
    1bee:	91 81       	ldd	r25, Z+1	; 0x01
    1bf0:	e9 81       	ldd	r30, Y+1	; 0x01
    1bf2:	fa 81       	ldd	r31, Y+2	; 0x02
    1bf4:	91 83       	std	Z+1, r25	; 0x01
    1bf6:	80 83       	st	Z, r24
	}
}
    1bf8:	0f 90       	pop	r0
    1bfa:	0f 90       	pop	r0
    1bfc:	cf 91       	pop	r28
    1bfe:	df 91       	pop	r29
    1c00:	08 95       	ret

00001c02 <MCAL_T1_voidTCNT1_GIEEnable>:
//TCNT1 PIE
void MCAL_T1_voidTCNT1_GIEEnable(void) {
    1c02:	df 93       	push	r29
    1c04:	cf 93       	push	r28
    1c06:	cd b7       	in	r28, 0x3d	; 61
    1c08:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, Pin7);
    1c0a:	af e5       	ldi	r26, 0x5F	; 95
    1c0c:	b0 e0       	ldi	r27, 0x00	; 0
    1c0e:	ef e5       	ldi	r30, 0x5F	; 95
    1c10:	f0 e0       	ldi	r31, 0x00	; 0
    1c12:	80 81       	ld	r24, Z
    1c14:	80 68       	ori	r24, 0x80	; 128
    1c16:	8c 93       	st	X, r24
	SET_BIT(TIMSK, Pin2);
    1c18:	a9 e5       	ldi	r26, 0x59	; 89
    1c1a:	b0 e0       	ldi	r27, 0x00	; 0
    1c1c:	e9 e5       	ldi	r30, 0x59	; 89
    1c1e:	f0 e0       	ldi	r31, 0x00	; 0
    1c20:	80 81       	ld	r24, Z
    1c22:	84 60       	ori	r24, 0x04	; 4
    1c24:	8c 93       	st	X, r24
}
    1c26:	cf 91       	pop	r28
    1c28:	df 91       	pop	r29
    1c2a:	08 95       	ret

00001c2c <MCAL_T1_voidTCNT1_GIEDisable>:
void MCAL_T1_voidTCNT1_GIEDisable(void) {
    1c2c:	df 93       	push	r29
    1c2e:	cf 93       	push	r28
    1c30:	cd b7       	in	r28, 0x3d	; 61
    1c32:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, Pin2);
    1c34:	a9 e5       	ldi	r26, 0x59	; 89
    1c36:	b0 e0       	ldi	r27, 0x00	; 0
    1c38:	e9 e5       	ldi	r30, 0x59	; 89
    1c3a:	f0 e0       	ldi	r31, 0x00	; 0
    1c3c:	80 81       	ld	r24, Z
    1c3e:	8b 7f       	andi	r24, 0xFB	; 251
    1c40:	8c 93       	st	X, r24
}
    1c42:	cf 91       	pop	r28
    1c44:	df 91       	pop	r29
    1c46:	08 95       	ret

00001c48 <MCAL_T1_voidOCR1B_GIEEnable>:
//OCR1B PIE
void MCAL_T1_voidOCR1B_GIEEnable(void) {
    1c48:	df 93       	push	r29
    1c4a:	cf 93       	push	r28
    1c4c:	cd b7       	in	r28, 0x3d	; 61
    1c4e:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, Pin7);
    1c50:	af e5       	ldi	r26, 0x5F	; 95
    1c52:	b0 e0       	ldi	r27, 0x00	; 0
    1c54:	ef e5       	ldi	r30, 0x5F	; 95
    1c56:	f0 e0       	ldi	r31, 0x00	; 0
    1c58:	80 81       	ld	r24, Z
    1c5a:	80 68       	ori	r24, 0x80	; 128
    1c5c:	8c 93       	st	X, r24
	SET_BIT(TIMSK, Pin3);
    1c5e:	a9 e5       	ldi	r26, 0x59	; 89
    1c60:	b0 e0       	ldi	r27, 0x00	; 0
    1c62:	e9 e5       	ldi	r30, 0x59	; 89
    1c64:	f0 e0       	ldi	r31, 0x00	; 0
    1c66:	80 81       	ld	r24, Z
    1c68:	88 60       	ori	r24, 0x08	; 8
    1c6a:	8c 93       	st	X, r24
}
    1c6c:	cf 91       	pop	r28
    1c6e:	df 91       	pop	r29
    1c70:	08 95       	ret

00001c72 <MCAL_T1_voidOCR1B_GIEDisable>:
void MCAL_T1_voidOCR1B_GIEDisable(void) {
    1c72:	df 93       	push	r29
    1c74:	cf 93       	push	r28
    1c76:	cd b7       	in	r28, 0x3d	; 61
    1c78:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, Pin3);
    1c7a:	a9 e5       	ldi	r26, 0x59	; 89
    1c7c:	b0 e0       	ldi	r27, 0x00	; 0
    1c7e:	e9 e5       	ldi	r30, 0x59	; 89
    1c80:	f0 e0       	ldi	r31, 0x00	; 0
    1c82:	80 81       	ld	r24, Z
    1c84:	87 7f       	andi	r24, 0xF7	; 247
    1c86:	8c 93       	st	X, r24
}
    1c88:	cf 91       	pop	r28
    1c8a:	df 91       	pop	r29
    1c8c:	08 95       	ret

00001c8e <MCAL_T1_voidOCR1A_GIEEnable>:
//OCR1A PIE
void MCAL_T1_voidOCR1A_GIEEnable(void) {
    1c8e:	df 93       	push	r29
    1c90:	cf 93       	push	r28
    1c92:	cd b7       	in	r28, 0x3d	; 61
    1c94:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, Pin7);
    1c96:	af e5       	ldi	r26, 0x5F	; 95
    1c98:	b0 e0       	ldi	r27, 0x00	; 0
    1c9a:	ef e5       	ldi	r30, 0x5F	; 95
    1c9c:	f0 e0       	ldi	r31, 0x00	; 0
    1c9e:	80 81       	ld	r24, Z
    1ca0:	80 68       	ori	r24, 0x80	; 128
    1ca2:	8c 93       	st	X, r24
	SET_BIT(TIMSK, Pin4);
    1ca4:	a9 e5       	ldi	r26, 0x59	; 89
    1ca6:	b0 e0       	ldi	r27, 0x00	; 0
    1ca8:	e9 e5       	ldi	r30, 0x59	; 89
    1caa:	f0 e0       	ldi	r31, 0x00	; 0
    1cac:	80 81       	ld	r24, Z
    1cae:	80 61       	ori	r24, 0x10	; 16
    1cb0:	8c 93       	st	X, r24
}
    1cb2:	cf 91       	pop	r28
    1cb4:	df 91       	pop	r29
    1cb6:	08 95       	ret

00001cb8 <MCAL_T1_voidOCR1A_GIEDisable>:
void MCAL_T1_voidOCR1A_GIEDisable(void) {
    1cb8:	df 93       	push	r29
    1cba:	cf 93       	push	r28
    1cbc:	cd b7       	in	r28, 0x3d	; 61
    1cbe:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, Pin4);
    1cc0:	a9 e5       	ldi	r26, 0x59	; 89
    1cc2:	b0 e0       	ldi	r27, 0x00	; 0
    1cc4:	e9 e5       	ldi	r30, 0x59	; 89
    1cc6:	f0 e0       	ldi	r31, 0x00	; 0
    1cc8:	80 81       	ld	r24, Z
    1cca:	8f 7e       	andi	r24, 0xEF	; 239
    1ccc:	8c 93       	st	X, r24
}
    1cce:	cf 91       	pop	r28
    1cd0:	df 91       	pop	r29
    1cd2:	08 95       	ret

00001cd4 <MCAL_T1_voidICR1_GIEEnable>:
//ICR1 PIE
void MCAL_T1_voidICR1_GIEEnable(void) {
    1cd4:	df 93       	push	r29
    1cd6:	cf 93       	push	r28
    1cd8:	cd b7       	in	r28, 0x3d	; 61
    1cda:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, Pin7);
    1cdc:	af e5       	ldi	r26, 0x5F	; 95
    1cde:	b0 e0       	ldi	r27, 0x00	; 0
    1ce0:	ef e5       	ldi	r30, 0x5F	; 95
    1ce2:	f0 e0       	ldi	r31, 0x00	; 0
    1ce4:	80 81       	ld	r24, Z
    1ce6:	80 68       	ori	r24, 0x80	; 128
    1ce8:	8c 93       	st	X, r24
	SET_BIT(TIMSK, Pin5);
    1cea:	a9 e5       	ldi	r26, 0x59	; 89
    1cec:	b0 e0       	ldi	r27, 0x00	; 0
    1cee:	e9 e5       	ldi	r30, 0x59	; 89
    1cf0:	f0 e0       	ldi	r31, 0x00	; 0
    1cf2:	80 81       	ld	r24, Z
    1cf4:	80 62       	ori	r24, 0x20	; 32
    1cf6:	8c 93       	st	X, r24
}
    1cf8:	cf 91       	pop	r28
    1cfa:	df 91       	pop	r29
    1cfc:	08 95       	ret

00001cfe <MCAL_T1_voidICR1_GIEDisable>:
void MCAL_T1_voidICR1_GIEDisable(void) {
    1cfe:	df 93       	push	r29
    1d00:	cf 93       	push	r28
    1d02:	cd b7       	in	r28, 0x3d	; 61
    1d04:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, Pin5);
    1d06:	a9 e5       	ldi	r26, 0x59	; 89
    1d08:	b0 e0       	ldi	r27, 0x00	; 0
    1d0a:	e9 e5       	ldi	r30, 0x59	; 89
    1d0c:	f0 e0       	ldi	r31, 0x00	; 0
    1d0e:	80 81       	ld	r24, Z
    1d10:	8f 7d       	andi	r24, 0xDF	; 223
    1d12:	8c 93       	st	X, r24
}
    1d14:	cf 91       	pop	r28
    1d16:	df 91       	pop	r29
    1d18:	08 95       	ret

00001d1a <MCAL_T1_u8T1DelayNormalMode>:

u8 MCAL_T1_u8T1DelayNormalMode(u8 LOC_u8Clock_Selection,
		f32 LOC_f32NumOFSecond, u16 *LOC_pu8StartValue, u16 *LOC_pu16Counter) {
    1d1a:	0f 93       	push	r16
    1d1c:	1f 93       	push	r17
    1d1e:	df 93       	push	r29
    1d20:	cf 93       	push	r28
    1d22:	cd b7       	in	r28, 0x3d	; 61
    1d24:	de b7       	in	r29, 0x3e	; 62
    1d26:	66 97       	sbiw	r28, 0x16	; 22
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	de bf       	out	0x3e, r29	; 62
    1d2e:	0f be       	out	0x3f, r0	; 63
    1d30:	cd bf       	out	0x3d, r28	; 61
    1d32:	8e 87       	std	Y+14, r24	; 0x0e
    1d34:	4f 87       	std	Y+15, r20	; 0x0f
    1d36:	58 8b       	std	Y+16, r21	; 0x10
    1d38:	69 8b       	std	Y+17, r22	; 0x11
    1d3a:	7a 8b       	std	Y+18, r23	; 0x12
    1d3c:	3c 8b       	std	Y+20, r19	; 0x14
    1d3e:	2b 8b       	std	Y+19, r18	; 0x13
    1d40:	1e 8b       	std	Y+22, r17	; 0x16
    1d42:	0d 8b       	std	Y+21, r16	; 0x15
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1d44:	81 e0       	ldi	r24, 0x01	; 1
    1d46:	89 87       	std	Y+9, r24	; 0x09
	f32 TickTime = NUMBER_0;
    1d48:	80 e0       	ldi	r24, 0x00	; 0
    1d4a:	90 e0       	ldi	r25, 0x00	; 0
    1d4c:	a0 e0       	ldi	r26, 0x00	; 0
    1d4e:	b0 e0       	ldi	r27, 0x00	; 0
    1d50:	8a 87       	std	Y+10, r24	; 0x0a
    1d52:	9b 87       	std	Y+11, r25	; 0x0b
    1d54:	ac 87       	std	Y+12, r26	; 0x0c
    1d56:	bd 87       	std	Y+13, r27	; 0x0d
	u32 N = NUMBER_0;
    1d58:	1d 82       	std	Y+5, r1	; 0x05
    1d5a:	1e 82       	std	Y+6, r1	; 0x06
    1d5c:	1f 82       	std	Y+7, r1	; 0x07
    1d5e:	18 86       	std	Y+8, r1	; 0x08
	u16 counter = NUMBER_0;
    1d60:	1c 82       	std	Y+4, r1	; 0x04
    1d62:	1b 82       	std	Y+3, r1	; 0x03
	u16 Reminder = NUMBER_0;
    1d64:	1a 82       	std	Y+2, r1	; 0x02
    1d66:	19 82       	std	Y+1, r1	; 0x01
	MCAL_T1_u8T1Prescaler(LOC_u8Clock_Selection, &TickTime);
    1d68:	9e 01       	movw	r18, r28
    1d6a:	26 5f       	subi	r18, 0xF6	; 246
    1d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    1d6e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d70:	b9 01       	movw	r22, r18
    1d72:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <MCAL_T1_u8T1Prescaler>
	if (LOC_f32NumOFSecond <= 0 || LOC_f32NumOFSecond > 0) {
    1d76:	6f 85       	ldd	r22, Y+15	; 0x0f
    1d78:	78 89       	ldd	r23, Y+16	; 0x10
    1d7a:	89 89       	ldd	r24, Y+17	; 0x11
    1d7c:	9a 89       	ldd	r25, Y+18	; 0x12
    1d7e:	20 e0       	ldi	r18, 0x00	; 0
    1d80:	30 e0       	ldi	r19, 0x00	; 0
    1d82:	40 e0       	ldi	r20, 0x00	; 0
    1d84:	50 e0       	ldi	r21, 0x00	; 0
    1d86:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    1d8a:	18 16       	cp	r1, r24
    1d8c:	6c f4       	brge	.+26     	; 0x1da8 <MCAL_T1_u8T1DelayNormalMode+0x8e>
    1d8e:	6f 85       	ldd	r22, Y+15	; 0x0f
    1d90:	78 89       	ldd	r23, Y+16	; 0x10
    1d92:	89 89       	ldd	r24, Y+17	; 0x11
    1d94:	9a 89       	ldd	r25, Y+18	; 0x12
    1d96:	20 e0       	ldi	r18, 0x00	; 0
    1d98:	30 e0       	ldi	r19, 0x00	; 0
    1d9a:	40 e0       	ldi	r20, 0x00	; 0
    1d9c:	50 e0       	ldi	r21, 0x00	; 0
    1d9e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1da2:	18 16       	cp	r1, r24
    1da4:	0c f0       	brlt	.+2      	; 0x1da8 <MCAL_T1_u8T1DelayNormalMode+0x8e>
    1da6:	6b c0       	rjmp	.+214    	; 0x1e7e <MCAL_T1_u8T1DelayNormalMode+0x164>
		N = LOC_f32NumOFSecond / (f32) TickTime;
    1da8:	2a 85       	ldd	r18, Y+10	; 0x0a
    1daa:	3b 85       	ldd	r19, Y+11	; 0x0b
    1dac:	4c 85       	ldd	r20, Y+12	; 0x0c
    1dae:	5d 85       	ldd	r21, Y+13	; 0x0d
    1db0:	6f 85       	ldd	r22, Y+15	; 0x0f
    1db2:	78 89       	ldd	r23, Y+16	; 0x10
    1db4:	89 89       	ldd	r24, Y+17	; 0x11
    1db6:	9a 89       	ldd	r25, Y+18	; 0x12
    1db8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1dbc:	dc 01       	movw	r26, r24
    1dbe:	cb 01       	movw	r24, r22
    1dc0:	bc 01       	movw	r22, r24
    1dc2:	cd 01       	movw	r24, r26
    1dc4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dc8:	dc 01       	movw	r26, r24
    1dca:	cb 01       	movw	r24, r22
    1dcc:	8d 83       	std	Y+5, r24	; 0x05
    1dce:	9e 83       	std	Y+6, r25	; 0x06
    1dd0:	af 83       	std	Y+7, r26	; 0x07
    1dd2:	b8 87       	std	Y+8, r27	; 0x08
		Reminder = N % OVER_FLOW_COUNT;
    1dd4:	8d 81       	ldd	r24, Y+5	; 0x05
    1dd6:	9e 81       	ldd	r25, Y+6	; 0x06
    1dd8:	af 81       	ldd	r26, Y+7	; 0x07
    1dda:	b8 85       	ldd	r27, Y+8	; 0x08
    1ddc:	2f ef       	ldi	r18, 0xFF	; 255
    1dde:	3f ef       	ldi	r19, 0xFF	; 255
    1de0:	40 e0       	ldi	r20, 0x00	; 0
    1de2:	50 e0       	ldi	r21, 0x00	; 0
    1de4:	bc 01       	movw	r22, r24
    1de6:	cd 01       	movw	r24, r26
    1de8:	0e 94 bc 46 	call	0x8d78	; 0x8d78 <__udivmodsi4>
    1dec:	dc 01       	movw	r26, r24
    1dee:	cb 01       	movw	r24, r22
    1df0:	9a 83       	std	Y+2, r25	; 0x02
    1df2:	89 83       	std	Y+1, r24	; 0x01
		*LOC_pu8StartValue = Reminder;
    1df4:	eb 89       	ldd	r30, Y+19	; 0x13
    1df6:	fc 89       	ldd	r31, Y+20	; 0x14
    1df8:	89 81       	ldd	r24, Y+1	; 0x01
    1dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    1dfc:	91 83       	std	Z+1, r25	; 0x01
    1dfe:	80 83       	st	Z, r24
		if (Reminder == NUMBER_0) {
    1e00:	89 81       	ldd	r24, Y+1	; 0x01
    1e02:	9a 81       	ldd	r25, Y+2	; 0x02
    1e04:	00 97       	sbiw	r24, 0x00	; 0
    1e06:	d9 f4       	brne	.+54     	; 0x1e3e <MCAL_T1_u8T1DelayNormalMode+0x124>
			MCAL_T1_voidSetTCNT1Value(Reminder);
    1e08:	89 81       	ldd	r24, Y+1	; 0x01
    1e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e0c:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <MCAL_T1_voidSetTCNT1Value>
			counter = N / OVER_FLOW_COUNT;
    1e10:	8d 81       	ldd	r24, Y+5	; 0x05
    1e12:	9e 81       	ldd	r25, Y+6	; 0x06
    1e14:	af 81       	ldd	r26, Y+7	; 0x07
    1e16:	b8 85       	ldd	r27, Y+8	; 0x08
    1e18:	2f ef       	ldi	r18, 0xFF	; 255
    1e1a:	3f ef       	ldi	r19, 0xFF	; 255
    1e1c:	40 e0       	ldi	r20, 0x00	; 0
    1e1e:	50 e0       	ldi	r21, 0x00	; 0
    1e20:	bc 01       	movw	r22, r24
    1e22:	cd 01       	movw	r24, r26
    1e24:	0e 94 bc 46 	call	0x8d78	; 0x8d78 <__udivmodsi4>
    1e28:	da 01       	movw	r26, r20
    1e2a:	c9 01       	movw	r24, r18
    1e2c:	9c 83       	std	Y+4, r25	; 0x04
    1e2e:	8b 83       	std	Y+3, r24	; 0x03
			*LOC_pu16Counter = counter;
    1e30:	ed 89       	ldd	r30, Y+21	; 0x15
    1e32:	fe 89       	ldd	r31, Y+22	; 0x16
    1e34:	8b 81       	ldd	r24, Y+3	; 0x03
    1e36:	9c 81       	ldd	r25, Y+4	; 0x04
    1e38:	91 83       	std	Z+1, r25	; 0x01
    1e3a:	80 83       	st	Z, r24
    1e3c:	1f c0       	rjmp	.+62     	; 0x1e7c <MCAL_T1_u8T1DelayNormalMode+0x162>
		} else if (Reminder != NUMBER_0) {
    1e3e:	89 81       	ldd	r24, Y+1	; 0x01
    1e40:	9a 81       	ldd	r25, Y+2	; 0x02
    1e42:	00 97       	sbiw	r24, 0x00	; 0
    1e44:	d9 f0       	breq	.+54     	; 0x1e7c <MCAL_T1_u8T1DelayNormalMode+0x162>
			MCAL_T1_voidSetTCNT1Value(Reminder);
    1e46:	89 81       	ldd	r24, Y+1	; 0x01
    1e48:	9a 81       	ldd	r25, Y+2	; 0x02
    1e4a:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <MCAL_T1_voidSetTCNT1Value>
			counter = ((N / OVER_FLOW_COUNT) + NUMBER_1);
    1e4e:	8d 81       	ldd	r24, Y+5	; 0x05
    1e50:	9e 81       	ldd	r25, Y+6	; 0x06
    1e52:	af 81       	ldd	r26, Y+7	; 0x07
    1e54:	b8 85       	ldd	r27, Y+8	; 0x08
    1e56:	2f ef       	ldi	r18, 0xFF	; 255
    1e58:	3f ef       	ldi	r19, 0xFF	; 255
    1e5a:	40 e0       	ldi	r20, 0x00	; 0
    1e5c:	50 e0       	ldi	r21, 0x00	; 0
    1e5e:	bc 01       	movw	r22, r24
    1e60:	cd 01       	movw	r24, r26
    1e62:	0e 94 bc 46 	call	0x8d78	; 0x8d78 <__udivmodsi4>
    1e66:	da 01       	movw	r26, r20
    1e68:	c9 01       	movw	r24, r18
    1e6a:	01 96       	adiw	r24, 0x01	; 1
    1e6c:	9c 83       	std	Y+4, r25	; 0x04
    1e6e:	8b 83       	std	Y+3, r24	; 0x03
			*LOC_pu16Counter = counter;
    1e70:	ed 89       	ldd	r30, Y+21	; 0x15
    1e72:	fe 89       	ldd	r31, Y+22	; 0x16
    1e74:	8b 81       	ldd	r24, Y+3	; 0x03
    1e76:	9c 81       	ldd	r25, Y+4	; 0x04
    1e78:	91 83       	std	Z+1, r25	; 0x01
    1e7a:	80 83       	st	Z, r24
		} else {
			//NOTHING
		}
		LOC_u8ReturnValue = E_OK;
    1e7c:	19 86       	std	Y+9, r1	; 0x09
	}
	return LOC_u8ReturnValue;
    1e7e:	89 85       	ldd	r24, Y+9	; 0x09

}
    1e80:	66 96       	adiw	r28, 0x16	; 22
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	de bf       	out	0x3e, r29	; 62
    1e88:	0f be       	out	0x3f, r0	; 63
    1e8a:	cd bf       	out	0x3d, r28	; 61
    1e8c:	cf 91       	pop	r28
    1e8e:	df 91       	pop	r29
    1e90:	1f 91       	pop	r17
    1e92:	0f 91       	pop	r16
    1e94:	08 95       	ret

00001e96 <MCAL_T1_voidDelayCTCMode>:

void MCAL_T1_voidDelayCTCMode(u8 LOC_u8Clock_Selection,
		f32 LOC_f32NumOFSecond, u16 *LOC_pu16Counter) {
    1e96:	df 93       	push	r29
    1e98:	cf 93       	push	r28
    1e9a:	cd b7       	in	r28, 0x3d	; 61
    1e9c:	de b7       	in	r29, 0x3e	; 62
    1e9e:	61 97       	sbiw	r28, 0x11	; 17
    1ea0:	0f b6       	in	r0, 0x3f	; 63
    1ea2:	f8 94       	cli
    1ea4:	de bf       	out	0x3e, r29	; 62
    1ea6:	0f be       	out	0x3f, r0	; 63
    1ea8:	cd bf       	out	0x3d, r28	; 61
    1eaa:	8b 87       	std	Y+11, r24	; 0x0b
    1eac:	4c 87       	std	Y+12, r20	; 0x0c
    1eae:	5d 87       	std	Y+13, r21	; 0x0d
    1eb0:	6e 87       	std	Y+14, r22	; 0x0e
    1eb2:	7f 87       	std	Y+15, r23	; 0x0f
    1eb4:	39 8b       	std	Y+17, r19	; 0x11
    1eb6:	28 8b       	std	Y+16, r18	; 0x10
	f32 TickTime = NUMBER_0;
    1eb8:	80 e0       	ldi	r24, 0x00	; 0
    1eba:	90 e0       	ldi	r25, 0x00	; 0
    1ebc:	a0 e0       	ldi	r26, 0x00	; 0
    1ebe:	b0 e0       	ldi	r27, 0x00	; 0
    1ec0:	8f 83       	std	Y+7, r24	; 0x07
    1ec2:	98 87       	std	Y+8, r25	; 0x08
    1ec4:	a9 87       	std	Y+9, r26	; 0x09
    1ec6:	ba 87       	std	Y+10, r27	; 0x0a
	f32 N = NUMBER_0;
    1ec8:	80 e0       	ldi	r24, 0x00	; 0
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	a0 e0       	ldi	r26, 0x00	; 0
    1ece:	b0 e0       	ldi	r27, 0x00	; 0
    1ed0:	8b 83       	std	Y+3, r24	; 0x03
    1ed2:	9c 83       	std	Y+4, r25	; 0x04
    1ed4:	ad 83       	std	Y+5, r26	; 0x05
    1ed6:	be 83       	std	Y+6, r27	; 0x06
	u16 counter = NUMBER_0;
    1ed8:	1a 82       	std	Y+2, r1	; 0x02
    1eda:	19 82       	std	Y+1, r1	; 0x01
	MCAL_T1_u8T1Prescaler(LOC_u8Clock_Selection, &TickTime);
    1edc:	9e 01       	movw	r18, r28
    1ede:	29 5f       	subi	r18, 0xF9	; 249
    1ee0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ee2:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ee4:	b9 01       	movw	r22, r18
    1ee6:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <MCAL_T1_u8T1Prescaler>
	MCAL_T1_voidSetOCR1AValue(CTC_DELAY_CONST);
    1eea:	87 ec       	ldi	r24, 0xC7	; 199
    1eec:	90 e0       	ldi	r25, 0x00	; 0
    1eee:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <MCAL_T1_voidSetOCR1AValue>
	if (LOC_f32NumOFSecond <= 0 || LOC_f32NumOFSecond > 0) {
    1ef2:	6c 85       	ldd	r22, Y+12	; 0x0c
    1ef4:	7d 85       	ldd	r23, Y+13	; 0x0d
    1ef6:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ef8:	9f 85       	ldd	r25, Y+15	; 0x0f
    1efa:	20 e0       	ldi	r18, 0x00	; 0
    1efc:	30 e0       	ldi	r19, 0x00	; 0
    1efe:	40 e0       	ldi	r20, 0x00	; 0
    1f00:	50 e0       	ldi	r21, 0x00	; 0
    1f02:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    1f06:	18 16       	cp	r1, r24
    1f08:	64 f4       	brge	.+24     	; 0x1f22 <MCAL_T1_voidDelayCTCMode+0x8c>
    1f0a:	6c 85       	ldd	r22, Y+12	; 0x0c
    1f0c:	7d 85       	ldd	r23, Y+13	; 0x0d
    1f0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f10:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f12:	20 e0       	ldi	r18, 0x00	; 0
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	40 e0       	ldi	r20, 0x00	; 0
    1f18:	50 e0       	ldi	r21, 0x00	; 0
    1f1a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f1e:	18 16       	cp	r1, r24
    1f20:	64 f5       	brge	.+88     	; 0x1f7a <MCAL_T1_voidDelayCTCMode+0xe4>
		N = ((CTC_DELAY_CONST + NUMBER_1) * TickTime);
    1f22:	8f 81       	ldd	r24, Y+7	; 0x07
    1f24:	98 85       	ldd	r25, Y+8	; 0x08
    1f26:	a9 85       	ldd	r26, Y+9	; 0x09
    1f28:	ba 85       	ldd	r27, Y+10	; 0x0a
    1f2a:	bc 01       	movw	r22, r24
    1f2c:	cd 01       	movw	r24, r26
    1f2e:	20 e0       	ldi	r18, 0x00	; 0
    1f30:	30 e0       	ldi	r19, 0x00	; 0
    1f32:	48 e4       	ldi	r20, 0x48	; 72
    1f34:	53 e4       	ldi	r21, 0x43	; 67
    1f36:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f3a:	dc 01       	movw	r26, r24
    1f3c:	cb 01       	movw	r24, r22
    1f3e:	8b 83       	std	Y+3, r24	; 0x03
    1f40:	9c 83       	std	Y+4, r25	; 0x04
    1f42:	ad 83       	std	Y+5, r26	; 0x05
    1f44:	be 83       	std	Y+6, r27	; 0x06
		counter = (LOC_f32NumOFSecond / N);
    1f46:	6c 85       	ldd	r22, Y+12	; 0x0c
    1f48:	7d 85       	ldd	r23, Y+13	; 0x0d
    1f4a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f4c:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f4e:	2b 81       	ldd	r18, Y+3	; 0x03
    1f50:	3c 81       	ldd	r19, Y+4	; 0x04
    1f52:	4d 81       	ldd	r20, Y+5	; 0x05
    1f54:	5e 81       	ldd	r21, Y+6	; 0x06
    1f56:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1f5a:	dc 01       	movw	r26, r24
    1f5c:	cb 01       	movw	r24, r22
    1f5e:	bc 01       	movw	r22, r24
    1f60:	cd 01       	movw	r24, r26
    1f62:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f66:	dc 01       	movw	r26, r24
    1f68:	cb 01       	movw	r24, r22
    1f6a:	9a 83       	std	Y+2, r25	; 0x02
    1f6c:	89 83       	std	Y+1, r24	; 0x01
		*LOC_pu16Counter = counter;
    1f6e:	e8 89       	ldd	r30, Y+16	; 0x10
    1f70:	f9 89       	ldd	r31, Y+17	; 0x11
    1f72:	89 81       	ldd	r24, Y+1	; 0x01
    1f74:	9a 81       	ldd	r25, Y+2	; 0x02
    1f76:	91 83       	std	Z+1, r25	; 0x01
    1f78:	80 83       	st	Z, r24
	} else {
		//NOTING
	}
}
    1f7a:	61 96       	adiw	r28, 0x11	; 17
    1f7c:	0f b6       	in	r0, 0x3f	; 63
    1f7e:	f8 94       	cli
    1f80:	de bf       	out	0x3e, r29	; 62
    1f82:	0f be       	out	0x3f, r0	; 63
    1f84:	cd bf       	out	0x3d, r28	; 61
    1f86:	cf 91       	pop	r28
    1f88:	df 91       	pop	r29
    1f8a:	08 95       	ret

00001f8c <MCAL_T1_voidSetTriggerEdge>:
//ICU EDGE
void MCAL_T1_voidSetTriggerEdge(u8 LOC_u8TriggerEdge) {
    1f8c:	df 93       	push	r29
    1f8e:	cf 93       	push	r28
    1f90:	0f 92       	push	r0
    1f92:	cd b7       	in	r28, 0x3d	; 61
    1f94:	de b7       	in	r29, 0x3e	; 62
    1f96:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_u8TriggerEdge <= RISING_EDGE) {
    1f98:	89 81       	ldd	r24, Y+1	; 0x01
    1f9a:	82 30       	cpi	r24, 0x02	; 2
    1f9c:	a8 f4       	brcc	.+42     	; 0x1fc8 <MCAL_T1_voidSetTriggerEdge+0x3c>
		if (LOC_u8TriggerEdge == RISING_EDGE) {
    1f9e:	89 81       	ldd	r24, Y+1	; 0x01
    1fa0:	81 30       	cpi	r24, 0x01	; 1
    1fa2:	41 f4       	brne	.+16     	; 0x1fb4 <MCAL_T1_voidSetTriggerEdge+0x28>
			SET_BIT(TCCR1B, Pin6);
    1fa4:	ae e4       	ldi	r26, 0x4E	; 78
    1fa6:	b0 e0       	ldi	r27, 0x00	; 0
    1fa8:	ee e4       	ldi	r30, 0x4E	; 78
    1faa:	f0 e0       	ldi	r31, 0x00	; 0
    1fac:	80 81       	ld	r24, Z
    1fae:	80 64       	ori	r24, 0x40	; 64
    1fb0:	8c 93       	st	X, r24
    1fb2:	0a c0       	rjmp	.+20     	; 0x1fc8 <MCAL_T1_voidSetTriggerEdge+0x3c>
		} else if (LOC_u8TriggerEdge == FALLING_EDGE) {
    1fb4:	89 81       	ldd	r24, Y+1	; 0x01
    1fb6:	88 23       	and	r24, r24
    1fb8:	39 f4       	brne	.+14     	; 0x1fc8 <MCAL_T1_voidSetTriggerEdge+0x3c>
			CLR_BIT(TCCR1B, Pin6);
    1fba:	ae e4       	ldi	r26, 0x4E	; 78
    1fbc:	b0 e0       	ldi	r27, 0x00	; 0
    1fbe:	ee e4       	ldi	r30, 0x4E	; 78
    1fc0:	f0 e0       	ldi	r31, 0x00	; 0
    1fc2:	80 81       	ld	r24, Z
    1fc4:	8f 7b       	andi	r24, 0xBF	; 191
    1fc6:	8c 93       	st	X, r24
			//NOTHING
		}
	} else {
		//NOTHING
	}
}
    1fc8:	0f 90       	pop	r0
    1fca:	cf 91       	pop	r28
    1fcc:	df 91       	pop	r29
    1fce:	08 95       	ret

00001fd0 <MCAL_T1_u8T1_Callback>:
u8 MCAL_T1_u8T1_Callback(void (*ptr)(void)) {
    1fd0:	df 93       	push	r29
    1fd2:	cf 93       	push	r28
    1fd4:	00 d0       	rcall	.+0      	; 0x1fd6 <MCAL_T1_u8T1_Callback+0x6>
    1fd6:	0f 92       	push	r0
    1fd8:	cd b7       	in	r28, 0x3d	; 61
    1fda:	de b7       	in	r29, 0x3e	; 62
    1fdc:	9b 83       	std	Y+3, r25	; 0x03
    1fde:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8ReturnValue = E_NOT_OK;
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0') {
    1fe4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fe6:	9b 81       	ldd	r25, Y+3	; 0x03
    1fe8:	00 97       	sbiw	r24, 0x00	; 0
    1fea:	39 f0       	breq	.+14     	; 0x1ffa <MCAL_T1_u8T1_Callback+0x2a>
		Gptr_3 = ptr;
    1fec:	8a 81       	ldd	r24, Y+2	; 0x02
    1fee:	9b 81       	ldd	r25, Y+3	; 0x03
    1ff0:	90 93 88 01 	sts	0x0188, r25
    1ff4:	80 93 87 01 	sts	0x0187, r24
		LOC_u8ReturnValue = E_OK;
    1ff8:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_u8ReturnValue;
    1ffa:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ffc:	0f 90       	pop	r0
    1ffe:	0f 90       	pop	r0
    2000:	0f 90       	pop	r0
    2002:	cf 91       	pop	r28
    2004:	df 91       	pop	r29
    2006:	08 95       	ret

00002008 <__vector_9>:

ISR(TIMER1_OVF_vect) {
    2008:	1f 92       	push	r1
    200a:	0f 92       	push	r0
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	0f 92       	push	r0
    2010:	11 24       	eor	r1, r1
    2012:	2f 93       	push	r18
    2014:	3f 93       	push	r19
    2016:	4f 93       	push	r20
    2018:	5f 93       	push	r21
    201a:	6f 93       	push	r22
    201c:	7f 93       	push	r23
    201e:	8f 93       	push	r24
    2020:	9f 93       	push	r25
    2022:	af 93       	push	r26
    2024:	bf 93       	push	r27
    2026:	ef 93       	push	r30
    2028:	ff 93       	push	r31
    202a:	df 93       	push	r29
    202c:	cf 93       	push	r28
    202e:	cd b7       	in	r28, 0x3d	; 61
    2030:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    2032:	80 91 87 01 	lds	r24, 0x0187
    2036:	90 91 88 01 	lds	r25, 0x0188
    203a:	00 97       	sbiw	r24, 0x00	; 0
    203c:	29 f0       	breq	.+10     	; 0x2048 <__vector_9+0x40>
		Gptr_3();
    203e:	e0 91 87 01 	lds	r30, 0x0187
    2042:	f0 91 88 01 	lds	r31, 0x0188
    2046:	09 95       	icall
	}
}
    2048:	cf 91       	pop	r28
    204a:	df 91       	pop	r29
    204c:	ff 91       	pop	r31
    204e:	ef 91       	pop	r30
    2050:	bf 91       	pop	r27
    2052:	af 91       	pop	r26
    2054:	9f 91       	pop	r25
    2056:	8f 91       	pop	r24
    2058:	7f 91       	pop	r23
    205a:	6f 91       	pop	r22
    205c:	5f 91       	pop	r21
    205e:	4f 91       	pop	r20
    2060:	3f 91       	pop	r19
    2062:	2f 91       	pop	r18
    2064:	0f 90       	pop	r0
    2066:	0f be       	out	0x3f, r0	; 63
    2068:	0f 90       	pop	r0
    206a:	1f 90       	pop	r1
    206c:	18 95       	reti

0000206e <__vector_8>:
//ISR(TIMER1_COMPA_vect) {
//	if (Gptr_3 != '\0') {
//		Gptr_3();
//	}
//}
ISR(TIMER1_COMPB_vect) {
    206e:	1f 92       	push	r1
    2070:	0f 92       	push	r0
    2072:	0f b6       	in	r0, 0x3f	; 63
    2074:	0f 92       	push	r0
    2076:	11 24       	eor	r1, r1
    2078:	2f 93       	push	r18
    207a:	3f 93       	push	r19
    207c:	4f 93       	push	r20
    207e:	5f 93       	push	r21
    2080:	6f 93       	push	r22
    2082:	7f 93       	push	r23
    2084:	8f 93       	push	r24
    2086:	9f 93       	push	r25
    2088:	af 93       	push	r26
    208a:	bf 93       	push	r27
    208c:	ef 93       	push	r30
    208e:	ff 93       	push	r31
    2090:	df 93       	push	r29
    2092:	cf 93       	push	r28
    2094:	cd b7       	in	r28, 0x3d	; 61
    2096:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    2098:	80 91 87 01 	lds	r24, 0x0187
    209c:	90 91 88 01 	lds	r25, 0x0188
    20a0:	00 97       	sbiw	r24, 0x00	; 0
    20a2:	29 f0       	breq	.+10     	; 0x20ae <__vector_8+0x40>
		Gptr_3();
    20a4:	e0 91 87 01 	lds	r30, 0x0187
    20a8:	f0 91 88 01 	lds	r31, 0x0188
    20ac:	09 95       	icall
	}
}
    20ae:	cf 91       	pop	r28
    20b0:	df 91       	pop	r29
    20b2:	ff 91       	pop	r31
    20b4:	ef 91       	pop	r30
    20b6:	bf 91       	pop	r27
    20b8:	af 91       	pop	r26
    20ba:	9f 91       	pop	r25
    20bc:	8f 91       	pop	r24
    20be:	7f 91       	pop	r23
    20c0:	6f 91       	pop	r22
    20c2:	5f 91       	pop	r21
    20c4:	4f 91       	pop	r20
    20c6:	3f 91       	pop	r19
    20c8:	2f 91       	pop	r18
    20ca:	0f 90       	pop	r0
    20cc:	0f be       	out	0x3f, r0	; 63
    20ce:	0f 90       	pop	r0
    20d0:	1f 90       	pop	r1
    20d2:	18 95       	reti

000020d4 <__vector_6>:
ISR(TIMER1_CAPT_vect) {
    20d4:	1f 92       	push	r1
    20d6:	0f 92       	push	r0
    20d8:	0f b6       	in	r0, 0x3f	; 63
    20da:	0f 92       	push	r0
    20dc:	11 24       	eor	r1, r1
    20de:	2f 93       	push	r18
    20e0:	3f 93       	push	r19
    20e2:	4f 93       	push	r20
    20e4:	5f 93       	push	r21
    20e6:	6f 93       	push	r22
    20e8:	7f 93       	push	r23
    20ea:	8f 93       	push	r24
    20ec:	9f 93       	push	r25
    20ee:	af 93       	push	r26
    20f0:	bf 93       	push	r27
    20f2:	ef 93       	push	r30
    20f4:	ff 93       	push	r31
    20f6:	df 93       	push	r29
    20f8:	cf 93       	push	r28
    20fa:	cd b7       	in	r28, 0x3d	; 61
    20fc:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_3 != '\0') {
    20fe:	80 91 87 01 	lds	r24, 0x0187
    2102:	90 91 88 01 	lds	r25, 0x0188
    2106:	00 97       	sbiw	r24, 0x00	; 0
    2108:	29 f0       	breq	.+10     	; 0x2114 <__vector_6+0x40>
		Gptr_3();
    210a:	e0 91 87 01 	lds	r30, 0x0187
    210e:	f0 91 88 01 	lds	r31, 0x0188
    2112:	09 95       	icall
	}
}
    2114:	cf 91       	pop	r28
    2116:	df 91       	pop	r29
    2118:	ff 91       	pop	r31
    211a:	ef 91       	pop	r30
    211c:	bf 91       	pop	r27
    211e:	af 91       	pop	r26
    2120:	9f 91       	pop	r25
    2122:	8f 91       	pop	r24
    2124:	7f 91       	pop	r23
    2126:	6f 91       	pop	r22
    2128:	5f 91       	pop	r21
    212a:	4f 91       	pop	r20
    212c:	3f 91       	pop	r19
    212e:	2f 91       	pop	r18
    2130:	0f 90       	pop	r0
    2132:	0f be       	out	0x3f, r0	; 63
    2134:	0f 90       	pop	r0
    2136:	1f 90       	pop	r1
    2138:	18 95       	reti

0000213a <MCAL_T1_FPWM_10bitRES>:

void MCAL_T1_FPWM_10bitRES(u8 copy_u8Channel, u8 copy_u8Duty) {
    213a:	0f 93       	push	r16
    213c:	1f 93       	push	r17
    213e:	df 93       	push	r29
    2140:	cf 93       	push	r28
    2142:	00 d0       	rcall	.+0      	; 0x2144 <MCAL_T1_FPWM_10bitRES+0xa>
    2144:	00 d0       	rcall	.+0      	; 0x2146 <MCAL_T1_FPWM_10bitRES+0xc>
    2146:	00 d0       	rcall	.+0      	; 0x2148 <MCAL_T1_FPWM_10bitRES+0xe>
    2148:	cd b7       	in	r28, 0x3d	; 61
    214a:	de b7       	in	r29, 0x3e	; 62
    214c:	8d 83       	std	Y+5, r24	; 0x05
    214e:	6e 83       	std	Y+6, r22	; 0x06
	f32 LOC_f32tickTime = 0;
    2150:	80 e0       	ldi	r24, 0x00	; 0
    2152:	90 e0       	ldi	r25, 0x00	; 0
    2154:	a0 e0       	ldi	r26, 0x00	; 0
    2156:	b0 e0       	ldi	r27, 0x00	; 0
    2158:	89 83       	std	Y+1, r24	; 0x01
    215a:	9a 83       	std	Y+2, r25	; 0x02
    215c:	ab 83       	std	Y+3, r26	; 0x03
    215e:	bc 83       	std	Y+4, r27	; 0x04
	//Set Mode
	MCAL_T1_u8T1Init(PWM_PHASE_CORRECT_10bit);
    2160:	83 e0       	ldi	r24, 0x03	; 3
    2162:	0e 94 bb 09 	call	0x1376	; 0x1376 <MCAL_T1_u8T1Init>
	//Select Prescaler
	MCAL_T1_u8T1Prescaler(PRESCALLING_64, &LOC_f32tickTime);
    2166:	83 e0       	ldi	r24, 0x03	; 3
    2168:	9e 01       	movw	r18, r28
    216a:	2f 5f       	subi	r18, 0xFF	; 255
    216c:	3f 4f       	sbci	r19, 0xFF	; 255
    216e:	b9 01       	movw	r22, r18
    2170:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <MCAL_T1_u8T1Prescaler>
	MCAL_T1_u8T1CompareOutputMode(NON_INVERTING_MODE, copy_u8Channel);
    2174:	80 e0       	ldi	r24, 0x00	; 0
    2176:	6d 81       	ldd	r22, Y+5	; 0x05
    2178:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <MCAL_T1_u8T1CompareOutputMode>
	if (copy_u8Channel == CHENNEL_A) {
    217c:	8d 81       	ldd	r24, Y+5	; 0x05
    217e:	88 23       	and	r24, r24
    2180:	19 f5       	brne	.+70     	; 0x21c8 <MCAL_T1_FPWM_10bitRES+0x8e>
		OCR1A = copy_u8Duty * 10.23;
    2182:	0a e4       	ldi	r16, 0x4A	; 74
    2184:	10 e0       	ldi	r17, 0x00	; 0
    2186:	8e 81       	ldd	r24, Y+6	; 0x06
    2188:	88 2f       	mov	r24, r24
    218a:	90 e0       	ldi	r25, 0x00	; 0
    218c:	aa 27       	eor	r26, r26
    218e:	97 fd       	sbrc	r25, 7
    2190:	a0 95       	com	r26
    2192:	ba 2f       	mov	r27, r26
    2194:	bc 01       	movw	r22, r24
    2196:	cd 01       	movw	r24, r26
    2198:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    219c:	dc 01       	movw	r26, r24
    219e:	cb 01       	movw	r24, r22
    21a0:	bc 01       	movw	r22, r24
    21a2:	cd 01       	movw	r24, r26
    21a4:	24 e1       	ldi	r18, 0x14	; 20
    21a6:	3e ea       	ldi	r19, 0xAE	; 174
    21a8:	43 e2       	ldi	r20, 0x23	; 35
    21aa:	51 e4       	ldi	r21, 0x41	; 65
    21ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21b0:	dc 01       	movw	r26, r24
    21b2:	cb 01       	movw	r24, r22
    21b4:	bc 01       	movw	r22, r24
    21b6:	cd 01       	movw	r24, r26
    21b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21bc:	dc 01       	movw	r26, r24
    21be:	cb 01       	movw	r24, r22
    21c0:	f8 01       	movw	r30, r16
    21c2:	91 83       	std	Z+1, r25	; 0x01
    21c4:	80 83       	st	Z, r24
    21c6:	25 c0       	rjmp	.+74     	; 0x2212 <MCAL_T1_FPWM_10bitRES+0xd8>
	} else if (copy_u8Channel == CHENNEL_B) {
    21c8:	8d 81       	ldd	r24, Y+5	; 0x05
    21ca:	81 30       	cpi	r24, 0x01	; 1
    21cc:	11 f5       	brne	.+68     	; 0x2212 <MCAL_T1_FPWM_10bitRES+0xd8>
		OCR1B = copy_u8Duty * 10.23;
    21ce:	08 e4       	ldi	r16, 0x48	; 72
    21d0:	10 e0       	ldi	r17, 0x00	; 0
    21d2:	8e 81       	ldd	r24, Y+6	; 0x06
    21d4:	88 2f       	mov	r24, r24
    21d6:	90 e0       	ldi	r25, 0x00	; 0
    21d8:	aa 27       	eor	r26, r26
    21da:	97 fd       	sbrc	r25, 7
    21dc:	a0 95       	com	r26
    21de:	ba 2f       	mov	r27, r26
    21e0:	bc 01       	movw	r22, r24
    21e2:	cd 01       	movw	r24, r26
    21e4:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    21e8:	dc 01       	movw	r26, r24
    21ea:	cb 01       	movw	r24, r22
    21ec:	bc 01       	movw	r22, r24
    21ee:	cd 01       	movw	r24, r26
    21f0:	24 e1       	ldi	r18, 0x14	; 20
    21f2:	3e ea       	ldi	r19, 0xAE	; 174
    21f4:	43 e2       	ldi	r20, 0x23	; 35
    21f6:	51 e4       	ldi	r21, 0x41	; 65
    21f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21fc:	dc 01       	movw	r26, r24
    21fe:	cb 01       	movw	r24, r22
    2200:	bc 01       	movw	r22, r24
    2202:	cd 01       	movw	r24, r26
    2204:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2208:	dc 01       	movw	r26, r24
    220a:	cb 01       	movw	r24, r22
    220c:	f8 01       	movw	r30, r16
    220e:	91 83       	std	Z+1, r25	; 0x01
    2210:	80 83       	st	Z, r24

	} else {
		//NOTHING
	}
}
    2212:	26 96       	adiw	r28, 0x06	; 6
    2214:	0f b6       	in	r0, 0x3f	; 63
    2216:	f8 94       	cli
    2218:	de bf       	out	0x3e, r29	; 62
    221a:	0f be       	out	0x3f, r0	; 63
    221c:	cd bf       	out	0x3d, r28	; 61
    221e:	cf 91       	pop	r28
    2220:	df 91       	pop	r29
    2222:	1f 91       	pop	r17
    2224:	0f 91       	pop	r16
    2226:	08 95       	ret

00002228 <MCAL_Timer0_Init>:
void (*Gptr3)(void)= '\0' ;
f32 Glob_TickTime;
u16 Start = 0;
u16 Counter = 0;

void MCAL_Timer0_Init(u8 Loc_u8Mode, u8 Loc_u8Prescaller,u8 Loc_u8OC0Mode) {
    2228:	df 93       	push	r29
    222a:	cf 93       	push	r28
    222c:	00 d0       	rcall	.+0      	; 0x222e <MCAL_Timer0_Init+0x6>
    222e:	00 d0       	rcall	.+0      	; 0x2230 <MCAL_Timer0_Init+0x8>
    2230:	cd b7       	in	r28, 0x3d	; 61
    2232:	de b7       	in	r29, 0x3e	; 62
    2234:	8a 83       	std	Y+2, r24	; 0x02
    2236:	6b 83       	std	Y+3, r22	; 0x03
    2238:	4c 83       	std	Y+4, r20	; 0x04
	u8 LOC_u8ReturnValue = E_NOT_OK;
    223a:	81 e0       	ldi	r24, 0x01	; 1
    223c:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(SREG, 7);
    223e:	af e5       	ldi	r26, 0x5F	; 95
    2240:	b0 e0       	ldi	r27, 0x00	; 0
    2242:	ef e5       	ldi	r30, 0x5F	; 95
    2244:	f0 e0       	ldi	r31, 0x00	; 0
    2246:	80 81       	ld	r24, Z
    2248:	80 68       	ori	r24, 0x80	; 128
    224a:	8c 93       	st	X, r24
	if (Loc_u8Mode == Normal_Mode) {
    224c:	8a 81       	ldd	r24, Y+2	; 0x02
    224e:	88 23       	and	r24, r24
    2250:	b1 f4       	brne	.+44     	; 0x227e <MCAL_Timer0_Init+0x56>
		CLR_BIT(TCCR0, 3);
    2252:	a3 e5       	ldi	r26, 0x53	; 83
    2254:	b0 e0       	ldi	r27, 0x00	; 0
    2256:	e3 e5       	ldi	r30, 0x53	; 83
    2258:	f0 e0       	ldi	r31, 0x00	; 0
    225a:	80 81       	ld	r24, Z
    225c:	87 7f       	andi	r24, 0xF7	; 247
    225e:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 6);
    2260:	a3 e5       	ldi	r26, 0x53	; 83
    2262:	b0 e0       	ldi	r27, 0x00	; 0
    2264:	e3 e5       	ldi	r30, 0x53	; 83
    2266:	f0 e0       	ldi	r31, 0x00	; 0
    2268:	80 81       	ld	r24, Z
    226a:	8f 7b       	andi	r24, 0xBF	; 191
    226c:	8c 93       	st	X, r24
		SET_BIT(TIMSK, 0);
    226e:	a9 e5       	ldi	r26, 0x59	; 89
    2270:	b0 e0       	ldi	r27, 0x00	; 0
    2272:	e9 e5       	ldi	r30, 0x59	; 89
    2274:	f0 e0       	ldi	r31, 0x00	; 0
    2276:	80 81       	ld	r24, Z
    2278:	81 60       	ori	r24, 0x01	; 1
    227a:	8c 93       	st	X, r24
    227c:	35 c0       	rjmp	.+106    	; 0x22e8 <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == CTC_Mode) {
    227e:	8a 81       	ldd	r24, Y+2	; 0x02
    2280:	81 30       	cpi	r24, 0x01	; 1
    2282:	b1 f4       	brne	.+44     	; 0x22b0 <MCAL_Timer0_Init+0x88>
		SET_BIT(TCCR0, 3);
    2284:	a3 e5       	ldi	r26, 0x53	; 83
    2286:	b0 e0       	ldi	r27, 0x00	; 0
    2288:	e3 e5       	ldi	r30, 0x53	; 83
    228a:	f0 e0       	ldi	r31, 0x00	; 0
    228c:	80 81       	ld	r24, Z
    228e:	88 60       	ori	r24, 0x08	; 8
    2290:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 6);
    2292:	a3 e5       	ldi	r26, 0x53	; 83
    2294:	b0 e0       	ldi	r27, 0x00	; 0
    2296:	e3 e5       	ldi	r30, 0x53	; 83
    2298:	f0 e0       	ldi	r31, 0x00	; 0
    229a:	80 81       	ld	r24, Z
    229c:	8f 7b       	andi	r24, 0xBF	; 191
    229e:	8c 93       	st	X, r24
		SET_BIT(TIMSK, 1);
    22a0:	a9 e5       	ldi	r26, 0x59	; 89
    22a2:	b0 e0       	ldi	r27, 0x00	; 0
    22a4:	e9 e5       	ldi	r30, 0x59	; 89
    22a6:	f0 e0       	ldi	r31, 0x00	; 0
    22a8:	80 81       	ld	r24, Z
    22aa:	82 60       	ori	r24, 0x02	; 2
    22ac:	8c 93       	st	X, r24
    22ae:	1c c0       	rjmp	.+56     	; 0x22e8 <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == PWM_Mode) {
    22b0:	8a 81       	ldd	r24, Y+2	; 0x02
    22b2:	82 30       	cpi	r24, 0x02	; 2
    22b4:	79 f4       	brne	.+30     	; 0x22d4 <MCAL_Timer0_Init+0xac>
		CLR_BIT(TCCR0, 3);
    22b6:	a3 e5       	ldi	r26, 0x53	; 83
    22b8:	b0 e0       	ldi	r27, 0x00	; 0
    22ba:	e3 e5       	ldi	r30, 0x53	; 83
    22bc:	f0 e0       	ldi	r31, 0x00	; 0
    22be:	80 81       	ld	r24, Z
    22c0:	87 7f       	andi	r24, 0xF7	; 247
    22c2:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 6);
    22c4:	a3 e5       	ldi	r26, 0x53	; 83
    22c6:	b0 e0       	ldi	r27, 0x00	; 0
    22c8:	e3 e5       	ldi	r30, 0x53	; 83
    22ca:	f0 e0       	ldi	r31, 0x00	; 0
    22cc:	80 81       	ld	r24, Z
    22ce:	80 64       	ori	r24, 0x40	; 64
    22d0:	8c 93       	st	X, r24
    22d2:	0a c0       	rjmp	.+20     	; 0x22e8 <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == FastPWM_Mode) {
    22d4:	8a 81       	ldd	r24, Y+2	; 0x02
    22d6:	83 30       	cpi	r24, 0x03	; 3
    22d8:	39 f4       	brne	.+14     	; 0x22e8 <MCAL_Timer0_Init+0xc0>
//		SET_BIT(TCCR0, 3);
//		SET_BIT(TCCR0, 6);
		SET_BIT(TIMSK, 1);
    22da:	a9 e5       	ldi	r26, 0x59	; 89
    22dc:	b0 e0       	ldi	r27, 0x00	; 0
    22de:	e9 e5       	ldi	r30, 0x59	; 89
    22e0:	f0 e0       	ldi	r31, 0x00	; 0
    22e2:	80 81       	ld	r24, Z
    22e4:	82 60       	ori	r24, 0x02	; 2
    22e6:	8c 93       	st	X, r24
	}
	if (Loc_u8Prescaller == NoPrescaller) {
    22e8:	8b 81       	ldd	r24, Y+3	; 0x03
    22ea:	88 23       	and	r24, r24
    22ec:	b9 f4       	brne	.+46     	; 0x231c <MCAL_Timer0_Init+0xf4>
		CLR_BIT(TCCR0, 0);
    22ee:	a3 e5       	ldi	r26, 0x53	; 83
    22f0:	b0 e0       	ldi	r27, 0x00	; 0
    22f2:	e3 e5       	ldi	r30, 0x53	; 83
    22f4:	f0 e0       	ldi	r31, 0x00	; 0
    22f6:	80 81       	ld	r24, Z
    22f8:	8e 7f       	andi	r24, 0xFE	; 254
    22fa:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    22fc:	a3 e5       	ldi	r26, 0x53	; 83
    22fe:	b0 e0       	ldi	r27, 0x00	; 0
    2300:	e3 e5       	ldi	r30, 0x53	; 83
    2302:	f0 e0       	ldi	r31, 0x00	; 0
    2304:	80 81       	ld	r24, Z
    2306:	8d 7f       	andi	r24, 0xFD	; 253
    2308:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    230a:	a3 e5       	ldi	r26, 0x53	; 83
    230c:	b0 e0       	ldi	r27, 0x00	; 0
    230e:	e3 e5       	ldi	r30, 0x53	; 83
    2310:	f0 e0       	ldi	r31, 0x00	; 0
    2312:	80 81       	ld	r24, Z
    2314:	8b 7f       	andi	r24, 0xFB	; 251
    2316:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    2318:	19 82       	std	Y+1, r1	; 0x01
    231a:	f1 c0       	rjmp	.+482    	; 0x24fe <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_1) {
    231c:	8b 81       	ldd	r24, Y+3	; 0x03
    231e:	81 30       	cpi	r24, 0x01	; 1
    2320:	19 f5       	brne	.+70     	; 0x2368 <MCAL_Timer0_Init+0x140>
		SET_BIT(TCCR0, 0);
    2322:	a3 e5       	ldi	r26, 0x53	; 83
    2324:	b0 e0       	ldi	r27, 0x00	; 0
    2326:	e3 e5       	ldi	r30, 0x53	; 83
    2328:	f0 e0       	ldi	r31, 0x00	; 0
    232a:	80 81       	ld	r24, Z
    232c:	81 60       	ori	r24, 0x01	; 1
    232e:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2330:	a3 e5       	ldi	r26, 0x53	; 83
    2332:	b0 e0       	ldi	r27, 0x00	; 0
    2334:	e3 e5       	ldi	r30, 0x53	; 83
    2336:	f0 e0       	ldi	r31, 0x00	; 0
    2338:	80 81       	ld	r24, Z
    233a:	8d 7f       	andi	r24, 0xFD	; 253
    233c:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    233e:	a3 e5       	ldi	r26, 0x53	; 83
    2340:	b0 e0       	ldi	r27, 0x00	; 0
    2342:	e3 e5       	ldi	r30, 0x53	; 83
    2344:	f0 e0       	ldi	r31, 0x00	; 0
    2346:	80 81       	ld	r24, Z
    2348:	8b 7f       	andi	r24, 0xFB	; 251
    234a:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller1_Value / (f32) CPU_Frequancy;
    234c:	8d eb       	ldi	r24, 0xBD	; 189
    234e:	97 e3       	ldi	r25, 0x37	; 55
    2350:	a6 e8       	ldi	r26, 0x86	; 134
    2352:	b3 e3       	ldi	r27, 0x33	; 51
    2354:	80 93 1f 06 	sts	0x061F, r24
    2358:	90 93 20 06 	sts	0x0620, r25
    235c:	a0 93 21 06 	sts	0x0621, r26
    2360:	b0 93 22 06 	sts	0x0622, r27
		LOC_u8ReturnValue = E_OK;
    2364:	19 82       	std	Y+1, r1	; 0x01
    2366:	cb c0       	rjmp	.+406    	; 0x24fe <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_8) {
    2368:	8b 81       	ldd	r24, Y+3	; 0x03
    236a:	82 30       	cpi	r24, 0x02	; 2
    236c:	19 f5       	brne	.+70     	; 0x23b4 <MCAL_Timer0_Init+0x18c>
		CLR_BIT(TCCR0, 0);
    236e:	a3 e5       	ldi	r26, 0x53	; 83
    2370:	b0 e0       	ldi	r27, 0x00	; 0
    2372:	e3 e5       	ldi	r30, 0x53	; 83
    2374:	f0 e0       	ldi	r31, 0x00	; 0
    2376:	80 81       	ld	r24, Z
    2378:	8e 7f       	andi	r24, 0xFE	; 254
    237a:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    237c:	a3 e5       	ldi	r26, 0x53	; 83
    237e:	b0 e0       	ldi	r27, 0x00	; 0
    2380:	e3 e5       	ldi	r30, 0x53	; 83
    2382:	f0 e0       	ldi	r31, 0x00	; 0
    2384:	80 81       	ld	r24, Z
    2386:	82 60       	ori	r24, 0x02	; 2
    2388:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    238a:	a3 e5       	ldi	r26, 0x53	; 83
    238c:	b0 e0       	ldi	r27, 0x00	; 0
    238e:	e3 e5       	ldi	r30, 0x53	; 83
    2390:	f0 e0       	ldi	r31, 0x00	; 0
    2392:	80 81       	ld	r24, Z
    2394:	8b 7f       	andi	r24, 0xFB	; 251
    2396:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller8_Value / (f32) CPU_Frequancy;
    2398:	8d eb       	ldi	r24, 0xBD	; 189
    239a:	97 e3       	ldi	r25, 0x37	; 55
    239c:	a6 e0       	ldi	r26, 0x06	; 6
    239e:	b5 e3       	ldi	r27, 0x35	; 53
    23a0:	80 93 1f 06 	sts	0x061F, r24
    23a4:	90 93 20 06 	sts	0x0620, r25
    23a8:	a0 93 21 06 	sts	0x0621, r26
    23ac:	b0 93 22 06 	sts	0x0622, r27
		LOC_u8ReturnValue = E_OK;
    23b0:	19 82       	std	Y+1, r1	; 0x01
    23b2:	a5 c0       	rjmp	.+330    	; 0x24fe <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_64) {
    23b4:	8b 81       	ldd	r24, Y+3	; 0x03
    23b6:	83 30       	cpi	r24, 0x03	; 3
    23b8:	19 f5       	brne	.+70     	; 0x2400 <MCAL_Timer0_Init+0x1d8>
		SET_BIT(TCCR0, 0);
    23ba:	a3 e5       	ldi	r26, 0x53	; 83
    23bc:	b0 e0       	ldi	r27, 0x00	; 0
    23be:	e3 e5       	ldi	r30, 0x53	; 83
    23c0:	f0 e0       	ldi	r31, 0x00	; 0
    23c2:	80 81       	ld	r24, Z
    23c4:	81 60       	ori	r24, 0x01	; 1
    23c6:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    23c8:	a3 e5       	ldi	r26, 0x53	; 83
    23ca:	b0 e0       	ldi	r27, 0x00	; 0
    23cc:	e3 e5       	ldi	r30, 0x53	; 83
    23ce:	f0 e0       	ldi	r31, 0x00	; 0
    23d0:	80 81       	ld	r24, Z
    23d2:	82 60       	ori	r24, 0x02	; 2
    23d4:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    23d6:	a3 e5       	ldi	r26, 0x53	; 83
    23d8:	b0 e0       	ldi	r27, 0x00	; 0
    23da:	e3 e5       	ldi	r30, 0x53	; 83
    23dc:	f0 e0       	ldi	r31, 0x00	; 0
    23de:	80 81       	ld	r24, Z
    23e0:	8b 7f       	andi	r24, 0xFB	; 251
    23e2:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller64_Value / (f32) CPU_Frequancy;
    23e4:	8d eb       	ldi	r24, 0xBD	; 189
    23e6:	97 e3       	ldi	r25, 0x37	; 55
    23e8:	a6 e8       	ldi	r26, 0x86	; 134
    23ea:	b6 e3       	ldi	r27, 0x36	; 54
    23ec:	80 93 1f 06 	sts	0x061F, r24
    23f0:	90 93 20 06 	sts	0x0620, r25
    23f4:	a0 93 21 06 	sts	0x0621, r26
    23f8:	b0 93 22 06 	sts	0x0622, r27
		LOC_u8ReturnValue = E_OK;
    23fc:	19 82       	std	Y+1, r1	; 0x01
    23fe:	7f c0       	rjmp	.+254    	; 0x24fe <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_256) {
    2400:	8b 81       	ldd	r24, Y+3	; 0x03
    2402:	84 30       	cpi	r24, 0x04	; 4
    2404:	19 f5       	brne	.+70     	; 0x244c <MCAL_Timer0_Init+0x224>
		CLR_BIT(TCCR0, 0);
    2406:	a3 e5       	ldi	r26, 0x53	; 83
    2408:	b0 e0       	ldi	r27, 0x00	; 0
    240a:	e3 e5       	ldi	r30, 0x53	; 83
    240c:	f0 e0       	ldi	r31, 0x00	; 0
    240e:	80 81       	ld	r24, Z
    2410:	8e 7f       	andi	r24, 0xFE	; 254
    2412:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2414:	a3 e5       	ldi	r26, 0x53	; 83
    2416:	b0 e0       	ldi	r27, 0x00	; 0
    2418:	e3 e5       	ldi	r30, 0x53	; 83
    241a:	f0 e0       	ldi	r31, 0x00	; 0
    241c:	80 81       	ld	r24, Z
    241e:	8d 7f       	andi	r24, 0xFD	; 253
    2420:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    2422:	a3 e5       	ldi	r26, 0x53	; 83
    2424:	b0 e0       	ldi	r27, 0x00	; 0
    2426:	e3 e5       	ldi	r30, 0x53	; 83
    2428:	f0 e0       	ldi	r31, 0x00	; 0
    242a:	80 81       	ld	r24, Z
    242c:	84 60       	ori	r24, 0x04	; 4
    242e:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller256_Value / (f32) CPU_Frequancy;
    2430:	8d eb       	ldi	r24, 0xBD	; 189
    2432:	97 e3       	ldi	r25, 0x37	; 55
    2434:	a6 e8       	ldi	r26, 0x86	; 134
    2436:	b7 e3       	ldi	r27, 0x37	; 55
    2438:	80 93 1f 06 	sts	0x061F, r24
    243c:	90 93 20 06 	sts	0x0620, r25
    2440:	a0 93 21 06 	sts	0x0621, r26
    2444:	b0 93 22 06 	sts	0x0622, r27
		LOC_u8ReturnValue = E_OK;
    2448:	19 82       	std	Y+1, r1	; 0x01
    244a:	59 c0       	rjmp	.+178    	; 0x24fe <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_1024) {
    244c:	8b 81       	ldd	r24, Y+3	; 0x03
    244e:	85 30       	cpi	r24, 0x05	; 5
    2450:	19 f5       	brne	.+70     	; 0x2498 <MCAL_Timer0_Init+0x270>
		SET_BIT(TCCR0, 0);
    2452:	a3 e5       	ldi	r26, 0x53	; 83
    2454:	b0 e0       	ldi	r27, 0x00	; 0
    2456:	e3 e5       	ldi	r30, 0x53	; 83
    2458:	f0 e0       	ldi	r31, 0x00	; 0
    245a:	80 81       	ld	r24, Z
    245c:	81 60       	ori	r24, 0x01	; 1
    245e:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    2460:	a3 e5       	ldi	r26, 0x53	; 83
    2462:	b0 e0       	ldi	r27, 0x00	; 0
    2464:	e3 e5       	ldi	r30, 0x53	; 83
    2466:	f0 e0       	ldi	r31, 0x00	; 0
    2468:	80 81       	ld	r24, Z
    246a:	8d 7f       	andi	r24, 0xFD	; 253
    246c:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    246e:	a3 e5       	ldi	r26, 0x53	; 83
    2470:	b0 e0       	ldi	r27, 0x00	; 0
    2472:	e3 e5       	ldi	r30, 0x53	; 83
    2474:	f0 e0       	ldi	r31, 0x00	; 0
    2476:	80 81       	ld	r24, Z
    2478:	84 60       	ori	r24, 0x04	; 4
    247a:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller1024_Value / (f32) CPU_Frequancy;
    247c:	8d eb       	ldi	r24, 0xBD	; 189
    247e:	97 e3       	ldi	r25, 0x37	; 55
    2480:	a6 e8       	ldi	r26, 0x86	; 134
    2482:	b8 e3       	ldi	r27, 0x38	; 56
    2484:	80 93 1f 06 	sts	0x061F, r24
    2488:	90 93 20 06 	sts	0x0620, r25
    248c:	a0 93 21 06 	sts	0x0621, r26
    2490:	b0 93 22 06 	sts	0x0622, r27
		LOC_u8ReturnValue = E_OK;
    2494:	19 82       	std	Y+1, r1	; 0x01
    2496:	33 c0       	rjmp	.+102    	; 0x24fe <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Clock_on_falling_edge) {
    2498:	8b 81       	ldd	r24, Y+3	; 0x03
    249a:	86 30       	cpi	r24, 0x06	; 6
    249c:	b9 f4       	brne	.+46     	; 0x24cc <MCAL_Timer0_Init+0x2a4>
		CLR_BIT(TCCR0, 0);
    249e:	a3 e5       	ldi	r26, 0x53	; 83
    24a0:	b0 e0       	ldi	r27, 0x00	; 0
    24a2:	e3 e5       	ldi	r30, 0x53	; 83
    24a4:	f0 e0       	ldi	r31, 0x00	; 0
    24a6:	80 81       	ld	r24, Z
    24a8:	8e 7f       	andi	r24, 0xFE	; 254
    24aa:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    24ac:	a3 e5       	ldi	r26, 0x53	; 83
    24ae:	b0 e0       	ldi	r27, 0x00	; 0
    24b0:	e3 e5       	ldi	r30, 0x53	; 83
    24b2:	f0 e0       	ldi	r31, 0x00	; 0
    24b4:	80 81       	ld	r24, Z
    24b6:	82 60       	ori	r24, 0x02	; 2
    24b8:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    24ba:	a3 e5       	ldi	r26, 0x53	; 83
    24bc:	b0 e0       	ldi	r27, 0x00	; 0
    24be:	e3 e5       	ldi	r30, 0x53	; 83
    24c0:	f0 e0       	ldi	r31, 0x00	; 0
    24c2:	80 81       	ld	r24, Z
    24c4:	84 60       	ori	r24, 0x04	; 4
    24c6:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    24c8:	19 82       	std	Y+1, r1	; 0x01
    24ca:	19 c0       	rjmp	.+50     	; 0x24fe <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Clock_on_rising_edge) {
    24cc:	8b 81       	ldd	r24, Y+3	; 0x03
    24ce:	87 30       	cpi	r24, 0x07	; 7
    24d0:	b1 f4       	brne	.+44     	; 0x24fe <MCAL_Timer0_Init+0x2d6>
		SET_BIT(TCCR0, 0);
    24d2:	a3 e5       	ldi	r26, 0x53	; 83
    24d4:	b0 e0       	ldi	r27, 0x00	; 0
    24d6:	e3 e5       	ldi	r30, 0x53	; 83
    24d8:	f0 e0       	ldi	r31, 0x00	; 0
    24da:	80 81       	ld	r24, Z
    24dc:	81 60       	ori	r24, 0x01	; 1
    24de:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    24e0:	a3 e5       	ldi	r26, 0x53	; 83
    24e2:	b0 e0       	ldi	r27, 0x00	; 0
    24e4:	e3 e5       	ldi	r30, 0x53	; 83
    24e6:	f0 e0       	ldi	r31, 0x00	; 0
    24e8:	80 81       	ld	r24, Z
    24ea:	82 60       	ori	r24, 0x02	; 2
    24ec:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    24ee:	a3 e5       	ldi	r26, 0x53	; 83
    24f0:	b0 e0       	ldi	r27, 0x00	; 0
    24f2:	e3 e5       	ldi	r30, 0x53	; 83
    24f4:	f0 e0       	ldi	r31, 0x00	; 0
    24f6:	80 81       	ld	r24, Z
    24f8:	84 60       	ori	r24, 0x04	; 4
    24fa:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    24fc:	19 82       	std	Y+1, r1	; 0x01
	} else {
		//NOTHING
	}
	if (Loc_u8OC0Mode == Disconnected) {
    24fe:	8c 81       	ldd	r24, Y+4	; 0x04
    2500:	88 23       	and	r24, r24
    2502:	79 f4       	brne	.+30     	; 0x2522 <MCAL_Timer0_Init+0x2fa>
			CLR_BIT(TCCR0, 4);
    2504:	a3 e5       	ldi	r26, 0x53	; 83
    2506:	b0 e0       	ldi	r27, 0x00	; 0
    2508:	e3 e5       	ldi	r30, 0x53	; 83
    250a:	f0 e0       	ldi	r31, 0x00	; 0
    250c:	80 81       	ld	r24, Z
    250e:	8f 7e       	andi	r24, 0xEF	; 239
    2510:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 5);
    2512:	a3 e5       	ldi	r26, 0x53	; 83
    2514:	b0 e0       	ldi	r27, 0x00	; 0
    2516:	e3 e5       	ldi	r30, 0x53	; 83
    2518:	f0 e0       	ldi	r31, 0x00	; 0
    251a:	80 81       	ld	r24, Z
    251c:	8f 7d       	andi	r24, 0xDF	; 223
    251e:	8c 93       	st	X, r24
    2520:	43 c0       	rjmp	.+134    	; 0x25a8 <MCAL_Timer0_Init+0x380>
		} else if (Loc_u8OC0Mode == Reserved) {
    2522:	8c 81       	ldd	r24, Y+4	; 0x04
    2524:	81 30       	cpi	r24, 0x01	; 1
    2526:	79 f4       	brne	.+30     	; 0x2546 <MCAL_Timer0_Init+0x31e>
			SET_BIT(TCCR0, 4);
    2528:	a3 e5       	ldi	r26, 0x53	; 83
    252a:	b0 e0       	ldi	r27, 0x00	; 0
    252c:	e3 e5       	ldi	r30, 0x53	; 83
    252e:	f0 e0       	ldi	r31, 0x00	; 0
    2530:	80 81       	ld	r24, Z
    2532:	80 61       	ori	r24, 0x10	; 16
    2534:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 5);
    2536:	a3 e5       	ldi	r26, 0x53	; 83
    2538:	b0 e0       	ldi	r27, 0x00	; 0
    253a:	e3 e5       	ldi	r30, 0x53	; 83
    253c:	f0 e0       	ldi	r31, 0x00	; 0
    253e:	80 81       	ld	r24, Z
    2540:	8f 7d       	andi	r24, 0xDF	; 223
    2542:	8c 93       	st	X, r24
    2544:	31 c0       	rjmp	.+98     	; 0x25a8 <MCAL_Timer0_Init+0x380>
			//PWM, Fast PWM
		} else if (Loc_u8OC0Mode == Non_Inverted) {
    2546:	8c 81       	ldd	r24, Y+4	; 0x04
    2548:	82 30       	cpi	r24, 0x02	; 2
    254a:	b1 f4       	brne	.+44     	; 0x2578 <MCAL_Timer0_Init+0x350>
			SET_BIT(TCCR0, 5);
    254c:	a3 e5       	ldi	r26, 0x53	; 83
    254e:	b0 e0       	ldi	r27, 0x00	; 0
    2550:	e3 e5       	ldi	r30, 0x53	; 83
    2552:	f0 e0       	ldi	r31, 0x00	; 0
    2554:	80 81       	ld	r24, Z
    2556:	80 62       	ori	r24, 0x20	; 32
    2558:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 4);
    255a:	a3 e5       	ldi	r26, 0x53	; 83
    255c:	b0 e0       	ldi	r27, 0x00	; 0
    255e:	e3 e5       	ldi	r30, 0x53	; 83
    2560:	f0 e0       	ldi	r31, 0x00	; 0
    2562:	80 81       	ld	r24, Z
    2564:	8f 7e       	andi	r24, 0xEF	; 239
    2566:	8c 93       	st	X, r24
			// OC0
			SET_BIT(DDRB, 3);
    2568:	a7 e3       	ldi	r26, 0x37	; 55
    256a:	b0 e0       	ldi	r27, 0x00	; 0
    256c:	e7 e3       	ldi	r30, 0x37	; 55
    256e:	f0 e0       	ldi	r31, 0x00	; 0
    2570:	80 81       	ld	r24, Z
    2572:	88 60       	ori	r24, 0x08	; 8
    2574:	8c 93       	st	X, r24
    2576:	18 c0       	rjmp	.+48     	; 0x25a8 <MCAL_Timer0_Init+0x380>
			//PWM, Fast PWM
		} else if (Loc_u8OC0Mode == Inverted) {
    2578:	8c 81       	ldd	r24, Y+4	; 0x04
    257a:	83 30       	cpi	r24, 0x03	; 3
    257c:	a9 f4       	brne	.+42     	; 0x25a8 <MCAL_Timer0_Init+0x380>
			SET_BIT(TCCR0, 4);
    257e:	a3 e5       	ldi	r26, 0x53	; 83
    2580:	b0 e0       	ldi	r27, 0x00	; 0
    2582:	e3 e5       	ldi	r30, 0x53	; 83
    2584:	f0 e0       	ldi	r31, 0x00	; 0
    2586:	80 81       	ld	r24, Z
    2588:	80 61       	ori	r24, 0x10	; 16
    258a:	8c 93       	st	X, r24
			SET_BIT(TCCR0, 5);
    258c:	a3 e5       	ldi	r26, 0x53	; 83
    258e:	b0 e0       	ldi	r27, 0x00	; 0
    2590:	e3 e5       	ldi	r30, 0x53	; 83
    2592:	f0 e0       	ldi	r31, 0x00	; 0
    2594:	80 81       	ld	r24, Z
    2596:	80 62       	ori	r24, 0x20	; 32
    2598:	8c 93       	st	X, r24
			// OC0
			SET_BIT(DDRB, 3);
    259a:	a7 e3       	ldi	r26, 0x37	; 55
    259c:	b0 e0       	ldi	r27, 0x00	; 0
    259e:	e7 e3       	ldi	r30, 0x37	; 55
    25a0:	f0 e0       	ldi	r31, 0x00	; 0
    25a2:	80 81       	ld	r24, Z
    25a4:	88 60       	ori	r24, 0x08	; 8
    25a6:	8c 93       	st	X, r24
		}
}
    25a8:	0f 90       	pop	r0
    25aa:	0f 90       	pop	r0
    25ac:	0f 90       	pop	r0
    25ae:	0f 90       	pop	r0
    25b0:	cf 91       	pop	r28
    25b2:	df 91       	pop	r29
    25b4:	08 95       	ret

000025b6 <MCAL_Timer0_SetPreloadValue>:
void MCAL_Timer0_SetPreloadValue(u8 Loc_u8Value) {
    25b6:	df 93       	push	r29
    25b8:	cf 93       	push	r28
    25ba:	0f 92       	push	r0
    25bc:	cd b7       	in	r28, 0x3d	; 61
    25be:	de b7       	in	r29, 0x3e	; 62
    25c0:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = Loc_u8Value;
    25c2:	e2 e5       	ldi	r30, 0x52	; 82
    25c4:	f0 e0       	ldi	r31, 0x00	; 0
    25c6:	89 81       	ldd	r24, Y+1	; 0x01
    25c8:	80 83       	st	Z, r24
}
    25ca:	0f 90       	pop	r0
    25cc:	cf 91       	pop	r28
    25ce:	df 91       	pop	r29
    25d0:	08 95       	ret

000025d2 <MCAL_Timer0_SetCompareValue>:
void MCAL_Timer0_SetCompareValue(u8 Loc_u8Value) {
    25d2:	df 93       	push	r29
    25d4:	cf 93       	push	r28
    25d6:	0f 92       	push	r0
    25d8:	cd b7       	in	r28, 0x3d	; 61
    25da:	de b7       	in	r29, 0x3e	; 62
    25dc:	89 83       	std	Y+1, r24	; 0x01
	OCR0 = Loc_u8Value;
    25de:	ec e5       	ldi	r30, 0x5C	; 92
    25e0:	f0 e0       	ldi	r31, 0x00	; 0
    25e2:	89 81       	ldd	r24, Y+1	; 0x01
    25e4:	80 83       	st	Z, r24
}
    25e6:	0f 90       	pop	r0
    25e8:	cf 91       	pop	r28
    25ea:	df 91       	pop	r29
    25ec:	08 95       	ret

000025ee <MCAL_Timer0_EnableNormalMode>:
void MCAL_Timer0_EnableNormalMode() {
    25ee:	df 93       	push	r29
    25f0:	cf 93       	push	r28
    25f2:	cd b7       	in	r28, 0x3d	; 61
    25f4:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK, 0);
    25f6:	a9 e5       	ldi	r26, 0x59	; 89
    25f8:	b0 e0       	ldi	r27, 0x00	; 0
    25fa:	e9 e5       	ldi	r30, 0x59	; 89
    25fc:	f0 e0       	ldi	r31, 0x00	; 0
    25fe:	80 81       	ld	r24, Z
    2600:	81 60       	ori	r24, 0x01	; 1
    2602:	8c 93       	st	X, r24
}
    2604:	cf 91       	pop	r28
    2606:	df 91       	pop	r29
    2608:	08 95       	ret

0000260a <MCAL_Timer0_DisableNormalMode>:
void MCAL_Timer0_DisableNormalMode() {
    260a:	df 93       	push	r29
    260c:	cf 93       	push	r28
    260e:	cd b7       	in	r28, 0x3d	; 61
    2610:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, 0);
    2612:	a9 e5       	ldi	r26, 0x59	; 89
    2614:	b0 e0       	ldi	r27, 0x00	; 0
    2616:	e9 e5       	ldi	r30, 0x59	; 89
    2618:	f0 e0       	ldi	r31, 0x00	; 0
    261a:	80 81       	ld	r24, Z
    261c:	8e 7f       	andi	r24, 0xFE	; 254
    261e:	8c 93       	st	X, r24
}
    2620:	cf 91       	pop	r28
    2622:	df 91       	pop	r29
    2624:	08 95       	ret

00002626 <MCAL_Timer0_EnableCTCMode>:
void MCAL_Timer0_EnableCTCMode() {
    2626:	df 93       	push	r29
    2628:	cf 93       	push	r28
    262a:	cd b7       	in	r28, 0x3d	; 61
    262c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK, 1);
    262e:	a9 e5       	ldi	r26, 0x59	; 89
    2630:	b0 e0       	ldi	r27, 0x00	; 0
    2632:	e9 e5       	ldi	r30, 0x59	; 89
    2634:	f0 e0       	ldi	r31, 0x00	; 0
    2636:	80 81       	ld	r24, Z
    2638:	82 60       	ori	r24, 0x02	; 2
    263a:	8c 93       	st	X, r24
}
    263c:	cf 91       	pop	r28
    263e:	df 91       	pop	r29
    2640:	08 95       	ret

00002642 <MCAL_Timer0_DisableCTCMode>:
void MCAL_Timer0_DisableCTCMode() {
    2642:	df 93       	push	r29
    2644:	cf 93       	push	r28
    2646:	cd b7       	in	r28, 0x3d	; 61
    2648:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, 1);
    264a:	a9 e5       	ldi	r26, 0x59	; 89
    264c:	b0 e0       	ldi	r27, 0x00	; 0
    264e:	e9 e5       	ldi	r30, 0x59	; 89
    2650:	f0 e0       	ldi	r31, 0x00	; 0
    2652:	80 81       	ld	r24, Z
    2654:	8d 7f       	andi	r24, 0xFD	; 253
    2656:	8c 93       	st	X, r24
}
    2658:	cf 91       	pop	r28
    265a:	df 91       	pop	r29
    265c:	08 95       	ret

0000265e <MCAL_Timer0_Delayms_NormalMode>:

void MCAL_Timer0_Delayms_NormalMode(u32 Loc_u32MilliSeconds) {
    265e:	df 93       	push	r29
    2660:	cf 93       	push	r28
    2662:	cd b7       	in	r28, 0x3d	; 61
    2664:	de b7       	in	r29, 0x3e	; 62
    2666:	28 97       	sbiw	r28, 0x08	; 8
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	de bf       	out	0x3e, r29	; 62
    266e:	0f be       	out	0x3f, r0	; 63
    2670:	cd bf       	out	0x3d, r28	; 61
    2672:	6d 83       	std	Y+5, r22	; 0x05
    2674:	7e 83       	std	Y+6, r23	; 0x06
    2676:	8f 83       	std	Y+7, r24	; 0x07
    2678:	98 87       	std	Y+8, r25	; 0x08
	u32 N = 0;
    267a:	19 82       	std	Y+1, r1	; 0x01
    267c:	1a 82       	std	Y+2, r1	; 0x02
    267e:	1b 82       	std	Y+3, r1	; 0x03
    2680:	1c 82       	std	Y+4, r1	; 0x04
	N = (Loc_u32MilliSeconds / 1000.0) / (f32) Glob_TickTime;
    2682:	6d 81       	ldd	r22, Y+5	; 0x05
    2684:	7e 81       	ldd	r23, Y+6	; 0x06
    2686:	8f 81       	ldd	r24, Y+7	; 0x07
    2688:	98 85       	ldd	r25, Y+8	; 0x08
    268a:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    268e:	dc 01       	movw	r26, r24
    2690:	cb 01       	movw	r24, r22
    2692:	bc 01       	movw	r22, r24
    2694:	cd 01       	movw	r24, r26
    2696:	20 e0       	ldi	r18, 0x00	; 0
    2698:	30 e0       	ldi	r19, 0x00	; 0
    269a:	4a e7       	ldi	r20, 0x7A	; 122
    269c:	54 e4       	ldi	r21, 0x44	; 68
    269e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    26a2:	dc 01       	movw	r26, r24
    26a4:	cb 01       	movw	r24, r22
    26a6:	20 91 1f 06 	lds	r18, 0x061F
    26aa:	30 91 20 06 	lds	r19, 0x0620
    26ae:	40 91 21 06 	lds	r20, 0x0621
    26b2:	50 91 22 06 	lds	r21, 0x0622
    26b6:	bc 01       	movw	r22, r24
    26b8:	cd 01       	movw	r24, r26
    26ba:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    26be:	dc 01       	movw	r26, r24
    26c0:	cb 01       	movw	r24, r22
    26c2:	bc 01       	movw	r22, r24
    26c4:	cd 01       	movw	r24, r26
    26c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26ca:	dc 01       	movw	r26, r24
    26cc:	cb 01       	movw	r24, r22
    26ce:	89 83       	std	Y+1, r24	; 0x01
    26d0:	9a 83       	std	Y+2, r25	; 0x02
    26d2:	ab 83       	std	Y+3, r26	; 0x03
    26d4:	bc 83       	std	Y+4, r27	; 0x04
	Start = N % 256;
    26d6:	89 81       	ldd	r24, Y+1	; 0x01
    26d8:	9a 81       	ldd	r25, Y+2	; 0x02
    26da:	90 70       	andi	r25, 0x00	; 0
    26dc:	90 93 8c 01 	sts	0x018C, r25
    26e0:	80 93 8b 01 	sts	0x018B, r24
	if (Start == 0) {
    26e4:	80 91 8b 01 	lds	r24, 0x018B
    26e8:	90 91 8c 01 	lds	r25, 0x018C
    26ec:	00 97       	sbiw	r24, 0x00	; 0
    26ee:	99 f4       	brne	.+38     	; 0x2716 <MCAL_Timer0_Delayms_NormalMode+0xb8>
		MCAL_Timer0_SetPreloadValue(Start);
    26f0:	80 91 8b 01 	lds	r24, 0x018B
    26f4:	90 91 8c 01 	lds	r25, 0x018C
    26f8:	0e 94 db 12 	call	0x25b6	; 0x25b6 <MCAL_Timer0_SetPreloadValue>
		Counter = N / 256;
    26fc:	89 81       	ldd	r24, Y+1	; 0x01
    26fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2700:	ab 81       	ldd	r26, Y+3	; 0x03
    2702:	bc 81       	ldd	r27, Y+4	; 0x04
    2704:	89 2f       	mov	r24, r25
    2706:	9a 2f       	mov	r25, r26
    2708:	ab 2f       	mov	r26, r27
    270a:	bb 27       	eor	r27, r27
    270c:	90 93 8e 01 	sts	0x018E, r25
    2710:	80 93 8d 01 	sts	0x018D, r24
    2714:	19 c0       	rjmp	.+50     	; 0x2748 <MCAL_Timer0_Delayms_NormalMode+0xea>
	} else if (Start != 0) {
    2716:	80 91 8b 01 	lds	r24, 0x018B
    271a:	90 91 8c 01 	lds	r25, 0x018C
    271e:	00 97       	sbiw	r24, 0x00	; 0
    2720:	99 f0       	breq	.+38     	; 0x2748 <MCAL_Timer0_Delayms_NormalMode+0xea>
		MCAL_Timer0_SetPreloadValue(Start);
    2722:	80 91 8b 01 	lds	r24, 0x018B
    2726:	90 91 8c 01 	lds	r25, 0x018C
    272a:	0e 94 db 12 	call	0x25b6	; 0x25b6 <MCAL_Timer0_SetPreloadValue>
		Counter = ((N / 256) + 1);
    272e:	89 81       	ldd	r24, Y+1	; 0x01
    2730:	9a 81       	ldd	r25, Y+2	; 0x02
    2732:	ab 81       	ldd	r26, Y+3	; 0x03
    2734:	bc 81       	ldd	r27, Y+4	; 0x04
    2736:	89 2f       	mov	r24, r25
    2738:	9a 2f       	mov	r25, r26
    273a:	ab 2f       	mov	r26, r27
    273c:	bb 27       	eor	r27, r27
    273e:	01 96       	adiw	r24, 0x01	; 1
    2740:	90 93 8e 01 	sts	0x018E, r25
    2744:	80 93 8d 01 	sts	0x018D, r24
	} else {
		//NOTHING
	}
}
    2748:	28 96       	adiw	r28, 0x08	; 8
    274a:	0f b6       	in	r0, 0x3f	; 63
    274c:	f8 94       	cli
    274e:	de bf       	out	0x3e, r29	; 62
    2750:	0f be       	out	0x3f, r0	; 63
    2752:	cd bf       	out	0x3d, r28	; 61
    2754:	cf 91       	pop	r28
    2756:	df 91       	pop	r29
    2758:	08 95       	ret

0000275a <MCAL_Timer0_Delayms_CTCMode>:
void MCAL_Timer0_Delayms_CTCMode(u32 Loc_u32MilliSeconds) {
    275a:	df 93       	push	r29
    275c:	cf 93       	push	r28
    275e:	cd b7       	in	r28, 0x3d	; 61
    2760:	de b7       	in	r29, 0x3e	; 62
    2762:	29 97       	sbiw	r28, 0x09	; 9
    2764:	0f b6       	in	r0, 0x3f	; 63
    2766:	f8 94       	cli
    2768:	de bf       	out	0x3e, r29	; 62
    276a:	0f be       	out	0x3f, r0	; 63
    276c:	cd bf       	out	0x3d, r28	; 61
    276e:	6e 83       	std	Y+6, r22	; 0x06
    2770:	7f 83       	std	Y+7, r23	; 0x07
    2772:	88 87       	std	Y+8, r24	; 0x08
    2774:	99 87       	std	Y+9, r25	; 0x09
	u8 LOC_u8ReturnValue = E_NOT_OK;
    2776:	81 e0       	ldi	r24, 0x01	; 1
    2778:	8d 83       	std	Y+5, r24	; 0x05
	f32 N = 0;
    277a:	80 e0       	ldi	r24, 0x00	; 0
    277c:	90 e0       	ldi	r25, 0x00	; 0
    277e:	a0 e0       	ldi	r26, 0x00	; 0
    2780:	b0 e0       	ldi	r27, 0x00	; 0
    2782:	89 83       	std	Y+1, r24	; 0x01
    2784:	9a 83       	std	Y+2, r25	; 0x02
    2786:	ab 83       	std	Y+3, r26	; 0x03
    2788:	bc 83       	std	Y+4, r27	; 0x04
	MCAL_Timer0_SetCompareValue(CompareStartValue);
    278a:	87 ec       	ldi	r24, 0xC7	; 199
    278c:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <MCAL_Timer0_SetCompareValue>
	N = ((CompareStartValue + 1) * Glob_TickTime);
    2790:	80 91 1f 06 	lds	r24, 0x061F
    2794:	90 91 20 06 	lds	r25, 0x0620
    2798:	a0 91 21 06 	lds	r26, 0x0621
    279c:	b0 91 22 06 	lds	r27, 0x0622
    27a0:	bc 01       	movw	r22, r24
    27a2:	cd 01       	movw	r24, r26
    27a4:	20 e0       	ldi	r18, 0x00	; 0
    27a6:	30 e0       	ldi	r19, 0x00	; 0
    27a8:	48 e4       	ldi	r20, 0x48	; 72
    27aa:	53 e4       	ldi	r21, 0x43	; 67
    27ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27b0:	dc 01       	movw	r26, r24
    27b2:	cb 01       	movw	r24, r22
    27b4:	89 83       	std	Y+1, r24	; 0x01
    27b6:	9a 83       	std	Y+2, r25	; 0x02
    27b8:	ab 83       	std	Y+3, r26	; 0x03
    27ba:	bc 83       	std	Y+4, r27	; 0x04
	Counter = ((Loc_u32MilliSeconds/1000.0) / N);
    27bc:	6e 81       	ldd	r22, Y+6	; 0x06
    27be:	7f 81       	ldd	r23, Y+7	; 0x07
    27c0:	88 85       	ldd	r24, Y+8	; 0x08
    27c2:	99 85       	ldd	r25, Y+9	; 0x09
    27c4:	0e 94 37 05 	call	0xa6e	; 0xa6e <__floatunsisf>
    27c8:	dc 01       	movw	r26, r24
    27ca:	cb 01       	movw	r24, r22
    27cc:	bc 01       	movw	r22, r24
    27ce:	cd 01       	movw	r24, r26
    27d0:	20 e0       	ldi	r18, 0x00	; 0
    27d2:	30 e0       	ldi	r19, 0x00	; 0
    27d4:	4a e7       	ldi	r20, 0x7A	; 122
    27d6:	54 e4       	ldi	r21, 0x44	; 68
    27d8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    27dc:	dc 01       	movw	r26, r24
    27de:	cb 01       	movw	r24, r22
    27e0:	bc 01       	movw	r22, r24
    27e2:	cd 01       	movw	r24, r26
    27e4:	29 81       	ldd	r18, Y+1	; 0x01
    27e6:	3a 81       	ldd	r19, Y+2	; 0x02
    27e8:	4b 81       	ldd	r20, Y+3	; 0x03
    27ea:	5c 81       	ldd	r21, Y+4	; 0x04
    27ec:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    27f0:	dc 01       	movw	r26, r24
    27f2:	cb 01       	movw	r24, r22
    27f4:	bc 01       	movw	r22, r24
    27f6:	cd 01       	movw	r24, r26
    27f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    27fc:	dc 01       	movw	r26, r24
    27fe:	cb 01       	movw	r24, r22
    2800:	90 93 8e 01 	sts	0x018E, r25
    2804:	80 93 8d 01 	sts	0x018D, r24

	LOC_u8ReturnValue = E_OK;
    2808:	1d 82       	std	Y+5, r1	; 0x05
}
    280a:	29 96       	adiw	r28, 0x09	; 9
    280c:	0f b6       	in	r0, 0x3f	; 63
    280e:	f8 94       	cli
    2810:	de bf       	out	0x3e, r29	; 62
    2812:	0f be       	out	0x3f, r0	; 63
    2814:	cd bf       	out	0x3d, r28	; 61
    2816:	cf 91       	pop	r28
    2818:	df 91       	pop	r29
    281a:	08 95       	ret

0000281c <MCAL_Timer0_CallBack>:

void MCAL_Timer0_CallBack(void (*ptr)(void)) {
    281c:	df 93       	push	r29
    281e:	cf 93       	push	r28
    2820:	00 d0       	rcall	.+0      	; 0x2822 <MCAL_Timer0_CallBack+0x6>
    2822:	cd b7       	in	r28, 0x3d	; 61
    2824:	de b7       	in	r29, 0x3e	; 62
    2826:	9a 83       	std	Y+2, r25	; 0x02
    2828:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    282a:	89 81       	ldd	r24, Y+1	; 0x01
    282c:	9a 81       	ldd	r25, Y+2	; 0x02
    282e:	00 97       	sbiw	r24, 0x00	; 0
    2830:	31 f0       	breq	.+12     	; 0x283e <MCAL_Timer0_CallBack+0x22>
		Gptr3 = ptr;
    2832:	89 81       	ldd	r24, Y+1	; 0x01
    2834:	9a 81       	ldd	r25, Y+2	; 0x02
    2836:	90 93 8a 01 	sts	0x018A, r25
    283a:	80 93 89 01 	sts	0x0189, r24
}
    283e:	0f 90       	pop	r0
    2840:	0f 90       	pop	r0
    2842:	cf 91       	pop	r28
    2844:	df 91       	pop	r29
    2846:	08 95       	ret

00002848 <__vector_11>:

ISR(TIMER0_OVF_vect) {
    2848:	1f 92       	push	r1
    284a:	0f 92       	push	r0
    284c:	0f b6       	in	r0, 0x3f	; 63
    284e:	0f 92       	push	r0
    2850:	11 24       	eor	r1, r1
    2852:	2f 93       	push	r18
    2854:	3f 93       	push	r19
    2856:	4f 93       	push	r20
    2858:	5f 93       	push	r21
    285a:	6f 93       	push	r22
    285c:	7f 93       	push	r23
    285e:	8f 93       	push	r24
    2860:	9f 93       	push	r25
    2862:	af 93       	push	r26
    2864:	bf 93       	push	r27
    2866:	ef 93       	push	r30
    2868:	ff 93       	push	r31
    286a:	df 93       	push	r29
    286c:	cf 93       	push	r28
    286e:	cd b7       	in	r28, 0x3d	; 61
    2870:	de b7       	in	r29, 0x3e	; 62
	if (Gptr3 != '\0')
    2872:	80 91 89 01 	lds	r24, 0x0189
    2876:	90 91 8a 01 	lds	r25, 0x018A
    287a:	00 97       	sbiw	r24, 0x00	; 0
    287c:	29 f0       	breq	.+10     	; 0x2888 <__vector_11+0x40>
		Gptr3();
    287e:	e0 91 89 01 	lds	r30, 0x0189
    2882:	f0 91 8a 01 	lds	r31, 0x018A
    2886:	09 95       	icall
}
    2888:	cf 91       	pop	r28
    288a:	df 91       	pop	r29
    288c:	ff 91       	pop	r31
    288e:	ef 91       	pop	r30
    2890:	bf 91       	pop	r27
    2892:	af 91       	pop	r26
    2894:	9f 91       	pop	r25
    2896:	8f 91       	pop	r24
    2898:	7f 91       	pop	r23
    289a:	6f 91       	pop	r22
    289c:	5f 91       	pop	r21
    289e:	4f 91       	pop	r20
    28a0:	3f 91       	pop	r19
    28a2:	2f 91       	pop	r18
    28a4:	0f 90       	pop	r0
    28a6:	0f be       	out	0x3f, r0	; 63
    28a8:	0f 90       	pop	r0
    28aa:	1f 90       	pop	r1
    28ac:	18 95       	reti

000028ae <__vector_10>:
ISR(TIMER0_COMP_vect) {
    28ae:	1f 92       	push	r1
    28b0:	0f 92       	push	r0
    28b2:	0f b6       	in	r0, 0x3f	; 63
    28b4:	0f 92       	push	r0
    28b6:	11 24       	eor	r1, r1
    28b8:	2f 93       	push	r18
    28ba:	3f 93       	push	r19
    28bc:	4f 93       	push	r20
    28be:	5f 93       	push	r21
    28c0:	6f 93       	push	r22
    28c2:	7f 93       	push	r23
    28c4:	8f 93       	push	r24
    28c6:	9f 93       	push	r25
    28c8:	af 93       	push	r26
    28ca:	bf 93       	push	r27
    28cc:	ef 93       	push	r30
    28ce:	ff 93       	push	r31
    28d0:	df 93       	push	r29
    28d2:	cf 93       	push	r28
    28d4:	cd b7       	in	r28, 0x3d	; 61
    28d6:	de b7       	in	r29, 0x3e	; 62
	if (Gptr3 != '\0')
    28d8:	80 91 89 01 	lds	r24, 0x0189
    28dc:	90 91 8a 01 	lds	r25, 0x018A
    28e0:	00 97       	sbiw	r24, 0x00	; 0
    28e2:	29 f0       	breq	.+10     	; 0x28ee <__vector_10+0x40>
		Gptr3();
    28e4:	e0 91 89 01 	lds	r30, 0x0189
    28e8:	f0 91 8a 01 	lds	r31, 0x018A
    28ec:	09 95       	icall
}
    28ee:	cf 91       	pop	r28
    28f0:	df 91       	pop	r29
    28f2:	ff 91       	pop	r31
    28f4:	ef 91       	pop	r30
    28f6:	bf 91       	pop	r27
    28f8:	af 91       	pop	r26
    28fa:	9f 91       	pop	r25
    28fc:	8f 91       	pop	r24
    28fe:	7f 91       	pop	r23
    2900:	6f 91       	pop	r22
    2902:	5f 91       	pop	r21
    2904:	4f 91       	pop	r20
    2906:	3f 91       	pop	r19
    2908:	2f 91       	pop	r18
    290a:	0f 90       	pop	r0
    290c:	0f be       	out	0x3f, r0	; 63
    290e:	0f 90       	pop	r0
    2910:	1f 90       	pop	r1
    2912:	18 95       	reti

00002914 <MCAL_TWI_Master_Init>:
 */

#include "TWI.h"

// Master
void MCAL_TWI_Master_Init(void) {
    2914:	df 93       	push	r29
    2916:	cf 93       	push	r28
    2918:	cd b7       	in	r28, 0x3d	; 61
    291a:	de b7       	in	r29, 0x3e	; 62
	//Enable TWI
	SET_BIT(TWCR, Pin2);
    291c:	a6 e5       	ldi	r26, 0x56	; 86
    291e:	b0 e0       	ldi	r27, 0x00	; 0
    2920:	e6 e5       	ldi	r30, 0x56	; 86
    2922:	f0 e0       	ldi	r31, 0x00	; 0
    2924:	80 81       	ld	r24, Z
    2926:	84 60       	ori	r24, 0x04	; 4
    2928:	8c 93       	st	X, r24
	//Enable ACK
	SET_BIT(TWCR, Pin6);
    292a:	a6 e5       	ldi	r26, 0x56	; 86
    292c:	b0 e0       	ldi	r27, 0x00	; 0
    292e:	e6 e5       	ldi	r30, 0x56	; 86
    2930:	f0 e0       	ldi	r31, 0x00	; 0
    2932:	80 81       	ld	r24, Z
    2934:	80 64       	ori	r24, 0x40	; 64
    2936:	8c 93       	st	X, r24
	//Bit Rate
	TWBR = Bit_Rate;
    2938:	e0 e2       	ldi	r30, 0x20	; 32
    293a:	f0 e0       	ldi	r31, 0x00	; 0
    293c:	88 e9       	ldi	r24, 0x98	; 152
    293e:	80 83       	st	Z, r24
}
    2940:	cf 91       	pop	r28
    2942:	df 91       	pop	r29
    2944:	08 95       	ret

00002946 <MCAL_TWI_Master_SendStartCondition>:

void MCAL_TWI_Master_SendStartCondition(void) {
    2946:	df 93       	push	r29
    2948:	cf 93       	push	r28
    294a:	cd b7       	in	r28, 0x3d	; 61
    294c:	de b7       	in	r29, 0x3e	; 62
	// Enable Start
	SET_BIT(TWCR, Pin5);
    294e:	a6 e5       	ldi	r26, 0x56	; 86
    2950:	b0 e0       	ldi	r27, 0x00	; 0
    2952:	e6 e5       	ldi	r30, 0x56	; 86
    2954:	f0 e0       	ldi	r31, 0x00	; 0
    2956:	80 81       	ld	r24, Z
    2958:	80 62       	ori	r24, 0x20	; 32
    295a:	8c 93       	st	X, r24
	//CLR Flag
	SET_BIT(TWCR, Pin7);
    295c:	a6 e5       	ldi	r26, 0x56	; 86
    295e:	b0 e0       	ldi	r27, 0x00	; 0
    2960:	e6 e5       	ldi	r30, 0x56	; 86
    2962:	f0 e0       	ldi	r31, 0x00	; 0
    2964:	80 81       	ld	r24, Z
    2966:	80 68       	ori	r24, 0x80	; 128
    2968:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    296a:	e6 e5       	ldi	r30, 0x56	; 86
    296c:	f0 e0       	ldi	r31, 0x00	; 0
    296e:	80 81       	ld	r24, Z
    2970:	88 23       	and	r24, r24
    2972:	dc f7       	brge	.-10     	; 0x296a <MCAL_TWI_Master_SendStartCondition+0x24>
		;
}
    2974:	cf 91       	pop	r28
    2976:	df 91       	pop	r29
    2978:	08 95       	ret

0000297a <MCAL_TWI_Master_SendReStartCondition>:
void MCAL_TWI_Master_SendReStartCondition(void) {
    297a:	df 93       	push	r29
    297c:	cf 93       	push	r28
    297e:	cd b7       	in	r28, 0x3d	; 61
    2980:	de b7       	in	r29, 0x3e	; 62
	// Enable Start
	SET_BIT(TWCR, Pin5);
    2982:	a6 e5       	ldi	r26, 0x56	; 86
    2984:	b0 e0       	ldi	r27, 0x00	; 0
    2986:	e6 e5       	ldi	r30, 0x56	; 86
    2988:	f0 e0       	ldi	r31, 0x00	; 0
    298a:	80 81       	ld	r24, Z
    298c:	80 62       	ori	r24, 0x20	; 32
    298e:	8c 93       	st	X, r24
	//CLR Flag
	SET_BIT(TWCR, Pin7);
    2990:	a6 e5       	ldi	r26, 0x56	; 86
    2992:	b0 e0       	ldi	r27, 0x00	; 0
    2994:	e6 e5       	ldi	r30, 0x56	; 86
    2996:	f0 e0       	ldi	r31, 0x00	; 0
    2998:	80 81       	ld	r24, Z
    299a:	80 68       	ori	r24, 0x80	; 128
    299c:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    299e:	e6 e5       	ldi	r30, 0x56	; 86
    29a0:	f0 e0       	ldi	r31, 0x00	; 0
    29a2:	80 81       	ld	r24, Z
    29a4:	88 23       	and	r24, r24
    29a6:	dc f7       	brge	.-10     	; 0x299e <MCAL_TWI_Master_SendReStartCondition+0x24>
		;
}
    29a8:	cf 91       	pop	r28
    29aa:	df 91       	pop	r29
    29ac:	08 95       	ret

000029ae <MCAL_TWI_Master_SendStopCondition>:

void MCAL_TWI_Master_SendStopCondition(void) {
    29ae:	df 93       	push	r29
    29b0:	cf 93       	push	r28
    29b2:	cd b7       	in	r28, 0x3d	; 61
    29b4:	de b7       	in	r29, 0x3e	; 62
	// Enable Stop
	SET_BIT(TWCR, Pin4);
    29b6:	a6 e5       	ldi	r26, 0x56	; 86
    29b8:	b0 e0       	ldi	r27, 0x00	; 0
    29ba:	e6 e5       	ldi	r30, 0x56	; 86
    29bc:	f0 e0       	ldi	r31, 0x00	; 0
    29be:	80 81       	ld	r24, Z
    29c0:	80 61       	ori	r24, 0x10	; 16
    29c2:	8c 93       	st	X, r24
	//CLR Flag
	SET_BIT(TWCR, Pin7);
    29c4:	a6 e5       	ldi	r26, 0x56	; 86
    29c6:	b0 e0       	ldi	r27, 0x00	; 0
    29c8:	e6 e5       	ldi	r30, 0x56	; 86
    29ca:	f0 e0       	ldi	r31, 0x00	; 0
    29cc:	80 81       	ld	r24, Z
    29ce:	80 68       	ori	r24, 0x80	; 128
    29d0:	8c 93       	st	X, r24
}
    29d2:	cf 91       	pop	r28
    29d4:	df 91       	pop	r29
    29d6:	08 95       	ret

000029d8 <MCAL_TWI_Master_SendSlaveAddWithWrite>:

void MCAL_TWI_Master_SendSlaveAddWithWrite(u8 Address) {
    29d8:	df 93       	push	r29
    29da:	cf 93       	push	r28
    29dc:	0f 92       	push	r0
    29de:	cd b7       	in	r28, 0x3d	; 61
    29e0:	de b7       	in	r29, 0x3e	; 62
    29e2:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Address << 1;
    29e4:	e3 e2       	ldi	r30, 0x23	; 35
    29e6:	f0 e0       	ldi	r31, 0x00	; 0
    29e8:	89 81       	ldd	r24, Y+1	; 0x01
    29ea:	88 0f       	add	r24, r24
    29ec:	80 83       	st	Z, r24
	//Write
	CLR_BIT(TWDR, Pin0);
    29ee:	a3 e2       	ldi	r26, 0x23	; 35
    29f0:	b0 e0       	ldi	r27, 0x00	; 0
    29f2:	e3 e2       	ldi	r30, 0x23	; 35
    29f4:	f0 e0       	ldi	r31, 0x00	; 0
    29f6:	80 81       	ld	r24, Z
    29f8:	8e 7f       	andi	r24, 0xFE	; 254
    29fa:	8c 93       	st	X, r24
	//clr start cond
	CLR_BIT(TWCR, Pin5);
    29fc:	a6 e5       	ldi	r26, 0x56	; 86
    29fe:	b0 e0       	ldi	r27, 0x00	; 0
    2a00:	e6 e5       	ldi	r30, 0x56	; 86
    2a02:	f0 e0       	ldi	r31, 0x00	; 0
    2a04:	80 81       	ld	r24, Z
    2a06:	8f 7d       	andi	r24, 0xDF	; 223
    2a08:	8c 93       	st	X, r24
	//clr flage
	SET_BIT(TWCR, Pin7);
    2a0a:	a6 e5       	ldi	r26, 0x56	; 86
    2a0c:	b0 e0       	ldi	r27, 0x00	; 0
    2a0e:	e6 e5       	ldi	r30, 0x56	; 86
    2a10:	f0 e0       	ldi	r31, 0x00	; 0
    2a12:	80 81       	ld	r24, Z
    2a14:	80 68       	ori	r24, 0x80	; 128
    2a16:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    2a18:	e6 e5       	ldi	r30, 0x56	; 86
    2a1a:	f0 e0       	ldi	r31, 0x00	; 0
    2a1c:	80 81       	ld	r24, Z
    2a1e:	88 23       	and	r24, r24
    2a20:	dc f7       	brge	.-10     	; 0x2a18 <MCAL_TWI_Master_SendSlaveAddWithWrite+0x40>
		;
}
    2a22:	0f 90       	pop	r0
    2a24:	cf 91       	pop	r28
    2a26:	df 91       	pop	r29
    2a28:	08 95       	ret

00002a2a <MCAL_TWI_Master_SendSlaveAddWithRead>:
void MCAL_TWI_Master_SendSlaveAddWithRead(u8 Address) {
    2a2a:	df 93       	push	r29
    2a2c:	cf 93       	push	r28
    2a2e:	0f 92       	push	r0
    2a30:	cd b7       	in	r28, 0x3d	; 61
    2a32:	de b7       	in	r29, 0x3e	; 62
    2a34:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Address << 1;
    2a36:	e3 e2       	ldi	r30, 0x23	; 35
    2a38:	f0 e0       	ldi	r31, 0x00	; 0
    2a3a:	89 81       	ldd	r24, Y+1	; 0x01
    2a3c:	88 0f       	add	r24, r24
    2a3e:	80 83       	st	Z, r24
	//Read
	SET_BIT(TWDR, Pin0);
    2a40:	a3 e2       	ldi	r26, 0x23	; 35
    2a42:	b0 e0       	ldi	r27, 0x00	; 0
    2a44:	e3 e2       	ldi	r30, 0x23	; 35
    2a46:	f0 e0       	ldi	r31, 0x00	; 0
    2a48:	80 81       	ld	r24, Z
    2a4a:	81 60       	ori	r24, 0x01	; 1
    2a4c:	8c 93       	st	X, r24
	//clr start cond
	CLR_BIT(TWCR, Pin5);
    2a4e:	a6 e5       	ldi	r26, 0x56	; 86
    2a50:	b0 e0       	ldi	r27, 0x00	; 0
    2a52:	e6 e5       	ldi	r30, 0x56	; 86
    2a54:	f0 e0       	ldi	r31, 0x00	; 0
    2a56:	80 81       	ld	r24, Z
    2a58:	8f 7d       	andi	r24, 0xDF	; 223
    2a5a:	8c 93       	st	X, r24
	//clr flage
	SET_BIT(TWCR, Pin7);
    2a5c:	a6 e5       	ldi	r26, 0x56	; 86
    2a5e:	b0 e0       	ldi	r27, 0x00	; 0
    2a60:	e6 e5       	ldi	r30, 0x56	; 86
    2a62:	f0 e0       	ldi	r31, 0x00	; 0
    2a64:	80 81       	ld	r24, Z
    2a66:	80 68       	ori	r24, 0x80	; 128
    2a68:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    2a6a:	e6 e5       	ldi	r30, 0x56	; 86
    2a6c:	f0 e0       	ldi	r31, 0x00	; 0
    2a6e:	80 81       	ld	r24, Z
    2a70:	88 23       	and	r24, r24
    2a72:	dc f7       	brge	.-10     	; 0x2a6a <MCAL_TWI_Master_SendSlaveAddWithRead+0x40>
		;
}
    2a74:	0f 90       	pop	r0
    2a76:	cf 91       	pop	r28
    2a78:	df 91       	pop	r29
    2a7a:	08 95       	ret

00002a7c <MCAL_TWI_Slave_Init>:

// Slave
void MCAL_TWI_Slave_Init(u8 Slave_Address) {
    2a7c:	df 93       	push	r29
    2a7e:	cf 93       	push	r28
    2a80:	0f 92       	push	r0
    2a82:	cd b7       	in	r28, 0x3d	; 61
    2a84:	de b7       	in	r29, 0x3e	; 62
    2a86:	89 83       	std	Y+1, r24	; 0x01
	//Enable TWI
	SET_BIT(TWCR, Pin2);
    2a88:	a6 e5       	ldi	r26, 0x56	; 86
    2a8a:	b0 e0       	ldi	r27, 0x00	; 0
    2a8c:	e6 e5       	ldi	r30, 0x56	; 86
    2a8e:	f0 e0       	ldi	r31, 0x00	; 0
    2a90:	80 81       	ld	r24, Z
    2a92:	84 60       	ori	r24, 0x04	; 4
    2a94:	8c 93       	st	X, r24
	//Enable ACK
	SET_BIT(TWCR, Pin6);
    2a96:	a6 e5       	ldi	r26, 0x56	; 86
    2a98:	b0 e0       	ldi	r27, 0x00	; 0
    2a9a:	e6 e5       	ldi	r30, 0x56	; 86
    2a9c:	f0 e0       	ldi	r31, 0x00	; 0
    2a9e:	80 81       	ld	r24, Z
    2aa0:	80 64       	ori	r24, 0x40	; 64
    2aa2:	8c 93       	st	X, r24
	//Set Slave Address
	TWAR = Slave_Address << 1;
    2aa4:	e2 e2       	ldi	r30, 0x22	; 34
    2aa6:	f0 e0       	ldi	r31, 0x00	; 0
    2aa8:	89 81       	ldd	r24, Y+1	; 0x01
    2aaa:	88 0f       	add	r24, r24
    2aac:	80 83       	st	Z, r24
	//config general call
	CLR_BIT(TWAR, Pin0);
    2aae:	a2 e2       	ldi	r26, 0x22	; 34
    2ab0:	b0 e0       	ldi	r27, 0x00	; 0
    2ab2:	e2 e2       	ldi	r30, 0x22	; 34
    2ab4:	f0 e0       	ldi	r31, 0x00	; 0
    2ab6:	80 81       	ld	r24, Z
    2ab8:	8e 7f       	andi	r24, 0xFE	; 254
    2aba:	8c 93       	st	X, r24
	//CLr flag
	SET_BIT(TWCR, Pin7);
    2abc:	a6 e5       	ldi	r26, 0x56	; 86
    2abe:	b0 e0       	ldi	r27, 0x00	; 0
    2ac0:	e6 e5       	ldi	r30, 0x56	; 86
    2ac2:	f0 e0       	ldi	r31, 0x00	; 0
    2ac4:	80 81       	ld	r24, Z
    2ac6:	80 68       	ori	r24, 0x80	; 128
    2ac8:	8c 93       	st	X, r24
}
    2aca:	0f 90       	pop	r0
    2acc:	cf 91       	pop	r28
    2ace:	df 91       	pop	r29
    2ad0:	08 95       	ret

00002ad2 <MCAL_TWI_Slave_Listen>:

void MCAL_TWI_Slave_Listen(void) {
    2ad2:	df 93       	push	r29
    2ad4:	cf 93       	push	r28
    2ad6:	cd b7       	in	r28, 0x3d	; 61
    2ad8:	de b7       	in	r29, 0x3e	; 62
	//clr flage
	SET_BIT(TWCR, Pin7);
    2ada:	a6 e5       	ldi	r26, 0x56	; 86
    2adc:	b0 e0       	ldi	r27, 0x00	; 0
    2ade:	e6 e5       	ldi	r30, 0x56	; 86
    2ae0:	f0 e0       	ldi	r31, 0x00	; 0
    2ae2:	80 81       	ld	r24, Z
    2ae4:	80 68       	ori	r24, 0x80	; 128
    2ae6:	8c 93       	st	X, r24

}
    2ae8:	cf 91       	pop	r28
    2aea:	df 91       	pop	r29
    2aec:	08 95       	ret

00002aee <MCAL_TWI_SendData>:

// Common

void MCAL_TWI_SendData(u8 Data) {
    2aee:	df 93       	push	r29
    2af0:	cf 93       	push	r28
    2af2:	0f 92       	push	r0
    2af4:	cd b7       	in	r28, 0x3d	; 61
    2af6:	de b7       	in	r29, 0x3e	; 62
    2af8:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Data;
    2afa:	e3 e2       	ldi	r30, 0x23	; 35
    2afc:	f0 e0       	ldi	r31, 0x00	; 0
    2afe:	89 81       	ldd	r24, Y+1	; 0x01
    2b00:	80 83       	st	Z, r24
	//clr flage
	SET_BIT(TWCR, Pin7);
    2b02:	a6 e5       	ldi	r26, 0x56	; 86
    2b04:	b0 e0       	ldi	r27, 0x00	; 0
    2b06:	e6 e5       	ldi	r30, 0x56	; 86
    2b08:	f0 e0       	ldi	r31, 0x00	; 0
    2b0a:	80 81       	ld	r24, Z
    2b0c:	80 68       	ori	r24, 0x80	; 128
    2b0e:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    2b10:	e6 e5       	ldi	r30, 0x56	; 86
    2b12:	f0 e0       	ldi	r31, 0x00	; 0
    2b14:	80 81       	ld	r24, Z
    2b16:	88 23       	and	r24, r24
    2b18:	dc f7       	brge	.-10     	; 0x2b10 <MCAL_TWI_SendData+0x22>
		;
}
    2b1a:	0f 90       	pop	r0
    2b1c:	cf 91       	pop	r28
    2b1e:	df 91       	pop	r29
    2b20:	08 95       	ret

00002b22 <MCAL_TWI_RecieveData>:
void MCAL_TWI_RecieveData(u8* Data) {
    2b22:	df 93       	push	r29
    2b24:	cf 93       	push	r28
    2b26:	00 d0       	rcall	.+0      	; 0x2b28 <MCAL_TWI_RecieveData+0x6>
    2b28:	cd b7       	in	r28, 0x3d	; 61
    2b2a:	de b7       	in	r29, 0x3e	; 62
    2b2c:	9a 83       	std	Y+2, r25	; 0x02
    2b2e:	89 83       	std	Y+1, r24	; 0x01
	//clr flage
	SET_BIT(TWCR, Pin7);
    2b30:	a6 e5       	ldi	r26, 0x56	; 86
    2b32:	b0 e0       	ldi	r27, 0x00	; 0
    2b34:	e6 e5       	ldi	r30, 0x56	; 86
    2b36:	f0 e0       	ldi	r31, 0x00	; 0
    2b38:	80 81       	ld	r24, Z
    2b3a:	80 68       	ori	r24, 0x80	; 128
    2b3c:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    2b3e:	e6 e5       	ldi	r30, 0x56	; 86
    2b40:	f0 e0       	ldi	r31, 0x00	; 0
    2b42:	80 81       	ld	r24, Z
    2b44:	88 23       	and	r24, r24
    2b46:	dc f7       	brge	.-10     	; 0x2b3e <MCAL_TWI_RecieveData+0x1c>
		;
	*Data = TWDR;
    2b48:	e3 e2       	ldi	r30, 0x23	; 35
    2b4a:	f0 e0       	ldi	r31, 0x00	; 0
    2b4c:	80 81       	ld	r24, Z
    2b4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b50:	fa 81       	ldd	r31, Y+2	; 0x02
    2b52:	80 83       	st	Z, r24
}
    2b54:	0f 90       	pop	r0
    2b56:	0f 90       	pop	r0
    2b58:	cf 91       	pop	r28
    2b5a:	df 91       	pop	r29
    2b5c:	08 95       	ret

00002b5e <MCAL_SPI_SPIInit>:
 */

//Slave
#include "SPI.h"

void MCAL_SPI_SPIInit(void) {
    2b5e:	df 93       	push	r29
    2b60:	cf 93       	push	r28
    2b62:	cd b7       	in	r28, 0x3d	; 61
    2b64:	de b7       	in	r29, 0x3e	; 62
#if SPI_Mode == SPI_Master
	//Master Enable   *
	SET_BIT(SPCR, MSTR_PIN);
    2b66:	ad e2       	ldi	r26, 0x2D	; 45
    2b68:	b0 e0       	ldi	r27, 0x00	; 0
    2b6a:	ed e2       	ldi	r30, 0x2D	; 45
    2b6c:	f0 e0       	ldi	r31, 0x00	; 0
    2b6e:	80 81       	ld	r24, Z
    2b70:	80 61       	ori	r24, 0x10	; 16
    2b72:	8c 93       	st	X, r24

	//MOSI   *
	MCAL_DIO_u8SetPinDirection(PortB, Pin5, Pin_High);
    2b74:	81 e0       	ldi	r24, 0x01	; 1
    2b76:	65 e0       	ldi	r22, 0x05	; 5
    2b78:	41 e0       	ldi	r20, 0x01	; 1
    2b7a:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	//Disable SS  *
	MCAL_DIO_u8SetPinDirection(PortB, Pin4, Pin_High);
    2b7e:	81 e0       	ldi	r24, 0x01	; 1
    2b80:	64 e0       	ldi	r22, 0x04	; 4
    2b82:	41 e0       	ldi	r20, 0x01	; 1
    2b84:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	//SDK  *
	MCAL_DIO_u8SetPinDirection(PortB, Pin7, Pin_High);
    2b88:	81 e0       	ldi	r24, 0x01	; 1
    2b8a:	67 e0       	ldi	r22, 0x07	; 7
    2b8c:	41 e0       	ldi	r20, 0x01	; 1
    2b8e:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>

	//SS Disable *
	MCAL_DIO_u8SetPinValue(PortB, Pin4, Pin_High);
    2b92:	81 e0       	ldi	r24, 0x01	; 1
    2b94:	64 e0       	ldi	r22, 0x04	; 4
    2b96:	41 e0       	ldi	r20, 0x01	; 1
    2b98:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>

	//Prescaler 64 *
	SET_BIT(SPCR, SPR0_PIN);
    2b9c:	ad e2       	ldi	r26, 0x2D	; 45
    2b9e:	b0 e0       	ldi	r27, 0x00	; 0
    2ba0:	ed e2       	ldi	r30, 0x2D	; 45
    2ba2:	f0 e0       	ldi	r31, 0x00	; 0
    2ba4:	80 81       	ld	r24, Z
    2ba6:	81 60       	ori	r24, 0x01	; 1
    2ba8:	8c 93       	st	X, r24
	SET_BIT(SPCR, SPR1_PIN);
    2baa:	ad e2       	ldi	r26, 0x2D	; 45
    2bac:	b0 e0       	ldi	r27, 0x00	; 0
    2bae:	ed e2       	ldi	r30, 0x2D	; 45
    2bb0:	f0 e0       	ldi	r31, 0x00	; 0
    2bb2:	80 81       	ld	r24, Z
    2bb4:	82 60       	ori	r24, 0x02	; 2
    2bb6:	8c 93       	st	X, r24
	//MISO *
	MCAL_DIO_u8SetPinDirection(PortB, Pin6, Pin_High);
#endif

//the LSB of the data word is transmitted first.
	SET_BIT(SPCR, DORD_PIN);
    2bb8:	ad e2       	ldi	r26, 0x2D	; 45
    2bba:	b0 e0       	ldi	r27, 0x00	; 0
    2bbc:	ed e2       	ldi	r30, 0x2D	; 45
    2bbe:	f0 e0       	ldi	r31, 0x00	; 0
    2bc0:	80 81       	ld	r24, Z
    2bc2:	80 62       	ori	r24, 0x20	; 32
    2bc4:	8c 93       	st	X, r24

	//Clock
//	SET_BIT(SPCR, CPOL_PIN);
	SET_BIT(SPCR, CPHA_PIN);
    2bc6:	ad e2       	ldi	r26, 0x2D	; 45
    2bc8:	b0 e0       	ldi	r27, 0x00	; 0
    2bca:	ed e2       	ldi	r30, 0x2D	; 45
    2bcc:	f0 e0       	ldi	r31, 0x00	; 0
    2bce:	80 81       	ld	r24, Z
    2bd0:	84 60       	ori	r24, 0x04	; 4
    2bd2:	8c 93       	st	X, r24

//Enable Interrupt
//	SET_BIT(SPCR, SPIE_PIN);

//SPI Enable
	SET_BIT(SPCR, SPE_PIN);
    2bd4:	ad e2       	ldi	r26, 0x2D	; 45
    2bd6:	b0 e0       	ldi	r27, 0x00	; 0
    2bd8:	ed e2       	ldi	r30, 0x2D	; 45
    2bda:	f0 e0       	ldi	r31, 0x00	; 0
    2bdc:	80 81       	ld	r24, Z
    2bde:	80 64       	ori	r24, 0x40	; 64
    2be0:	8c 93       	st	X, r24
}
    2be2:	cf 91       	pop	r28
    2be4:	df 91       	pop	r29
    2be6:	08 95       	ret

00002be8 <MCAL_SPI_SendString>:

void MCAL_SPI_SendString(u8* Loc_Data) {
    2be8:	df 93       	push	r29
    2bea:	cf 93       	push	r28
    2bec:	00 d0       	rcall	.+0      	; 0x2bee <MCAL_SPI_SendString+0x6>
    2bee:	00 d0       	rcall	.+0      	; 0x2bf0 <MCAL_SPI_SendString+0x8>
    2bf0:	00 d0       	rcall	.+0      	; 0x2bf2 <MCAL_SPI_SendString+0xa>
    2bf2:	cd b7       	in	r28, 0x3d	; 61
    2bf4:	de b7       	in	r29, 0x3e	; 62
    2bf6:	9e 83       	std	Y+6, r25	; 0x06
    2bf8:	8d 83       	std	Y+5, r24	; 0x05
	for (u32 i = 0; Loc_Data[i] != '\0'; i++) {
    2bfa:	19 82       	std	Y+1, r1	; 0x01
    2bfc:	1a 82       	std	Y+2, r1	; 0x02
    2bfe:	1b 82       	std	Y+3, r1	; 0x03
    2c00:	1c 82       	std	Y+4, r1	; 0x04
    2c02:	15 c0       	rjmp	.+42     	; 0x2c2e <MCAL_SPI_SendString+0x46>
		MCAL_SPI_SPITranceive(Loc_Data[i]);
    2c04:	29 81       	ldd	r18, Y+1	; 0x01
    2c06:	3a 81       	ldd	r19, Y+2	; 0x02
    2c08:	8d 81       	ldd	r24, Y+5	; 0x05
    2c0a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c0c:	fc 01       	movw	r30, r24
    2c0e:	e2 0f       	add	r30, r18
    2c10:	f3 1f       	adc	r31, r19
    2c12:	80 81       	ld	r24, Z
    2c14:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <MCAL_SPI_SPITranceive>
//SPI Enable
	SET_BIT(SPCR, SPE_PIN);
}

void MCAL_SPI_SendString(u8* Loc_Data) {
	for (u32 i = 0; Loc_Data[i] != '\0'; i++) {
    2c18:	89 81       	ldd	r24, Y+1	; 0x01
    2c1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c1c:	ab 81       	ldd	r26, Y+3	; 0x03
    2c1e:	bc 81       	ldd	r27, Y+4	; 0x04
    2c20:	01 96       	adiw	r24, 0x01	; 1
    2c22:	a1 1d       	adc	r26, r1
    2c24:	b1 1d       	adc	r27, r1
    2c26:	89 83       	std	Y+1, r24	; 0x01
    2c28:	9a 83       	std	Y+2, r25	; 0x02
    2c2a:	ab 83       	std	Y+3, r26	; 0x03
    2c2c:	bc 83       	std	Y+4, r27	; 0x04
    2c2e:	29 81       	ldd	r18, Y+1	; 0x01
    2c30:	3a 81       	ldd	r19, Y+2	; 0x02
    2c32:	8d 81       	ldd	r24, Y+5	; 0x05
    2c34:	9e 81       	ldd	r25, Y+6	; 0x06
    2c36:	fc 01       	movw	r30, r24
    2c38:	e2 0f       	add	r30, r18
    2c3a:	f3 1f       	adc	r31, r19
    2c3c:	80 81       	ld	r24, Z
    2c3e:	88 23       	and	r24, r24
    2c40:	09 f7       	brne	.-62     	; 0x2c04 <MCAL_SPI_SendString+0x1c>
		MCAL_SPI_SPITranceive(Loc_Data[i]);
	}
}
    2c42:	26 96       	adiw	r28, 0x06	; 6
    2c44:	0f b6       	in	r0, 0x3f	; 63
    2c46:	f8 94       	cli
    2c48:	de bf       	out	0x3e, r29	; 62
    2c4a:	0f be       	out	0x3f, r0	; 63
    2c4c:	cd bf       	out	0x3d, r28	; 61
    2c4e:	cf 91       	pop	r28
    2c50:	df 91       	pop	r29
    2c52:	08 95       	ret

00002c54 <MCAL_SPI_RecieveString>:

void MCAL_SPI_RecieveString(u8* Loc_Data) {
    2c54:	0f 93       	push	r16
    2c56:	1f 93       	push	r17
    2c58:	df 93       	push	r29
    2c5a:	cf 93       	push	r28
    2c5c:	00 d0       	rcall	.+0      	; 0x2c5e <MCAL_SPI_RecieveString+0xa>
    2c5e:	00 d0       	rcall	.+0      	; 0x2c60 <MCAL_SPI_RecieveString+0xc>
    2c60:	00 d0       	rcall	.+0      	; 0x2c62 <MCAL_SPI_RecieveString+0xe>
    2c62:	cd b7       	in	r28, 0x3d	; 61
    2c64:	de b7       	in	r29, 0x3e	; 62
    2c66:	9e 83       	std	Y+6, r25	; 0x06
    2c68:	8d 83       	std	Y+5, r24	; 0x05
	for (u32 i = 0; Loc_Data[i] != '\0'; i++) {
    2c6a:	19 82       	std	Y+1, r1	; 0x01
    2c6c:	1a 82       	std	Y+2, r1	; 0x02
    2c6e:	1b 82       	std	Y+3, r1	; 0x03
    2c70:	1c 82       	std	Y+4, r1	; 0x04
    2c72:	17 c0       	rjmp	.+46     	; 0x2ca2 <MCAL_SPI_RecieveString+0x4e>
		Loc_Data[i] = MCAL_SPI_SPITranceive(0xff);
    2c74:	29 81       	ldd	r18, Y+1	; 0x01
    2c76:	3a 81       	ldd	r19, Y+2	; 0x02
    2c78:	8d 81       	ldd	r24, Y+5	; 0x05
    2c7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c7c:	8c 01       	movw	r16, r24
    2c7e:	02 0f       	add	r16, r18
    2c80:	13 1f       	adc	r17, r19
    2c82:	8f ef       	ldi	r24, 0xFF	; 255
    2c84:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <MCAL_SPI_SPITranceive>
    2c88:	f8 01       	movw	r30, r16
    2c8a:	80 83       	st	Z, r24
		MCAL_SPI_SPITranceive(Loc_Data[i]);
	}
}

void MCAL_SPI_RecieveString(u8* Loc_Data) {
	for (u32 i = 0; Loc_Data[i] != '\0'; i++) {
    2c8c:	89 81       	ldd	r24, Y+1	; 0x01
    2c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c90:	ab 81       	ldd	r26, Y+3	; 0x03
    2c92:	bc 81       	ldd	r27, Y+4	; 0x04
    2c94:	01 96       	adiw	r24, 0x01	; 1
    2c96:	a1 1d       	adc	r26, r1
    2c98:	b1 1d       	adc	r27, r1
    2c9a:	89 83       	std	Y+1, r24	; 0x01
    2c9c:	9a 83       	std	Y+2, r25	; 0x02
    2c9e:	ab 83       	std	Y+3, r26	; 0x03
    2ca0:	bc 83       	std	Y+4, r27	; 0x04
    2ca2:	29 81       	ldd	r18, Y+1	; 0x01
    2ca4:	3a 81       	ldd	r19, Y+2	; 0x02
    2ca6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ca8:	9e 81       	ldd	r25, Y+6	; 0x06
    2caa:	fc 01       	movw	r30, r24
    2cac:	e2 0f       	add	r30, r18
    2cae:	f3 1f       	adc	r31, r19
    2cb0:	80 81       	ld	r24, Z
    2cb2:	88 23       	and	r24, r24
    2cb4:	f9 f6       	brne	.-66     	; 0x2c74 <MCAL_SPI_RecieveString+0x20>
		Loc_Data[i] = MCAL_SPI_SPITranceive(0xff);
	}
}
    2cb6:	26 96       	adiw	r28, 0x06	; 6
    2cb8:	0f b6       	in	r0, 0x3f	; 63
    2cba:	f8 94       	cli
    2cbc:	de bf       	out	0x3e, r29	; 62
    2cbe:	0f be       	out	0x3f, r0	; 63
    2cc0:	cd bf       	out	0x3d, r28	; 61
    2cc2:	cf 91       	pop	r28
    2cc4:	df 91       	pop	r29
    2cc6:	1f 91       	pop	r17
    2cc8:	0f 91       	pop	r16
    2cca:	08 95       	ret

00002ccc <MCAL_SPI_SPITranceive>:

u8 MCAL_SPI_SPITranceive(u8 Loc_u8Data) {
    2ccc:	df 93       	push	r29
    2cce:	cf 93       	push	r28
    2cd0:	0f 92       	push	r0
    2cd2:	cd b7       	in	r28, 0x3d	; 61
    2cd4:	de b7       	in	r29, 0x3e	; 62
    2cd6:	89 83       	std	Y+1, r24	; 0x01
	SPDR = Loc_u8Data;
    2cd8:	ef e2       	ldi	r30, 0x2F	; 47
    2cda:	f0 e0       	ldi	r31, 0x00	; 0
    2cdc:	89 81       	ldd	r24, Y+1	; 0x01
    2cde:	80 83       	st	Z, r24
	while (GET_BIT(SPSR,SPIF_PIN) == 0)
    2ce0:	ee e2       	ldi	r30, 0x2E	; 46
    2ce2:	f0 e0       	ldi	r31, 0x00	; 0
    2ce4:	80 81       	ld	r24, Z
    2ce6:	88 23       	and	r24, r24
    2ce8:	dc f7       	brge	.-10     	; 0x2ce0 <MCAL_SPI_SPITranceive+0x14>
		;
	return SPDR;
    2cea:	ef e2       	ldi	r30, 0x2F	; 47
    2cec:	f0 e0       	ldi	r31, 0x00	; 0
    2cee:	80 81       	ld	r24, Z
}
    2cf0:	0f 90       	pop	r0
    2cf2:	cf 91       	pop	r28
    2cf4:	df 91       	pop	r29
    2cf6:	08 95       	ret

00002cf8 <MCAL_Interrupt_u8SetRegister>:

void (*Gptr0)(void)= '\0' ;
void (*Gptr1)(void)= '\0' ;
void (*Gptr2)(void)= '\0' ;

void MCAL_Interrupt_u8SetRegister(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    2cf8:	df 93       	push	r29
    2cfa:	cf 93       	push	r28
    2cfc:	00 d0       	rcall	.+0      	; 0x2cfe <MCAL_Interrupt_u8SetRegister+0x6>
    2cfe:	cd b7       	in	r28, 0x3d	; 61
    2d00:	de b7       	in	r29, 0x3e	; 62
    2d02:	89 83       	std	Y+1, r24	; 0x01
    2d04:	6a 83       	std	Y+2, r22	; 0x02
	if (Loc_u8PortValue == PORT_OUTPUT) {
    2d06:	8a 81       	ldd	r24, Y+2	; 0x02
    2d08:	8f 3f       	cpi	r24, 0xFF	; 255
    2d0a:	09 f5       	brne	.+66     	; 0x2d4e <MCAL_Interrupt_u8SetRegister+0x56>
		if (Loc_u8PortID == Sreg) {
    2d0c:	89 81       	ldd	r24, Y+1	; 0x01
    2d0e:	88 23       	and	r24, r24
    2d10:	29 f4       	brne	.+10     	; 0x2d1c <MCAL_Interrupt_u8SetRegister+0x24>
			SREG = PORT_OUTPUT;
    2d12:	ef e5       	ldi	r30, 0x5F	; 95
    2d14:	f0 e0       	ldi	r31, 0x00	; 0
    2d16:	8f ef       	ldi	r24, 0xFF	; 255
    2d18:	80 83       	st	Z, r24
    2d1a:	57 c0       	rjmp	.+174    	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    2d1c:	89 81       	ldd	r24, Y+1	; 0x01
    2d1e:	81 30       	cpi	r24, 0x01	; 1
    2d20:	29 f4       	brne	.+10     	; 0x2d2c <MCAL_Interrupt_u8SetRegister+0x34>
			GICR = PORT_OUTPUT;
    2d22:	eb e5       	ldi	r30, 0x5B	; 91
    2d24:	f0 e0       	ldi	r31, 0x00	; 0
    2d26:	8f ef       	ldi	r24, 0xFF	; 255
    2d28:	80 83       	st	Z, r24
    2d2a:	4f c0       	rjmp	.+158    	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    2d2c:	89 81       	ldd	r24, Y+1	; 0x01
    2d2e:	82 30       	cpi	r24, 0x02	; 2
    2d30:	29 f4       	brne	.+10     	; 0x2d3c <MCAL_Interrupt_u8SetRegister+0x44>
			MCUCR = PORT_OUTPUT;
    2d32:	e5 e5       	ldi	r30, 0x55	; 85
    2d34:	f0 e0       	ldi	r31, 0x00	; 0
    2d36:	8f ef       	ldi	r24, 0xFF	; 255
    2d38:	80 83       	st	Z, r24
    2d3a:	47 c0       	rjmp	.+142    	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    2d3c:	89 81       	ldd	r24, Y+1	; 0x01
    2d3e:	83 30       	cpi	r24, 0x03	; 3
    2d40:	09 f0       	breq	.+2      	; 0x2d44 <MCAL_Interrupt_u8SetRegister+0x4c>
    2d42:	43 c0       	rjmp	.+134    	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = PORT_OUTPUT;
    2d44:	e4 e5       	ldi	r30, 0x54	; 84
    2d46:	f0 e0       	ldi	r31, 0x00	; 0
    2d48:	8f ef       	ldi	r24, 0xFF	; 255
    2d4a:	80 83       	st	Z, r24
    2d4c:	3e c0       	rjmp	.+124    	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PortValue == PORT_INPUT) {
    2d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d50:	88 23       	and	r24, r24
    2d52:	e1 f4       	brne	.+56     	; 0x2d8c <MCAL_Interrupt_u8SetRegister+0x94>
		if (Loc_u8PortID == Sreg) {
    2d54:	89 81       	ldd	r24, Y+1	; 0x01
    2d56:	88 23       	and	r24, r24
    2d58:	21 f4       	brne	.+8      	; 0x2d62 <MCAL_Interrupt_u8SetRegister+0x6a>
			SREG = PORT_INPUT;
    2d5a:	ef e5       	ldi	r30, 0x5F	; 95
    2d5c:	f0 e0       	ldi	r31, 0x00	; 0
    2d5e:	10 82       	st	Z, r1
    2d60:	34 c0       	rjmp	.+104    	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    2d62:	89 81       	ldd	r24, Y+1	; 0x01
    2d64:	81 30       	cpi	r24, 0x01	; 1
    2d66:	21 f4       	brne	.+8      	; 0x2d70 <MCAL_Interrupt_u8SetRegister+0x78>
			GICR = PORT_INPUT;
    2d68:	eb e5       	ldi	r30, 0x5B	; 91
    2d6a:	f0 e0       	ldi	r31, 0x00	; 0
    2d6c:	10 82       	st	Z, r1
    2d6e:	2d c0       	rjmp	.+90     	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    2d70:	89 81       	ldd	r24, Y+1	; 0x01
    2d72:	82 30       	cpi	r24, 0x02	; 2
    2d74:	21 f4       	brne	.+8      	; 0x2d7e <MCAL_Interrupt_u8SetRegister+0x86>
			MCUCR = PORT_INPUT;
    2d76:	e5 e5       	ldi	r30, 0x55	; 85
    2d78:	f0 e0       	ldi	r31, 0x00	; 0
    2d7a:	10 82       	st	Z, r1
    2d7c:	26 c0       	rjmp	.+76     	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    2d7e:	89 81       	ldd	r24, Y+1	; 0x01
    2d80:	83 30       	cpi	r24, 0x03	; 3
    2d82:	19 f5       	brne	.+70     	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = PORT_INPUT;
    2d84:	e4 e5       	ldi	r30, 0x54	; 84
    2d86:	f0 e0       	ldi	r31, 0x00	; 0
    2d88:	10 82       	st	Z, r1
    2d8a:	1f c0       	rjmp	.+62     	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else {
			//Do Nothing
		}
	} else {
		if (Loc_u8PortID == Sreg) {
    2d8c:	89 81       	ldd	r24, Y+1	; 0x01
    2d8e:	88 23       	and	r24, r24
    2d90:	29 f4       	brne	.+10     	; 0x2d9c <MCAL_Interrupt_u8SetRegister+0xa4>
			SREG = Loc_u8PortValue;
    2d92:	ef e5       	ldi	r30, 0x5F	; 95
    2d94:	f0 e0       	ldi	r31, 0x00	; 0
    2d96:	8a 81       	ldd	r24, Y+2	; 0x02
    2d98:	80 83       	st	Z, r24
    2d9a:	17 c0       	rjmp	.+46     	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    2d9c:	89 81       	ldd	r24, Y+1	; 0x01
    2d9e:	81 30       	cpi	r24, 0x01	; 1
    2da0:	29 f4       	brne	.+10     	; 0x2dac <MCAL_Interrupt_u8SetRegister+0xb4>
			GICR = Loc_u8PortValue;
    2da2:	eb e5       	ldi	r30, 0x5B	; 91
    2da4:	f0 e0       	ldi	r31, 0x00	; 0
    2da6:	8a 81       	ldd	r24, Y+2	; 0x02
    2da8:	80 83       	st	Z, r24
    2daa:	0f c0       	rjmp	.+30     	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    2dac:	89 81       	ldd	r24, Y+1	; 0x01
    2dae:	82 30       	cpi	r24, 0x02	; 2
    2db0:	29 f4       	brne	.+10     	; 0x2dbc <MCAL_Interrupt_u8SetRegister+0xc4>
			MCUCR = Loc_u8PortValue;
    2db2:	e5 e5       	ldi	r30, 0x55	; 85
    2db4:	f0 e0       	ldi	r31, 0x00	; 0
    2db6:	8a 81       	ldd	r24, Y+2	; 0x02
    2db8:	80 83       	st	Z, r24
    2dba:	07 c0       	rjmp	.+14     	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    2dbc:	89 81       	ldd	r24, Y+1	; 0x01
    2dbe:	83 30       	cpi	r24, 0x03	; 3
    2dc0:	21 f4       	brne	.+8      	; 0x2dca <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = Loc_u8PortValue;
    2dc2:	e4 e5       	ldi	r30, 0x54	; 84
    2dc4:	f0 e0       	ldi	r31, 0x00	; 0
    2dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    2dc8:	80 83       	st	Z, r24
		}
	}
}
    2dca:	0f 90       	pop	r0
    2dcc:	0f 90       	pop	r0
    2dce:	cf 91       	pop	r28
    2dd0:	df 91       	pop	r29
    2dd2:	08 95       	ret

00002dd4 <MCAL_Interrupt_u8SetRegisterPin>:

void MCAL_Interrupt_u8SetRegisterPin(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    2dd4:	df 93       	push	r29
    2dd6:	cf 93       	push	r28
    2dd8:	00 d0       	rcall	.+0      	; 0x2dda <MCAL_Interrupt_u8SetRegisterPin+0x6>
    2dda:	0f 92       	push	r0
    2ddc:	cd b7       	in	r28, 0x3d	; 61
    2dde:	de b7       	in	r29, 0x3e	; 62
    2de0:	89 83       	std	Y+1, r24	; 0x01
    2de2:	6a 83       	std	Y+2, r22	; 0x02
    2de4:	4b 83       	std	Y+3, r20	; 0x03
	if (Loc_u8PinValue == Pin_High) {
    2de6:	8b 81       	ldd	r24, Y+3	; 0x03
    2de8:	81 30       	cpi	r24, 0x01	; 1
    2dea:	09 f0       	breq	.+2      	; 0x2dee <MCAL_Interrupt_u8SetRegisterPin+0x1a>
    2dec:	5d c0       	rjmp	.+186    	; 0x2ea8 <MCAL_Interrupt_u8SetRegisterPin+0xd4>
		if (Loc_u8PortID == Sreg) {
    2dee:	89 81       	ldd	r24, Y+1	; 0x01
    2df0:	88 23       	and	r24, r24
    2df2:	a1 f4       	brne	.+40     	; 0x2e1c <MCAL_Interrupt_u8SetRegisterPin+0x48>
			SET_BIT(SREG, Loc_u8PinID);
    2df4:	af e5       	ldi	r26, 0x5F	; 95
    2df6:	b0 e0       	ldi	r27, 0x00	; 0
    2df8:	ef e5       	ldi	r30, 0x5F	; 95
    2dfa:	f0 e0       	ldi	r31, 0x00	; 0
    2dfc:	80 81       	ld	r24, Z
    2dfe:	48 2f       	mov	r20, r24
    2e00:	8a 81       	ldd	r24, Y+2	; 0x02
    2e02:	28 2f       	mov	r18, r24
    2e04:	30 e0       	ldi	r19, 0x00	; 0
    2e06:	81 e0       	ldi	r24, 0x01	; 1
    2e08:	90 e0       	ldi	r25, 0x00	; 0
    2e0a:	02 2e       	mov	r0, r18
    2e0c:	02 c0       	rjmp	.+4      	; 0x2e12 <MCAL_Interrupt_u8SetRegisterPin+0x3e>
    2e0e:	88 0f       	add	r24, r24
    2e10:	99 1f       	adc	r25, r25
    2e12:	0a 94       	dec	r0
    2e14:	e2 f7       	brpl	.-8      	; 0x2e0e <MCAL_Interrupt_u8SetRegisterPin+0x3a>
    2e16:	84 2b       	or	r24, r20
    2e18:	8c 93       	st	X, r24
    2e1a:	a9 c0       	rjmp	.+338    	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Gicr) {
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	81 30       	cpi	r24, 0x01	; 1
    2e20:	a1 f4       	brne	.+40     	; 0x2e4a <MCAL_Interrupt_u8SetRegisterPin+0x76>
			SET_BIT(GICR, Loc_u8PinID);
    2e22:	ab e5       	ldi	r26, 0x5B	; 91
    2e24:	b0 e0       	ldi	r27, 0x00	; 0
    2e26:	eb e5       	ldi	r30, 0x5B	; 91
    2e28:	f0 e0       	ldi	r31, 0x00	; 0
    2e2a:	80 81       	ld	r24, Z
    2e2c:	48 2f       	mov	r20, r24
    2e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e30:	28 2f       	mov	r18, r24
    2e32:	30 e0       	ldi	r19, 0x00	; 0
    2e34:	81 e0       	ldi	r24, 0x01	; 1
    2e36:	90 e0       	ldi	r25, 0x00	; 0
    2e38:	02 2e       	mov	r0, r18
    2e3a:	02 c0       	rjmp	.+4      	; 0x2e40 <MCAL_Interrupt_u8SetRegisterPin+0x6c>
    2e3c:	88 0f       	add	r24, r24
    2e3e:	99 1f       	adc	r25, r25
    2e40:	0a 94       	dec	r0
    2e42:	e2 f7       	brpl	.-8      	; 0x2e3c <MCAL_Interrupt_u8SetRegisterPin+0x68>
    2e44:	84 2b       	or	r24, r20
    2e46:	8c 93       	st	X, r24
    2e48:	92 c0       	rjmp	.+292    	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucr) {
    2e4a:	89 81       	ldd	r24, Y+1	; 0x01
    2e4c:	82 30       	cpi	r24, 0x02	; 2
    2e4e:	a1 f4       	brne	.+40     	; 0x2e78 <MCAL_Interrupt_u8SetRegisterPin+0xa4>
			SET_BIT(MCUCR, Loc_u8PinID);
    2e50:	a5 e5       	ldi	r26, 0x55	; 85
    2e52:	b0 e0       	ldi	r27, 0x00	; 0
    2e54:	e5 e5       	ldi	r30, 0x55	; 85
    2e56:	f0 e0       	ldi	r31, 0x00	; 0
    2e58:	80 81       	ld	r24, Z
    2e5a:	48 2f       	mov	r20, r24
    2e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e5e:	28 2f       	mov	r18, r24
    2e60:	30 e0       	ldi	r19, 0x00	; 0
    2e62:	81 e0       	ldi	r24, 0x01	; 1
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	02 2e       	mov	r0, r18
    2e68:	02 c0       	rjmp	.+4      	; 0x2e6e <MCAL_Interrupt_u8SetRegisterPin+0x9a>
    2e6a:	88 0f       	add	r24, r24
    2e6c:	99 1f       	adc	r25, r25
    2e6e:	0a 94       	dec	r0
    2e70:	e2 f7       	brpl	.-8      	; 0x2e6a <MCAL_Interrupt_u8SetRegisterPin+0x96>
    2e72:	84 2b       	or	r24, r20
    2e74:	8c 93       	st	X, r24
    2e76:	7b c0       	rjmp	.+246    	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucsr) {
    2e78:	89 81       	ldd	r24, Y+1	; 0x01
    2e7a:	83 30       	cpi	r24, 0x03	; 3
    2e7c:	09 f0       	breq	.+2      	; 0x2e80 <MCAL_Interrupt_u8SetRegisterPin+0xac>
    2e7e:	77 c0       	rjmp	.+238    	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
			SET_BIT(MCUCSR, Loc_u8PinID);
    2e80:	a4 e5       	ldi	r26, 0x54	; 84
    2e82:	b0 e0       	ldi	r27, 0x00	; 0
    2e84:	e4 e5       	ldi	r30, 0x54	; 84
    2e86:	f0 e0       	ldi	r31, 0x00	; 0
    2e88:	80 81       	ld	r24, Z
    2e8a:	48 2f       	mov	r20, r24
    2e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e8e:	28 2f       	mov	r18, r24
    2e90:	30 e0       	ldi	r19, 0x00	; 0
    2e92:	81 e0       	ldi	r24, 0x01	; 1
    2e94:	90 e0       	ldi	r25, 0x00	; 0
    2e96:	02 2e       	mov	r0, r18
    2e98:	02 c0       	rjmp	.+4      	; 0x2e9e <MCAL_Interrupt_u8SetRegisterPin+0xca>
    2e9a:	88 0f       	add	r24, r24
    2e9c:	99 1f       	adc	r25, r25
    2e9e:	0a 94       	dec	r0
    2ea0:	e2 f7       	brpl	.-8      	; 0x2e9a <MCAL_Interrupt_u8SetRegisterPin+0xc6>
    2ea2:	84 2b       	or	r24, r20
    2ea4:	8c 93       	st	X, r24
    2ea6:	63 c0       	rjmp	.+198    	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PinValue == Pin_Low) {
    2ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eaa:	88 23       	and	r24, r24
    2eac:	09 f0       	breq	.+2      	; 0x2eb0 <MCAL_Interrupt_u8SetRegisterPin+0xdc>
    2eae:	5f c0       	rjmp	.+190    	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		if (Loc_u8PortID == Sreg) {
    2eb0:	89 81       	ldd	r24, Y+1	; 0x01
    2eb2:	88 23       	and	r24, r24
    2eb4:	a9 f4       	brne	.+42     	; 0x2ee0 <MCAL_Interrupt_u8SetRegisterPin+0x10c>
			CLR_BIT(SREG, Loc_u8PinID);
    2eb6:	af e5       	ldi	r26, 0x5F	; 95
    2eb8:	b0 e0       	ldi	r27, 0x00	; 0
    2eba:	ef e5       	ldi	r30, 0x5F	; 95
    2ebc:	f0 e0       	ldi	r31, 0x00	; 0
    2ebe:	80 81       	ld	r24, Z
    2ec0:	48 2f       	mov	r20, r24
    2ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec4:	28 2f       	mov	r18, r24
    2ec6:	30 e0       	ldi	r19, 0x00	; 0
    2ec8:	81 e0       	ldi	r24, 0x01	; 1
    2eca:	90 e0       	ldi	r25, 0x00	; 0
    2ecc:	02 2e       	mov	r0, r18
    2ece:	02 c0       	rjmp	.+4      	; 0x2ed4 <MCAL_Interrupt_u8SetRegisterPin+0x100>
    2ed0:	88 0f       	add	r24, r24
    2ed2:	99 1f       	adc	r25, r25
    2ed4:	0a 94       	dec	r0
    2ed6:	e2 f7       	brpl	.-8      	; 0x2ed0 <MCAL_Interrupt_u8SetRegisterPin+0xfc>
    2ed8:	80 95       	com	r24
    2eda:	84 23       	and	r24, r20
    2edc:	8c 93       	st	X, r24
    2ede:	47 c0       	rjmp	.+142    	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Gicr) {
    2ee0:	89 81       	ldd	r24, Y+1	; 0x01
    2ee2:	81 30       	cpi	r24, 0x01	; 1
    2ee4:	a9 f4       	brne	.+42     	; 0x2f10 <MCAL_Interrupt_u8SetRegisterPin+0x13c>
			CLR_BIT(GICR, Loc_u8PinID);
    2ee6:	ab e5       	ldi	r26, 0x5B	; 91
    2ee8:	b0 e0       	ldi	r27, 0x00	; 0
    2eea:	eb e5       	ldi	r30, 0x5B	; 91
    2eec:	f0 e0       	ldi	r31, 0x00	; 0
    2eee:	80 81       	ld	r24, Z
    2ef0:	48 2f       	mov	r20, r24
    2ef2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ef4:	28 2f       	mov	r18, r24
    2ef6:	30 e0       	ldi	r19, 0x00	; 0
    2ef8:	81 e0       	ldi	r24, 0x01	; 1
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	02 2e       	mov	r0, r18
    2efe:	02 c0       	rjmp	.+4      	; 0x2f04 <MCAL_Interrupt_u8SetRegisterPin+0x130>
    2f00:	88 0f       	add	r24, r24
    2f02:	99 1f       	adc	r25, r25
    2f04:	0a 94       	dec	r0
    2f06:	e2 f7       	brpl	.-8      	; 0x2f00 <MCAL_Interrupt_u8SetRegisterPin+0x12c>
    2f08:	80 95       	com	r24
    2f0a:	84 23       	and	r24, r20
    2f0c:	8c 93       	st	X, r24
    2f0e:	2f c0       	rjmp	.+94     	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucr) {
    2f10:	89 81       	ldd	r24, Y+1	; 0x01
    2f12:	82 30       	cpi	r24, 0x02	; 2
    2f14:	a9 f4       	brne	.+42     	; 0x2f40 <MCAL_Interrupt_u8SetRegisterPin+0x16c>
			CLR_BIT(MCUCR, Loc_u8PinID);
    2f16:	a5 e5       	ldi	r26, 0x55	; 85
    2f18:	b0 e0       	ldi	r27, 0x00	; 0
    2f1a:	e5 e5       	ldi	r30, 0x55	; 85
    2f1c:	f0 e0       	ldi	r31, 0x00	; 0
    2f1e:	80 81       	ld	r24, Z
    2f20:	48 2f       	mov	r20, r24
    2f22:	8a 81       	ldd	r24, Y+2	; 0x02
    2f24:	28 2f       	mov	r18, r24
    2f26:	30 e0       	ldi	r19, 0x00	; 0
    2f28:	81 e0       	ldi	r24, 0x01	; 1
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	02 2e       	mov	r0, r18
    2f2e:	02 c0       	rjmp	.+4      	; 0x2f34 <MCAL_Interrupt_u8SetRegisterPin+0x160>
    2f30:	88 0f       	add	r24, r24
    2f32:	99 1f       	adc	r25, r25
    2f34:	0a 94       	dec	r0
    2f36:	e2 f7       	brpl	.-8      	; 0x2f30 <MCAL_Interrupt_u8SetRegisterPin+0x15c>
    2f38:	80 95       	com	r24
    2f3a:	84 23       	and	r24, r20
    2f3c:	8c 93       	st	X, r24
    2f3e:	17 c0       	rjmp	.+46     	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucsr) {
    2f40:	89 81       	ldd	r24, Y+1	; 0x01
    2f42:	83 30       	cpi	r24, 0x03	; 3
    2f44:	a1 f4       	brne	.+40     	; 0x2f6e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
			CLR_BIT(MCUCSR, Loc_u8PinID);
    2f46:	a4 e5       	ldi	r26, 0x54	; 84
    2f48:	b0 e0       	ldi	r27, 0x00	; 0
    2f4a:	e4 e5       	ldi	r30, 0x54	; 84
    2f4c:	f0 e0       	ldi	r31, 0x00	; 0
    2f4e:	80 81       	ld	r24, Z
    2f50:	48 2f       	mov	r20, r24
    2f52:	8a 81       	ldd	r24, Y+2	; 0x02
    2f54:	28 2f       	mov	r18, r24
    2f56:	30 e0       	ldi	r19, 0x00	; 0
    2f58:	81 e0       	ldi	r24, 0x01	; 1
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	02 2e       	mov	r0, r18
    2f5e:	02 c0       	rjmp	.+4      	; 0x2f64 <MCAL_Interrupt_u8SetRegisterPin+0x190>
    2f60:	88 0f       	add	r24, r24
    2f62:	99 1f       	adc	r25, r25
    2f64:	0a 94       	dec	r0
    2f66:	e2 f7       	brpl	.-8      	; 0x2f60 <MCAL_Interrupt_u8SetRegisterPin+0x18c>
    2f68:	80 95       	com	r24
    2f6a:	84 23       	and	r24, r20
    2f6c:	8c 93       	st	X, r24
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
}
    2f6e:	0f 90       	pop	r0
    2f70:	0f 90       	pop	r0
    2f72:	0f 90       	pop	r0
    2f74:	cf 91       	pop	r28
    2f76:	df 91       	pop	r29
    2f78:	08 95       	ret

00002f7a <MCAL_Interrupt_EXIT_CallBack_0>:

void MCAL_Interrupt_EXIT_CallBack_0(void (*ptr)(void)) {
    2f7a:	df 93       	push	r29
    2f7c:	cf 93       	push	r28
    2f7e:	00 d0       	rcall	.+0      	; 0x2f80 <MCAL_Interrupt_EXIT_CallBack_0+0x6>
    2f80:	cd b7       	in	r28, 0x3d	; 61
    2f82:	de b7       	in	r29, 0x3e	; 62
    2f84:	9a 83       	std	Y+2, r25	; 0x02
    2f86:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2f88:	89 81       	ldd	r24, Y+1	; 0x01
    2f8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f8c:	00 97       	sbiw	r24, 0x00	; 0
    2f8e:	31 f0       	breq	.+12     	; 0x2f9c <MCAL_Interrupt_EXIT_CallBack_0+0x22>
		Gptr0 = ptr;
    2f90:	89 81       	ldd	r24, Y+1	; 0x01
    2f92:	9a 81       	ldd	r25, Y+2	; 0x02
    2f94:	90 93 90 01 	sts	0x0190, r25
    2f98:	80 93 8f 01 	sts	0x018F, r24
}
    2f9c:	0f 90       	pop	r0
    2f9e:	0f 90       	pop	r0
    2fa0:	cf 91       	pop	r28
    2fa2:	df 91       	pop	r29
    2fa4:	08 95       	ret

00002fa6 <MCAL_Interrupt_EXIT_CallBack_1>:
void MCAL_Interrupt_EXIT_CallBack_1(void (*ptr)(void)) {
    2fa6:	df 93       	push	r29
    2fa8:	cf 93       	push	r28
    2faa:	00 d0       	rcall	.+0      	; 0x2fac <MCAL_Interrupt_EXIT_CallBack_1+0x6>
    2fac:	cd b7       	in	r28, 0x3d	; 61
    2fae:	de b7       	in	r29, 0x3e	; 62
    2fb0:	9a 83       	std	Y+2, r25	; 0x02
    2fb2:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2fb4:	89 81       	ldd	r24, Y+1	; 0x01
    2fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb8:	00 97       	sbiw	r24, 0x00	; 0
    2fba:	31 f0       	breq	.+12     	; 0x2fc8 <MCAL_Interrupt_EXIT_CallBack_1+0x22>
		Gptr1 = ptr;
    2fbc:	89 81       	ldd	r24, Y+1	; 0x01
    2fbe:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc0:	90 93 92 01 	sts	0x0192, r25
    2fc4:	80 93 91 01 	sts	0x0191, r24
}
    2fc8:	0f 90       	pop	r0
    2fca:	0f 90       	pop	r0
    2fcc:	cf 91       	pop	r28
    2fce:	df 91       	pop	r29
    2fd0:	08 95       	ret

00002fd2 <MCAL_Interrupt_EXIT_CallBack_2>:
void MCAL_Interrupt_EXIT_CallBack_2(void (*ptr)(void)) {
    2fd2:	df 93       	push	r29
    2fd4:	cf 93       	push	r28
    2fd6:	00 d0       	rcall	.+0      	; 0x2fd8 <MCAL_Interrupt_EXIT_CallBack_2+0x6>
    2fd8:	cd b7       	in	r28, 0x3d	; 61
    2fda:	de b7       	in	r29, 0x3e	; 62
    2fdc:	9a 83       	std	Y+2, r25	; 0x02
    2fde:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2fe0:	89 81       	ldd	r24, Y+1	; 0x01
    2fe2:	9a 81       	ldd	r25, Y+2	; 0x02
    2fe4:	00 97       	sbiw	r24, 0x00	; 0
    2fe6:	31 f0       	breq	.+12     	; 0x2ff4 <MCAL_Interrupt_EXIT_CallBack_2+0x22>
		Gptr2 = ptr;
    2fe8:	89 81       	ldd	r24, Y+1	; 0x01
    2fea:	9a 81       	ldd	r25, Y+2	; 0x02
    2fec:	90 93 94 01 	sts	0x0194, r25
    2ff0:	80 93 93 01 	sts	0x0193, r24
}
    2ff4:	0f 90       	pop	r0
    2ff6:	0f 90       	pop	r0
    2ff8:	cf 91       	pop	r28
    2ffa:	df 91       	pop	r29
    2ffc:	08 95       	ret

00002ffe <MCAL_Interrupt_EnableGIE>:

void MCAL_Interrupt_EnableGIE(u8 Loc_u8value) {
    2ffe:	df 93       	push	r29
    3000:	cf 93       	push	r28
    3002:	0f 92       	push	r0
    3004:	cd b7       	in	r28, 0x3d	; 61
    3006:	de b7       	in	r29, 0x3e	; 62
    3008:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8value == Enable) {
    300a:	89 81       	ldd	r24, Y+1	; 0x01
    300c:	81 30       	cpi	r24, 0x01	; 1
    300e:	31 f4       	brne	.+12     	; 0x301c <MCAL_Interrupt_EnableGIE+0x1e>
		MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_High);
    3010:	80 e0       	ldi	r24, 0x00	; 0
    3012:	67 e0       	ldi	r22, 0x07	; 7
    3014:	41 e0       	ldi	r20, 0x01	; 1
    3016:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <MCAL_Interrupt_u8SetRegisterPin>
    301a:	08 c0       	rjmp	.+16     	; 0x302c <MCAL_Interrupt_EnableGIE+0x2e>
	} else if (Loc_u8value == Disable) {
    301c:	89 81       	ldd	r24, Y+1	; 0x01
    301e:	88 23       	and	r24, r24
    3020:	29 f4       	brne	.+10     	; 0x302c <MCAL_Interrupt_EnableGIE+0x2e>
		MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_Low);
    3022:	80 e0       	ldi	r24, 0x00	; 0
    3024:	67 e0       	ldi	r22, 0x07	; 7
    3026:	40 e0       	ldi	r20, 0x00	; 0
    3028:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <MCAL_Interrupt_u8SetRegisterPin>
	}
}
    302c:	0f 90       	pop	r0
    302e:	cf 91       	pop	r28
    3030:	df 91       	pop	r29
    3032:	08 95       	ret

00003034 <MCAL_Interrupt_InterruptInit>:

void MCAL_Interrupt_InterruptInit() {
    3034:	df 93       	push	r29
    3036:	cf 93       	push	r28
    3038:	cd b7       	in	r28, 0x3d	; 61
    303a:	de b7       	in	r29, 0x3e	; 62
	MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_High);
    303c:	80 e0       	ldi	r24, 0x00	; 0
    303e:	67 e0       	ldi	r22, 0x07	; 7
    3040:	41 e0       	ldi	r20, 0x01	; 1
    3042:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin6, Pin_High);
    3046:	81 e0       	ldi	r24, 0x01	; 1
    3048:	66 e0       	ldi	r22, 0x06	; 6
    304a:	41 e0       	ldi	r20, 0x01	; 1
    304c:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <MCAL_Interrupt_u8SetRegisterPin>
}
    3050:	cf 91       	pop	r28
    3052:	df 91       	pop	r29
    3054:	08 95       	ret

00003056 <__vector_1>:

ISR(VECT_INT0) {
    3056:	1f 92       	push	r1
    3058:	0f 92       	push	r0
    305a:	0f b6       	in	r0, 0x3f	; 63
    305c:	0f 92       	push	r0
    305e:	11 24       	eor	r1, r1
    3060:	2f 93       	push	r18
    3062:	3f 93       	push	r19
    3064:	4f 93       	push	r20
    3066:	5f 93       	push	r21
    3068:	6f 93       	push	r22
    306a:	7f 93       	push	r23
    306c:	8f 93       	push	r24
    306e:	9f 93       	push	r25
    3070:	af 93       	push	r26
    3072:	bf 93       	push	r27
    3074:	ef 93       	push	r30
    3076:	ff 93       	push	r31
    3078:	df 93       	push	r29
    307a:	cf 93       	push	r28
    307c:	cd b7       	in	r28, 0x3d	; 61
    307e:	de b7       	in	r29, 0x3e	; 62
	if (Gptr0 != '\0')
    3080:	80 91 8f 01 	lds	r24, 0x018F
    3084:	90 91 90 01 	lds	r25, 0x0190
    3088:	00 97       	sbiw	r24, 0x00	; 0
    308a:	29 f0       	breq	.+10     	; 0x3096 <__vector_1+0x40>
		Gptr0();
    308c:	e0 91 8f 01 	lds	r30, 0x018F
    3090:	f0 91 90 01 	lds	r31, 0x0190
    3094:	09 95       	icall
}
    3096:	cf 91       	pop	r28
    3098:	df 91       	pop	r29
    309a:	ff 91       	pop	r31
    309c:	ef 91       	pop	r30
    309e:	bf 91       	pop	r27
    30a0:	af 91       	pop	r26
    30a2:	9f 91       	pop	r25
    30a4:	8f 91       	pop	r24
    30a6:	7f 91       	pop	r23
    30a8:	6f 91       	pop	r22
    30aa:	5f 91       	pop	r21
    30ac:	4f 91       	pop	r20
    30ae:	3f 91       	pop	r19
    30b0:	2f 91       	pop	r18
    30b2:	0f 90       	pop	r0
    30b4:	0f be       	out	0x3f, r0	; 63
    30b6:	0f 90       	pop	r0
    30b8:	1f 90       	pop	r1
    30ba:	18 95       	reti

000030bc <__vector_2>:
ISR(VECT_INT1) {
    30bc:	1f 92       	push	r1
    30be:	0f 92       	push	r0
    30c0:	0f b6       	in	r0, 0x3f	; 63
    30c2:	0f 92       	push	r0
    30c4:	11 24       	eor	r1, r1
    30c6:	2f 93       	push	r18
    30c8:	3f 93       	push	r19
    30ca:	4f 93       	push	r20
    30cc:	5f 93       	push	r21
    30ce:	6f 93       	push	r22
    30d0:	7f 93       	push	r23
    30d2:	8f 93       	push	r24
    30d4:	9f 93       	push	r25
    30d6:	af 93       	push	r26
    30d8:	bf 93       	push	r27
    30da:	ef 93       	push	r30
    30dc:	ff 93       	push	r31
    30de:	df 93       	push	r29
    30e0:	cf 93       	push	r28
    30e2:	cd b7       	in	r28, 0x3d	; 61
    30e4:	de b7       	in	r29, 0x3e	; 62
	if (Gptr1 != '\0')
    30e6:	80 91 91 01 	lds	r24, 0x0191
    30ea:	90 91 92 01 	lds	r25, 0x0192
    30ee:	00 97       	sbiw	r24, 0x00	; 0
    30f0:	29 f0       	breq	.+10     	; 0x30fc <__vector_2+0x40>
		Gptr1();
    30f2:	e0 91 91 01 	lds	r30, 0x0191
    30f6:	f0 91 92 01 	lds	r31, 0x0192
    30fa:	09 95       	icall
}
    30fc:	cf 91       	pop	r28
    30fe:	df 91       	pop	r29
    3100:	ff 91       	pop	r31
    3102:	ef 91       	pop	r30
    3104:	bf 91       	pop	r27
    3106:	af 91       	pop	r26
    3108:	9f 91       	pop	r25
    310a:	8f 91       	pop	r24
    310c:	7f 91       	pop	r23
    310e:	6f 91       	pop	r22
    3110:	5f 91       	pop	r21
    3112:	4f 91       	pop	r20
    3114:	3f 91       	pop	r19
    3116:	2f 91       	pop	r18
    3118:	0f 90       	pop	r0
    311a:	0f be       	out	0x3f, r0	; 63
    311c:	0f 90       	pop	r0
    311e:	1f 90       	pop	r1
    3120:	18 95       	reti

00003122 <__vector_3>:
ISR(VECT_INT2) {
    3122:	1f 92       	push	r1
    3124:	0f 92       	push	r0
    3126:	0f b6       	in	r0, 0x3f	; 63
    3128:	0f 92       	push	r0
    312a:	11 24       	eor	r1, r1
    312c:	2f 93       	push	r18
    312e:	3f 93       	push	r19
    3130:	4f 93       	push	r20
    3132:	5f 93       	push	r21
    3134:	6f 93       	push	r22
    3136:	7f 93       	push	r23
    3138:	8f 93       	push	r24
    313a:	9f 93       	push	r25
    313c:	af 93       	push	r26
    313e:	bf 93       	push	r27
    3140:	ef 93       	push	r30
    3142:	ff 93       	push	r31
    3144:	df 93       	push	r29
    3146:	cf 93       	push	r28
    3148:	cd b7       	in	r28, 0x3d	; 61
    314a:	de b7       	in	r29, 0x3e	; 62
	if (Gptr2 != '\0')
    314c:	80 91 93 01 	lds	r24, 0x0193
    3150:	90 91 94 01 	lds	r25, 0x0194
    3154:	00 97       	sbiw	r24, 0x00	; 0
    3156:	29 f0       	breq	.+10     	; 0x3162 <__vector_3+0x40>
		Gptr2();
    3158:	e0 91 93 01 	lds	r30, 0x0193
    315c:	f0 91 94 01 	lds	r31, 0x0194
    3160:	09 95       	icall
}
    3162:	cf 91       	pop	r28
    3164:	df 91       	pop	r29
    3166:	ff 91       	pop	r31
    3168:	ef 91       	pop	r30
    316a:	bf 91       	pop	r27
    316c:	af 91       	pop	r26
    316e:	9f 91       	pop	r25
    3170:	8f 91       	pop	r24
    3172:	7f 91       	pop	r23
    3174:	6f 91       	pop	r22
    3176:	5f 91       	pop	r21
    3178:	4f 91       	pop	r20
    317a:	3f 91       	pop	r19
    317c:	2f 91       	pop	r18
    317e:	0f 90       	pop	r0
    3180:	0f be       	out	0x3f, r0	; 63
    3182:	0f 90       	pop	r0
    3184:	1f 90       	pop	r1
    3186:	18 95       	reti

00003188 <MCAL_DIO_u8SetPortDirection>:
 *      Author: Mohamed
 */

#include "DIO.h"

STD_Type MCAL_DIO_u8SetPortDirection(u8 Loc_u8PortID, u8 Loc_u8PortDirection) {
    3188:	df 93       	push	r29
    318a:	cf 93       	push	r28
    318c:	00 d0       	rcall	.+0      	; 0x318e <MCAL_DIO_u8SetPortDirection+0x6>
    318e:	0f 92       	push	r0
    3190:	cd b7       	in	r28, 0x3d	; 61
    3192:	de b7       	in	r29, 0x3e	; 62
    3194:	8a 83       	std	Y+2, r24	; 0x02
    3196:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    3198:	81 e0       	ldi	r24, 0x01	; 1
    319a:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PortDirection <= PORT_OUTPUT) {
    319c:	8a 81       	ldd	r24, Y+2	; 0x02
    319e:	84 30       	cpi	r24, 0x04	; 4
    31a0:	08 f0       	brcs	.+2      	; 0x31a4 <MCAL_DIO_u8SetPortDirection+0x1c>
    31a2:	6e c0       	rjmp	.+220    	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
		if (Loc_u8PortDirection == PORT_OUTPUT) {
    31a4:	8b 81       	ldd	r24, Y+3	; 0x03
    31a6:	8f 3f       	cpi	r24, 0xFF	; 255
    31a8:	29 f5       	brne	.+74     	; 0x31f4 <MCAL_DIO_u8SetPortDirection+0x6c>
			if (Loc_u8PortID == PortA) {
    31aa:	8a 81       	ldd	r24, Y+2	; 0x02
    31ac:	88 23       	and	r24, r24
    31ae:	31 f4       	brne	.+12     	; 0x31bc <MCAL_DIO_u8SetPortDirection+0x34>
				DDRA = PORT_OUTPUT;
    31b0:	ea e3       	ldi	r30, 0x3A	; 58
    31b2:	f0 e0       	ldi	r31, 0x00	; 0
    31b4:	8f ef       	ldi	r24, 0xFF	; 255
    31b6:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    31b8:	19 82       	std	Y+1, r1	; 0x01
    31ba:	62 c0       	rjmp	.+196    	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    31bc:	8a 81       	ldd	r24, Y+2	; 0x02
    31be:	81 30       	cpi	r24, 0x01	; 1
    31c0:	31 f4       	brne	.+12     	; 0x31ce <MCAL_DIO_u8SetPortDirection+0x46>
				DDRB = PORT_OUTPUT;
    31c2:	e7 e3       	ldi	r30, 0x37	; 55
    31c4:	f0 e0       	ldi	r31, 0x00	; 0
    31c6:	8f ef       	ldi	r24, 0xFF	; 255
    31c8:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    31ca:	19 82       	std	Y+1, r1	; 0x01
    31cc:	59 c0       	rjmp	.+178    	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    31ce:	8a 81       	ldd	r24, Y+2	; 0x02
    31d0:	82 30       	cpi	r24, 0x02	; 2
    31d2:	31 f4       	brne	.+12     	; 0x31e0 <MCAL_DIO_u8SetPortDirection+0x58>
				DDRC = PORT_OUTPUT;
    31d4:	e4 e3       	ldi	r30, 0x34	; 52
    31d6:	f0 e0       	ldi	r31, 0x00	; 0
    31d8:	8f ef       	ldi	r24, 0xFF	; 255
    31da:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    31dc:	19 82       	std	Y+1, r1	; 0x01
    31de:	50 c0       	rjmp	.+160    	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    31e0:	8a 81       	ldd	r24, Y+2	; 0x02
    31e2:	83 30       	cpi	r24, 0x03	; 3
    31e4:	09 f0       	breq	.+2      	; 0x31e8 <MCAL_DIO_u8SetPortDirection+0x60>
    31e6:	4c c0       	rjmp	.+152    	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = PORT_OUTPUT;
    31e8:	e1 e3       	ldi	r30, 0x31	; 49
    31ea:	f0 e0       	ldi	r31, 0x00	; 0
    31ec:	8f ef       	ldi	r24, 0xFF	; 255
    31ee:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    31f0:	19 82       	std	Y+1, r1	; 0x01
    31f2:	46 c0       	rjmp	.+140    	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PortDirection == PORT_INPUT) {
    31f4:	8b 81       	ldd	r24, Y+3	; 0x03
    31f6:	88 23       	and	r24, r24
    31f8:	01 f5       	brne	.+64     	; 0x323a <MCAL_DIO_u8SetPortDirection+0xb2>
			if (Loc_u8PortID == PortA) {
    31fa:	8a 81       	ldd	r24, Y+2	; 0x02
    31fc:	88 23       	and	r24, r24
    31fe:	29 f4       	brne	.+10     	; 0x320a <MCAL_DIO_u8SetPortDirection+0x82>
				DDRA = PORT_INPUT;
    3200:	ea e3       	ldi	r30, 0x3A	; 58
    3202:	f0 e0       	ldi	r31, 0x00	; 0
    3204:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    3206:	19 82       	std	Y+1, r1	; 0x01
    3208:	3b c0       	rjmp	.+118    	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    320a:	8a 81       	ldd	r24, Y+2	; 0x02
    320c:	81 30       	cpi	r24, 0x01	; 1
    320e:	29 f4       	brne	.+10     	; 0x321a <MCAL_DIO_u8SetPortDirection+0x92>
				DDRB = PORT_INPUT;
    3210:	e7 e3       	ldi	r30, 0x37	; 55
    3212:	f0 e0       	ldi	r31, 0x00	; 0
    3214:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    3216:	19 82       	std	Y+1, r1	; 0x01
    3218:	33 c0       	rjmp	.+102    	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    321a:	8a 81       	ldd	r24, Y+2	; 0x02
    321c:	82 30       	cpi	r24, 0x02	; 2
    321e:	29 f4       	brne	.+10     	; 0x322a <MCAL_DIO_u8SetPortDirection+0xa2>
				DDRC = PORT_INPUT;
    3220:	e4 e3       	ldi	r30, 0x34	; 52
    3222:	f0 e0       	ldi	r31, 0x00	; 0
    3224:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    3226:	19 82       	std	Y+1, r1	; 0x01
    3228:	2b c0       	rjmp	.+86     	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    322a:	8a 81       	ldd	r24, Y+2	; 0x02
    322c:	83 30       	cpi	r24, 0x03	; 3
    322e:	41 f5       	brne	.+80     	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = PORT_INPUT;
    3230:	e1 e3       	ldi	r30, 0x31	; 49
    3232:	f0 e0       	ldi	r31, 0x00	; 0
    3234:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    3236:	19 82       	std	Y+1, r1	; 0x01
    3238:	23 c0       	rjmp	.+70     	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else {
				//Do Nothing
			}
		} else {
			if (Loc_u8PortID == PortA) {
    323a:	8a 81       	ldd	r24, Y+2	; 0x02
    323c:	88 23       	and	r24, r24
    323e:	31 f4       	brne	.+12     	; 0x324c <MCAL_DIO_u8SetPortDirection+0xc4>
				DDRA = Loc_u8PortDirection;
    3240:	ea e3       	ldi	r30, 0x3A	; 58
    3242:	f0 e0       	ldi	r31, 0x00	; 0
    3244:	8b 81       	ldd	r24, Y+3	; 0x03
    3246:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    3248:	19 82       	std	Y+1, r1	; 0x01
    324a:	1a c0       	rjmp	.+52     	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    324c:	8a 81       	ldd	r24, Y+2	; 0x02
    324e:	81 30       	cpi	r24, 0x01	; 1
    3250:	31 f4       	brne	.+12     	; 0x325e <MCAL_DIO_u8SetPortDirection+0xd6>
				DDRB = Loc_u8PortDirection;
    3252:	e7 e3       	ldi	r30, 0x37	; 55
    3254:	f0 e0       	ldi	r31, 0x00	; 0
    3256:	8b 81       	ldd	r24, Y+3	; 0x03
    3258:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    325a:	19 82       	std	Y+1, r1	; 0x01
    325c:	11 c0       	rjmp	.+34     	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    325e:	8a 81       	ldd	r24, Y+2	; 0x02
    3260:	82 30       	cpi	r24, 0x02	; 2
    3262:	31 f4       	brne	.+12     	; 0x3270 <MCAL_DIO_u8SetPortDirection+0xe8>
				DDRC = Loc_u8PortDirection;
    3264:	e4 e3       	ldi	r30, 0x34	; 52
    3266:	f0 e0       	ldi	r31, 0x00	; 0
    3268:	8b 81       	ldd	r24, Y+3	; 0x03
    326a:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    326c:	19 82       	std	Y+1, r1	; 0x01
    326e:	08 c0       	rjmp	.+16     	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    3270:	8a 81       	ldd	r24, Y+2	; 0x02
    3272:	83 30       	cpi	r24, 0x03	; 3
    3274:	29 f4       	brne	.+10     	; 0x3280 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = Loc_u8PortDirection;
    3276:	e1 e3       	ldi	r30, 0x31	; 49
    3278:	f0 e0       	ldi	r31, 0x00	; 0
    327a:	8b 81       	ldd	r24, Y+3	; 0x03
    327c:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    327e:	19 82       	std	Y+1, r1	; 0x01
			}
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3280:	89 81       	ldd	r24, Y+1	; 0x01
}
    3282:	0f 90       	pop	r0
    3284:	0f 90       	pop	r0
    3286:	0f 90       	pop	r0
    3288:	cf 91       	pop	r28
    328a:	df 91       	pop	r29
    328c:	08 95       	ret

0000328e <MCAL_DIO_u8SetPinDirection>:

STD_Type MCAL_DIO_u8SetPinDirection(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinDirection) {
    328e:	df 93       	push	r29
    3290:	cf 93       	push	r28
    3292:	00 d0       	rcall	.+0      	; 0x3294 <MCAL_DIO_u8SetPinDirection+0x6>
    3294:	00 d0       	rcall	.+0      	; 0x3296 <MCAL_DIO_u8SetPinDirection+0x8>
    3296:	cd b7       	in	r28, 0x3d	; 61
    3298:	de b7       	in	r29, 0x3e	; 62
    329a:	8a 83       	std	Y+2, r24	; 0x02
    329c:	6b 83       	std	Y+3, r22	; 0x03
    329e:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    32a0:	81 e0       	ldi	r24, 0x01	; 1
    32a2:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins
    32a4:	8a 81       	ldd	r24, Y+2	; 0x02
    32a6:	84 30       	cpi	r24, 0x04	; 4
    32a8:	08 f0       	brcs	.+2      	; 0x32ac <MCAL_DIO_u8SetPinDirection+0x1e>
    32aa:	d4 c0       	rjmp	.+424    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
    32ac:	8b 81       	ldd	r24, Y+3	; 0x03
    32ae:	88 30       	cpi	r24, 0x08	; 8
    32b0:	08 f0       	brcs	.+2      	; 0x32b4 <MCAL_DIO_u8SetPinDirection+0x26>
    32b2:	d0 c0       	rjmp	.+416    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
    32b4:	8c 81       	ldd	r24, Y+4	; 0x04
    32b6:	82 30       	cpi	r24, 0x02	; 2
    32b8:	08 f0       	brcs	.+2      	; 0x32bc <MCAL_DIO_u8SetPinDirection+0x2e>
    32ba:	cc c0       	rjmp	.+408    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			&& Loc_u8PinDirection <= Pin_High) {
		if (Loc_u8PinDirection == Pin_High) {
    32bc:	8c 81       	ldd	r24, Y+4	; 0x04
    32be:	81 30       	cpi	r24, 0x01	; 1
    32c0:	09 f0       	breq	.+2      	; 0x32c4 <MCAL_DIO_u8SetPinDirection+0x36>
    32c2:	61 c0       	rjmp	.+194    	; 0x3386 <MCAL_DIO_u8SetPinDirection+0xf8>
			if (Loc_u8PortID == PortA) {
    32c4:	8a 81       	ldd	r24, Y+2	; 0x02
    32c6:	88 23       	and	r24, r24
    32c8:	a9 f4       	brne	.+42     	; 0x32f4 <MCAL_DIO_u8SetPinDirection+0x66>
				SET_BIT(DDRA, Loc_u8PinID);
    32ca:	aa e3       	ldi	r26, 0x3A	; 58
    32cc:	b0 e0       	ldi	r27, 0x00	; 0
    32ce:	ea e3       	ldi	r30, 0x3A	; 58
    32d0:	f0 e0       	ldi	r31, 0x00	; 0
    32d2:	80 81       	ld	r24, Z
    32d4:	48 2f       	mov	r20, r24
    32d6:	8b 81       	ldd	r24, Y+3	; 0x03
    32d8:	28 2f       	mov	r18, r24
    32da:	30 e0       	ldi	r19, 0x00	; 0
    32dc:	81 e0       	ldi	r24, 0x01	; 1
    32de:	90 e0       	ldi	r25, 0x00	; 0
    32e0:	02 2e       	mov	r0, r18
    32e2:	02 c0       	rjmp	.+4      	; 0x32e8 <MCAL_DIO_u8SetPinDirection+0x5a>
    32e4:	88 0f       	add	r24, r24
    32e6:	99 1f       	adc	r25, r25
    32e8:	0a 94       	dec	r0
    32ea:	e2 f7       	brpl	.-8      	; 0x32e4 <MCAL_DIO_u8SetPinDirection+0x56>
    32ec:	84 2b       	or	r24, r20
    32ee:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    32f0:	19 82       	std	Y+1, r1	; 0x01
    32f2:	b0 c0       	rjmp	.+352    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    32f4:	8a 81       	ldd	r24, Y+2	; 0x02
    32f6:	81 30       	cpi	r24, 0x01	; 1
    32f8:	a9 f4       	brne	.+42     	; 0x3324 <MCAL_DIO_u8SetPinDirection+0x96>
				SET_BIT(DDRB, Loc_u8PinID);
    32fa:	a7 e3       	ldi	r26, 0x37	; 55
    32fc:	b0 e0       	ldi	r27, 0x00	; 0
    32fe:	e7 e3       	ldi	r30, 0x37	; 55
    3300:	f0 e0       	ldi	r31, 0x00	; 0
    3302:	80 81       	ld	r24, Z
    3304:	48 2f       	mov	r20, r24
    3306:	8b 81       	ldd	r24, Y+3	; 0x03
    3308:	28 2f       	mov	r18, r24
    330a:	30 e0       	ldi	r19, 0x00	; 0
    330c:	81 e0       	ldi	r24, 0x01	; 1
    330e:	90 e0       	ldi	r25, 0x00	; 0
    3310:	02 2e       	mov	r0, r18
    3312:	02 c0       	rjmp	.+4      	; 0x3318 <MCAL_DIO_u8SetPinDirection+0x8a>
    3314:	88 0f       	add	r24, r24
    3316:	99 1f       	adc	r25, r25
    3318:	0a 94       	dec	r0
    331a:	e2 f7       	brpl	.-8      	; 0x3314 <MCAL_DIO_u8SetPinDirection+0x86>
    331c:	84 2b       	or	r24, r20
    331e:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3320:	19 82       	std	Y+1, r1	; 0x01
    3322:	98 c0       	rjmp	.+304    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    3324:	8a 81       	ldd	r24, Y+2	; 0x02
    3326:	82 30       	cpi	r24, 0x02	; 2
    3328:	a9 f4       	brne	.+42     	; 0x3354 <MCAL_DIO_u8SetPinDirection+0xc6>
				SET_BIT(DDRC, Loc_u8PinID);
    332a:	a4 e3       	ldi	r26, 0x34	; 52
    332c:	b0 e0       	ldi	r27, 0x00	; 0
    332e:	e4 e3       	ldi	r30, 0x34	; 52
    3330:	f0 e0       	ldi	r31, 0x00	; 0
    3332:	80 81       	ld	r24, Z
    3334:	48 2f       	mov	r20, r24
    3336:	8b 81       	ldd	r24, Y+3	; 0x03
    3338:	28 2f       	mov	r18, r24
    333a:	30 e0       	ldi	r19, 0x00	; 0
    333c:	81 e0       	ldi	r24, 0x01	; 1
    333e:	90 e0       	ldi	r25, 0x00	; 0
    3340:	02 2e       	mov	r0, r18
    3342:	02 c0       	rjmp	.+4      	; 0x3348 <MCAL_DIO_u8SetPinDirection+0xba>
    3344:	88 0f       	add	r24, r24
    3346:	99 1f       	adc	r25, r25
    3348:	0a 94       	dec	r0
    334a:	e2 f7       	brpl	.-8      	; 0x3344 <MCAL_DIO_u8SetPinDirection+0xb6>
    334c:	84 2b       	or	r24, r20
    334e:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3350:	19 82       	std	Y+1, r1	; 0x01
    3352:	80 c0       	rjmp	.+256    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    3354:	8a 81       	ldd	r24, Y+2	; 0x02
    3356:	83 30       	cpi	r24, 0x03	; 3
    3358:	09 f0       	breq	.+2      	; 0x335c <MCAL_DIO_u8SetPinDirection+0xce>
    335a:	7c c0       	rjmp	.+248    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
				SET_BIT(DDRD, Loc_u8PinID);
    335c:	a1 e3       	ldi	r26, 0x31	; 49
    335e:	b0 e0       	ldi	r27, 0x00	; 0
    3360:	e1 e3       	ldi	r30, 0x31	; 49
    3362:	f0 e0       	ldi	r31, 0x00	; 0
    3364:	80 81       	ld	r24, Z
    3366:	48 2f       	mov	r20, r24
    3368:	8b 81       	ldd	r24, Y+3	; 0x03
    336a:	28 2f       	mov	r18, r24
    336c:	30 e0       	ldi	r19, 0x00	; 0
    336e:	81 e0       	ldi	r24, 0x01	; 1
    3370:	90 e0       	ldi	r25, 0x00	; 0
    3372:	02 2e       	mov	r0, r18
    3374:	02 c0       	rjmp	.+4      	; 0x337a <MCAL_DIO_u8SetPinDirection+0xec>
    3376:	88 0f       	add	r24, r24
    3378:	99 1f       	adc	r25, r25
    337a:	0a 94       	dec	r0
    337c:	e2 f7       	brpl	.-8      	; 0x3376 <MCAL_DIO_u8SetPinDirection+0xe8>
    337e:	84 2b       	or	r24, r20
    3380:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3382:	19 82       	std	Y+1, r1	; 0x01
    3384:	67 c0       	rjmp	.+206    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PinDirection == Pin_Low) {
    3386:	8c 81       	ldd	r24, Y+4	; 0x04
    3388:	88 23       	and	r24, r24
    338a:	09 f0       	breq	.+2      	; 0x338e <MCAL_DIO_u8SetPinDirection+0x100>
    338c:	63 c0       	rjmp	.+198    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			if (Loc_u8PortID == PortA) {
    338e:	8a 81       	ldd	r24, Y+2	; 0x02
    3390:	88 23       	and	r24, r24
    3392:	b1 f4       	brne	.+44     	; 0x33c0 <MCAL_DIO_u8SetPinDirection+0x132>
				CLR_BIT(DDRA, Loc_u8PinID);
    3394:	aa e3       	ldi	r26, 0x3A	; 58
    3396:	b0 e0       	ldi	r27, 0x00	; 0
    3398:	ea e3       	ldi	r30, 0x3A	; 58
    339a:	f0 e0       	ldi	r31, 0x00	; 0
    339c:	80 81       	ld	r24, Z
    339e:	48 2f       	mov	r20, r24
    33a0:	8b 81       	ldd	r24, Y+3	; 0x03
    33a2:	28 2f       	mov	r18, r24
    33a4:	30 e0       	ldi	r19, 0x00	; 0
    33a6:	81 e0       	ldi	r24, 0x01	; 1
    33a8:	90 e0       	ldi	r25, 0x00	; 0
    33aa:	02 2e       	mov	r0, r18
    33ac:	02 c0       	rjmp	.+4      	; 0x33b2 <MCAL_DIO_u8SetPinDirection+0x124>
    33ae:	88 0f       	add	r24, r24
    33b0:	99 1f       	adc	r25, r25
    33b2:	0a 94       	dec	r0
    33b4:	e2 f7       	brpl	.-8      	; 0x33ae <MCAL_DIO_u8SetPinDirection+0x120>
    33b6:	80 95       	com	r24
    33b8:	84 23       	and	r24, r20
    33ba:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    33bc:	19 82       	std	Y+1, r1	; 0x01
    33be:	4a c0       	rjmp	.+148    	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    33c0:	8a 81       	ldd	r24, Y+2	; 0x02
    33c2:	81 30       	cpi	r24, 0x01	; 1
    33c4:	b1 f4       	brne	.+44     	; 0x33f2 <MCAL_DIO_u8SetPinDirection+0x164>
				CLR_BIT(DDRB, Loc_u8PinID);
    33c6:	a7 e3       	ldi	r26, 0x37	; 55
    33c8:	b0 e0       	ldi	r27, 0x00	; 0
    33ca:	e7 e3       	ldi	r30, 0x37	; 55
    33cc:	f0 e0       	ldi	r31, 0x00	; 0
    33ce:	80 81       	ld	r24, Z
    33d0:	48 2f       	mov	r20, r24
    33d2:	8b 81       	ldd	r24, Y+3	; 0x03
    33d4:	28 2f       	mov	r18, r24
    33d6:	30 e0       	ldi	r19, 0x00	; 0
    33d8:	81 e0       	ldi	r24, 0x01	; 1
    33da:	90 e0       	ldi	r25, 0x00	; 0
    33dc:	02 2e       	mov	r0, r18
    33de:	02 c0       	rjmp	.+4      	; 0x33e4 <MCAL_DIO_u8SetPinDirection+0x156>
    33e0:	88 0f       	add	r24, r24
    33e2:	99 1f       	adc	r25, r25
    33e4:	0a 94       	dec	r0
    33e6:	e2 f7       	brpl	.-8      	; 0x33e0 <MCAL_DIO_u8SetPinDirection+0x152>
    33e8:	80 95       	com	r24
    33ea:	84 23       	and	r24, r20
    33ec:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    33ee:	19 82       	std	Y+1, r1	; 0x01
    33f0:	31 c0       	rjmp	.+98     	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    33f2:	8a 81       	ldd	r24, Y+2	; 0x02
    33f4:	82 30       	cpi	r24, 0x02	; 2
    33f6:	b1 f4       	brne	.+44     	; 0x3424 <MCAL_DIO_u8SetPinDirection+0x196>
				CLR_BIT(DDRC, Loc_u8PinID);
    33f8:	a4 e3       	ldi	r26, 0x34	; 52
    33fa:	b0 e0       	ldi	r27, 0x00	; 0
    33fc:	e4 e3       	ldi	r30, 0x34	; 52
    33fe:	f0 e0       	ldi	r31, 0x00	; 0
    3400:	80 81       	ld	r24, Z
    3402:	48 2f       	mov	r20, r24
    3404:	8b 81       	ldd	r24, Y+3	; 0x03
    3406:	28 2f       	mov	r18, r24
    3408:	30 e0       	ldi	r19, 0x00	; 0
    340a:	81 e0       	ldi	r24, 0x01	; 1
    340c:	90 e0       	ldi	r25, 0x00	; 0
    340e:	02 2e       	mov	r0, r18
    3410:	02 c0       	rjmp	.+4      	; 0x3416 <MCAL_DIO_u8SetPinDirection+0x188>
    3412:	88 0f       	add	r24, r24
    3414:	99 1f       	adc	r25, r25
    3416:	0a 94       	dec	r0
    3418:	e2 f7       	brpl	.-8      	; 0x3412 <MCAL_DIO_u8SetPinDirection+0x184>
    341a:	80 95       	com	r24
    341c:	84 23       	and	r24, r20
    341e:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3420:	19 82       	std	Y+1, r1	; 0x01
    3422:	18 c0       	rjmp	.+48     	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    3424:	8a 81       	ldd	r24, Y+2	; 0x02
    3426:	83 30       	cpi	r24, 0x03	; 3
    3428:	a9 f4       	brne	.+42     	; 0x3454 <MCAL_DIO_u8SetPinDirection+0x1c6>
				CLR_BIT(DDRD, Loc_u8PinID);
    342a:	a1 e3       	ldi	r26, 0x31	; 49
    342c:	b0 e0       	ldi	r27, 0x00	; 0
    342e:	e1 e3       	ldi	r30, 0x31	; 49
    3430:	f0 e0       	ldi	r31, 0x00	; 0
    3432:	80 81       	ld	r24, Z
    3434:	48 2f       	mov	r20, r24
    3436:	8b 81       	ldd	r24, Y+3	; 0x03
    3438:	28 2f       	mov	r18, r24
    343a:	30 e0       	ldi	r19, 0x00	; 0
    343c:	81 e0       	ldi	r24, 0x01	; 1
    343e:	90 e0       	ldi	r25, 0x00	; 0
    3440:	02 2e       	mov	r0, r18
    3442:	02 c0       	rjmp	.+4      	; 0x3448 <MCAL_DIO_u8SetPinDirection+0x1ba>
    3444:	88 0f       	add	r24, r24
    3446:	99 1f       	adc	r25, r25
    3448:	0a 94       	dec	r0
    344a:	e2 f7       	brpl	.-8      	; 0x3444 <MCAL_DIO_u8SetPinDirection+0x1b6>
    344c:	80 95       	com	r24
    344e:	84 23       	and	r24, r20
    3450:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3452:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3454:	89 81       	ldd	r24, Y+1	; 0x01

}
    3456:	0f 90       	pop	r0
    3458:	0f 90       	pop	r0
    345a:	0f 90       	pop	r0
    345c:	0f 90       	pop	r0
    345e:	cf 91       	pop	r28
    3460:	df 91       	pop	r29
    3462:	08 95       	ret

00003464 <MCAL_DIO_u8SetPortValue>:

STD_Type MCAL_DIO_u8SetPortValue(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    3464:	df 93       	push	r29
    3466:	cf 93       	push	r28
    3468:	00 d0       	rcall	.+0      	; 0x346a <MCAL_DIO_u8SetPortValue+0x6>
    346a:	0f 92       	push	r0
    346c:	cd b7       	in	r28, 0x3d	; 61
    346e:	de b7       	in	r29, 0x3e	; 62
    3470:	8a 83       	std	Y+2, r24	; 0x02
    3472:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    3474:	81 e0       	ldi	r24, 0x01	; 1
    3476:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PortValue <= PORT_OUTPUT) {
    3478:	8a 81       	ldd	r24, Y+2	; 0x02
    347a:	84 30       	cpi	r24, 0x04	; 4
    347c:	08 f0       	brcs	.+2      	; 0x3480 <MCAL_DIO_u8SetPortValue+0x1c>
    347e:	6e c0       	rjmp	.+220    	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
		if (Loc_u8PortValue == PORT_OUTPUT) {
    3480:	8b 81       	ldd	r24, Y+3	; 0x03
    3482:	8f 3f       	cpi	r24, 0xFF	; 255
    3484:	29 f5       	brne	.+74     	; 0x34d0 <MCAL_DIO_u8SetPortValue+0x6c>
			if (Loc_u8PortID == PortA) {
    3486:	8a 81       	ldd	r24, Y+2	; 0x02
    3488:	88 23       	and	r24, r24
    348a:	31 f4       	brne	.+12     	; 0x3498 <MCAL_DIO_u8SetPortValue+0x34>
				PORTA = PORT_OUTPUT;
    348c:	eb e3       	ldi	r30, 0x3B	; 59
    348e:	f0 e0       	ldi	r31, 0x00	; 0
    3490:	8f ef       	ldi	r24, 0xFF	; 255
    3492:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    3494:	19 82       	std	Y+1, r1	; 0x01
    3496:	62 c0       	rjmp	.+196    	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    3498:	8a 81       	ldd	r24, Y+2	; 0x02
    349a:	81 30       	cpi	r24, 0x01	; 1
    349c:	31 f4       	brne	.+12     	; 0x34aa <MCAL_DIO_u8SetPortValue+0x46>
				PORTB = PORT_OUTPUT;
    349e:	e8 e3       	ldi	r30, 0x38	; 56
    34a0:	f0 e0       	ldi	r31, 0x00	; 0
    34a2:	8f ef       	ldi	r24, 0xFF	; 255
    34a4:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    34a6:	19 82       	std	Y+1, r1	; 0x01
    34a8:	59 c0       	rjmp	.+178    	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    34aa:	8a 81       	ldd	r24, Y+2	; 0x02
    34ac:	82 30       	cpi	r24, 0x02	; 2
    34ae:	31 f4       	brne	.+12     	; 0x34bc <MCAL_DIO_u8SetPortValue+0x58>
				PORTC = PORT_OUTPUT;
    34b0:	e5 e3       	ldi	r30, 0x35	; 53
    34b2:	f0 e0       	ldi	r31, 0x00	; 0
    34b4:	8f ef       	ldi	r24, 0xFF	; 255
    34b6:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    34b8:	19 82       	std	Y+1, r1	; 0x01
    34ba:	50 c0       	rjmp	.+160    	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    34bc:	8a 81       	ldd	r24, Y+2	; 0x02
    34be:	83 30       	cpi	r24, 0x03	; 3
    34c0:	09 f0       	breq	.+2      	; 0x34c4 <MCAL_DIO_u8SetPortValue+0x60>
    34c2:	4c c0       	rjmp	.+152    	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = PORT_OUTPUT;
    34c4:	e2 e3       	ldi	r30, 0x32	; 50
    34c6:	f0 e0       	ldi	r31, 0x00	; 0
    34c8:	8f ef       	ldi	r24, 0xFF	; 255
    34ca:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    34cc:	19 82       	std	Y+1, r1	; 0x01
    34ce:	46 c0       	rjmp	.+140    	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PortValue == PORT_INPUT) {
    34d0:	8b 81       	ldd	r24, Y+3	; 0x03
    34d2:	88 23       	and	r24, r24
    34d4:	01 f5       	brne	.+64     	; 0x3516 <MCAL_DIO_u8SetPortValue+0xb2>
			if (Loc_u8PortID == PortA) {
    34d6:	8a 81       	ldd	r24, Y+2	; 0x02
    34d8:	88 23       	and	r24, r24
    34da:	29 f4       	brne	.+10     	; 0x34e6 <MCAL_DIO_u8SetPortValue+0x82>
				PORTA = PORT_INPUT;
    34dc:	eb e3       	ldi	r30, 0x3B	; 59
    34de:	f0 e0       	ldi	r31, 0x00	; 0
    34e0:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    34e2:	19 82       	std	Y+1, r1	; 0x01
    34e4:	3b c0       	rjmp	.+118    	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    34e6:	8a 81       	ldd	r24, Y+2	; 0x02
    34e8:	81 30       	cpi	r24, 0x01	; 1
    34ea:	29 f4       	brne	.+10     	; 0x34f6 <MCAL_DIO_u8SetPortValue+0x92>
				PORTB = PORT_INPUT;
    34ec:	e8 e3       	ldi	r30, 0x38	; 56
    34ee:	f0 e0       	ldi	r31, 0x00	; 0
    34f0:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    34f2:	19 82       	std	Y+1, r1	; 0x01
    34f4:	33 c0       	rjmp	.+102    	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    34f6:	8a 81       	ldd	r24, Y+2	; 0x02
    34f8:	82 30       	cpi	r24, 0x02	; 2
    34fa:	29 f4       	brne	.+10     	; 0x3506 <MCAL_DIO_u8SetPortValue+0xa2>
				PORTC = PORT_INPUT;
    34fc:	e5 e3       	ldi	r30, 0x35	; 53
    34fe:	f0 e0       	ldi	r31, 0x00	; 0
    3500:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    3502:	19 82       	std	Y+1, r1	; 0x01
    3504:	2b c0       	rjmp	.+86     	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    3506:	8a 81       	ldd	r24, Y+2	; 0x02
    3508:	83 30       	cpi	r24, 0x03	; 3
    350a:	41 f5       	brne	.+80     	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = PORT_INPUT;
    350c:	e2 e3       	ldi	r30, 0x32	; 50
    350e:	f0 e0       	ldi	r31, 0x00	; 0
    3510:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    3512:	19 82       	std	Y+1, r1	; 0x01
    3514:	23 c0       	rjmp	.+70     	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else {
				//Do Nothing
			}
		} else {
			if (Loc_u8PortID == PortA) {
    3516:	8a 81       	ldd	r24, Y+2	; 0x02
    3518:	88 23       	and	r24, r24
    351a:	31 f4       	brne	.+12     	; 0x3528 <MCAL_DIO_u8SetPortValue+0xc4>
				PORTA = Loc_u8PortValue;
    351c:	eb e3       	ldi	r30, 0x3B	; 59
    351e:	f0 e0       	ldi	r31, 0x00	; 0
    3520:	8b 81       	ldd	r24, Y+3	; 0x03
    3522:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    3524:	19 82       	std	Y+1, r1	; 0x01
    3526:	1a c0       	rjmp	.+52     	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    3528:	8a 81       	ldd	r24, Y+2	; 0x02
    352a:	81 30       	cpi	r24, 0x01	; 1
    352c:	31 f4       	brne	.+12     	; 0x353a <MCAL_DIO_u8SetPortValue+0xd6>
				PORTB = Loc_u8PortValue;
    352e:	e8 e3       	ldi	r30, 0x38	; 56
    3530:	f0 e0       	ldi	r31, 0x00	; 0
    3532:	8b 81       	ldd	r24, Y+3	; 0x03
    3534:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    3536:	19 82       	std	Y+1, r1	; 0x01
    3538:	11 c0       	rjmp	.+34     	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    353a:	8a 81       	ldd	r24, Y+2	; 0x02
    353c:	82 30       	cpi	r24, 0x02	; 2
    353e:	31 f4       	brne	.+12     	; 0x354c <MCAL_DIO_u8SetPortValue+0xe8>
				PORTC = Loc_u8PortValue;
    3540:	e5 e3       	ldi	r30, 0x35	; 53
    3542:	f0 e0       	ldi	r31, 0x00	; 0
    3544:	8b 81       	ldd	r24, Y+3	; 0x03
    3546:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    3548:	19 82       	std	Y+1, r1	; 0x01
    354a:	08 c0       	rjmp	.+16     	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    354c:	8a 81       	ldd	r24, Y+2	; 0x02
    354e:	83 30       	cpi	r24, 0x03	; 3
    3550:	29 f4       	brne	.+10     	; 0x355c <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = Loc_u8PortValue;
    3552:	e2 e3       	ldi	r30, 0x32	; 50
    3554:	f0 e0       	ldi	r31, 0x00	; 0
    3556:	8b 81       	ldd	r24, Y+3	; 0x03
    3558:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    355a:	19 82       	std	Y+1, r1	; 0x01
			}
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    355c:	89 81       	ldd	r24, Y+1	; 0x01
}
    355e:	0f 90       	pop	r0
    3560:	0f 90       	pop	r0
    3562:	0f 90       	pop	r0
    3564:	cf 91       	pop	r28
    3566:	df 91       	pop	r29
    3568:	08 95       	ret

0000356a <MCAL_DIO_u8SetPinValue>:

STD_Type MCAL_DIO_u8SetPinValue(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    356a:	df 93       	push	r29
    356c:	cf 93       	push	r28
    356e:	00 d0       	rcall	.+0      	; 0x3570 <MCAL_DIO_u8SetPinValue+0x6>
    3570:	00 d0       	rcall	.+0      	; 0x3572 <MCAL_DIO_u8SetPinValue+0x8>
    3572:	cd b7       	in	r28, 0x3d	; 61
    3574:	de b7       	in	r29, 0x3e	; 62
    3576:	8a 83       	std	Y+2, r24	; 0x02
    3578:	6b 83       	std	Y+3, r22	; 0x03
    357a:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    357c:	81 e0       	ldi	r24, 0x01	; 1
    357e:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins
    3580:	8a 81       	ldd	r24, Y+2	; 0x02
    3582:	84 30       	cpi	r24, 0x04	; 4
    3584:	08 f0       	brcs	.+2      	; 0x3588 <MCAL_DIO_u8SetPinValue+0x1e>
    3586:	d4 c0       	rjmp	.+424    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
    3588:	8b 81       	ldd	r24, Y+3	; 0x03
    358a:	88 30       	cpi	r24, 0x08	; 8
    358c:	08 f0       	brcs	.+2      	; 0x3590 <MCAL_DIO_u8SetPinValue+0x26>
    358e:	d0 c0       	rjmp	.+416    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
    3590:	8c 81       	ldd	r24, Y+4	; 0x04
    3592:	82 30       	cpi	r24, 0x02	; 2
    3594:	08 f0       	brcs	.+2      	; 0x3598 <MCAL_DIO_u8SetPinValue+0x2e>
    3596:	cc c0       	rjmp	.+408    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			&& Loc_u8PinValue <= Pin_High) {
		if (Loc_u8PinValue == Pin_High) {
    3598:	8c 81       	ldd	r24, Y+4	; 0x04
    359a:	81 30       	cpi	r24, 0x01	; 1
    359c:	09 f0       	breq	.+2      	; 0x35a0 <MCAL_DIO_u8SetPinValue+0x36>
    359e:	61 c0       	rjmp	.+194    	; 0x3662 <MCAL_DIO_u8SetPinValue+0xf8>
			if (Loc_u8PortID == PortA) {
    35a0:	8a 81       	ldd	r24, Y+2	; 0x02
    35a2:	88 23       	and	r24, r24
    35a4:	a9 f4       	brne	.+42     	; 0x35d0 <MCAL_DIO_u8SetPinValue+0x66>
				SET_BIT(PORTA, Loc_u8PinID);
    35a6:	ab e3       	ldi	r26, 0x3B	; 59
    35a8:	b0 e0       	ldi	r27, 0x00	; 0
    35aa:	eb e3       	ldi	r30, 0x3B	; 59
    35ac:	f0 e0       	ldi	r31, 0x00	; 0
    35ae:	80 81       	ld	r24, Z
    35b0:	48 2f       	mov	r20, r24
    35b2:	8b 81       	ldd	r24, Y+3	; 0x03
    35b4:	28 2f       	mov	r18, r24
    35b6:	30 e0       	ldi	r19, 0x00	; 0
    35b8:	81 e0       	ldi	r24, 0x01	; 1
    35ba:	90 e0       	ldi	r25, 0x00	; 0
    35bc:	02 2e       	mov	r0, r18
    35be:	02 c0       	rjmp	.+4      	; 0x35c4 <MCAL_DIO_u8SetPinValue+0x5a>
    35c0:	88 0f       	add	r24, r24
    35c2:	99 1f       	adc	r25, r25
    35c4:	0a 94       	dec	r0
    35c6:	e2 f7       	brpl	.-8      	; 0x35c0 <MCAL_DIO_u8SetPinValue+0x56>
    35c8:	84 2b       	or	r24, r20
    35ca:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    35cc:	19 82       	std	Y+1, r1	; 0x01
    35ce:	b0 c0       	rjmp	.+352    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    35d0:	8a 81       	ldd	r24, Y+2	; 0x02
    35d2:	81 30       	cpi	r24, 0x01	; 1
    35d4:	a9 f4       	brne	.+42     	; 0x3600 <MCAL_DIO_u8SetPinValue+0x96>
				SET_BIT(PORTB, Loc_u8PinID);
    35d6:	a8 e3       	ldi	r26, 0x38	; 56
    35d8:	b0 e0       	ldi	r27, 0x00	; 0
    35da:	e8 e3       	ldi	r30, 0x38	; 56
    35dc:	f0 e0       	ldi	r31, 0x00	; 0
    35de:	80 81       	ld	r24, Z
    35e0:	48 2f       	mov	r20, r24
    35e2:	8b 81       	ldd	r24, Y+3	; 0x03
    35e4:	28 2f       	mov	r18, r24
    35e6:	30 e0       	ldi	r19, 0x00	; 0
    35e8:	81 e0       	ldi	r24, 0x01	; 1
    35ea:	90 e0       	ldi	r25, 0x00	; 0
    35ec:	02 2e       	mov	r0, r18
    35ee:	02 c0       	rjmp	.+4      	; 0x35f4 <MCAL_DIO_u8SetPinValue+0x8a>
    35f0:	88 0f       	add	r24, r24
    35f2:	99 1f       	adc	r25, r25
    35f4:	0a 94       	dec	r0
    35f6:	e2 f7       	brpl	.-8      	; 0x35f0 <MCAL_DIO_u8SetPinValue+0x86>
    35f8:	84 2b       	or	r24, r20
    35fa:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    35fc:	19 82       	std	Y+1, r1	; 0x01
    35fe:	98 c0       	rjmp	.+304    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    3600:	8a 81       	ldd	r24, Y+2	; 0x02
    3602:	82 30       	cpi	r24, 0x02	; 2
    3604:	a9 f4       	brne	.+42     	; 0x3630 <MCAL_DIO_u8SetPinValue+0xc6>
				SET_BIT(PORTC, Loc_u8PinID);
    3606:	a5 e3       	ldi	r26, 0x35	; 53
    3608:	b0 e0       	ldi	r27, 0x00	; 0
    360a:	e5 e3       	ldi	r30, 0x35	; 53
    360c:	f0 e0       	ldi	r31, 0x00	; 0
    360e:	80 81       	ld	r24, Z
    3610:	48 2f       	mov	r20, r24
    3612:	8b 81       	ldd	r24, Y+3	; 0x03
    3614:	28 2f       	mov	r18, r24
    3616:	30 e0       	ldi	r19, 0x00	; 0
    3618:	81 e0       	ldi	r24, 0x01	; 1
    361a:	90 e0       	ldi	r25, 0x00	; 0
    361c:	02 2e       	mov	r0, r18
    361e:	02 c0       	rjmp	.+4      	; 0x3624 <MCAL_DIO_u8SetPinValue+0xba>
    3620:	88 0f       	add	r24, r24
    3622:	99 1f       	adc	r25, r25
    3624:	0a 94       	dec	r0
    3626:	e2 f7       	brpl	.-8      	; 0x3620 <MCAL_DIO_u8SetPinValue+0xb6>
    3628:	84 2b       	or	r24, r20
    362a:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    362c:	19 82       	std	Y+1, r1	; 0x01
    362e:	80 c0       	rjmp	.+256    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    3630:	8a 81       	ldd	r24, Y+2	; 0x02
    3632:	83 30       	cpi	r24, 0x03	; 3
    3634:	09 f0       	breq	.+2      	; 0x3638 <MCAL_DIO_u8SetPinValue+0xce>
    3636:	7c c0       	rjmp	.+248    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
				SET_BIT(PORTD, Loc_u8PinID);
    3638:	a2 e3       	ldi	r26, 0x32	; 50
    363a:	b0 e0       	ldi	r27, 0x00	; 0
    363c:	e2 e3       	ldi	r30, 0x32	; 50
    363e:	f0 e0       	ldi	r31, 0x00	; 0
    3640:	80 81       	ld	r24, Z
    3642:	48 2f       	mov	r20, r24
    3644:	8b 81       	ldd	r24, Y+3	; 0x03
    3646:	28 2f       	mov	r18, r24
    3648:	30 e0       	ldi	r19, 0x00	; 0
    364a:	81 e0       	ldi	r24, 0x01	; 1
    364c:	90 e0       	ldi	r25, 0x00	; 0
    364e:	02 2e       	mov	r0, r18
    3650:	02 c0       	rjmp	.+4      	; 0x3656 <MCAL_DIO_u8SetPinValue+0xec>
    3652:	88 0f       	add	r24, r24
    3654:	99 1f       	adc	r25, r25
    3656:	0a 94       	dec	r0
    3658:	e2 f7       	brpl	.-8      	; 0x3652 <MCAL_DIO_u8SetPinValue+0xe8>
    365a:	84 2b       	or	r24, r20
    365c:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    365e:	19 82       	std	Y+1, r1	; 0x01
    3660:	67 c0       	rjmp	.+206    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PinValue == Pin_Low) {
    3662:	8c 81       	ldd	r24, Y+4	; 0x04
    3664:	88 23       	and	r24, r24
    3666:	09 f0       	breq	.+2      	; 0x366a <MCAL_DIO_u8SetPinValue+0x100>
    3668:	63 c0       	rjmp	.+198    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			if (Loc_u8PortID == PortA) {
    366a:	8a 81       	ldd	r24, Y+2	; 0x02
    366c:	88 23       	and	r24, r24
    366e:	b1 f4       	brne	.+44     	; 0x369c <MCAL_DIO_u8SetPinValue+0x132>
				CLR_BIT(PORTA, Loc_u8PinID);
    3670:	ab e3       	ldi	r26, 0x3B	; 59
    3672:	b0 e0       	ldi	r27, 0x00	; 0
    3674:	eb e3       	ldi	r30, 0x3B	; 59
    3676:	f0 e0       	ldi	r31, 0x00	; 0
    3678:	80 81       	ld	r24, Z
    367a:	48 2f       	mov	r20, r24
    367c:	8b 81       	ldd	r24, Y+3	; 0x03
    367e:	28 2f       	mov	r18, r24
    3680:	30 e0       	ldi	r19, 0x00	; 0
    3682:	81 e0       	ldi	r24, 0x01	; 1
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	02 2e       	mov	r0, r18
    3688:	02 c0       	rjmp	.+4      	; 0x368e <MCAL_DIO_u8SetPinValue+0x124>
    368a:	88 0f       	add	r24, r24
    368c:	99 1f       	adc	r25, r25
    368e:	0a 94       	dec	r0
    3690:	e2 f7       	brpl	.-8      	; 0x368a <MCAL_DIO_u8SetPinValue+0x120>
    3692:	80 95       	com	r24
    3694:	84 23       	and	r24, r20
    3696:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    3698:	19 82       	std	Y+1, r1	; 0x01
    369a:	4a c0       	rjmp	.+148    	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    369c:	8a 81       	ldd	r24, Y+2	; 0x02
    369e:	81 30       	cpi	r24, 0x01	; 1
    36a0:	b1 f4       	brne	.+44     	; 0x36ce <MCAL_DIO_u8SetPinValue+0x164>
				CLR_BIT(PORTB, Loc_u8PinID);
    36a2:	a8 e3       	ldi	r26, 0x38	; 56
    36a4:	b0 e0       	ldi	r27, 0x00	; 0
    36a6:	e8 e3       	ldi	r30, 0x38	; 56
    36a8:	f0 e0       	ldi	r31, 0x00	; 0
    36aa:	80 81       	ld	r24, Z
    36ac:	48 2f       	mov	r20, r24
    36ae:	8b 81       	ldd	r24, Y+3	; 0x03
    36b0:	28 2f       	mov	r18, r24
    36b2:	30 e0       	ldi	r19, 0x00	; 0
    36b4:	81 e0       	ldi	r24, 0x01	; 1
    36b6:	90 e0       	ldi	r25, 0x00	; 0
    36b8:	02 2e       	mov	r0, r18
    36ba:	02 c0       	rjmp	.+4      	; 0x36c0 <MCAL_DIO_u8SetPinValue+0x156>
    36bc:	88 0f       	add	r24, r24
    36be:	99 1f       	adc	r25, r25
    36c0:	0a 94       	dec	r0
    36c2:	e2 f7       	brpl	.-8      	; 0x36bc <MCAL_DIO_u8SetPinValue+0x152>
    36c4:	80 95       	com	r24
    36c6:	84 23       	and	r24, r20
    36c8:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    36ca:	19 82       	std	Y+1, r1	; 0x01
    36cc:	31 c0       	rjmp	.+98     	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    36ce:	8a 81       	ldd	r24, Y+2	; 0x02
    36d0:	82 30       	cpi	r24, 0x02	; 2
    36d2:	b1 f4       	brne	.+44     	; 0x3700 <MCAL_DIO_u8SetPinValue+0x196>
				CLR_BIT(PORTC, Loc_u8PinID);
    36d4:	a5 e3       	ldi	r26, 0x35	; 53
    36d6:	b0 e0       	ldi	r27, 0x00	; 0
    36d8:	e5 e3       	ldi	r30, 0x35	; 53
    36da:	f0 e0       	ldi	r31, 0x00	; 0
    36dc:	80 81       	ld	r24, Z
    36de:	48 2f       	mov	r20, r24
    36e0:	8b 81       	ldd	r24, Y+3	; 0x03
    36e2:	28 2f       	mov	r18, r24
    36e4:	30 e0       	ldi	r19, 0x00	; 0
    36e6:	81 e0       	ldi	r24, 0x01	; 1
    36e8:	90 e0       	ldi	r25, 0x00	; 0
    36ea:	02 2e       	mov	r0, r18
    36ec:	02 c0       	rjmp	.+4      	; 0x36f2 <MCAL_DIO_u8SetPinValue+0x188>
    36ee:	88 0f       	add	r24, r24
    36f0:	99 1f       	adc	r25, r25
    36f2:	0a 94       	dec	r0
    36f4:	e2 f7       	brpl	.-8      	; 0x36ee <MCAL_DIO_u8SetPinValue+0x184>
    36f6:	80 95       	com	r24
    36f8:	84 23       	and	r24, r20
    36fa:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    36fc:	19 82       	std	Y+1, r1	; 0x01
    36fe:	18 c0       	rjmp	.+48     	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    3700:	8a 81       	ldd	r24, Y+2	; 0x02
    3702:	83 30       	cpi	r24, 0x03	; 3
    3704:	a9 f4       	brne	.+42     	; 0x3730 <MCAL_DIO_u8SetPinValue+0x1c6>
				CLR_BIT(PORTD, Loc_u8PinID);
    3706:	a2 e3       	ldi	r26, 0x32	; 50
    3708:	b0 e0       	ldi	r27, 0x00	; 0
    370a:	e2 e3       	ldi	r30, 0x32	; 50
    370c:	f0 e0       	ldi	r31, 0x00	; 0
    370e:	80 81       	ld	r24, Z
    3710:	48 2f       	mov	r20, r24
    3712:	8b 81       	ldd	r24, Y+3	; 0x03
    3714:	28 2f       	mov	r18, r24
    3716:	30 e0       	ldi	r19, 0x00	; 0
    3718:	81 e0       	ldi	r24, 0x01	; 1
    371a:	90 e0       	ldi	r25, 0x00	; 0
    371c:	02 2e       	mov	r0, r18
    371e:	02 c0       	rjmp	.+4      	; 0x3724 <MCAL_DIO_u8SetPinValue+0x1ba>
    3720:	88 0f       	add	r24, r24
    3722:	99 1f       	adc	r25, r25
    3724:	0a 94       	dec	r0
    3726:	e2 f7       	brpl	.-8      	; 0x3720 <MCAL_DIO_u8SetPinValue+0x1b6>
    3728:	80 95       	com	r24
    372a:	84 23       	and	r24, r20
    372c:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    372e:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3730:	89 81       	ldd	r24, Y+1	; 0x01

}
    3732:	0f 90       	pop	r0
    3734:	0f 90       	pop	r0
    3736:	0f 90       	pop	r0
    3738:	0f 90       	pop	r0
    373a:	cf 91       	pop	r28
    373c:	df 91       	pop	r29
    373e:	08 95       	ret

00003740 <MCAL_DIO_u8SGetPortValue>:

STD_Type MCAL_DIO_u8SGetPortValue(u8 Loc_u8PortID, u8* Loc_u8PortValue) {
    3740:	df 93       	push	r29
    3742:	cf 93       	push	r28
    3744:	00 d0       	rcall	.+0      	; 0x3746 <MCAL_DIO_u8SGetPortValue+0x6>
    3746:	00 d0       	rcall	.+0      	; 0x3748 <MCAL_DIO_u8SGetPortValue+0x8>
    3748:	cd b7       	in	r28, 0x3d	; 61
    374a:	de b7       	in	r29, 0x3e	; 62
    374c:	8a 83       	std	Y+2, r24	; 0x02
    374e:	7c 83       	std	Y+4, r23	; 0x04
    3750:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    3752:	81 e0       	ldi	r24, 0x01	; 1
    3754:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD) {
    3756:	8a 81       	ldd	r24, Y+2	; 0x02
    3758:	84 30       	cpi	r24, 0x04	; 4
    375a:	58 f5       	brcc	.+86     	; 0x37b2 <MCAL_DIO_u8SGetPortValue+0x72>
		if (Loc_u8PortID == PortA) {
    375c:	8a 81       	ldd	r24, Y+2	; 0x02
    375e:	88 23       	and	r24, r24
    3760:	41 f4       	brne	.+16     	; 0x3772 <MCAL_DIO_u8SGetPortValue+0x32>
			*Loc_u8PortValue = PORTA;
    3762:	eb e3       	ldi	r30, 0x3B	; 59
    3764:	f0 e0       	ldi	r31, 0x00	; 0
    3766:	80 81       	ld	r24, Z
    3768:	eb 81       	ldd	r30, Y+3	; 0x03
    376a:	fc 81       	ldd	r31, Y+4	; 0x04
    376c:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    376e:	19 82       	std	Y+1, r1	; 0x01
    3770:	20 c0       	rjmp	.+64     	; 0x37b2 <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortB) {
    3772:	8a 81       	ldd	r24, Y+2	; 0x02
    3774:	81 30       	cpi	r24, 0x01	; 1
    3776:	41 f4       	brne	.+16     	; 0x3788 <MCAL_DIO_u8SGetPortValue+0x48>
			*Loc_u8PortValue = PORTB;
    3778:	e8 e3       	ldi	r30, 0x38	; 56
    377a:	f0 e0       	ldi	r31, 0x00	; 0
    377c:	80 81       	ld	r24, Z
    377e:	eb 81       	ldd	r30, Y+3	; 0x03
    3780:	fc 81       	ldd	r31, Y+4	; 0x04
    3782:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3784:	19 82       	std	Y+1, r1	; 0x01
    3786:	15 c0       	rjmp	.+42     	; 0x37b2 <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortC) {
    3788:	8a 81       	ldd	r24, Y+2	; 0x02
    378a:	82 30       	cpi	r24, 0x02	; 2
    378c:	41 f4       	brne	.+16     	; 0x379e <MCAL_DIO_u8SGetPortValue+0x5e>
			*Loc_u8PortValue = PORTC;
    378e:	e5 e3       	ldi	r30, 0x35	; 53
    3790:	f0 e0       	ldi	r31, 0x00	; 0
    3792:	80 81       	ld	r24, Z
    3794:	eb 81       	ldd	r30, Y+3	; 0x03
    3796:	fc 81       	ldd	r31, Y+4	; 0x04
    3798:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    379a:	19 82       	std	Y+1, r1	; 0x01
    379c:	0a c0       	rjmp	.+20     	; 0x37b2 <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortD) {
    379e:	8a 81       	ldd	r24, Y+2	; 0x02
    37a0:	83 30       	cpi	r24, 0x03	; 3
    37a2:	39 f4       	brne	.+14     	; 0x37b2 <MCAL_DIO_u8SGetPortValue+0x72>
			*Loc_u8PortValue = PORTD;
    37a4:	e2 e3       	ldi	r30, 0x32	; 50
    37a6:	f0 e0       	ldi	r31, 0x00	; 0
    37a8:	80 81       	ld	r24, Z
    37aa:	eb 81       	ldd	r30, Y+3	; 0x03
    37ac:	fc 81       	ldd	r31, Y+4	; 0x04
    37ae:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    37b0:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    37b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    37b4:	0f 90       	pop	r0
    37b6:	0f 90       	pop	r0
    37b8:	0f 90       	pop	r0
    37ba:	0f 90       	pop	r0
    37bc:	cf 91       	pop	r28
    37be:	df 91       	pop	r29
    37c0:	08 95       	ret

000037c2 <MCAL_DIO_u8GetPinValue>:

STD_Type MCAL_DIO_u8GetPinValue(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8* Loc_u8PinValue) {
    37c2:	df 93       	push	r29
    37c4:	cf 93       	push	r28
    37c6:	00 d0       	rcall	.+0      	; 0x37c8 <MCAL_DIO_u8GetPinValue+0x6>
    37c8:	00 d0       	rcall	.+0      	; 0x37ca <MCAL_DIO_u8GetPinValue+0x8>
    37ca:	0f 92       	push	r0
    37cc:	cd b7       	in	r28, 0x3d	; 61
    37ce:	de b7       	in	r29, 0x3e	; 62
    37d0:	8a 83       	std	Y+2, r24	; 0x02
    37d2:	6b 83       	std	Y+3, r22	; 0x03
    37d4:	5d 83       	std	Y+5, r21	; 0x05
    37d6:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    37d8:	81 e0       	ldi	r24, 0x01	; 1
    37da:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins) {
    37dc:	8a 81       	ldd	r24, Y+2	; 0x02
    37de:	84 30       	cpi	r24, 0x04	; 4
    37e0:	08 f0       	brcs	.+2      	; 0x37e4 <MCAL_DIO_u8GetPinValue+0x22>
    37e2:	63 c0       	rjmp	.+198    	; 0x38aa <MCAL_DIO_u8GetPinValue+0xe8>
    37e4:	8b 81       	ldd	r24, Y+3	; 0x03
    37e6:	88 30       	cpi	r24, 0x08	; 8
    37e8:	08 f0       	brcs	.+2      	; 0x37ec <MCAL_DIO_u8GetPinValue+0x2a>
    37ea:	5f c0       	rjmp	.+190    	; 0x38aa <MCAL_DIO_u8GetPinValue+0xe8>
		if (Loc_u8PortID == PortA) {
    37ec:	8a 81       	ldd	r24, Y+2	; 0x02
    37ee:	88 23       	and	r24, r24
    37f0:	a9 f4       	brne	.+42     	; 0x381c <MCAL_DIO_u8GetPinValue+0x5a>
			*Loc_u8PinValue = GET_BIT(PINA, Loc_u8PinID);
    37f2:	e9 e3       	ldi	r30, 0x39	; 57
    37f4:	f0 e0       	ldi	r31, 0x00	; 0
    37f6:	80 81       	ld	r24, Z
    37f8:	28 2f       	mov	r18, r24
    37fa:	30 e0       	ldi	r19, 0x00	; 0
    37fc:	8b 81       	ldd	r24, Y+3	; 0x03
    37fe:	88 2f       	mov	r24, r24
    3800:	90 e0       	ldi	r25, 0x00	; 0
    3802:	a9 01       	movw	r20, r18
    3804:	02 c0       	rjmp	.+4      	; 0x380a <MCAL_DIO_u8GetPinValue+0x48>
    3806:	55 95       	asr	r21
    3808:	47 95       	ror	r20
    380a:	8a 95       	dec	r24
    380c:	e2 f7       	brpl	.-8      	; 0x3806 <MCAL_DIO_u8GetPinValue+0x44>
    380e:	ca 01       	movw	r24, r20
    3810:	81 70       	andi	r24, 0x01	; 1
    3812:	ec 81       	ldd	r30, Y+4	; 0x04
    3814:	fd 81       	ldd	r31, Y+5	; 0x05
    3816:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3818:	19 82       	std	Y+1, r1	; 0x01
    381a:	47 c0       	rjmp	.+142    	; 0x38aa <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortB) {
    381c:	8a 81       	ldd	r24, Y+2	; 0x02
    381e:	81 30       	cpi	r24, 0x01	; 1
    3820:	a9 f4       	brne	.+42     	; 0x384c <MCAL_DIO_u8GetPinValue+0x8a>
			*Loc_u8PinValue = GET_BIT(PINB, Loc_u8PinID);
    3822:	e6 e3       	ldi	r30, 0x36	; 54
    3824:	f0 e0       	ldi	r31, 0x00	; 0
    3826:	80 81       	ld	r24, Z
    3828:	28 2f       	mov	r18, r24
    382a:	30 e0       	ldi	r19, 0x00	; 0
    382c:	8b 81       	ldd	r24, Y+3	; 0x03
    382e:	88 2f       	mov	r24, r24
    3830:	90 e0       	ldi	r25, 0x00	; 0
    3832:	a9 01       	movw	r20, r18
    3834:	02 c0       	rjmp	.+4      	; 0x383a <MCAL_DIO_u8GetPinValue+0x78>
    3836:	55 95       	asr	r21
    3838:	47 95       	ror	r20
    383a:	8a 95       	dec	r24
    383c:	e2 f7       	brpl	.-8      	; 0x3836 <MCAL_DIO_u8GetPinValue+0x74>
    383e:	ca 01       	movw	r24, r20
    3840:	81 70       	andi	r24, 0x01	; 1
    3842:	ec 81       	ldd	r30, Y+4	; 0x04
    3844:	fd 81       	ldd	r31, Y+5	; 0x05
    3846:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3848:	19 82       	std	Y+1, r1	; 0x01
    384a:	2f c0       	rjmp	.+94     	; 0x38aa <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortC) {
    384c:	8a 81       	ldd	r24, Y+2	; 0x02
    384e:	82 30       	cpi	r24, 0x02	; 2
    3850:	a9 f4       	brne	.+42     	; 0x387c <MCAL_DIO_u8GetPinValue+0xba>
			*Loc_u8PinValue = GET_BIT(PINC, Loc_u8PinID);
    3852:	e3 e3       	ldi	r30, 0x33	; 51
    3854:	f0 e0       	ldi	r31, 0x00	; 0
    3856:	80 81       	ld	r24, Z
    3858:	28 2f       	mov	r18, r24
    385a:	30 e0       	ldi	r19, 0x00	; 0
    385c:	8b 81       	ldd	r24, Y+3	; 0x03
    385e:	88 2f       	mov	r24, r24
    3860:	90 e0       	ldi	r25, 0x00	; 0
    3862:	a9 01       	movw	r20, r18
    3864:	02 c0       	rjmp	.+4      	; 0x386a <MCAL_DIO_u8GetPinValue+0xa8>
    3866:	55 95       	asr	r21
    3868:	47 95       	ror	r20
    386a:	8a 95       	dec	r24
    386c:	e2 f7       	brpl	.-8      	; 0x3866 <MCAL_DIO_u8GetPinValue+0xa4>
    386e:	ca 01       	movw	r24, r20
    3870:	81 70       	andi	r24, 0x01	; 1
    3872:	ec 81       	ldd	r30, Y+4	; 0x04
    3874:	fd 81       	ldd	r31, Y+5	; 0x05
    3876:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    3878:	19 82       	std	Y+1, r1	; 0x01
    387a:	17 c0       	rjmp	.+46     	; 0x38aa <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortD) {
    387c:	8a 81       	ldd	r24, Y+2	; 0x02
    387e:	83 30       	cpi	r24, 0x03	; 3
    3880:	a1 f4       	brne	.+40     	; 0x38aa <MCAL_DIO_u8GetPinValue+0xe8>
			*Loc_u8PinValue = GET_BIT(PIND, Loc_u8PinID);
    3882:	e0 e3       	ldi	r30, 0x30	; 48
    3884:	f0 e0       	ldi	r31, 0x00	; 0
    3886:	80 81       	ld	r24, Z
    3888:	28 2f       	mov	r18, r24
    388a:	30 e0       	ldi	r19, 0x00	; 0
    388c:	8b 81       	ldd	r24, Y+3	; 0x03
    388e:	88 2f       	mov	r24, r24
    3890:	90 e0       	ldi	r25, 0x00	; 0
    3892:	a9 01       	movw	r20, r18
    3894:	02 c0       	rjmp	.+4      	; 0x389a <MCAL_DIO_u8GetPinValue+0xd8>
    3896:	55 95       	asr	r21
    3898:	47 95       	ror	r20
    389a:	8a 95       	dec	r24
    389c:	e2 f7       	brpl	.-8      	; 0x3896 <MCAL_DIO_u8GetPinValue+0xd4>
    389e:	ca 01       	movw	r24, r20
    38a0:	81 70       	andi	r24, 0x01	; 1
    38a2:	ec 81       	ldd	r30, Y+4	; 0x04
    38a4:	fd 81       	ldd	r31, Y+5	; 0x05
    38a6:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    38a8:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    38aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    38ac:	0f 90       	pop	r0
    38ae:	0f 90       	pop	r0
    38b0:	0f 90       	pop	r0
    38b2:	0f 90       	pop	r0
    38b4:	0f 90       	pop	r0
    38b6:	cf 91       	pop	r28
    38b8:	df 91       	pop	r29
    38ba:	08 95       	ret

000038bc <MCAL_DIO_u8TogglePortValue>:

STD_Type MCAL_DIO_u8TogglePortValue(u8 Loc_u8PortID) {
    38bc:	df 93       	push	r29
    38be:	cf 93       	push	r28
    38c0:	00 d0       	rcall	.+0      	; 0x38c2 <MCAL_DIO_u8TogglePortValue+0x6>
    38c2:	cd b7       	in	r28, 0x3d	; 61
    38c4:	de b7       	in	r29, 0x3e	; 62
    38c6:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Return_Value = E_NOT_OK;
    38c8:	81 e0       	ldi	r24, 0x01	; 1
    38ca:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD) {
    38cc:	8a 81       	ldd	r24, Y+2	; 0x02
    38ce:	84 30       	cpi	r24, 0x04	; 4
    38d0:	78 f5       	brcc	.+94     	; 0x3930 <MCAL_DIO_u8TogglePortValue+0x74>
		if (Loc_u8PortID == PortA) {
    38d2:	8a 81       	ldd	r24, Y+2	; 0x02
    38d4:	88 23       	and	r24, r24
    38d6:	49 f4       	brne	.+18     	; 0x38ea <MCAL_DIO_u8TogglePortValue+0x2e>
			PORTA = ~PORTA;
    38d8:	ab e3       	ldi	r26, 0x3B	; 59
    38da:	b0 e0       	ldi	r27, 0x00	; 0
    38dc:	eb e3       	ldi	r30, 0x3B	; 59
    38de:	f0 e0       	ldi	r31, 0x00	; 0
    38e0:	80 81       	ld	r24, Z
    38e2:	80 95       	com	r24
    38e4:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    38e6:	19 82       	std	Y+1, r1	; 0x01
    38e8:	23 c0       	rjmp	.+70     	; 0x3930 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortB) {
    38ea:	8a 81       	ldd	r24, Y+2	; 0x02
    38ec:	81 30       	cpi	r24, 0x01	; 1
    38ee:	49 f4       	brne	.+18     	; 0x3902 <MCAL_DIO_u8TogglePortValue+0x46>
			PORTB = ~PORTB;
    38f0:	a8 e3       	ldi	r26, 0x38	; 56
    38f2:	b0 e0       	ldi	r27, 0x00	; 0
    38f4:	e8 e3       	ldi	r30, 0x38	; 56
    38f6:	f0 e0       	ldi	r31, 0x00	; 0
    38f8:	80 81       	ld	r24, Z
    38fa:	80 95       	com	r24
    38fc:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    38fe:	19 82       	std	Y+1, r1	; 0x01
    3900:	17 c0       	rjmp	.+46     	; 0x3930 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortC) {
    3902:	8a 81       	ldd	r24, Y+2	; 0x02
    3904:	82 30       	cpi	r24, 0x02	; 2
    3906:	49 f4       	brne	.+18     	; 0x391a <MCAL_DIO_u8TogglePortValue+0x5e>
			PORTC = ~PORTC;
    3908:	a5 e3       	ldi	r26, 0x35	; 53
    390a:	b0 e0       	ldi	r27, 0x00	; 0
    390c:	e5 e3       	ldi	r30, 0x35	; 53
    390e:	f0 e0       	ldi	r31, 0x00	; 0
    3910:	80 81       	ld	r24, Z
    3912:	80 95       	com	r24
    3914:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3916:	19 82       	std	Y+1, r1	; 0x01
    3918:	0b c0       	rjmp	.+22     	; 0x3930 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortD) {
    391a:	8a 81       	ldd	r24, Y+2	; 0x02
    391c:	83 30       	cpi	r24, 0x03	; 3
    391e:	41 f4       	brne	.+16     	; 0x3930 <MCAL_DIO_u8TogglePortValue+0x74>
			PORTD = ~PORTD;
    3920:	a2 e3       	ldi	r26, 0x32	; 50
    3922:	b0 e0       	ldi	r27, 0x00	; 0
    3924:	e2 e3       	ldi	r30, 0x32	; 50
    3926:	f0 e0       	ldi	r31, 0x00	; 0
    3928:	80 81       	ld	r24, Z
    392a:	80 95       	com	r24
    392c:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    392e:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3930:	89 81       	ldd	r24, Y+1	; 0x01
}
    3932:	0f 90       	pop	r0
    3934:	0f 90       	pop	r0
    3936:	cf 91       	pop	r28
    3938:	df 91       	pop	r29
    393a:	08 95       	ret

0000393c <MCAL_DIO_u8TogglePinValue>:

STD_Type MCAL_DIO_u8TogglePinValue(u8 Loc_u8PortID, u8 Loc_u8PinID) {
    393c:	df 93       	push	r29
    393e:	cf 93       	push	r28
    3940:	00 d0       	rcall	.+0      	; 0x3942 <MCAL_DIO_u8TogglePinValue+0x6>
    3942:	0f 92       	push	r0
    3944:	cd b7       	in	r28, 0x3d	; 61
    3946:	de b7       	in	r29, 0x3e	; 62
    3948:	8a 83       	std	Y+2, r24	; 0x02
    394a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    394c:	81 e0       	ldi	r24, 0x01	; 1
    394e:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins) {
    3950:	8a 81       	ldd	r24, Y+2	; 0x02
    3952:	84 30       	cpi	r24, 0x04	; 4
    3954:	08 f0       	brcs	.+2      	; 0x3958 <MCAL_DIO_u8TogglePinValue+0x1c>
    3956:	63 c0       	rjmp	.+198    	; 0x3a1e <MCAL_DIO_u8TogglePinValue+0xe2>
    3958:	8b 81       	ldd	r24, Y+3	; 0x03
    395a:	88 30       	cpi	r24, 0x08	; 8
    395c:	08 f0       	brcs	.+2      	; 0x3960 <MCAL_DIO_u8TogglePinValue+0x24>
    395e:	5f c0       	rjmp	.+190    	; 0x3a1e <MCAL_DIO_u8TogglePinValue+0xe2>
		if (Loc_u8PortID == PortA) {
    3960:	8a 81       	ldd	r24, Y+2	; 0x02
    3962:	88 23       	and	r24, r24
    3964:	a9 f4       	brne	.+42     	; 0x3990 <MCAL_DIO_u8TogglePinValue+0x54>
			TOGGLE_BIT(PORTA, Loc_u8PinID);
    3966:	ab e3       	ldi	r26, 0x3B	; 59
    3968:	b0 e0       	ldi	r27, 0x00	; 0
    396a:	eb e3       	ldi	r30, 0x3B	; 59
    396c:	f0 e0       	ldi	r31, 0x00	; 0
    396e:	80 81       	ld	r24, Z
    3970:	48 2f       	mov	r20, r24
    3972:	8b 81       	ldd	r24, Y+3	; 0x03
    3974:	28 2f       	mov	r18, r24
    3976:	30 e0       	ldi	r19, 0x00	; 0
    3978:	81 e0       	ldi	r24, 0x01	; 1
    397a:	90 e0       	ldi	r25, 0x00	; 0
    397c:	02 2e       	mov	r0, r18
    397e:	02 c0       	rjmp	.+4      	; 0x3984 <MCAL_DIO_u8TogglePinValue+0x48>
    3980:	88 0f       	add	r24, r24
    3982:	99 1f       	adc	r25, r25
    3984:	0a 94       	dec	r0
    3986:	e2 f7       	brpl	.-8      	; 0x3980 <MCAL_DIO_u8TogglePinValue+0x44>
    3988:	84 27       	eor	r24, r20
    398a:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    398c:	19 82       	std	Y+1, r1	; 0x01
    398e:	47 c0       	rjmp	.+142    	; 0x3a1e <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortB) {
    3990:	8a 81       	ldd	r24, Y+2	; 0x02
    3992:	81 30       	cpi	r24, 0x01	; 1
    3994:	a9 f4       	brne	.+42     	; 0x39c0 <MCAL_DIO_u8TogglePinValue+0x84>
			TOGGLE_BIT(PORTB, Loc_u8PinID);
    3996:	a8 e3       	ldi	r26, 0x38	; 56
    3998:	b0 e0       	ldi	r27, 0x00	; 0
    399a:	e8 e3       	ldi	r30, 0x38	; 56
    399c:	f0 e0       	ldi	r31, 0x00	; 0
    399e:	80 81       	ld	r24, Z
    39a0:	48 2f       	mov	r20, r24
    39a2:	8b 81       	ldd	r24, Y+3	; 0x03
    39a4:	28 2f       	mov	r18, r24
    39a6:	30 e0       	ldi	r19, 0x00	; 0
    39a8:	81 e0       	ldi	r24, 0x01	; 1
    39aa:	90 e0       	ldi	r25, 0x00	; 0
    39ac:	02 2e       	mov	r0, r18
    39ae:	02 c0       	rjmp	.+4      	; 0x39b4 <MCAL_DIO_u8TogglePinValue+0x78>
    39b0:	88 0f       	add	r24, r24
    39b2:	99 1f       	adc	r25, r25
    39b4:	0a 94       	dec	r0
    39b6:	e2 f7       	brpl	.-8      	; 0x39b0 <MCAL_DIO_u8TogglePinValue+0x74>
    39b8:	84 27       	eor	r24, r20
    39ba:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    39bc:	19 82       	std	Y+1, r1	; 0x01
    39be:	2f c0       	rjmp	.+94     	; 0x3a1e <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortC) {
    39c0:	8a 81       	ldd	r24, Y+2	; 0x02
    39c2:	82 30       	cpi	r24, 0x02	; 2
    39c4:	a9 f4       	brne	.+42     	; 0x39f0 <MCAL_DIO_u8TogglePinValue+0xb4>
			TOGGLE_BIT(PORTC, Loc_u8PinID);
    39c6:	a5 e3       	ldi	r26, 0x35	; 53
    39c8:	b0 e0       	ldi	r27, 0x00	; 0
    39ca:	e5 e3       	ldi	r30, 0x35	; 53
    39cc:	f0 e0       	ldi	r31, 0x00	; 0
    39ce:	80 81       	ld	r24, Z
    39d0:	48 2f       	mov	r20, r24
    39d2:	8b 81       	ldd	r24, Y+3	; 0x03
    39d4:	28 2f       	mov	r18, r24
    39d6:	30 e0       	ldi	r19, 0x00	; 0
    39d8:	81 e0       	ldi	r24, 0x01	; 1
    39da:	90 e0       	ldi	r25, 0x00	; 0
    39dc:	02 2e       	mov	r0, r18
    39de:	02 c0       	rjmp	.+4      	; 0x39e4 <MCAL_DIO_u8TogglePinValue+0xa8>
    39e0:	88 0f       	add	r24, r24
    39e2:	99 1f       	adc	r25, r25
    39e4:	0a 94       	dec	r0
    39e6:	e2 f7       	brpl	.-8      	; 0x39e0 <MCAL_DIO_u8TogglePinValue+0xa4>
    39e8:	84 27       	eor	r24, r20
    39ea:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    39ec:	19 82       	std	Y+1, r1	; 0x01
    39ee:	17 c0       	rjmp	.+46     	; 0x3a1e <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortD) {
    39f0:	8a 81       	ldd	r24, Y+2	; 0x02
    39f2:	83 30       	cpi	r24, 0x03	; 3
    39f4:	a1 f4       	brne	.+40     	; 0x3a1e <MCAL_DIO_u8TogglePinValue+0xe2>
			TOGGLE_BIT(PORTD, Loc_u8PinID);
    39f6:	a2 e3       	ldi	r26, 0x32	; 50
    39f8:	b0 e0       	ldi	r27, 0x00	; 0
    39fa:	e2 e3       	ldi	r30, 0x32	; 50
    39fc:	f0 e0       	ldi	r31, 0x00	; 0
    39fe:	80 81       	ld	r24, Z
    3a00:	48 2f       	mov	r20, r24
    3a02:	8b 81       	ldd	r24, Y+3	; 0x03
    3a04:	28 2f       	mov	r18, r24
    3a06:	30 e0       	ldi	r19, 0x00	; 0
    3a08:	81 e0       	ldi	r24, 0x01	; 1
    3a0a:	90 e0       	ldi	r25, 0x00	; 0
    3a0c:	02 2e       	mov	r0, r18
    3a0e:	02 c0       	rjmp	.+4      	; 0x3a14 <MCAL_DIO_u8TogglePinValue+0xd8>
    3a10:	88 0f       	add	r24, r24
    3a12:	99 1f       	adc	r25, r25
    3a14:	0a 94       	dec	r0
    3a16:	e2 f7       	brpl	.-8      	; 0x3a10 <MCAL_DIO_u8TogglePinValue+0xd4>
    3a18:	84 27       	eor	r24, r20
    3a1a:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    3a1c:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3a1e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a20:	0f 90       	pop	r0
    3a22:	0f 90       	pop	r0
    3a24:	0f 90       	pop	r0
    3a26:	cf 91       	pop	r28
    3a28:	df 91       	pop	r29
    3a2a:	08 95       	ret

00003a2c <MCAL_ADC_u8SetRegister>:

#include "ADC.h"

void (*Gptr_ADC)(void)= '\0' ;

void MCAL_ADC_u8SetRegister(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    3a2c:	df 93       	push	r29
    3a2e:	cf 93       	push	r28
    3a30:	00 d0       	rcall	.+0      	; 0x3a32 <MCAL_ADC_u8SetRegister+0x6>
    3a32:	cd b7       	in	r28, 0x3d	; 61
    3a34:	de b7       	in	r29, 0x3e	; 62
    3a36:	89 83       	std	Y+1, r24	; 0x01
    3a38:	6a 83       	std	Y+2, r22	; 0x02
	if (Loc_u8PortValue == PORT_OUTPUT) {
    3a3a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a3c:	8f 3f       	cpi	r24, 0xFF	; 255
    3a3e:	c1 f4       	brne	.+48     	; 0x3a70 <MCAL_ADC_u8SetRegister+0x44>
		if (Loc_u8PortID == Admux) {
    3a40:	89 81       	ldd	r24, Y+1	; 0x01
    3a42:	88 23       	and	r24, r24
    3a44:	29 f4       	brne	.+10     	; 0x3a50 <MCAL_ADC_u8SetRegister+0x24>
			ADMUX = PORT_OUTPUT;
    3a46:	e7 e2       	ldi	r30, 0x27	; 39
    3a48:	f0 e0       	ldi	r31, 0x00	; 0
    3a4a:	8f ef       	ldi	r24, 0xFF	; 255
    3a4c:	80 83       	st	Z, r24
    3a4e:	3f c0       	rjmp	.+126    	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Adcsra) {
    3a50:	89 81       	ldd	r24, Y+1	; 0x01
    3a52:	81 30       	cpi	r24, 0x01	; 1
    3a54:	29 f4       	brne	.+10     	; 0x3a60 <MCAL_ADC_u8SetRegister+0x34>
			ADCSRA = PORT_OUTPUT;
    3a56:	e6 e2       	ldi	r30, 0x26	; 38
    3a58:	f0 e0       	ldi	r31, 0x00	; 0
    3a5a:	8f ef       	ldi	r24, 0xFF	; 255
    3a5c:	80 83       	st	Z, r24
    3a5e:	37 c0       	rjmp	.+110    	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Sfior) {
    3a60:	89 81       	ldd	r24, Y+1	; 0x01
    3a62:	82 30       	cpi	r24, 0x02	; 2
    3a64:	a1 f5       	brne	.+104    	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
			SFIOR = PORT_OUTPUT;
    3a66:	e0 e5       	ldi	r30, 0x50	; 80
    3a68:	f0 e0       	ldi	r31, 0x00	; 0
    3a6a:	8f ef       	ldi	r24, 0xFF	; 255
    3a6c:	80 83       	st	Z, r24
    3a6e:	2f c0       	rjmp	.+94     	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PortValue == PORT_INPUT) {
    3a70:	8a 81       	ldd	r24, Y+2	; 0x02
    3a72:	88 23       	and	r24, r24
    3a74:	a9 f4       	brne	.+42     	; 0x3aa0 <MCAL_ADC_u8SetRegister+0x74>
		if (Loc_u8PortID == Admux) {
    3a76:	89 81       	ldd	r24, Y+1	; 0x01
    3a78:	88 23       	and	r24, r24
    3a7a:	21 f4       	brne	.+8      	; 0x3a84 <MCAL_ADC_u8SetRegister+0x58>
			ADMUX = PORT_INPUT;
    3a7c:	e7 e2       	ldi	r30, 0x27	; 39
    3a7e:	f0 e0       	ldi	r31, 0x00	; 0
    3a80:	10 82       	st	Z, r1
    3a82:	25 c0       	rjmp	.+74     	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Adcsra) {
    3a84:	89 81       	ldd	r24, Y+1	; 0x01
    3a86:	81 30       	cpi	r24, 0x01	; 1
    3a88:	21 f4       	brne	.+8      	; 0x3a92 <MCAL_ADC_u8SetRegister+0x66>
			ADCSRA = PORT_INPUT;
    3a8a:	e6 e2       	ldi	r30, 0x26	; 38
    3a8c:	f0 e0       	ldi	r31, 0x00	; 0
    3a8e:	10 82       	st	Z, r1
    3a90:	1e c0       	rjmp	.+60     	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Sfior) {
    3a92:	89 81       	ldd	r24, Y+1	; 0x01
    3a94:	82 30       	cpi	r24, 0x02	; 2
    3a96:	d9 f4       	brne	.+54     	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
			SFIOR = PORT_INPUT;
    3a98:	e0 e5       	ldi	r30, 0x50	; 80
    3a9a:	f0 e0       	ldi	r31, 0x00	; 0
    3a9c:	10 82       	st	Z, r1
    3a9e:	17 c0       	rjmp	.+46     	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
		} else {
			//Do Nothing
		}
	} else {
		if (Loc_u8PortID == Admux) {
    3aa0:	89 81       	ldd	r24, Y+1	; 0x01
    3aa2:	88 23       	and	r24, r24
    3aa4:	29 f4       	brne	.+10     	; 0x3ab0 <MCAL_ADC_u8SetRegister+0x84>
			ADMUX = Loc_u8PortValue;
    3aa6:	e7 e2       	ldi	r30, 0x27	; 39
    3aa8:	f0 e0       	ldi	r31, 0x00	; 0
    3aaa:	8a 81       	ldd	r24, Y+2	; 0x02
    3aac:	80 83       	st	Z, r24
    3aae:	0f c0       	rjmp	.+30     	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Adcsra) {
    3ab0:	89 81       	ldd	r24, Y+1	; 0x01
    3ab2:	81 30       	cpi	r24, 0x01	; 1
    3ab4:	29 f4       	brne	.+10     	; 0x3ac0 <MCAL_ADC_u8SetRegister+0x94>
			ADCSRA = Loc_u8PortValue;
    3ab6:	e6 e2       	ldi	r30, 0x26	; 38
    3ab8:	f0 e0       	ldi	r31, 0x00	; 0
    3aba:	8a 81       	ldd	r24, Y+2	; 0x02
    3abc:	80 83       	st	Z, r24
    3abe:	07 c0       	rjmp	.+14     	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Sfior) {
    3ac0:	89 81       	ldd	r24, Y+1	; 0x01
    3ac2:	82 30       	cpi	r24, 0x02	; 2
    3ac4:	21 f4       	brne	.+8      	; 0x3ace <MCAL_ADC_u8SetRegister+0xa2>
			SFIOR = Loc_u8PortValue;
    3ac6:	e0 e5       	ldi	r30, 0x50	; 80
    3ac8:	f0 e0       	ldi	r31, 0x00	; 0
    3aca:	8a 81       	ldd	r24, Y+2	; 0x02
    3acc:	80 83       	st	Z, r24
		}
	}
}
    3ace:	0f 90       	pop	r0
    3ad0:	0f 90       	pop	r0
    3ad2:	cf 91       	pop	r28
    3ad4:	df 91       	pop	r29
    3ad6:	08 95       	ret

00003ad8 <MCAL_ADC_u8SetRegisterPin>:

void MCAL_ADC_u8SetRegisterPin(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    3ad8:	df 93       	push	r29
    3ada:	cf 93       	push	r28
    3adc:	00 d0       	rcall	.+0      	; 0x3ade <MCAL_ADC_u8SetRegisterPin+0x6>
    3ade:	0f 92       	push	r0
    3ae0:	cd b7       	in	r28, 0x3d	; 61
    3ae2:	de b7       	in	r29, 0x3e	; 62
    3ae4:	89 83       	std	Y+1, r24	; 0x01
    3ae6:	6a 83       	std	Y+2, r22	; 0x02
    3ae8:	4b 83       	std	Y+3, r20	; 0x03
	if (Loc_u8PinValue == Pin_High) {
    3aea:	8b 81       	ldd	r24, Y+3	; 0x03
    3aec:	81 30       	cpi	r24, 0x01	; 1
    3aee:	09 f0       	breq	.+2      	; 0x3af2 <MCAL_ADC_u8SetRegisterPin+0x1a>
    3af0:	46 c0       	rjmp	.+140    	; 0x3b7e <MCAL_ADC_u8SetRegisterPin+0xa6>
		if (Loc_u8PortID == Admux) {
    3af2:	89 81       	ldd	r24, Y+1	; 0x01
    3af4:	88 23       	and	r24, r24
    3af6:	a1 f4       	brne	.+40     	; 0x3b20 <MCAL_ADC_u8SetRegisterPin+0x48>
			SET_BIT(ADMUX, Loc_u8PinID);
    3af8:	a7 e2       	ldi	r26, 0x27	; 39
    3afa:	b0 e0       	ldi	r27, 0x00	; 0
    3afc:	e7 e2       	ldi	r30, 0x27	; 39
    3afe:	f0 e0       	ldi	r31, 0x00	; 0
    3b00:	80 81       	ld	r24, Z
    3b02:	48 2f       	mov	r20, r24
    3b04:	8a 81       	ldd	r24, Y+2	; 0x02
    3b06:	28 2f       	mov	r18, r24
    3b08:	30 e0       	ldi	r19, 0x00	; 0
    3b0a:	81 e0       	ldi	r24, 0x01	; 1
    3b0c:	90 e0       	ldi	r25, 0x00	; 0
    3b0e:	02 2e       	mov	r0, r18
    3b10:	02 c0       	rjmp	.+4      	; 0x3b16 <MCAL_ADC_u8SetRegisterPin+0x3e>
    3b12:	88 0f       	add	r24, r24
    3b14:	99 1f       	adc	r25, r25
    3b16:	0a 94       	dec	r0
    3b18:	e2 f7       	brpl	.-8      	; 0x3b12 <MCAL_ADC_u8SetRegisterPin+0x3a>
    3b1a:	84 2b       	or	r24, r20
    3b1c:	8c 93       	st	X, r24
    3b1e:	7a c0       	rjmp	.+244    	; 0x3c14 <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else if (Loc_u8PortID == Adcsra) {
    3b20:	89 81       	ldd	r24, Y+1	; 0x01
    3b22:	81 30       	cpi	r24, 0x01	; 1
    3b24:	a1 f4       	brne	.+40     	; 0x3b4e <MCAL_ADC_u8SetRegisterPin+0x76>
			SET_BIT(ADCSRA, Loc_u8PinID);
    3b26:	a6 e2       	ldi	r26, 0x26	; 38
    3b28:	b0 e0       	ldi	r27, 0x00	; 0
    3b2a:	e6 e2       	ldi	r30, 0x26	; 38
    3b2c:	f0 e0       	ldi	r31, 0x00	; 0
    3b2e:	80 81       	ld	r24, Z
    3b30:	48 2f       	mov	r20, r24
    3b32:	8a 81       	ldd	r24, Y+2	; 0x02
    3b34:	28 2f       	mov	r18, r24
    3b36:	30 e0       	ldi	r19, 0x00	; 0
    3b38:	81 e0       	ldi	r24, 0x01	; 1
    3b3a:	90 e0       	ldi	r25, 0x00	; 0
    3b3c:	02 2e       	mov	r0, r18
    3b3e:	02 c0       	rjmp	.+4      	; 0x3b44 <MCAL_ADC_u8SetRegisterPin+0x6c>
    3b40:	88 0f       	add	r24, r24
    3b42:	99 1f       	adc	r25, r25
    3b44:	0a 94       	dec	r0
    3b46:	e2 f7       	brpl	.-8      	; 0x3b40 <MCAL_ADC_u8SetRegisterPin+0x68>
    3b48:	84 2b       	or	r24, r20
    3b4a:	8c 93       	st	X, r24
    3b4c:	63 c0       	rjmp	.+198    	; 0x3c14 <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else if (Loc_u8PortID == Sfior) {
    3b4e:	89 81       	ldd	r24, Y+1	; 0x01
    3b50:	82 30       	cpi	r24, 0x02	; 2
    3b52:	09 f0       	breq	.+2      	; 0x3b56 <MCAL_ADC_u8SetRegisterPin+0x7e>
    3b54:	5f c0       	rjmp	.+190    	; 0x3c14 <MCAL_ADC_u8SetRegisterPin+0x13c>
			SET_BIT(SFIOR, Loc_u8PinID);
    3b56:	a0 e5       	ldi	r26, 0x50	; 80
    3b58:	b0 e0       	ldi	r27, 0x00	; 0
    3b5a:	e0 e5       	ldi	r30, 0x50	; 80
    3b5c:	f0 e0       	ldi	r31, 0x00	; 0
    3b5e:	80 81       	ld	r24, Z
    3b60:	48 2f       	mov	r20, r24
    3b62:	8a 81       	ldd	r24, Y+2	; 0x02
    3b64:	28 2f       	mov	r18, r24
    3b66:	30 e0       	ldi	r19, 0x00	; 0
    3b68:	81 e0       	ldi	r24, 0x01	; 1
    3b6a:	90 e0       	ldi	r25, 0x00	; 0
    3b6c:	02 2e       	mov	r0, r18
    3b6e:	02 c0       	rjmp	.+4      	; 0x3b74 <MCAL_ADC_u8SetRegisterPin+0x9c>
    3b70:	88 0f       	add	r24, r24
    3b72:	99 1f       	adc	r25, r25
    3b74:	0a 94       	dec	r0
    3b76:	e2 f7       	brpl	.-8      	; 0x3b70 <MCAL_ADC_u8SetRegisterPin+0x98>
    3b78:	84 2b       	or	r24, r20
    3b7a:	8c 93       	st	X, r24
    3b7c:	4b c0       	rjmp	.+150    	; 0x3c14 <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PinValue == Pin_Low) {
    3b7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b80:	88 23       	and	r24, r24
    3b82:	09 f0       	breq	.+2      	; 0x3b86 <MCAL_ADC_u8SetRegisterPin+0xae>
    3b84:	47 c0       	rjmp	.+142    	; 0x3c14 <MCAL_ADC_u8SetRegisterPin+0x13c>
		if (Loc_u8PortID == Admux) {
    3b86:	89 81       	ldd	r24, Y+1	; 0x01
    3b88:	88 23       	and	r24, r24
    3b8a:	a9 f4       	brne	.+42     	; 0x3bb6 <MCAL_ADC_u8SetRegisterPin+0xde>
			CLR_BIT(ADMUX, Loc_u8PinID);
    3b8c:	a7 e2       	ldi	r26, 0x27	; 39
    3b8e:	b0 e0       	ldi	r27, 0x00	; 0
    3b90:	e7 e2       	ldi	r30, 0x27	; 39
    3b92:	f0 e0       	ldi	r31, 0x00	; 0
    3b94:	80 81       	ld	r24, Z
    3b96:	48 2f       	mov	r20, r24
    3b98:	8a 81       	ldd	r24, Y+2	; 0x02
    3b9a:	28 2f       	mov	r18, r24
    3b9c:	30 e0       	ldi	r19, 0x00	; 0
    3b9e:	81 e0       	ldi	r24, 0x01	; 1
    3ba0:	90 e0       	ldi	r25, 0x00	; 0
    3ba2:	02 2e       	mov	r0, r18
    3ba4:	02 c0       	rjmp	.+4      	; 0x3baa <MCAL_ADC_u8SetRegisterPin+0xd2>
    3ba6:	88 0f       	add	r24, r24
    3ba8:	99 1f       	adc	r25, r25
    3baa:	0a 94       	dec	r0
    3bac:	e2 f7       	brpl	.-8      	; 0x3ba6 <MCAL_ADC_u8SetRegisterPin+0xce>
    3bae:	80 95       	com	r24
    3bb0:	84 23       	and	r24, r20
    3bb2:	8c 93       	st	X, r24
    3bb4:	2f c0       	rjmp	.+94     	; 0x3c14 <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else if (Loc_u8PortID == Adcsra) {
    3bb6:	89 81       	ldd	r24, Y+1	; 0x01
    3bb8:	81 30       	cpi	r24, 0x01	; 1
    3bba:	a9 f4       	brne	.+42     	; 0x3be6 <MCAL_ADC_u8SetRegisterPin+0x10e>
			CLR_BIT(ADCSRA, Loc_u8PinID);
    3bbc:	a6 e2       	ldi	r26, 0x26	; 38
    3bbe:	b0 e0       	ldi	r27, 0x00	; 0
    3bc0:	e6 e2       	ldi	r30, 0x26	; 38
    3bc2:	f0 e0       	ldi	r31, 0x00	; 0
    3bc4:	80 81       	ld	r24, Z
    3bc6:	48 2f       	mov	r20, r24
    3bc8:	8a 81       	ldd	r24, Y+2	; 0x02
    3bca:	28 2f       	mov	r18, r24
    3bcc:	30 e0       	ldi	r19, 0x00	; 0
    3bce:	81 e0       	ldi	r24, 0x01	; 1
    3bd0:	90 e0       	ldi	r25, 0x00	; 0
    3bd2:	02 2e       	mov	r0, r18
    3bd4:	02 c0       	rjmp	.+4      	; 0x3bda <MCAL_ADC_u8SetRegisterPin+0x102>
    3bd6:	88 0f       	add	r24, r24
    3bd8:	99 1f       	adc	r25, r25
    3bda:	0a 94       	dec	r0
    3bdc:	e2 f7       	brpl	.-8      	; 0x3bd6 <MCAL_ADC_u8SetRegisterPin+0xfe>
    3bde:	80 95       	com	r24
    3be0:	84 23       	and	r24, r20
    3be2:	8c 93       	st	X, r24
    3be4:	17 c0       	rjmp	.+46     	; 0x3c14 <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else if (Loc_u8PortID == Sfior) {
    3be6:	89 81       	ldd	r24, Y+1	; 0x01
    3be8:	82 30       	cpi	r24, 0x02	; 2
    3bea:	a1 f4       	brne	.+40     	; 0x3c14 <MCAL_ADC_u8SetRegisterPin+0x13c>
			CLR_BIT(SFIOR, Loc_u8PinID);
    3bec:	a0 e5       	ldi	r26, 0x50	; 80
    3bee:	b0 e0       	ldi	r27, 0x00	; 0
    3bf0:	e0 e5       	ldi	r30, 0x50	; 80
    3bf2:	f0 e0       	ldi	r31, 0x00	; 0
    3bf4:	80 81       	ld	r24, Z
    3bf6:	48 2f       	mov	r20, r24
    3bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    3bfa:	28 2f       	mov	r18, r24
    3bfc:	30 e0       	ldi	r19, 0x00	; 0
    3bfe:	81 e0       	ldi	r24, 0x01	; 1
    3c00:	90 e0       	ldi	r25, 0x00	; 0
    3c02:	02 2e       	mov	r0, r18
    3c04:	02 c0       	rjmp	.+4      	; 0x3c0a <MCAL_ADC_u8SetRegisterPin+0x132>
    3c06:	88 0f       	add	r24, r24
    3c08:	99 1f       	adc	r25, r25
    3c0a:	0a 94       	dec	r0
    3c0c:	e2 f7       	brpl	.-8      	; 0x3c06 <MCAL_ADC_u8SetRegisterPin+0x12e>
    3c0e:	80 95       	com	r24
    3c10:	84 23       	and	r24, r20
    3c12:	8c 93       	st	X, r24
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
}
    3c14:	0f 90       	pop	r0
    3c16:	0f 90       	pop	r0
    3c18:	0f 90       	pop	r0
    3c1a:	cf 91       	pop	r28
    3c1c:	df 91       	pop	r29
    3c1e:	08 95       	ret

00003c20 <MCAL_ADC_AdcInit>:

void MCAL_ADC_AdcInit(u8 Loc_u8Position) {
    3c20:	df 93       	push	r29
    3c22:	cf 93       	push	r28
    3c24:	0f 92       	push	r0
    3c26:	cd b7       	in	r28, 0x3d	; 61
    3c28:	de b7       	in	r29, 0x3e	; 62
    3c2a:	89 83       	std	Y+1, r24	; 0x01
	MCAL_ADC_u8SetRegister(Adcsra, ADCSRA_VALUE);
    3c2c:	81 e0       	ldi	r24, 0x01	; 1
    3c2e:	6f ea       	ldi	r22, 0xAF	; 175
    3c30:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
	MCAL_ADC_u8SetRegisterPin(Sfior, 7, Pin_Low);
    3c34:	82 e0       	ldi	r24, 0x02	; 2
    3c36:	67 e0       	ldi	r22, 0x07	; 7
    3c38:	40 e0       	ldi	r20, 0x00	; 0
    3c3a:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <MCAL_ADC_u8SetRegisterPin>
	MCAL_ADC_u8SetRegisterPin(Sfior, 6, Pin_Low);
    3c3e:	82 e0       	ldi	r24, 0x02	; 2
    3c40:	66 e0       	ldi	r22, 0x06	; 6
    3c42:	40 e0       	ldi	r20, 0x00	; 0
    3c44:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <MCAL_ADC_u8SetRegisterPin>
	MCAL_ADC_u8SetRegisterPin(Sfior, 5, Pin_Low);
    3c48:	82 e0       	ldi	r24, 0x02	; 2
    3c4a:	65 e0       	ldi	r22, 0x05	; 5
    3c4c:	40 e0       	ldi	r20, 0x00	; 0
    3c4e:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <MCAL_ADC_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(SREG, 7, Pin_High);
    3c52:	ef e5       	ldi	r30, 0x5F	; 95
    3c54:	f0 e0       	ldi	r31, 0x00	; 0
    3c56:	80 81       	ld	r24, Z
    3c58:	88 2f       	mov	r24, r24
    3c5a:	90 e0       	ldi	r25, 0x00	; 0
    3c5c:	67 e0       	ldi	r22, 0x07	; 7
    3c5e:	70 e0       	ldi	r23, 0x00	; 0
    3c60:	41 e0       	ldi	r20, 0x01	; 1
    3c62:	50 e0       	ldi	r21, 0x00	; 0
    3c64:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <MCAL_Interrupt_u8SetRegisterPin>
	if (Loc_u8Position == Adc_0) {
    3c68:	89 81       	ldd	r24, Y+1	; 0x01
    3c6a:	88 23       	and	r24, r24
    3c6c:	29 f4       	brne	.+10     	; 0x3c78 <MCAL_ADC_AdcInit+0x58>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc0);
    3c6e:	80 e0       	ldi	r24, 0x00	; 0
    3c70:	60 e4       	ldi	r22, 0x40	; 64
    3c72:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
    3c76:	37 c0       	rjmp	.+110    	; 0x3ce6 <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_1) {
    3c78:	89 81       	ldd	r24, Y+1	; 0x01
    3c7a:	81 30       	cpi	r24, 0x01	; 1
    3c7c:	29 f4       	brne	.+10     	; 0x3c88 <MCAL_ADC_AdcInit+0x68>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc1);
    3c7e:	80 e0       	ldi	r24, 0x00	; 0
    3c80:	61 e4       	ldi	r22, 0x41	; 65
    3c82:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
    3c86:	2f c0       	rjmp	.+94     	; 0x3ce6 <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_2) {
    3c88:	89 81       	ldd	r24, Y+1	; 0x01
    3c8a:	82 30       	cpi	r24, 0x02	; 2
    3c8c:	29 f4       	brne	.+10     	; 0x3c98 <MCAL_ADC_AdcInit+0x78>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc2);
    3c8e:	80 e0       	ldi	r24, 0x00	; 0
    3c90:	62 e4       	ldi	r22, 0x42	; 66
    3c92:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
    3c96:	27 c0       	rjmp	.+78     	; 0x3ce6 <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_3) {
    3c98:	89 81       	ldd	r24, Y+1	; 0x01
    3c9a:	83 30       	cpi	r24, 0x03	; 3
    3c9c:	29 f4       	brne	.+10     	; 0x3ca8 <MCAL_ADC_AdcInit+0x88>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc3);
    3c9e:	80 e0       	ldi	r24, 0x00	; 0
    3ca0:	63 e4       	ldi	r22, 0x43	; 67
    3ca2:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
    3ca6:	1f c0       	rjmp	.+62     	; 0x3ce6 <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_4) {
    3ca8:	89 81       	ldd	r24, Y+1	; 0x01
    3caa:	84 30       	cpi	r24, 0x04	; 4
    3cac:	29 f4       	brne	.+10     	; 0x3cb8 <MCAL_ADC_AdcInit+0x98>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc4);
    3cae:	80 e0       	ldi	r24, 0x00	; 0
    3cb0:	64 e4       	ldi	r22, 0x44	; 68
    3cb2:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
    3cb6:	17 c0       	rjmp	.+46     	; 0x3ce6 <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_5) {
    3cb8:	89 81       	ldd	r24, Y+1	; 0x01
    3cba:	85 30       	cpi	r24, 0x05	; 5
    3cbc:	29 f4       	brne	.+10     	; 0x3cc8 <MCAL_ADC_AdcInit+0xa8>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc5);
    3cbe:	80 e0       	ldi	r24, 0x00	; 0
    3cc0:	65 e4       	ldi	r22, 0x45	; 69
    3cc2:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
    3cc6:	0f c0       	rjmp	.+30     	; 0x3ce6 <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_6) {
    3cc8:	89 81       	ldd	r24, Y+1	; 0x01
    3cca:	86 30       	cpi	r24, 0x06	; 6
    3ccc:	29 f4       	brne	.+10     	; 0x3cd8 <MCAL_ADC_AdcInit+0xb8>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc6);
    3cce:	80 e0       	ldi	r24, 0x00	; 0
    3cd0:	66 e4       	ldi	r22, 0x46	; 70
    3cd2:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
    3cd6:	07 c0       	rjmp	.+14     	; 0x3ce6 <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_7) {
    3cd8:	89 81       	ldd	r24, Y+1	; 0x01
    3cda:	87 30       	cpi	r24, 0x07	; 7
    3cdc:	21 f4       	brne	.+8      	; 0x3ce6 <MCAL_ADC_AdcInit+0xc6>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc7);
    3cde:	80 e0       	ldi	r24, 0x00	; 0
    3ce0:	67 e4       	ldi	r22, 0x47	; 71
    3ce2:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <MCAL_ADC_u8SetRegister>
	} else {
		//Do Nothing
	}
}
    3ce6:	0f 90       	pop	r0
    3ce8:	cf 91       	pop	r28
    3cea:	df 91       	pop	r29
    3cec:	08 95       	ret

00003cee <MCAL_ADC_AdcStartConversion>:

void MCAL_ADC_AdcStartConversion(u8 Loc_u8Value) {
    3cee:	df 93       	push	r29
    3cf0:	cf 93       	push	r28
    3cf2:	0f 92       	push	r0
    3cf4:	cd b7       	in	r28, 0x3d	; 61
    3cf6:	de b7       	in	r29, 0x3e	; 62
    3cf8:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8Value == Enable) {
    3cfa:	89 81       	ldd	r24, Y+1	; 0x01
    3cfc:	81 30       	cpi	r24, 0x01	; 1
    3cfe:	31 f4       	brne	.+12     	; 0x3d0c <MCAL_ADC_AdcStartConversion+0x1e>
		MCAL_ADC_u8SetRegisterPin(Adcsra, 6, Enable);
    3d00:	81 e0       	ldi	r24, 0x01	; 1
    3d02:	66 e0       	ldi	r22, 0x06	; 6
    3d04:	41 e0       	ldi	r20, 0x01	; 1
    3d06:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <MCAL_ADC_u8SetRegisterPin>
    3d0a:	08 c0       	rjmp	.+16     	; 0x3d1c <MCAL_ADC_AdcStartConversion+0x2e>
	} else if (Loc_u8Value == Disable) {
    3d0c:	89 81       	ldd	r24, Y+1	; 0x01
    3d0e:	88 23       	and	r24, r24
    3d10:	29 f4       	brne	.+10     	; 0x3d1c <MCAL_ADC_AdcStartConversion+0x2e>
		MCAL_ADC_u8SetRegisterPin(Adcsra, 6, Disable);
    3d12:	81 e0       	ldi	r24, 0x01	; 1
    3d14:	66 e0       	ldi	r22, 0x06	; 6
    3d16:	40 e0       	ldi	r20, 0x00	; 0
    3d18:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <MCAL_ADC_u8SetRegisterPin>
	} else {
		//NOTHING
	}
}
    3d1c:	0f 90       	pop	r0
    3d1e:	cf 91       	pop	r28
    3d20:	df 91       	pop	r29
    3d22:	08 95       	ret

00003d24 <MCAL_ADC_u8AdcSetValue>:

u8 MCAL_ADC_u8AdcSetValue(u16 *Loc_u16Value) {
    3d24:	df 93       	push	r29
    3d26:	cf 93       	push	r28
    3d28:	00 d0       	rcall	.+0      	; 0x3d2a <MCAL_ADC_u8AdcSetValue+0x6>
    3d2a:	0f 92       	push	r0
    3d2c:	cd b7       	in	r28, 0x3d	; 61
    3d2e:	de b7       	in	r29, 0x3e	; 62
    3d30:	9b 83       	std	Y+3, r25	; 0x03
    3d32:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8ReturnValue = E_NOT_OK;
    3d34:	81 e0       	ldi	r24, 0x01	; 1
    3d36:	89 83       	std	Y+1, r24	; 0x01
	*Loc_u16Value = (((u32) ADC * 5000) / 1024);
    3d38:	e4 e2       	ldi	r30, 0x24	; 36
    3d3a:	f0 e0       	ldi	r31, 0x00	; 0
    3d3c:	80 81       	ld	r24, Z
    3d3e:	91 81       	ldd	r25, Z+1	; 0x01
    3d40:	cc 01       	movw	r24, r24
    3d42:	a0 e0       	ldi	r26, 0x00	; 0
    3d44:	b0 e0       	ldi	r27, 0x00	; 0
    3d46:	28 e8       	ldi	r18, 0x88	; 136
    3d48:	33 e1       	ldi	r19, 0x13	; 19
    3d4a:	40 e0       	ldi	r20, 0x00	; 0
    3d4c:	50 e0       	ldi	r21, 0x00	; 0
    3d4e:	bc 01       	movw	r22, r24
    3d50:	cd 01       	movw	r24, r26
    3d52:	0e 94 9d 46 	call	0x8d3a	; 0x8d3a <__mulsi3>
    3d56:	dc 01       	movw	r26, r24
    3d58:	cb 01       	movw	r24, r22
    3d5a:	07 2e       	mov	r0, r23
    3d5c:	7a e0       	ldi	r23, 0x0A	; 10
    3d5e:	b6 95       	lsr	r27
    3d60:	a7 95       	ror	r26
    3d62:	97 95       	ror	r25
    3d64:	87 95       	ror	r24
    3d66:	7a 95       	dec	r23
    3d68:	d1 f7       	brne	.-12     	; 0x3d5e <MCAL_ADC_u8AdcSetValue+0x3a>
    3d6a:	70 2d       	mov	r23, r0
    3d6c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d6e:	fb 81       	ldd	r31, Y+3	; 0x03
    3d70:	91 83       	std	Z+1, r25	; 0x01
    3d72:	80 83       	st	Z, r24
	return LOC_u8ReturnValue;
    3d74:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d76:	0f 90       	pop	r0
    3d78:	0f 90       	pop	r0
    3d7a:	0f 90       	pop	r0
    3d7c:	cf 91       	pop	r28
    3d7e:	df 91       	pop	r29
    3d80:	08 95       	ret

00003d82 <MCAL_ADC_EXIT_CallBack>:

void MCAL_ADC_EXIT_CallBack(void (*ptr)(void)) {
    3d82:	df 93       	push	r29
    3d84:	cf 93       	push	r28
    3d86:	00 d0       	rcall	.+0      	; 0x3d88 <MCAL_ADC_EXIT_CallBack+0x6>
    3d88:	cd b7       	in	r28, 0x3d	; 61
    3d8a:	de b7       	in	r29, 0x3e	; 62
    3d8c:	9a 83       	std	Y+2, r25	; 0x02
    3d8e:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    3d90:	89 81       	ldd	r24, Y+1	; 0x01
    3d92:	9a 81       	ldd	r25, Y+2	; 0x02
    3d94:	00 97       	sbiw	r24, 0x00	; 0
    3d96:	31 f0       	breq	.+12     	; 0x3da4 <MCAL_ADC_EXIT_CallBack+0x22>
		Gptr_ADC = ptr;
    3d98:	89 81       	ldd	r24, Y+1	; 0x01
    3d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d9c:	90 93 96 01 	sts	0x0196, r25
    3da0:	80 93 95 01 	sts	0x0195, r24
}
    3da4:	0f 90       	pop	r0
    3da6:	0f 90       	pop	r0
    3da8:	cf 91       	pop	r28
    3daa:	df 91       	pop	r29
    3dac:	08 95       	ret

00003dae <__vector_16>:

ISR(ADC_vect) {
    3dae:	1f 92       	push	r1
    3db0:	0f 92       	push	r0
    3db2:	0f b6       	in	r0, 0x3f	; 63
    3db4:	0f 92       	push	r0
    3db6:	11 24       	eor	r1, r1
    3db8:	2f 93       	push	r18
    3dba:	3f 93       	push	r19
    3dbc:	4f 93       	push	r20
    3dbe:	5f 93       	push	r21
    3dc0:	6f 93       	push	r22
    3dc2:	7f 93       	push	r23
    3dc4:	8f 93       	push	r24
    3dc6:	9f 93       	push	r25
    3dc8:	af 93       	push	r26
    3dca:	bf 93       	push	r27
    3dcc:	ef 93       	push	r30
    3dce:	ff 93       	push	r31
    3dd0:	df 93       	push	r29
    3dd2:	cf 93       	push	r28
    3dd4:	cd b7       	in	r28, 0x3d	; 61
    3dd6:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_ADC != '\0')
    3dd8:	80 91 95 01 	lds	r24, 0x0195
    3ddc:	90 91 96 01 	lds	r25, 0x0196
    3de0:	00 97       	sbiw	r24, 0x00	; 0
    3de2:	29 f0       	breq	.+10     	; 0x3dee <__vector_16+0x40>
		Gptr_ADC();
    3de4:	e0 91 95 01 	lds	r30, 0x0195
    3de8:	f0 91 96 01 	lds	r31, 0x0196
    3dec:	09 95       	icall
}
    3dee:	cf 91       	pop	r28
    3df0:	df 91       	pop	r29
    3df2:	ff 91       	pop	r31
    3df4:	ef 91       	pop	r30
    3df6:	bf 91       	pop	r27
    3df8:	af 91       	pop	r26
    3dfa:	9f 91       	pop	r25
    3dfc:	8f 91       	pop	r24
    3dfe:	7f 91       	pop	r23
    3e00:	6f 91       	pop	r22
    3e02:	5f 91       	pop	r21
    3e04:	4f 91       	pop	r20
    3e06:	3f 91       	pop	r19
    3e08:	2f 91       	pop	r18
    3e0a:	0f 90       	pop	r0
    3e0c:	0f be       	out	0x3f, r0	; 63
    3e0e:	0f 90       	pop	r0
    3e10:	1f 90       	pop	r1
    3e12:	18 95       	reti

00003e14 <HAL_SM_voidSMInit>:
 *
 *  Created on: Oct 29, 2023
 *      Author: TOP_WORLD
 */
#include "Servo_Motor.h"
void HAL_SM_voidSMInit(void){
    3e14:	df 93       	push	r29
    3e16:	cf 93       	push	r28
    3e18:	00 d0       	rcall	.+0      	; 0x3e1a <HAL_SM_voidSMInit+0x6>
    3e1a:	00 d0       	rcall	.+0      	; 0x3e1c <HAL_SM_voidSMInit+0x8>
    3e1c:	cd b7       	in	r28, 0x3d	; 61
    3e1e:	de b7       	in	r29, 0x3e	; 62
	f32 Tick_Time=0;
    3e20:	80 e0       	ldi	r24, 0x00	; 0
    3e22:	90 e0       	ldi	r25, 0x00	; 0
    3e24:	a0 e0       	ldi	r26, 0x00	; 0
    3e26:	b0 e0       	ldi	r27, 0x00	; 0
    3e28:	89 83       	std	Y+1, r24	; 0x01
    3e2a:	9a 83       	std	Y+2, r25	; 0x02
    3e2c:	ab 83       	std	Y+3, r26	; 0x03
    3e2e:	bc 83       	std	Y+4, r27	; 0x04
	MCAL_T1_u8T1Init(FAST_PWM_ICR1);
    3e30:	8e e0       	ldi	r24, 0x0E	; 14
    3e32:	0e 94 bb 09 	call	0x1376	; 0x1376 <MCAL_T1_u8T1Init>
	MCAL_T1_u8T1Prescaler(PRESCALLING_64,&Tick_Time);
    3e36:	83 e0       	ldi	r24, 0x03	; 3
    3e38:	9e 01       	movw	r18, r28
    3e3a:	2f 5f       	subi	r18, 0xFF	; 255
    3e3c:	3f 4f       	sbci	r19, 0xFF	; 255
    3e3e:	b9 01       	movw	r22, r18
    3e40:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <MCAL_T1_u8T1Prescaler>
	MCAL_T1_u8T1CompareOutputMode(NON_INVERTING_MODE,CHENNEL_A);
    3e44:	80 e0       	ldi	r24, 0x00	; 0
    3e46:	60 e0       	ldi	r22, 0x00	; 0
    3e48:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <MCAL_T1_u8T1CompareOutputMode>
	MCAL_T1_voidSetICR1Value(INIT_VALUE);
    3e4c:	87 e8       	ldi	r24, 0x87	; 135
    3e4e:	93 e1       	ldi	r25, 0x13	; 19
    3e50:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <MCAL_T1_voidSetICR1Value>
	MCAL_T1_voidSetOCR1AValue(START_ZERO);
    3e54:	8a e8       	ldi	r24, 0x8A	; 138
    3e56:	90 e0       	ldi	r25, 0x00	; 0
    3e58:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <MCAL_T1_voidSetOCR1AValue>

}
    3e5c:	0f 90       	pop	r0
    3e5e:	0f 90       	pop	r0
    3e60:	0f 90       	pop	r0
    3e62:	0f 90       	pop	r0
    3e64:	cf 91       	pop	r28
    3e66:	df 91       	pop	r29
    3e68:	08 95       	ret

00003e6a <HAL_SM_voidSMSetAngle>:
void HAL_SM_voidSMSetAngle(u8 LOC_u8Angle){
    3e6a:	df 93       	push	r29
    3e6c:	cf 93       	push	r28
    3e6e:	00 d0       	rcall	.+0      	; 0x3e70 <HAL_SM_voidSMSetAngle+0x6>
    3e70:	0f 92       	push	r0
    3e72:	cd b7       	in	r28, 0x3d	; 61
    3e74:	de b7       	in	r29, 0x3e	; 62
    3e76:	8b 83       	std	Y+3, r24	; 0x03
	if(LOC_u8Angle<=MAX_ANGLE&&LOC_u8Angle>=MIN_ANGLE){
    3e78:	8b 81       	ldd	r24, Y+3	; 0x03
    3e7a:	88 2f       	mov	r24, r24
    3e7c:	90 e0       	ldi	r25, 0x00	; 0
    3e7e:	aa 27       	eor	r26, r26
    3e80:	97 fd       	sbrc	r25, 7
    3e82:	a0 95       	com	r26
    3e84:	ba 2f       	mov	r27, r26
    3e86:	bc 01       	movw	r22, r24
    3e88:	cd 01       	movw	r24, r26
    3e8a:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    3e8e:	dc 01       	movw	r26, r24
    3e90:	cb 01       	movw	r24, r22
    3e92:	bc 01       	movw	r22, r24
    3e94:	cd 01       	movw	r24, r26
    3e96:	20 e0       	ldi	r18, 0x00	; 0
    3e98:	30 e0       	ldi	r19, 0x00	; 0
    3e9a:	44 e3       	ldi	r20, 0x34	; 52
    3e9c:	53 e4       	ldi	r21, 0x43	; 67
    3e9e:	0e 94 55 04 	call	0x8aa	; 0x8aa <__lesf2>
    3ea2:	18 16       	cp	r1, r24
    3ea4:	bc f1       	brlt	.+110    	; 0x3f14 <HAL_SM_voidSMSetAngle+0xaa>
	u16 SetAngle=START_ZERO+((LOC_u8Angle/MAX_ANGLE)*BETWEEN_0_180);
    3ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ea8:	88 2f       	mov	r24, r24
    3eaa:	90 e0       	ldi	r25, 0x00	; 0
    3eac:	aa 27       	eor	r26, r26
    3eae:	97 fd       	sbrc	r25, 7
    3eb0:	a0 95       	com	r26
    3eb2:	ba 2f       	mov	r27, r26
    3eb4:	bc 01       	movw	r22, r24
    3eb6:	cd 01       	movw	r24, r26
    3eb8:	0e 94 85 04 	call	0x90a	; 0x90a <__floatsisf>
    3ebc:	dc 01       	movw	r26, r24
    3ebe:	cb 01       	movw	r24, r22
    3ec0:	bc 01       	movw	r22, r24
    3ec2:	cd 01       	movw	r24, r26
    3ec4:	20 e0       	ldi	r18, 0x00	; 0
    3ec6:	30 e0       	ldi	r19, 0x00	; 0
    3ec8:	44 e3       	ldi	r20, 0x34	; 52
    3eca:	53 e4       	ldi	r21, 0x43	; 67
    3ecc:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3ed0:	dc 01       	movw	r26, r24
    3ed2:	cb 01       	movw	r24, r22
    3ed4:	bc 01       	movw	r22, r24
    3ed6:	cd 01       	movw	r24, r26
    3ed8:	20 e0       	ldi	r18, 0x00	; 0
    3eda:	30 e0       	ldi	r19, 0x00	; 0
    3edc:	4e ef       	ldi	r20, 0xFE	; 254
    3ede:	53 e4       	ldi	r21, 0x43	; 67
    3ee0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ee4:	dc 01       	movw	r26, r24
    3ee6:	cb 01       	movw	r24, r22
    3ee8:	bc 01       	movw	r22, r24
    3eea:	cd 01       	movw	r24, r26
    3eec:	20 e0       	ldi	r18, 0x00	; 0
    3eee:	30 e0       	ldi	r19, 0x00	; 0
    3ef0:	4a e0       	ldi	r20, 0x0A	; 10
    3ef2:	53 e4       	ldi	r21, 0x43	; 67
    3ef4:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    3ef8:	dc 01       	movw	r26, r24
    3efa:	cb 01       	movw	r24, r22
    3efc:	bc 01       	movw	r22, r24
    3efe:	cd 01       	movw	r24, r26
    3f00:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f04:	dc 01       	movw	r26, r24
    3f06:	cb 01       	movw	r24, r22
    3f08:	9a 83       	std	Y+2, r25	; 0x02
    3f0a:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_voidSetOCR1AValue(SetAngle);
    3f0c:	89 81       	ldd	r24, Y+1	; 0x01
    3f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f10:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <MCAL_T1_voidSetOCR1AValue>
	}else {
		//NOTHING
	}
}
    3f14:	0f 90       	pop	r0
    3f16:	0f 90       	pop	r0
    3f18:	0f 90       	pop	r0
    3f1a:	cf 91       	pop	r28
    3f1c:	df 91       	pop	r29
    3f1e:	08 95       	ret

00003f20 <HAL_PushButton_u8PushButtonInit>:
u8 Glob_PB0_u8PinValue=0;
u8 Glob_PB1_u8PinValue=0;
u8 Glob_PB2_u8PinValue=0;

STD_Type HAL_PushButton_u8PushButtonInit(u8 Loc_u8PushButtonPortID,
		u8 Loc_u8PushButtonPinID) {
    3f20:	df 93       	push	r29
    3f22:	cf 93       	push	r28
    3f24:	00 d0       	rcall	.+0      	; 0x3f26 <HAL_PushButton_u8PushButtonInit+0x6>
    3f26:	0f 92       	push	r0
    3f28:	cd b7       	in	r28, 0x3d	; 61
    3f2a:	de b7       	in	r29, 0x3e	; 62
    3f2c:	8a 83       	std	Y+2, r24	; 0x02
    3f2e:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    3f30:	81 e0       	ldi	r24, 0x01	; 1
    3f32:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PushButtonPortID <= PortD && Loc_u8PushButtonPinID <= Num_Of_Pins) {
    3f34:	8a 81       	ldd	r24, Y+2	; 0x02
    3f36:	84 30       	cpi	r24, 0x04	; 4
    3f38:	48 f4       	brcc	.+18     	; 0x3f4c <HAL_PushButton_u8PushButtonInit+0x2c>
    3f3a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f3c:	88 30       	cpi	r24, 0x08	; 8
    3f3e:	30 f4       	brcc	.+12     	; 0x3f4c <HAL_PushButton_u8PushButtonInit+0x2c>
		Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8PushButtonPortID,
    3f40:	8a 81       	ldd	r24, Y+2	; 0x02
    3f42:	6b 81       	ldd	r22, Y+3	; 0x03
    3f44:	41 e0       	ldi	r20, 0x01	; 1
    3f46:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
    3f4a:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8PushButtonPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3f4c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f4e:	0f 90       	pop	r0
    3f50:	0f 90       	pop	r0
    3f52:	0f 90       	pop	r0
    3f54:	cf 91       	pop	r28
    3f56:	df 91       	pop	r29
    3f58:	08 95       	ret

00003f5a <HAL_PushButton_u8PushButtonCheck>:

STD_Type HAL_PushButton_u8PushButtonCheck(u8 Loc_u8PushButtonPortID,
		u8 Loc_u8PushButtonPinID) {
    3f5a:	df 93       	push	r29
    3f5c:	cf 93       	push	r28
    3f5e:	00 d0       	rcall	.+0      	; 0x3f60 <HAL_PushButton_u8PushButtonCheck+0x6>
    3f60:	0f 92       	push	r0
    3f62:	cd b7       	in	r28, 0x3d	; 61
    3f64:	de b7       	in	r29, 0x3e	; 62
    3f66:	8a 83       	std	Y+2, r24	; 0x02
    3f68:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    3f6a:	81 e0       	ldi	r24, 0x01	; 1
    3f6c:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PushButtonPortID <= PortD && Loc_u8PushButtonPinID <= Num_Of_Pins) {
    3f6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f70:	84 30       	cpi	r24, 0x04	; 4
    3f72:	30 f5       	brcc	.+76     	; 0x3fc0 <HAL_PushButton_u8PushButtonCheck+0x66>
    3f74:	8b 81       	ldd	r24, Y+3	; 0x03
    3f76:	88 30       	cpi	r24, 0x08	; 8
    3f78:	18 f5       	brcc	.+70     	; 0x3fc0 <HAL_PushButton_u8PushButtonCheck+0x66>
		if(Loc_u8PushButtonPinID==PushButton0_PIN){
    3f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f7c:	88 23       	and	r24, r24
    3f7e:	49 f4       	brne	.+18     	; 0x3f92 <HAL_PushButton_u8PushButtonCheck+0x38>
			Loc_u8Return_Value = MCAL_DIO_u8GetPinValue(Loc_u8PushButtonPortID,
    3f80:	27 e9       	ldi	r18, 0x97	; 151
    3f82:	31 e0       	ldi	r19, 0x01	; 1
    3f84:	8a 81       	ldd	r24, Y+2	; 0x02
    3f86:	6b 81       	ldd	r22, Y+3	; 0x03
    3f88:	a9 01       	movw	r20, r18
    3f8a:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <MCAL_DIO_u8GetPinValue>
    3f8e:	89 83       	std	Y+1, r24	; 0x01
    3f90:	17 c0       	rjmp	.+46     	; 0x3fc0 <HAL_PushButton_u8PushButtonCheck+0x66>
					Loc_u8PushButtonPinID, &Glob_PB0_u8PinValue);
		}
		else if(Loc_u8PushButtonPinID==PushButton1_PIN){
    3f92:	8b 81       	ldd	r24, Y+3	; 0x03
    3f94:	86 30       	cpi	r24, 0x06	; 6
    3f96:	49 f4       	brne	.+18     	; 0x3faa <HAL_PushButton_u8PushButtonCheck+0x50>
			Loc_u8Return_Value = MCAL_DIO_u8GetPinValue(Loc_u8PushButtonPortID,
    3f98:	28 e9       	ldi	r18, 0x98	; 152
    3f9a:	31 e0       	ldi	r19, 0x01	; 1
    3f9c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f9e:	6b 81       	ldd	r22, Y+3	; 0x03
    3fa0:	a9 01       	movw	r20, r18
    3fa2:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <MCAL_DIO_u8GetPinValue>
    3fa6:	89 83       	std	Y+1, r24	; 0x01
    3fa8:	0b c0       	rjmp	.+22     	; 0x3fc0 <HAL_PushButton_u8PushButtonCheck+0x66>
					Loc_u8PushButtonPinID, &Glob_PB1_u8PinValue);
		}
		else if(Loc_u8PushButtonPinID==PushButton2_PIN){
    3faa:	8b 81       	ldd	r24, Y+3	; 0x03
    3fac:	82 30       	cpi	r24, 0x02	; 2
    3fae:	41 f4       	brne	.+16     	; 0x3fc0 <HAL_PushButton_u8PushButtonCheck+0x66>
			Loc_u8Return_Value = MCAL_DIO_u8GetPinValue(Loc_u8PushButtonPortID,
    3fb0:	29 e9       	ldi	r18, 0x99	; 153
    3fb2:	31 e0       	ldi	r19, 0x01	; 1
    3fb4:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb6:	6b 81       	ldd	r22, Y+3	; 0x03
    3fb8:	a9 01       	movw	r20, r18
    3fba:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <MCAL_DIO_u8GetPinValue>
    3fbe:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    3fc0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3fc2:	0f 90       	pop	r0
    3fc4:	0f 90       	pop	r0
    3fc6:	0f 90       	pop	r0
    3fc8:	cf 91       	pop	r28
    3fca:	df 91       	pop	r29
    3fcc:	08 95       	ret

00003fce <HAL_Potentiometer_PotentiometerInit>:
 *      Author: Mohamed
 */

#include "Potentiometer.h"

void HAL_Potentiometer_PotentiometerInit(u8 Loc_u8PotPort,u8 Loc_u8PotPin) {
    3fce:	df 93       	push	r29
    3fd0:	cf 93       	push	r28
    3fd2:	00 d0       	rcall	.+0      	; 0x3fd4 <HAL_Potentiometer_PotentiometerInit+0x6>
    3fd4:	cd b7       	in	r28, 0x3d	; 61
    3fd6:	de b7       	in	r29, 0x3e	; 62
    3fd8:	89 83       	std	Y+1, r24	; 0x01
    3fda:	6a 83       	std	Y+2, r22	; 0x02
//	MCAL_DIO_u8SetPinDirection(Loc_u8PotPort,Loc_u8PotPin,Pin_Low);
	MCAL_ADC_AdcInit(Adc_1);
    3fdc:	81 e0       	ldi	r24, 0x01	; 1
    3fde:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <MCAL_ADC_AdcInit>
}
    3fe2:	0f 90       	pop	r0
    3fe4:	0f 90       	pop	r0
    3fe6:	cf 91       	pop	r28
    3fe8:	df 91       	pop	r29
    3fea:	08 95       	ret

00003fec <HAL_Potentiometer_PotentiometerValue>:

void HAL_Potentiometer_PotentiometerValue(u16 *Loc_u16Value) {
    3fec:	df 93       	push	r29
    3fee:	cf 93       	push	r28
    3ff0:	00 d0       	rcall	.+0      	; 0x3ff2 <HAL_Potentiometer_PotentiometerValue+0x6>
    3ff2:	cd b7       	in	r28, 0x3d	; 61
    3ff4:	de b7       	in	r29, 0x3e	; 62
    3ff6:	9a 83       	std	Y+2, r25	; 0x02
    3ff8:	89 83       	std	Y+1, r24	; 0x01
	MCAL_ADC_AdcStartConversion(Enable);
    3ffa:	81 e0       	ldi	r24, 0x01	; 1
    3ffc:	0e 94 77 1e 	call	0x3cee	; 0x3cee <MCAL_ADC_AdcStartConversion>
	MCAL_ADC_u8AdcSetValue(Loc_u16Value);
    4000:	89 81       	ldd	r24, Y+1	; 0x01
    4002:	9a 81       	ldd	r25, Y+2	; 0x02
    4004:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <MCAL_ADC_u8AdcSetValue>
}
    4008:	0f 90       	pop	r0
    400a:	0f 90       	pop	r0
    400c:	cf 91       	pop	r28
    400e:	df 91       	pop	r29
    4010:	08 95       	ret

00004012 <HAL_LED_u8LedInit>:
 *  Created on: Sep 25, 2023
 *      Author: Mohamed
 */
#include "LED.h"

STD_Type HAL_LED_u8LedInit(u8 Loc_u8LEDPortID, u8 Loc_u8LEDPinID) {
    4012:	df 93       	push	r29
    4014:	cf 93       	push	r28
    4016:	00 d0       	rcall	.+0      	; 0x4018 <HAL_LED_u8LedInit+0x6>
    4018:	0f 92       	push	r0
    401a:	cd b7       	in	r28, 0x3d	; 61
    401c:	de b7       	in	r29, 0x3e	; 62
    401e:	8a 83       	std	Y+2, r24	; 0x02
    4020:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    4022:	81 e0       	ldi	r24, 0x01	; 1
    4024:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8LEDPortID <= PortD && Loc_u8LEDPinID <= Num_Of_Pins) {
    4026:	8a 81       	ldd	r24, Y+2	; 0x02
    4028:	84 30       	cpi	r24, 0x04	; 4
    402a:	48 f4       	brcc	.+18     	; 0x403e <HAL_LED_u8LedInit+0x2c>
    402c:	8b 81       	ldd	r24, Y+3	; 0x03
    402e:	88 30       	cpi	r24, 0x08	; 8
    4030:	30 f4       	brcc	.+12     	; 0x403e <HAL_LED_u8LedInit+0x2c>
		Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8LEDPortID,
    4032:	8a 81       	ldd	r24, Y+2	; 0x02
    4034:	6b 81       	ldd	r22, Y+3	; 0x03
    4036:	41 e0       	ldi	r20, 0x01	; 1
    4038:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
    403c:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8LEDPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    403e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4040:	0f 90       	pop	r0
    4042:	0f 90       	pop	r0
    4044:	0f 90       	pop	r0
    4046:	cf 91       	pop	r28
    4048:	df 91       	pop	r29
    404a:	08 95       	ret

0000404c <HAL_LED_u8LedMode>:

STD_Type HAL_LED_u8LedMode(u8 Loc_u8LEDPortID, u8 Loc_u8LEDPinID,
		u8 Loc_u8LEDMode) {
    404c:	df 93       	push	r29
    404e:	cf 93       	push	r28
    4050:	00 d0       	rcall	.+0      	; 0x4052 <HAL_LED_u8LedMode+0x6>
    4052:	00 d0       	rcall	.+0      	; 0x4054 <HAL_LED_u8LedMode+0x8>
    4054:	cd b7       	in	r28, 0x3d	; 61
    4056:	de b7       	in	r29, 0x3e	; 62
    4058:	8a 83       	std	Y+2, r24	; 0x02
    405a:	6b 83       	std	Y+3, r22	; 0x03
    405c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    405e:	81 e0       	ldi	r24, 0x01	; 1
    4060:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8LEDPortID <= PortD && Loc_u8LEDPinID <= Num_Of_Pins
    4062:	8a 81       	ldd	r24, Y+2	; 0x02
    4064:	84 30       	cpi	r24, 0x04	; 4
    4066:	10 f5       	brcc	.+68     	; 0x40ac <HAL_LED_u8LedMode+0x60>
    4068:	8b 81       	ldd	r24, Y+3	; 0x03
    406a:	88 30       	cpi	r24, 0x08	; 8
    406c:	f8 f4       	brcc	.+62     	; 0x40ac <HAL_LED_u8LedMode+0x60>
    406e:	8c 81       	ldd	r24, Y+4	; 0x04
    4070:	83 30       	cpi	r24, 0x03	; 3
    4072:	e0 f4       	brcc	.+56     	; 0x40ac <HAL_LED_u8LedMode+0x60>
			&& Loc_u8LEDMode <= LED_TOG) {
		if (Loc_u8LEDMode == LED_ON) {
    4074:	8c 81       	ldd	r24, Y+4	; 0x04
    4076:	81 30       	cpi	r24, 0x01	; 1
    4078:	39 f4       	brne	.+14     	; 0x4088 <HAL_LED_u8LedMode+0x3c>
			Loc_u8Return_Value = MCAL_DIO_u8SetPinValue(Loc_u8LEDPortID,
    407a:	8a 81       	ldd	r24, Y+2	; 0x02
    407c:	6b 81       	ldd	r22, Y+3	; 0x03
    407e:	41 e0       	ldi	r20, 0x01	; 1
    4080:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
    4084:	89 83       	std	Y+1, r24	; 0x01
    4086:	12 c0       	rjmp	.+36     	; 0x40ac <HAL_LED_u8LedMode+0x60>
					Loc_u8LEDPinID, Pin_High);
		} else if (Loc_u8LEDMode == LED_OFF) {
    4088:	8c 81       	ldd	r24, Y+4	; 0x04
    408a:	88 23       	and	r24, r24
    408c:	39 f4       	brne	.+14     	; 0x409c <HAL_LED_u8LedMode+0x50>
			Loc_u8Return_Value = MCAL_DIO_u8SetPinValue(Loc_u8LEDPortID,
    408e:	8a 81       	ldd	r24, Y+2	; 0x02
    4090:	6b 81       	ldd	r22, Y+3	; 0x03
    4092:	40 e0       	ldi	r20, 0x00	; 0
    4094:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
    4098:	89 83       	std	Y+1, r24	; 0x01
    409a:	08 c0       	rjmp	.+16     	; 0x40ac <HAL_LED_u8LedMode+0x60>
					Loc_u8LEDPinID, Pin_Low);
		} else if (Loc_u8LEDMode == LED_TOG) {
    409c:	8c 81       	ldd	r24, Y+4	; 0x04
    409e:	82 30       	cpi	r24, 0x02	; 2
    40a0:	29 f4       	brne	.+10     	; 0x40ac <HAL_LED_u8LedMode+0x60>
			Loc_u8Return_Value = MCAL_DIO_u8TogglePinValue(Loc_u8LEDPortID,
    40a2:	8a 81       	ldd	r24, Y+2	; 0x02
    40a4:	6b 81       	ldd	r22, Y+3	; 0x03
    40a6:	0e 94 9e 1c 	call	0x393c	; 0x393c <MCAL_DIO_u8TogglePinValue>
    40aa:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    40ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    40ae:	0f 90       	pop	r0
    40b0:	0f 90       	pop	r0
    40b2:	0f 90       	pop	r0
    40b4:	0f 90       	pop	r0
    40b6:	cf 91       	pop	r28
    40b8:	df 91       	pop	r29
    40ba:	08 95       	ret

000040bc <HAL_LCD_u8LCDInit>:

#include "LCD.h"

//static u32 Counter = 0;

void HAL_LCD_u8LCDInit() {
    40bc:	0f 93       	push	r16
    40be:	1f 93       	push	r17
    40c0:	df 93       	push	r29
    40c2:	cf 93       	push	r28
    40c4:	cd b7       	in	r28, 0x3d	; 61
    40c6:	de b7       	in	r29, 0x3e	; 62
    40c8:	c6 54       	subi	r28, 0x46	; 70
    40ca:	d0 40       	sbci	r29, 0x00	; 0
    40cc:	0f b6       	in	r0, 0x3f	; 63
    40ce:	f8 94       	cli
    40d0:	de bf       	out	0x3e, r29	; 62
    40d2:	0f be       	out	0x3f, r0	; 63
    40d4:	cd bf       	out	0x3d, r28	; 61
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D7_PIN, Pin_High);
    40d6:	80 e0       	ldi	r24, 0x00	; 0
    40d8:	67 e0       	ldi	r22, 0x07	; 7
    40da:	41 e0       	ldi	r20, 0x01	; 1
    40dc:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D6_PIN, Pin_High);
    40e0:	80 e0       	ldi	r24, 0x00	; 0
    40e2:	66 e0       	ldi	r22, 0x06	; 6
    40e4:	41 e0       	ldi	r20, 0x01	; 1
    40e6:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D5_PIN, Pin_High);
    40ea:	80 e0       	ldi	r24, 0x00	; 0
    40ec:	65 e0       	ldi	r22, 0x05	; 5
    40ee:	41 e0       	ldi	r20, 0x01	; 1
    40f0:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D4_PIN, Pin_High);
    40f4:	80 e0       	ldi	r24, 0x00	; 0
    40f6:	64 e0       	ldi	r22, 0x04	; 4
    40f8:	41 e0       	ldi	r20, 0x01	; 1
    40fa:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(RS_Port, RS_Pin, Pin_High);
    40fe:	81 e0       	ldi	r24, 0x01	; 1
    4100:	61 e0       	ldi	r22, 0x01	; 1
    4102:	41 e0       	ldi	r20, 0x01	; 1
    4104:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(RW_Port, RW_Pin, Pin_High);
    4108:	81 e0       	ldi	r24, 0x01	; 1
    410a:	62 e0       	ldi	r22, 0x02	; 2
    410c:	41 e0       	ldi	r20, 0x01	; 1
    410e:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(Enable_PORT, Enable_PIN, Pin_High);
    4112:	81 e0       	ldi	r24, 0x01	; 1
    4114:	63 e0       	ldi	r22, 0x03	; 3
    4116:	41 e0       	ldi	r20, 0x01	; 1
    4118:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
    411c:	fe 01       	movw	r30, r28
    411e:	ed 5b       	subi	r30, 0xBD	; 189
    4120:	ff 4f       	sbci	r31, 0xFF	; 255
    4122:	80 e0       	ldi	r24, 0x00	; 0
    4124:	90 e0       	ldi	r25, 0x00	; 0
    4126:	a0 e0       	ldi	r26, 0x00	; 0
    4128:	b0 e4       	ldi	r27, 0x40	; 64
    412a:	80 83       	st	Z, r24
    412c:	91 83       	std	Z+1, r25	; 0x01
    412e:	a2 83       	std	Z+2, r26	; 0x02
    4130:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4132:	8e 01       	movw	r16, r28
    4134:	01 5c       	subi	r16, 0xC1	; 193
    4136:	1f 4f       	sbci	r17, 0xFF	; 255
    4138:	fe 01       	movw	r30, r28
    413a:	ed 5b       	subi	r30, 0xBD	; 189
    413c:	ff 4f       	sbci	r31, 0xFF	; 255
    413e:	60 81       	ld	r22, Z
    4140:	71 81       	ldd	r23, Z+1	; 0x01
    4142:	82 81       	ldd	r24, Z+2	; 0x02
    4144:	93 81       	ldd	r25, Z+3	; 0x03
    4146:	20 e0       	ldi	r18, 0x00	; 0
    4148:	30 e0       	ldi	r19, 0x00	; 0
    414a:	4a e7       	ldi	r20, 0x7A	; 122
    414c:	55 e4       	ldi	r21, 0x45	; 69
    414e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4152:	dc 01       	movw	r26, r24
    4154:	cb 01       	movw	r24, r22
    4156:	f8 01       	movw	r30, r16
    4158:	80 83       	st	Z, r24
    415a:	91 83       	std	Z+1, r25	; 0x01
    415c:	a2 83       	std	Z+2, r26	; 0x02
    415e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    4160:	fe 01       	movw	r30, r28
    4162:	ff 96       	adiw	r30, 0x3f	; 63
    4164:	60 81       	ld	r22, Z
    4166:	71 81       	ldd	r23, Z+1	; 0x01
    4168:	82 81       	ldd	r24, Z+2	; 0x02
    416a:	93 81       	ldd	r25, Z+3	; 0x03
    416c:	20 e0       	ldi	r18, 0x00	; 0
    416e:	30 e0       	ldi	r19, 0x00	; 0
    4170:	40 e8       	ldi	r20, 0x80	; 128
    4172:	5f e3       	ldi	r21, 0x3F	; 63
    4174:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4178:	88 23       	and	r24, r24
    417a:	2c f4       	brge	.+10     	; 0x4186 <HAL_LCD_u8LCDInit+0xca>
		__ticks = 1;
    417c:	81 e0       	ldi	r24, 0x01	; 1
    417e:	90 e0       	ldi	r25, 0x00	; 0
    4180:	9e af       	std	Y+62, r25	; 0x3e
    4182:	8d af       	std	Y+61, r24	; 0x3d
    4184:	46 c0       	rjmp	.+140    	; 0x4212 <HAL_LCD_u8LCDInit+0x156>
	else if (__tmp > 65535)
    4186:	fe 01       	movw	r30, r28
    4188:	ff 96       	adiw	r30, 0x3f	; 63
    418a:	60 81       	ld	r22, Z
    418c:	71 81       	ldd	r23, Z+1	; 0x01
    418e:	82 81       	ldd	r24, Z+2	; 0x02
    4190:	93 81       	ldd	r25, Z+3	; 0x03
    4192:	20 e0       	ldi	r18, 0x00	; 0
    4194:	3f ef       	ldi	r19, 0xFF	; 255
    4196:	4f e7       	ldi	r20, 0x7F	; 127
    4198:	57 e4       	ldi	r21, 0x47	; 71
    419a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    419e:	18 16       	cp	r1, r24
    41a0:	64 f5       	brge	.+88     	; 0x41fa <HAL_LCD_u8LCDInit+0x13e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41a2:	fe 01       	movw	r30, r28
    41a4:	ed 5b       	subi	r30, 0xBD	; 189
    41a6:	ff 4f       	sbci	r31, 0xFF	; 255
    41a8:	60 81       	ld	r22, Z
    41aa:	71 81       	ldd	r23, Z+1	; 0x01
    41ac:	82 81       	ldd	r24, Z+2	; 0x02
    41ae:	93 81       	ldd	r25, Z+3	; 0x03
    41b0:	20 e0       	ldi	r18, 0x00	; 0
    41b2:	30 e0       	ldi	r19, 0x00	; 0
    41b4:	40 e2       	ldi	r20, 0x20	; 32
    41b6:	51 e4       	ldi	r21, 0x41	; 65
    41b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41bc:	dc 01       	movw	r26, r24
    41be:	cb 01       	movw	r24, r22
    41c0:	bc 01       	movw	r22, r24
    41c2:	cd 01       	movw	r24, r26
    41c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41c8:	dc 01       	movw	r26, r24
    41ca:	cb 01       	movw	r24, r22
    41cc:	9e af       	std	Y+62, r25	; 0x3e
    41ce:	8d af       	std	Y+61, r24	; 0x3d
    41d0:	0f c0       	rjmp	.+30     	; 0x41f0 <HAL_LCD_u8LCDInit+0x134>
    41d2:	80 e9       	ldi	r24, 0x90	; 144
    41d4:	91 e0       	ldi	r25, 0x01	; 1
    41d6:	9c af       	std	Y+60, r25	; 0x3c
    41d8:	8b af       	std	Y+59, r24	; 0x3b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    41da:	8b ad       	ldd	r24, Y+59	; 0x3b
    41dc:	9c ad       	ldd	r25, Y+60	; 0x3c
    41de:	01 97       	sbiw	r24, 0x01	; 1
    41e0:	f1 f7       	brne	.-4      	; 0x41de <HAL_LCD_u8LCDInit+0x122>
    41e2:	9c af       	std	Y+60, r25	; 0x3c
    41e4:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    41e6:	8d ad       	ldd	r24, Y+61	; 0x3d
    41e8:	9e ad       	ldd	r25, Y+62	; 0x3e
    41ea:	01 97       	sbiw	r24, 0x01	; 1
    41ec:	9e af       	std	Y+62, r25	; 0x3e
    41ee:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    41f0:	8d ad       	ldd	r24, Y+61	; 0x3d
    41f2:	9e ad       	ldd	r25, Y+62	; 0x3e
    41f4:	00 97       	sbiw	r24, 0x00	; 0
    41f6:	69 f7       	brne	.-38     	; 0x41d2 <HAL_LCD_u8LCDInit+0x116>
    41f8:	16 c0       	rjmp	.+44     	; 0x4226 <HAL_LCD_u8LCDInit+0x16a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    41fa:	fe 01       	movw	r30, r28
    41fc:	ff 96       	adiw	r30, 0x3f	; 63
    41fe:	60 81       	ld	r22, Z
    4200:	71 81       	ldd	r23, Z+1	; 0x01
    4202:	82 81       	ldd	r24, Z+2	; 0x02
    4204:	93 81       	ldd	r25, Z+3	; 0x03
    4206:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    420a:	dc 01       	movw	r26, r24
    420c:	cb 01       	movw	r24, r22
    420e:	9e af       	std	Y+62, r25	; 0x3e
    4210:	8d af       	std	Y+61, r24	; 0x3d
    4212:	8d ad       	ldd	r24, Y+61	; 0x3d
    4214:	9e ad       	ldd	r25, Y+62	; 0x3e
    4216:	9a af       	std	Y+58, r25	; 0x3a
    4218:	89 af       	std	Y+57, r24	; 0x39
    421a:	89 ad       	ldd	r24, Y+57	; 0x39
    421c:	9a ad       	ldd	r25, Y+58	; 0x3a
    421e:	01 97       	sbiw	r24, 0x01	; 1
    4220:	f1 f7       	brne	.-4      	; 0x421e <HAL_LCD_u8LCDInit+0x162>
    4222:	9a af       	std	Y+58, r25	; 0x3a
    4224:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Reset);
    4226:	82 e0       	ldi	r24, 0x02	; 2
    4228:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
    422c:	80 e0       	ldi	r24, 0x00	; 0
    422e:	90 e0       	ldi	r25, 0x00	; 0
    4230:	a0 e0       	ldi	r26, 0x00	; 0
    4232:	b0 e4       	ldi	r27, 0x40	; 64
    4234:	8d ab       	std	Y+53, r24	; 0x35
    4236:	9e ab       	std	Y+54, r25	; 0x36
    4238:	af ab       	std	Y+55, r26	; 0x37
    423a:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    423c:	6d a9       	ldd	r22, Y+53	; 0x35
    423e:	7e a9       	ldd	r23, Y+54	; 0x36
    4240:	8f a9       	ldd	r24, Y+55	; 0x37
    4242:	98 ad       	ldd	r25, Y+56	; 0x38
    4244:	20 e0       	ldi	r18, 0x00	; 0
    4246:	30 e0       	ldi	r19, 0x00	; 0
    4248:	4a e7       	ldi	r20, 0x7A	; 122
    424a:	55 e4       	ldi	r21, 0x45	; 69
    424c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4250:	dc 01       	movw	r26, r24
    4252:	cb 01       	movw	r24, r22
    4254:	89 ab       	std	Y+49, r24	; 0x31
    4256:	9a ab       	std	Y+50, r25	; 0x32
    4258:	ab ab       	std	Y+51, r26	; 0x33
    425a:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    425c:	69 a9       	ldd	r22, Y+49	; 0x31
    425e:	7a a9       	ldd	r23, Y+50	; 0x32
    4260:	8b a9       	ldd	r24, Y+51	; 0x33
    4262:	9c a9       	ldd	r25, Y+52	; 0x34
    4264:	20 e0       	ldi	r18, 0x00	; 0
    4266:	30 e0       	ldi	r19, 0x00	; 0
    4268:	40 e8       	ldi	r20, 0x80	; 128
    426a:	5f e3       	ldi	r21, 0x3F	; 63
    426c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4270:	88 23       	and	r24, r24
    4272:	2c f4       	brge	.+10     	; 0x427e <HAL_LCD_u8LCDInit+0x1c2>
		__ticks = 1;
    4274:	81 e0       	ldi	r24, 0x01	; 1
    4276:	90 e0       	ldi	r25, 0x00	; 0
    4278:	98 ab       	std	Y+48, r25	; 0x30
    427a:	8f a7       	std	Y+47, r24	; 0x2f
    427c:	3f c0       	rjmp	.+126    	; 0x42fc <HAL_LCD_u8LCDInit+0x240>
	else if (__tmp > 65535)
    427e:	69 a9       	ldd	r22, Y+49	; 0x31
    4280:	7a a9       	ldd	r23, Y+50	; 0x32
    4282:	8b a9       	ldd	r24, Y+51	; 0x33
    4284:	9c a9       	ldd	r25, Y+52	; 0x34
    4286:	20 e0       	ldi	r18, 0x00	; 0
    4288:	3f ef       	ldi	r19, 0xFF	; 255
    428a:	4f e7       	ldi	r20, 0x7F	; 127
    428c:	57 e4       	ldi	r21, 0x47	; 71
    428e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4292:	18 16       	cp	r1, r24
    4294:	4c f5       	brge	.+82     	; 0x42e8 <HAL_LCD_u8LCDInit+0x22c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4296:	6d a9       	ldd	r22, Y+53	; 0x35
    4298:	7e a9       	ldd	r23, Y+54	; 0x36
    429a:	8f a9       	ldd	r24, Y+55	; 0x37
    429c:	98 ad       	ldd	r25, Y+56	; 0x38
    429e:	20 e0       	ldi	r18, 0x00	; 0
    42a0:	30 e0       	ldi	r19, 0x00	; 0
    42a2:	40 e2       	ldi	r20, 0x20	; 32
    42a4:	51 e4       	ldi	r21, 0x41	; 65
    42a6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    42aa:	dc 01       	movw	r26, r24
    42ac:	cb 01       	movw	r24, r22
    42ae:	bc 01       	movw	r22, r24
    42b0:	cd 01       	movw	r24, r26
    42b2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42b6:	dc 01       	movw	r26, r24
    42b8:	cb 01       	movw	r24, r22
    42ba:	98 ab       	std	Y+48, r25	; 0x30
    42bc:	8f a7       	std	Y+47, r24	; 0x2f
    42be:	0f c0       	rjmp	.+30     	; 0x42de <HAL_LCD_u8LCDInit+0x222>
    42c0:	80 e9       	ldi	r24, 0x90	; 144
    42c2:	91 e0       	ldi	r25, 0x01	; 1
    42c4:	9e a7       	std	Y+46, r25	; 0x2e
    42c6:	8d a7       	std	Y+45, r24	; 0x2d
    42c8:	8d a5       	ldd	r24, Y+45	; 0x2d
    42ca:	9e a5       	ldd	r25, Y+46	; 0x2e
    42cc:	01 97       	sbiw	r24, 0x01	; 1
    42ce:	f1 f7       	brne	.-4      	; 0x42cc <HAL_LCD_u8LCDInit+0x210>
    42d0:	9e a7       	std	Y+46, r25	; 0x2e
    42d2:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    42d4:	8f a5       	ldd	r24, Y+47	; 0x2f
    42d6:	98 a9       	ldd	r25, Y+48	; 0x30
    42d8:	01 97       	sbiw	r24, 0x01	; 1
    42da:	98 ab       	std	Y+48, r25	; 0x30
    42dc:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    42de:	8f a5       	ldd	r24, Y+47	; 0x2f
    42e0:	98 a9       	ldd	r25, Y+48	; 0x30
    42e2:	00 97       	sbiw	r24, 0x00	; 0
    42e4:	69 f7       	brne	.-38     	; 0x42c0 <HAL_LCD_u8LCDInit+0x204>
    42e6:	14 c0       	rjmp	.+40     	; 0x4310 <HAL_LCD_u8LCDInit+0x254>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    42e8:	69 a9       	ldd	r22, Y+49	; 0x31
    42ea:	7a a9       	ldd	r23, Y+50	; 0x32
    42ec:	8b a9       	ldd	r24, Y+51	; 0x33
    42ee:	9c a9       	ldd	r25, Y+52	; 0x34
    42f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42f4:	dc 01       	movw	r26, r24
    42f6:	cb 01       	movw	r24, r22
    42f8:	98 ab       	std	Y+48, r25	; 0x30
    42fa:	8f a7       	std	Y+47, r24	; 0x2f
    42fc:	8f a5       	ldd	r24, Y+47	; 0x2f
    42fe:	98 a9       	ldd	r25, Y+48	; 0x30
    4300:	9c a7       	std	Y+44, r25	; 0x2c
    4302:	8b a7       	std	Y+43, r24	; 0x2b
    4304:	8b a5       	ldd	r24, Y+43	; 0x2b
    4306:	9c a5       	ldd	r25, Y+44	; 0x2c
    4308:	01 97       	sbiw	r24, 0x01	; 1
    430a:	f1 f7       	brne	.-4      	; 0x4308 <HAL_LCD_u8LCDInit+0x24c>
    430c:	9c a7       	std	Y+44, r25	; 0x2c
    430e:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Function_Set);
    4310:	88 e2       	ldi	r24, 0x28	; 40
    4312:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
    4316:	80 e0       	ldi	r24, 0x00	; 0
    4318:	90 e0       	ldi	r25, 0x00	; 0
    431a:	a0 e0       	ldi	r26, 0x00	; 0
    431c:	b0 e4       	ldi	r27, 0x40	; 64
    431e:	8f a3       	std	Y+39, r24	; 0x27
    4320:	98 a7       	std	Y+40, r25	; 0x28
    4322:	a9 a7       	std	Y+41, r26	; 0x29
    4324:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4326:	6f a1       	ldd	r22, Y+39	; 0x27
    4328:	78 a5       	ldd	r23, Y+40	; 0x28
    432a:	89 a5       	ldd	r24, Y+41	; 0x29
    432c:	9a a5       	ldd	r25, Y+42	; 0x2a
    432e:	20 e0       	ldi	r18, 0x00	; 0
    4330:	30 e0       	ldi	r19, 0x00	; 0
    4332:	4a e7       	ldi	r20, 0x7A	; 122
    4334:	55 e4       	ldi	r21, 0x45	; 69
    4336:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    433a:	dc 01       	movw	r26, r24
    433c:	cb 01       	movw	r24, r22
    433e:	8b a3       	std	Y+35, r24	; 0x23
    4340:	9c a3       	std	Y+36, r25	; 0x24
    4342:	ad a3       	std	Y+37, r26	; 0x25
    4344:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4346:	6b a1       	ldd	r22, Y+35	; 0x23
    4348:	7c a1       	ldd	r23, Y+36	; 0x24
    434a:	8d a1       	ldd	r24, Y+37	; 0x25
    434c:	9e a1       	ldd	r25, Y+38	; 0x26
    434e:	20 e0       	ldi	r18, 0x00	; 0
    4350:	30 e0       	ldi	r19, 0x00	; 0
    4352:	40 e8       	ldi	r20, 0x80	; 128
    4354:	5f e3       	ldi	r21, 0x3F	; 63
    4356:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    435a:	88 23       	and	r24, r24
    435c:	2c f4       	brge	.+10     	; 0x4368 <HAL_LCD_u8LCDInit+0x2ac>
		__ticks = 1;
    435e:	81 e0       	ldi	r24, 0x01	; 1
    4360:	90 e0       	ldi	r25, 0x00	; 0
    4362:	9a a3       	std	Y+34, r25	; 0x22
    4364:	89 a3       	std	Y+33, r24	; 0x21
    4366:	3f c0       	rjmp	.+126    	; 0x43e6 <HAL_LCD_u8LCDInit+0x32a>
	else if (__tmp > 65535)
    4368:	6b a1       	ldd	r22, Y+35	; 0x23
    436a:	7c a1       	ldd	r23, Y+36	; 0x24
    436c:	8d a1       	ldd	r24, Y+37	; 0x25
    436e:	9e a1       	ldd	r25, Y+38	; 0x26
    4370:	20 e0       	ldi	r18, 0x00	; 0
    4372:	3f ef       	ldi	r19, 0xFF	; 255
    4374:	4f e7       	ldi	r20, 0x7F	; 127
    4376:	57 e4       	ldi	r21, 0x47	; 71
    4378:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    437c:	18 16       	cp	r1, r24
    437e:	4c f5       	brge	.+82     	; 0x43d2 <HAL_LCD_u8LCDInit+0x316>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4380:	6f a1       	ldd	r22, Y+39	; 0x27
    4382:	78 a5       	ldd	r23, Y+40	; 0x28
    4384:	89 a5       	ldd	r24, Y+41	; 0x29
    4386:	9a a5       	ldd	r25, Y+42	; 0x2a
    4388:	20 e0       	ldi	r18, 0x00	; 0
    438a:	30 e0       	ldi	r19, 0x00	; 0
    438c:	40 e2       	ldi	r20, 0x20	; 32
    438e:	51 e4       	ldi	r21, 0x41	; 65
    4390:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4394:	dc 01       	movw	r26, r24
    4396:	cb 01       	movw	r24, r22
    4398:	bc 01       	movw	r22, r24
    439a:	cd 01       	movw	r24, r26
    439c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    43a0:	dc 01       	movw	r26, r24
    43a2:	cb 01       	movw	r24, r22
    43a4:	9a a3       	std	Y+34, r25	; 0x22
    43a6:	89 a3       	std	Y+33, r24	; 0x21
    43a8:	0f c0       	rjmp	.+30     	; 0x43c8 <HAL_LCD_u8LCDInit+0x30c>
    43aa:	80 e9       	ldi	r24, 0x90	; 144
    43ac:	91 e0       	ldi	r25, 0x01	; 1
    43ae:	98 a3       	std	Y+32, r25	; 0x20
    43b0:	8f 8f       	std	Y+31, r24	; 0x1f
    43b2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    43b4:	98 a1       	ldd	r25, Y+32	; 0x20
    43b6:	01 97       	sbiw	r24, 0x01	; 1
    43b8:	f1 f7       	brne	.-4      	; 0x43b6 <HAL_LCD_u8LCDInit+0x2fa>
    43ba:	98 a3       	std	Y+32, r25	; 0x20
    43bc:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    43be:	89 a1       	ldd	r24, Y+33	; 0x21
    43c0:	9a a1       	ldd	r25, Y+34	; 0x22
    43c2:	01 97       	sbiw	r24, 0x01	; 1
    43c4:	9a a3       	std	Y+34, r25	; 0x22
    43c6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    43c8:	89 a1       	ldd	r24, Y+33	; 0x21
    43ca:	9a a1       	ldd	r25, Y+34	; 0x22
    43cc:	00 97       	sbiw	r24, 0x00	; 0
    43ce:	69 f7       	brne	.-38     	; 0x43aa <HAL_LCD_u8LCDInit+0x2ee>
    43d0:	14 c0       	rjmp	.+40     	; 0x43fa <HAL_LCD_u8LCDInit+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    43d2:	6b a1       	ldd	r22, Y+35	; 0x23
    43d4:	7c a1       	ldd	r23, Y+36	; 0x24
    43d6:	8d a1       	ldd	r24, Y+37	; 0x25
    43d8:	9e a1       	ldd	r25, Y+38	; 0x26
    43da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    43de:	dc 01       	movw	r26, r24
    43e0:	cb 01       	movw	r24, r22
    43e2:	9a a3       	std	Y+34, r25	; 0x22
    43e4:	89 a3       	std	Y+33, r24	; 0x21
    43e6:	89 a1       	ldd	r24, Y+33	; 0x21
    43e8:	9a a1       	ldd	r25, Y+34	; 0x22
    43ea:	9e 8f       	std	Y+30, r25	; 0x1e
    43ec:	8d 8f       	std	Y+29, r24	; 0x1d
    43ee:	8d 8d       	ldd	r24, Y+29	; 0x1d
    43f0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    43f2:	01 97       	sbiw	r24, 0x01	; 1
    43f4:	f1 f7       	brne	.-4      	; 0x43f2 <HAL_LCD_u8LCDInit+0x336>
    43f6:	9e 8f       	std	Y+30, r25	; 0x1e
    43f8:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Mode);
    43fa:	8f e0       	ldi	r24, 0x0F	; 15
    43fc:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
    4400:	80 e0       	ldi	r24, 0x00	; 0
    4402:	90 e0       	ldi	r25, 0x00	; 0
    4404:	a0 e0       	ldi	r26, 0x00	; 0
    4406:	b0 e4       	ldi	r27, 0x40	; 64
    4408:	89 8f       	std	Y+25, r24	; 0x19
    440a:	9a 8f       	std	Y+26, r25	; 0x1a
    440c:	ab 8f       	std	Y+27, r26	; 0x1b
    440e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4410:	69 8d       	ldd	r22, Y+25	; 0x19
    4412:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4414:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4416:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4418:	20 e0       	ldi	r18, 0x00	; 0
    441a:	30 e0       	ldi	r19, 0x00	; 0
    441c:	4a e7       	ldi	r20, 0x7A	; 122
    441e:	55 e4       	ldi	r21, 0x45	; 69
    4420:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4424:	dc 01       	movw	r26, r24
    4426:	cb 01       	movw	r24, r22
    4428:	8d 8b       	std	Y+21, r24	; 0x15
    442a:	9e 8b       	std	Y+22, r25	; 0x16
    442c:	af 8b       	std	Y+23, r26	; 0x17
    442e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4430:	6d 89       	ldd	r22, Y+21	; 0x15
    4432:	7e 89       	ldd	r23, Y+22	; 0x16
    4434:	8f 89       	ldd	r24, Y+23	; 0x17
    4436:	98 8d       	ldd	r25, Y+24	; 0x18
    4438:	20 e0       	ldi	r18, 0x00	; 0
    443a:	30 e0       	ldi	r19, 0x00	; 0
    443c:	40 e8       	ldi	r20, 0x80	; 128
    443e:	5f e3       	ldi	r21, 0x3F	; 63
    4440:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4444:	88 23       	and	r24, r24
    4446:	2c f4       	brge	.+10     	; 0x4452 <HAL_LCD_u8LCDInit+0x396>
		__ticks = 1;
    4448:	81 e0       	ldi	r24, 0x01	; 1
    444a:	90 e0       	ldi	r25, 0x00	; 0
    444c:	9c 8b       	std	Y+20, r25	; 0x14
    444e:	8b 8b       	std	Y+19, r24	; 0x13
    4450:	3f c0       	rjmp	.+126    	; 0x44d0 <HAL_LCD_u8LCDInit+0x414>
	else if (__tmp > 65535)
    4452:	6d 89       	ldd	r22, Y+21	; 0x15
    4454:	7e 89       	ldd	r23, Y+22	; 0x16
    4456:	8f 89       	ldd	r24, Y+23	; 0x17
    4458:	98 8d       	ldd	r25, Y+24	; 0x18
    445a:	20 e0       	ldi	r18, 0x00	; 0
    445c:	3f ef       	ldi	r19, 0xFF	; 255
    445e:	4f e7       	ldi	r20, 0x7F	; 127
    4460:	57 e4       	ldi	r21, 0x47	; 71
    4462:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4466:	18 16       	cp	r1, r24
    4468:	4c f5       	brge	.+82     	; 0x44bc <HAL_LCD_u8LCDInit+0x400>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    446a:	69 8d       	ldd	r22, Y+25	; 0x19
    446c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    446e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4470:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4472:	20 e0       	ldi	r18, 0x00	; 0
    4474:	30 e0       	ldi	r19, 0x00	; 0
    4476:	40 e2       	ldi	r20, 0x20	; 32
    4478:	51 e4       	ldi	r21, 0x41	; 65
    447a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    447e:	dc 01       	movw	r26, r24
    4480:	cb 01       	movw	r24, r22
    4482:	bc 01       	movw	r22, r24
    4484:	cd 01       	movw	r24, r26
    4486:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    448a:	dc 01       	movw	r26, r24
    448c:	cb 01       	movw	r24, r22
    448e:	9c 8b       	std	Y+20, r25	; 0x14
    4490:	8b 8b       	std	Y+19, r24	; 0x13
    4492:	0f c0       	rjmp	.+30     	; 0x44b2 <HAL_LCD_u8LCDInit+0x3f6>
    4494:	80 e9       	ldi	r24, 0x90	; 144
    4496:	91 e0       	ldi	r25, 0x01	; 1
    4498:	9a 8b       	std	Y+18, r25	; 0x12
    449a:	89 8b       	std	Y+17, r24	; 0x11
    449c:	89 89       	ldd	r24, Y+17	; 0x11
    449e:	9a 89       	ldd	r25, Y+18	; 0x12
    44a0:	01 97       	sbiw	r24, 0x01	; 1
    44a2:	f1 f7       	brne	.-4      	; 0x44a0 <HAL_LCD_u8LCDInit+0x3e4>
    44a4:	9a 8b       	std	Y+18, r25	; 0x12
    44a6:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    44a8:	8b 89       	ldd	r24, Y+19	; 0x13
    44aa:	9c 89       	ldd	r25, Y+20	; 0x14
    44ac:	01 97       	sbiw	r24, 0x01	; 1
    44ae:	9c 8b       	std	Y+20, r25	; 0x14
    44b0:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    44b2:	8b 89       	ldd	r24, Y+19	; 0x13
    44b4:	9c 89       	ldd	r25, Y+20	; 0x14
    44b6:	00 97       	sbiw	r24, 0x00	; 0
    44b8:	69 f7       	brne	.-38     	; 0x4494 <HAL_LCD_u8LCDInit+0x3d8>
    44ba:	14 c0       	rjmp	.+40     	; 0x44e4 <HAL_LCD_u8LCDInit+0x428>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    44bc:	6d 89       	ldd	r22, Y+21	; 0x15
    44be:	7e 89       	ldd	r23, Y+22	; 0x16
    44c0:	8f 89       	ldd	r24, Y+23	; 0x17
    44c2:	98 8d       	ldd	r25, Y+24	; 0x18
    44c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    44c8:	dc 01       	movw	r26, r24
    44ca:	cb 01       	movw	r24, r22
    44cc:	9c 8b       	std	Y+20, r25	; 0x14
    44ce:	8b 8b       	std	Y+19, r24	; 0x13
    44d0:	8b 89       	ldd	r24, Y+19	; 0x13
    44d2:	9c 89       	ldd	r25, Y+20	; 0x14
    44d4:	98 8b       	std	Y+16, r25	; 0x10
    44d6:	8f 87       	std	Y+15, r24	; 0x0f
    44d8:	8f 85       	ldd	r24, Y+15	; 0x0f
    44da:	98 89       	ldd	r25, Y+16	; 0x10
    44dc:	01 97       	sbiw	r24, 0x01	; 1
    44de:	f1 f7       	brne	.-4      	; 0x44dc <HAL_LCD_u8LCDInit+0x420>
    44e0:	98 8b       	std	Y+16, r25	; 0x10
    44e2:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Clear);
    44e4:	81 e0       	ldi	r24, 0x01	; 1
    44e6:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
    44ea:	80 e0       	ldi	r24, 0x00	; 0
    44ec:	90 e0       	ldi	r25, 0x00	; 0
    44ee:	a0 e0       	ldi	r26, 0x00	; 0
    44f0:	b0 e4       	ldi	r27, 0x40	; 64
    44f2:	8b 87       	std	Y+11, r24	; 0x0b
    44f4:	9c 87       	std	Y+12, r25	; 0x0c
    44f6:	ad 87       	std	Y+13, r26	; 0x0d
    44f8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    44fa:	6b 85       	ldd	r22, Y+11	; 0x0b
    44fc:	7c 85       	ldd	r23, Y+12	; 0x0c
    44fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    4500:	9e 85       	ldd	r25, Y+14	; 0x0e
    4502:	20 e0       	ldi	r18, 0x00	; 0
    4504:	30 e0       	ldi	r19, 0x00	; 0
    4506:	4a e7       	ldi	r20, 0x7A	; 122
    4508:	55 e4       	ldi	r21, 0x45	; 69
    450a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    450e:	dc 01       	movw	r26, r24
    4510:	cb 01       	movw	r24, r22
    4512:	8f 83       	std	Y+7, r24	; 0x07
    4514:	98 87       	std	Y+8, r25	; 0x08
    4516:	a9 87       	std	Y+9, r26	; 0x09
    4518:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    451a:	6f 81       	ldd	r22, Y+7	; 0x07
    451c:	78 85       	ldd	r23, Y+8	; 0x08
    451e:	89 85       	ldd	r24, Y+9	; 0x09
    4520:	9a 85       	ldd	r25, Y+10	; 0x0a
    4522:	20 e0       	ldi	r18, 0x00	; 0
    4524:	30 e0       	ldi	r19, 0x00	; 0
    4526:	40 e8       	ldi	r20, 0x80	; 128
    4528:	5f e3       	ldi	r21, 0x3F	; 63
    452a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    452e:	88 23       	and	r24, r24
    4530:	2c f4       	brge	.+10     	; 0x453c <HAL_LCD_u8LCDInit+0x480>
		__ticks = 1;
    4532:	81 e0       	ldi	r24, 0x01	; 1
    4534:	90 e0       	ldi	r25, 0x00	; 0
    4536:	9e 83       	std	Y+6, r25	; 0x06
    4538:	8d 83       	std	Y+5, r24	; 0x05
    453a:	3f c0       	rjmp	.+126    	; 0x45ba <HAL_LCD_u8LCDInit+0x4fe>
	else if (__tmp > 65535)
    453c:	6f 81       	ldd	r22, Y+7	; 0x07
    453e:	78 85       	ldd	r23, Y+8	; 0x08
    4540:	89 85       	ldd	r24, Y+9	; 0x09
    4542:	9a 85       	ldd	r25, Y+10	; 0x0a
    4544:	20 e0       	ldi	r18, 0x00	; 0
    4546:	3f ef       	ldi	r19, 0xFF	; 255
    4548:	4f e7       	ldi	r20, 0x7F	; 127
    454a:	57 e4       	ldi	r21, 0x47	; 71
    454c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4550:	18 16       	cp	r1, r24
    4552:	4c f5       	brge	.+82     	; 0x45a6 <HAL_LCD_u8LCDInit+0x4ea>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4554:	6b 85       	ldd	r22, Y+11	; 0x0b
    4556:	7c 85       	ldd	r23, Y+12	; 0x0c
    4558:	8d 85       	ldd	r24, Y+13	; 0x0d
    455a:	9e 85       	ldd	r25, Y+14	; 0x0e
    455c:	20 e0       	ldi	r18, 0x00	; 0
    455e:	30 e0       	ldi	r19, 0x00	; 0
    4560:	40 e2       	ldi	r20, 0x20	; 32
    4562:	51 e4       	ldi	r21, 0x41	; 65
    4564:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4568:	dc 01       	movw	r26, r24
    456a:	cb 01       	movw	r24, r22
    456c:	bc 01       	movw	r22, r24
    456e:	cd 01       	movw	r24, r26
    4570:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4574:	dc 01       	movw	r26, r24
    4576:	cb 01       	movw	r24, r22
    4578:	9e 83       	std	Y+6, r25	; 0x06
    457a:	8d 83       	std	Y+5, r24	; 0x05
    457c:	0f c0       	rjmp	.+30     	; 0x459c <HAL_LCD_u8LCDInit+0x4e0>
    457e:	80 e9       	ldi	r24, 0x90	; 144
    4580:	91 e0       	ldi	r25, 0x01	; 1
    4582:	9c 83       	std	Y+4, r25	; 0x04
    4584:	8b 83       	std	Y+3, r24	; 0x03
    4586:	8b 81       	ldd	r24, Y+3	; 0x03
    4588:	9c 81       	ldd	r25, Y+4	; 0x04
    458a:	01 97       	sbiw	r24, 0x01	; 1
    458c:	f1 f7       	brne	.-4      	; 0x458a <HAL_LCD_u8LCDInit+0x4ce>
    458e:	9c 83       	std	Y+4, r25	; 0x04
    4590:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4592:	8d 81       	ldd	r24, Y+5	; 0x05
    4594:	9e 81       	ldd	r25, Y+6	; 0x06
    4596:	01 97       	sbiw	r24, 0x01	; 1
    4598:	9e 83       	std	Y+6, r25	; 0x06
    459a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    459c:	8d 81       	ldd	r24, Y+5	; 0x05
    459e:	9e 81       	ldd	r25, Y+6	; 0x06
    45a0:	00 97       	sbiw	r24, 0x00	; 0
    45a2:	69 f7       	brne	.-38     	; 0x457e <HAL_LCD_u8LCDInit+0x4c2>
    45a4:	14 c0       	rjmp	.+40     	; 0x45ce <HAL_LCD_u8LCDInit+0x512>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    45a6:	6f 81       	ldd	r22, Y+7	; 0x07
    45a8:	78 85       	ldd	r23, Y+8	; 0x08
    45aa:	89 85       	ldd	r24, Y+9	; 0x09
    45ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    45ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    45b2:	dc 01       	movw	r26, r24
    45b4:	cb 01       	movw	r24, r22
    45b6:	9e 83       	std	Y+6, r25	; 0x06
    45b8:	8d 83       	std	Y+5, r24	; 0x05
    45ba:	8d 81       	ldd	r24, Y+5	; 0x05
    45bc:	9e 81       	ldd	r25, Y+6	; 0x06
    45be:	9a 83       	std	Y+2, r25	; 0x02
    45c0:	89 83       	std	Y+1, r24	; 0x01
    45c2:	89 81       	ldd	r24, Y+1	; 0x01
    45c4:	9a 81       	ldd	r25, Y+2	; 0x02
    45c6:	01 97       	sbiw	r24, 0x01	; 1
    45c8:	f1 f7       	brne	.-4      	; 0x45c6 <HAL_LCD_u8LCDInit+0x50a>
    45ca:	9a 83       	std	Y+2, r25	; 0x02
    45cc:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Entry_Mode);
    45ce:	86 e0       	ldi	r24, 0x06	; 6
    45d0:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
}
    45d4:	ca 5b       	subi	r28, 0xBA	; 186
    45d6:	df 4f       	sbci	r29, 0xFF	; 255
    45d8:	0f b6       	in	r0, 0x3f	; 63
    45da:	f8 94       	cli
    45dc:	de bf       	out	0x3e, r29	; 62
    45de:	0f be       	out	0x3f, r0	; 63
    45e0:	cd bf       	out	0x3d, r28	; 61
    45e2:	cf 91       	pop	r28
    45e4:	df 91       	pop	r29
    45e6:	1f 91       	pop	r17
    45e8:	0f 91       	pop	r16
    45ea:	08 95       	ret

000045ec <HAL_LCD_u8SendCommands>:

void HAL_LCD_u8SendCommands(u8 Loc_u8LCD_Command) {
    45ec:	df 93       	push	r29
    45ee:	cf 93       	push	r28
    45f0:	cd b7       	in	r28, 0x3d	; 61
    45f2:	de b7       	in	r29, 0x3e	; 62
    45f4:	6d 97       	sbiw	r28, 0x1d	; 29
    45f6:	0f b6       	in	r0, 0x3f	; 63
    45f8:	f8 94       	cli
    45fa:	de bf       	out	0x3e, r29	; 62
    45fc:	0f be       	out	0x3f, r0	; 63
    45fe:	cd bf       	out	0x3d, r28	; 61
    4600:	8d 8f       	std	Y+29, r24	; 0x1d
	MCAL_DIO_u8SetPinValue(RS_Port, RS_Pin, RS_Low);
    4602:	81 e0       	ldi	r24, 0x01	; 1
    4604:	61 e0       	ldi	r22, 0x01	; 1
    4606:	40 e0       	ldi	r20, 0x00	; 0
    4608:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(RW_Port, RW_Pin, RW_Low);
    460c:	81 e0       	ldi	r24, 0x01	; 1
    460e:	62 e0       	ldi	r22, 0x02	; 2
    4610:	40 e0       	ldi	r20, 0x00	; 0
    4612:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPortValue(LCD_D_PORT, Loc_u8LCD_Command);
    4616:	80 e0       	ldi	r24, 0x00	; 0
    4618:	6d 8d       	ldd	r22, Y+29	; 0x1d
    461a:	0e 94 32 1a 	call	0x3464	; 0x3464 <MCAL_DIO_u8SetPortValue>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    461e:	81 e0       	ldi	r24, 0x01	; 1
    4620:	63 e0       	ldi	r22, 0x03	; 3
    4622:	41 e0       	ldi	r20, 0x01	; 1
    4624:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
    4628:	80 e0       	ldi	r24, 0x00	; 0
    462a:	90 e0       	ldi	r25, 0x00	; 0
    462c:	a0 e0       	ldi	r26, 0x00	; 0
    462e:	b0 e4       	ldi	r27, 0x40	; 64
    4630:	89 8f       	std	Y+25, r24	; 0x19
    4632:	9a 8f       	std	Y+26, r25	; 0x1a
    4634:	ab 8f       	std	Y+27, r26	; 0x1b
    4636:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4638:	69 8d       	ldd	r22, Y+25	; 0x19
    463a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    463c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    463e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4640:	20 e0       	ldi	r18, 0x00	; 0
    4642:	30 e0       	ldi	r19, 0x00	; 0
    4644:	4a e7       	ldi	r20, 0x7A	; 122
    4646:	55 e4       	ldi	r21, 0x45	; 69
    4648:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    464c:	dc 01       	movw	r26, r24
    464e:	cb 01       	movw	r24, r22
    4650:	8d 8b       	std	Y+21, r24	; 0x15
    4652:	9e 8b       	std	Y+22, r25	; 0x16
    4654:	af 8b       	std	Y+23, r26	; 0x17
    4656:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4658:	6d 89       	ldd	r22, Y+21	; 0x15
    465a:	7e 89       	ldd	r23, Y+22	; 0x16
    465c:	8f 89       	ldd	r24, Y+23	; 0x17
    465e:	98 8d       	ldd	r25, Y+24	; 0x18
    4660:	20 e0       	ldi	r18, 0x00	; 0
    4662:	30 e0       	ldi	r19, 0x00	; 0
    4664:	40 e8       	ldi	r20, 0x80	; 128
    4666:	5f e3       	ldi	r21, 0x3F	; 63
    4668:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    466c:	88 23       	and	r24, r24
    466e:	2c f4       	brge	.+10     	; 0x467a <HAL_LCD_u8SendCommands+0x8e>
		__ticks = 1;
    4670:	81 e0       	ldi	r24, 0x01	; 1
    4672:	90 e0       	ldi	r25, 0x00	; 0
    4674:	9c 8b       	std	Y+20, r25	; 0x14
    4676:	8b 8b       	std	Y+19, r24	; 0x13
    4678:	3f c0       	rjmp	.+126    	; 0x46f8 <HAL_LCD_u8SendCommands+0x10c>
	else if (__tmp > 65535)
    467a:	6d 89       	ldd	r22, Y+21	; 0x15
    467c:	7e 89       	ldd	r23, Y+22	; 0x16
    467e:	8f 89       	ldd	r24, Y+23	; 0x17
    4680:	98 8d       	ldd	r25, Y+24	; 0x18
    4682:	20 e0       	ldi	r18, 0x00	; 0
    4684:	3f ef       	ldi	r19, 0xFF	; 255
    4686:	4f e7       	ldi	r20, 0x7F	; 127
    4688:	57 e4       	ldi	r21, 0x47	; 71
    468a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    468e:	18 16       	cp	r1, r24
    4690:	4c f5       	brge	.+82     	; 0x46e4 <HAL_LCD_u8SendCommands+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4692:	69 8d       	ldd	r22, Y+25	; 0x19
    4694:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4696:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4698:	9c 8d       	ldd	r25, Y+28	; 0x1c
    469a:	20 e0       	ldi	r18, 0x00	; 0
    469c:	30 e0       	ldi	r19, 0x00	; 0
    469e:	40 e2       	ldi	r20, 0x20	; 32
    46a0:	51 e4       	ldi	r21, 0x41	; 65
    46a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    46a6:	dc 01       	movw	r26, r24
    46a8:	cb 01       	movw	r24, r22
    46aa:	bc 01       	movw	r22, r24
    46ac:	cd 01       	movw	r24, r26
    46ae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    46b2:	dc 01       	movw	r26, r24
    46b4:	cb 01       	movw	r24, r22
    46b6:	9c 8b       	std	Y+20, r25	; 0x14
    46b8:	8b 8b       	std	Y+19, r24	; 0x13
    46ba:	0f c0       	rjmp	.+30     	; 0x46da <HAL_LCD_u8SendCommands+0xee>
    46bc:	80 e9       	ldi	r24, 0x90	; 144
    46be:	91 e0       	ldi	r25, 0x01	; 1
    46c0:	9a 8b       	std	Y+18, r25	; 0x12
    46c2:	89 8b       	std	Y+17, r24	; 0x11
    46c4:	89 89       	ldd	r24, Y+17	; 0x11
    46c6:	9a 89       	ldd	r25, Y+18	; 0x12
    46c8:	01 97       	sbiw	r24, 0x01	; 1
    46ca:	f1 f7       	brne	.-4      	; 0x46c8 <HAL_LCD_u8SendCommands+0xdc>
    46cc:	9a 8b       	std	Y+18, r25	; 0x12
    46ce:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    46d0:	8b 89       	ldd	r24, Y+19	; 0x13
    46d2:	9c 89       	ldd	r25, Y+20	; 0x14
    46d4:	01 97       	sbiw	r24, 0x01	; 1
    46d6:	9c 8b       	std	Y+20, r25	; 0x14
    46d8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    46da:	8b 89       	ldd	r24, Y+19	; 0x13
    46dc:	9c 89       	ldd	r25, Y+20	; 0x14
    46de:	00 97       	sbiw	r24, 0x00	; 0
    46e0:	69 f7       	brne	.-38     	; 0x46bc <HAL_LCD_u8SendCommands+0xd0>
    46e2:	14 c0       	rjmp	.+40     	; 0x470c <HAL_LCD_u8SendCommands+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    46e4:	6d 89       	ldd	r22, Y+21	; 0x15
    46e6:	7e 89       	ldd	r23, Y+22	; 0x16
    46e8:	8f 89       	ldd	r24, Y+23	; 0x17
    46ea:	98 8d       	ldd	r25, Y+24	; 0x18
    46ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    46f0:	dc 01       	movw	r26, r24
    46f2:	cb 01       	movw	r24, r22
    46f4:	9c 8b       	std	Y+20, r25	; 0x14
    46f6:	8b 8b       	std	Y+19, r24	; 0x13
    46f8:	8b 89       	ldd	r24, Y+19	; 0x13
    46fa:	9c 89       	ldd	r25, Y+20	; 0x14
    46fc:	98 8b       	std	Y+16, r25	; 0x10
    46fe:	8f 87       	std	Y+15, r24	; 0x0f
    4700:	8f 85       	ldd	r24, Y+15	; 0x0f
    4702:	98 89       	ldd	r25, Y+16	; 0x10
    4704:	01 97       	sbiw	r24, 0x01	; 1
    4706:	f1 f7       	brne	.-4      	; 0x4704 <HAL_LCD_u8SendCommands+0x118>
    4708:	98 8b       	std	Y+16, r25	; 0x10
    470a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    470c:	81 e0       	ldi	r24, 0x01	; 1
    470e:	63 e0       	ldi	r22, 0x03	; 3
    4710:	40 e0       	ldi	r20, 0x00	; 0
    4712:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPortValue(LCD_D_PORT, (Loc_u8LCD_Command << 4));
    4716:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4718:	98 2f       	mov	r25, r24
    471a:	92 95       	swap	r25
    471c:	90 7f       	andi	r25, 0xF0	; 240
    471e:	80 e0       	ldi	r24, 0x00	; 0
    4720:	69 2f       	mov	r22, r25
    4722:	0e 94 32 1a 	call	0x3464	; 0x3464 <MCAL_DIO_u8SetPortValue>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    4726:	81 e0       	ldi	r24, 0x01	; 1
    4728:	63 e0       	ldi	r22, 0x03	; 3
    472a:	41 e0       	ldi	r20, 0x01	; 1
    472c:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
    4730:	80 e0       	ldi	r24, 0x00	; 0
    4732:	90 e0       	ldi	r25, 0x00	; 0
    4734:	a0 e0       	ldi	r26, 0x00	; 0
    4736:	b0 e4       	ldi	r27, 0x40	; 64
    4738:	8b 87       	std	Y+11, r24	; 0x0b
    473a:	9c 87       	std	Y+12, r25	; 0x0c
    473c:	ad 87       	std	Y+13, r26	; 0x0d
    473e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4740:	6b 85       	ldd	r22, Y+11	; 0x0b
    4742:	7c 85       	ldd	r23, Y+12	; 0x0c
    4744:	8d 85       	ldd	r24, Y+13	; 0x0d
    4746:	9e 85       	ldd	r25, Y+14	; 0x0e
    4748:	20 e0       	ldi	r18, 0x00	; 0
    474a:	30 e0       	ldi	r19, 0x00	; 0
    474c:	4a e7       	ldi	r20, 0x7A	; 122
    474e:	55 e4       	ldi	r21, 0x45	; 69
    4750:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4754:	dc 01       	movw	r26, r24
    4756:	cb 01       	movw	r24, r22
    4758:	8f 83       	std	Y+7, r24	; 0x07
    475a:	98 87       	std	Y+8, r25	; 0x08
    475c:	a9 87       	std	Y+9, r26	; 0x09
    475e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4760:	6f 81       	ldd	r22, Y+7	; 0x07
    4762:	78 85       	ldd	r23, Y+8	; 0x08
    4764:	89 85       	ldd	r24, Y+9	; 0x09
    4766:	9a 85       	ldd	r25, Y+10	; 0x0a
    4768:	20 e0       	ldi	r18, 0x00	; 0
    476a:	30 e0       	ldi	r19, 0x00	; 0
    476c:	40 e8       	ldi	r20, 0x80	; 128
    476e:	5f e3       	ldi	r21, 0x3F	; 63
    4770:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4774:	88 23       	and	r24, r24
    4776:	2c f4       	brge	.+10     	; 0x4782 <HAL_LCD_u8SendCommands+0x196>
		__ticks = 1;
    4778:	81 e0       	ldi	r24, 0x01	; 1
    477a:	90 e0       	ldi	r25, 0x00	; 0
    477c:	9e 83       	std	Y+6, r25	; 0x06
    477e:	8d 83       	std	Y+5, r24	; 0x05
    4780:	3f c0       	rjmp	.+126    	; 0x4800 <HAL_LCD_u8SendCommands+0x214>
	else if (__tmp > 65535)
    4782:	6f 81       	ldd	r22, Y+7	; 0x07
    4784:	78 85       	ldd	r23, Y+8	; 0x08
    4786:	89 85       	ldd	r24, Y+9	; 0x09
    4788:	9a 85       	ldd	r25, Y+10	; 0x0a
    478a:	20 e0       	ldi	r18, 0x00	; 0
    478c:	3f ef       	ldi	r19, 0xFF	; 255
    478e:	4f e7       	ldi	r20, 0x7F	; 127
    4790:	57 e4       	ldi	r21, 0x47	; 71
    4792:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4796:	18 16       	cp	r1, r24
    4798:	4c f5       	brge	.+82     	; 0x47ec <HAL_LCD_u8SendCommands+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    479a:	6b 85       	ldd	r22, Y+11	; 0x0b
    479c:	7c 85       	ldd	r23, Y+12	; 0x0c
    479e:	8d 85       	ldd	r24, Y+13	; 0x0d
    47a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    47a2:	20 e0       	ldi	r18, 0x00	; 0
    47a4:	30 e0       	ldi	r19, 0x00	; 0
    47a6:	40 e2       	ldi	r20, 0x20	; 32
    47a8:	51 e4       	ldi	r21, 0x41	; 65
    47aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    47ae:	dc 01       	movw	r26, r24
    47b0:	cb 01       	movw	r24, r22
    47b2:	bc 01       	movw	r22, r24
    47b4:	cd 01       	movw	r24, r26
    47b6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    47ba:	dc 01       	movw	r26, r24
    47bc:	cb 01       	movw	r24, r22
    47be:	9e 83       	std	Y+6, r25	; 0x06
    47c0:	8d 83       	std	Y+5, r24	; 0x05
    47c2:	0f c0       	rjmp	.+30     	; 0x47e2 <HAL_LCD_u8SendCommands+0x1f6>
    47c4:	80 e9       	ldi	r24, 0x90	; 144
    47c6:	91 e0       	ldi	r25, 0x01	; 1
    47c8:	9c 83       	std	Y+4, r25	; 0x04
    47ca:	8b 83       	std	Y+3, r24	; 0x03
    47cc:	8b 81       	ldd	r24, Y+3	; 0x03
    47ce:	9c 81       	ldd	r25, Y+4	; 0x04
    47d0:	01 97       	sbiw	r24, 0x01	; 1
    47d2:	f1 f7       	brne	.-4      	; 0x47d0 <HAL_LCD_u8SendCommands+0x1e4>
    47d4:	9c 83       	std	Y+4, r25	; 0x04
    47d6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    47d8:	8d 81       	ldd	r24, Y+5	; 0x05
    47da:	9e 81       	ldd	r25, Y+6	; 0x06
    47dc:	01 97       	sbiw	r24, 0x01	; 1
    47de:	9e 83       	std	Y+6, r25	; 0x06
    47e0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    47e2:	8d 81       	ldd	r24, Y+5	; 0x05
    47e4:	9e 81       	ldd	r25, Y+6	; 0x06
    47e6:	00 97       	sbiw	r24, 0x00	; 0
    47e8:	69 f7       	brne	.-38     	; 0x47c4 <HAL_LCD_u8SendCommands+0x1d8>
    47ea:	14 c0       	rjmp	.+40     	; 0x4814 <HAL_LCD_u8SendCommands+0x228>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    47ec:	6f 81       	ldd	r22, Y+7	; 0x07
    47ee:	78 85       	ldd	r23, Y+8	; 0x08
    47f0:	89 85       	ldd	r24, Y+9	; 0x09
    47f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    47f4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    47f8:	dc 01       	movw	r26, r24
    47fa:	cb 01       	movw	r24, r22
    47fc:	9e 83       	std	Y+6, r25	; 0x06
    47fe:	8d 83       	std	Y+5, r24	; 0x05
    4800:	8d 81       	ldd	r24, Y+5	; 0x05
    4802:	9e 81       	ldd	r25, Y+6	; 0x06
    4804:	9a 83       	std	Y+2, r25	; 0x02
    4806:	89 83       	std	Y+1, r24	; 0x01
    4808:	89 81       	ldd	r24, Y+1	; 0x01
    480a:	9a 81       	ldd	r25, Y+2	; 0x02
    480c:	01 97       	sbiw	r24, 0x01	; 1
    480e:	f1 f7       	brne	.-4      	; 0x480c <HAL_LCD_u8SendCommands+0x220>
    4810:	9a 83       	std	Y+2, r25	; 0x02
    4812:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    4814:	81 e0       	ldi	r24, 0x01	; 1
    4816:	63 e0       	ldi	r22, 0x03	; 3
    4818:	40 e0       	ldi	r20, 0x00	; 0
    481a:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
}
    481e:	6d 96       	adiw	r28, 0x1d	; 29
    4820:	0f b6       	in	r0, 0x3f	; 63
    4822:	f8 94       	cli
    4824:	de bf       	out	0x3e, r29	; 62
    4826:	0f be       	out	0x3f, r0	; 63
    4828:	cd bf       	out	0x3d, r28	; 61
    482a:	cf 91       	pop	r28
    482c:	df 91       	pop	r29
    482e:	08 95       	ret

00004830 <HAL_LCD_u8SendChar>:

void HAL_LCD_u8SendChar(u8 Loc_u8LCD_Char) {
    4830:	df 93       	push	r29
    4832:	cf 93       	push	r28
    4834:	cd b7       	in	r28, 0x3d	; 61
    4836:	de b7       	in	r29, 0x3e	; 62
    4838:	6d 97       	sbiw	r28, 0x1d	; 29
    483a:	0f b6       	in	r0, 0x3f	; 63
    483c:	f8 94       	cli
    483e:	de bf       	out	0x3e, r29	; 62
    4840:	0f be       	out	0x3f, r0	; 63
    4842:	cd bf       	out	0x3d, r28	; 61
    4844:	8d 8f       	std	Y+29, r24	; 0x1d
	MCAL_DIO_u8SetPinValue(RS_Port, RS_Pin, RS_High);
    4846:	81 e0       	ldi	r24, 0x01	; 1
    4848:	61 e0       	ldi	r22, 0x01	; 1
    484a:	41 e0       	ldi	r20, 0x01	; 1
    484c:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(RW_Port, RW_Pin, RW_Low);
    4850:	81 e0       	ldi	r24, 0x01	; 1
    4852:	62 e0       	ldi	r22, 0x02	; 2
    4854:	40 e0       	ldi	r20, 0x00	; 0
    4856:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPortValue(LCD_D_PORT, Loc_u8LCD_Char);
    485a:	80 e0       	ldi	r24, 0x00	; 0
    485c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    485e:	0e 94 32 1a 	call	0x3464	; 0x3464 <MCAL_DIO_u8SetPortValue>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    4862:	81 e0       	ldi	r24, 0x01	; 1
    4864:	63 e0       	ldi	r22, 0x03	; 3
    4866:	41 e0       	ldi	r20, 0x01	; 1
    4868:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
    486c:	80 e0       	ldi	r24, 0x00	; 0
    486e:	90 e0       	ldi	r25, 0x00	; 0
    4870:	a0 e0       	ldi	r26, 0x00	; 0
    4872:	b0 e4       	ldi	r27, 0x40	; 64
    4874:	89 8f       	std	Y+25, r24	; 0x19
    4876:	9a 8f       	std	Y+26, r25	; 0x1a
    4878:	ab 8f       	std	Y+27, r26	; 0x1b
    487a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    487c:	69 8d       	ldd	r22, Y+25	; 0x19
    487e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4880:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4882:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4884:	20 e0       	ldi	r18, 0x00	; 0
    4886:	30 e0       	ldi	r19, 0x00	; 0
    4888:	4a e7       	ldi	r20, 0x7A	; 122
    488a:	55 e4       	ldi	r21, 0x45	; 69
    488c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4890:	dc 01       	movw	r26, r24
    4892:	cb 01       	movw	r24, r22
    4894:	8d 8b       	std	Y+21, r24	; 0x15
    4896:	9e 8b       	std	Y+22, r25	; 0x16
    4898:	af 8b       	std	Y+23, r26	; 0x17
    489a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    489c:	6d 89       	ldd	r22, Y+21	; 0x15
    489e:	7e 89       	ldd	r23, Y+22	; 0x16
    48a0:	8f 89       	ldd	r24, Y+23	; 0x17
    48a2:	98 8d       	ldd	r25, Y+24	; 0x18
    48a4:	20 e0       	ldi	r18, 0x00	; 0
    48a6:	30 e0       	ldi	r19, 0x00	; 0
    48a8:	40 e8       	ldi	r20, 0x80	; 128
    48aa:	5f e3       	ldi	r21, 0x3F	; 63
    48ac:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    48b0:	88 23       	and	r24, r24
    48b2:	2c f4       	brge	.+10     	; 0x48be <HAL_LCD_u8SendChar+0x8e>
		__ticks = 1;
    48b4:	81 e0       	ldi	r24, 0x01	; 1
    48b6:	90 e0       	ldi	r25, 0x00	; 0
    48b8:	9c 8b       	std	Y+20, r25	; 0x14
    48ba:	8b 8b       	std	Y+19, r24	; 0x13
    48bc:	3f c0       	rjmp	.+126    	; 0x493c <HAL_LCD_u8SendChar+0x10c>
	else if (__tmp > 65535)
    48be:	6d 89       	ldd	r22, Y+21	; 0x15
    48c0:	7e 89       	ldd	r23, Y+22	; 0x16
    48c2:	8f 89       	ldd	r24, Y+23	; 0x17
    48c4:	98 8d       	ldd	r25, Y+24	; 0x18
    48c6:	20 e0       	ldi	r18, 0x00	; 0
    48c8:	3f ef       	ldi	r19, 0xFF	; 255
    48ca:	4f e7       	ldi	r20, 0x7F	; 127
    48cc:	57 e4       	ldi	r21, 0x47	; 71
    48ce:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    48d2:	18 16       	cp	r1, r24
    48d4:	4c f5       	brge	.+82     	; 0x4928 <HAL_LCD_u8SendChar+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    48d6:	69 8d       	ldd	r22, Y+25	; 0x19
    48d8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    48da:	8b 8d       	ldd	r24, Y+27	; 0x1b
    48dc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    48de:	20 e0       	ldi	r18, 0x00	; 0
    48e0:	30 e0       	ldi	r19, 0x00	; 0
    48e2:	40 e2       	ldi	r20, 0x20	; 32
    48e4:	51 e4       	ldi	r21, 0x41	; 65
    48e6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    48ea:	dc 01       	movw	r26, r24
    48ec:	cb 01       	movw	r24, r22
    48ee:	bc 01       	movw	r22, r24
    48f0:	cd 01       	movw	r24, r26
    48f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    48f6:	dc 01       	movw	r26, r24
    48f8:	cb 01       	movw	r24, r22
    48fa:	9c 8b       	std	Y+20, r25	; 0x14
    48fc:	8b 8b       	std	Y+19, r24	; 0x13
    48fe:	0f c0       	rjmp	.+30     	; 0x491e <HAL_LCD_u8SendChar+0xee>
    4900:	80 e9       	ldi	r24, 0x90	; 144
    4902:	91 e0       	ldi	r25, 0x01	; 1
    4904:	9a 8b       	std	Y+18, r25	; 0x12
    4906:	89 8b       	std	Y+17, r24	; 0x11
    4908:	89 89       	ldd	r24, Y+17	; 0x11
    490a:	9a 89       	ldd	r25, Y+18	; 0x12
    490c:	01 97       	sbiw	r24, 0x01	; 1
    490e:	f1 f7       	brne	.-4      	; 0x490c <HAL_LCD_u8SendChar+0xdc>
    4910:	9a 8b       	std	Y+18, r25	; 0x12
    4912:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4914:	8b 89       	ldd	r24, Y+19	; 0x13
    4916:	9c 89       	ldd	r25, Y+20	; 0x14
    4918:	01 97       	sbiw	r24, 0x01	; 1
    491a:	9c 8b       	std	Y+20, r25	; 0x14
    491c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    491e:	8b 89       	ldd	r24, Y+19	; 0x13
    4920:	9c 89       	ldd	r25, Y+20	; 0x14
    4922:	00 97       	sbiw	r24, 0x00	; 0
    4924:	69 f7       	brne	.-38     	; 0x4900 <HAL_LCD_u8SendChar+0xd0>
    4926:	14 c0       	rjmp	.+40     	; 0x4950 <HAL_LCD_u8SendChar+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4928:	6d 89       	ldd	r22, Y+21	; 0x15
    492a:	7e 89       	ldd	r23, Y+22	; 0x16
    492c:	8f 89       	ldd	r24, Y+23	; 0x17
    492e:	98 8d       	ldd	r25, Y+24	; 0x18
    4930:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4934:	dc 01       	movw	r26, r24
    4936:	cb 01       	movw	r24, r22
    4938:	9c 8b       	std	Y+20, r25	; 0x14
    493a:	8b 8b       	std	Y+19, r24	; 0x13
    493c:	8b 89       	ldd	r24, Y+19	; 0x13
    493e:	9c 89       	ldd	r25, Y+20	; 0x14
    4940:	98 8b       	std	Y+16, r25	; 0x10
    4942:	8f 87       	std	Y+15, r24	; 0x0f
    4944:	8f 85       	ldd	r24, Y+15	; 0x0f
    4946:	98 89       	ldd	r25, Y+16	; 0x10
    4948:	01 97       	sbiw	r24, 0x01	; 1
    494a:	f1 f7       	brne	.-4      	; 0x4948 <HAL_LCD_u8SendChar+0x118>
    494c:	98 8b       	std	Y+16, r25	; 0x10
    494e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    4950:	81 e0       	ldi	r24, 0x01	; 1
    4952:	63 e0       	ldi	r22, 0x03	; 3
    4954:	40 e0       	ldi	r20, 0x00	; 0
    4956:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPortValue(LCD_D_PORT, (Loc_u8LCD_Char << 4));
    495a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    495c:	98 2f       	mov	r25, r24
    495e:	92 95       	swap	r25
    4960:	90 7f       	andi	r25, 0xF0	; 240
    4962:	80 e0       	ldi	r24, 0x00	; 0
    4964:	69 2f       	mov	r22, r25
    4966:	0e 94 32 1a 	call	0x3464	; 0x3464 <MCAL_DIO_u8SetPortValue>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    496a:	81 e0       	ldi	r24, 0x01	; 1
    496c:	63 e0       	ldi	r22, 0x03	; 3
    496e:	41 e0       	ldi	r20, 0x01	; 1
    4970:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
    4974:	80 e0       	ldi	r24, 0x00	; 0
    4976:	90 e0       	ldi	r25, 0x00	; 0
    4978:	a0 e0       	ldi	r26, 0x00	; 0
    497a:	b0 e4       	ldi	r27, 0x40	; 64
    497c:	8b 87       	std	Y+11, r24	; 0x0b
    497e:	9c 87       	std	Y+12, r25	; 0x0c
    4980:	ad 87       	std	Y+13, r26	; 0x0d
    4982:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4984:	6b 85       	ldd	r22, Y+11	; 0x0b
    4986:	7c 85       	ldd	r23, Y+12	; 0x0c
    4988:	8d 85       	ldd	r24, Y+13	; 0x0d
    498a:	9e 85       	ldd	r25, Y+14	; 0x0e
    498c:	20 e0       	ldi	r18, 0x00	; 0
    498e:	30 e0       	ldi	r19, 0x00	; 0
    4990:	4a e7       	ldi	r20, 0x7A	; 122
    4992:	55 e4       	ldi	r21, 0x45	; 69
    4994:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4998:	dc 01       	movw	r26, r24
    499a:	cb 01       	movw	r24, r22
    499c:	8f 83       	std	Y+7, r24	; 0x07
    499e:	98 87       	std	Y+8, r25	; 0x08
    49a0:	a9 87       	std	Y+9, r26	; 0x09
    49a2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    49a4:	6f 81       	ldd	r22, Y+7	; 0x07
    49a6:	78 85       	ldd	r23, Y+8	; 0x08
    49a8:	89 85       	ldd	r24, Y+9	; 0x09
    49aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    49ac:	20 e0       	ldi	r18, 0x00	; 0
    49ae:	30 e0       	ldi	r19, 0x00	; 0
    49b0:	40 e8       	ldi	r20, 0x80	; 128
    49b2:	5f e3       	ldi	r21, 0x3F	; 63
    49b4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    49b8:	88 23       	and	r24, r24
    49ba:	2c f4       	brge	.+10     	; 0x49c6 <HAL_LCD_u8SendChar+0x196>
		__ticks = 1;
    49bc:	81 e0       	ldi	r24, 0x01	; 1
    49be:	90 e0       	ldi	r25, 0x00	; 0
    49c0:	9e 83       	std	Y+6, r25	; 0x06
    49c2:	8d 83       	std	Y+5, r24	; 0x05
    49c4:	3f c0       	rjmp	.+126    	; 0x4a44 <HAL_LCD_u8SendChar+0x214>
	else if (__tmp > 65535)
    49c6:	6f 81       	ldd	r22, Y+7	; 0x07
    49c8:	78 85       	ldd	r23, Y+8	; 0x08
    49ca:	89 85       	ldd	r24, Y+9	; 0x09
    49cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    49ce:	20 e0       	ldi	r18, 0x00	; 0
    49d0:	3f ef       	ldi	r19, 0xFF	; 255
    49d2:	4f e7       	ldi	r20, 0x7F	; 127
    49d4:	57 e4       	ldi	r21, 0x47	; 71
    49d6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    49da:	18 16       	cp	r1, r24
    49dc:	4c f5       	brge	.+82     	; 0x4a30 <HAL_LCD_u8SendChar+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    49de:	6b 85       	ldd	r22, Y+11	; 0x0b
    49e0:	7c 85       	ldd	r23, Y+12	; 0x0c
    49e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    49e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    49e6:	20 e0       	ldi	r18, 0x00	; 0
    49e8:	30 e0       	ldi	r19, 0x00	; 0
    49ea:	40 e2       	ldi	r20, 0x20	; 32
    49ec:	51 e4       	ldi	r21, 0x41	; 65
    49ee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49f2:	dc 01       	movw	r26, r24
    49f4:	cb 01       	movw	r24, r22
    49f6:	bc 01       	movw	r22, r24
    49f8:	cd 01       	movw	r24, r26
    49fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    49fe:	dc 01       	movw	r26, r24
    4a00:	cb 01       	movw	r24, r22
    4a02:	9e 83       	std	Y+6, r25	; 0x06
    4a04:	8d 83       	std	Y+5, r24	; 0x05
    4a06:	0f c0       	rjmp	.+30     	; 0x4a26 <HAL_LCD_u8SendChar+0x1f6>
    4a08:	80 e9       	ldi	r24, 0x90	; 144
    4a0a:	91 e0       	ldi	r25, 0x01	; 1
    4a0c:	9c 83       	std	Y+4, r25	; 0x04
    4a0e:	8b 83       	std	Y+3, r24	; 0x03
    4a10:	8b 81       	ldd	r24, Y+3	; 0x03
    4a12:	9c 81       	ldd	r25, Y+4	; 0x04
    4a14:	01 97       	sbiw	r24, 0x01	; 1
    4a16:	f1 f7       	brne	.-4      	; 0x4a14 <HAL_LCD_u8SendChar+0x1e4>
    4a18:	9c 83       	std	Y+4, r25	; 0x04
    4a1a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a1c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a1e:	9e 81       	ldd	r25, Y+6	; 0x06
    4a20:	01 97       	sbiw	r24, 0x01	; 1
    4a22:	9e 83       	std	Y+6, r25	; 0x06
    4a24:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a26:	8d 81       	ldd	r24, Y+5	; 0x05
    4a28:	9e 81       	ldd	r25, Y+6	; 0x06
    4a2a:	00 97       	sbiw	r24, 0x00	; 0
    4a2c:	69 f7       	brne	.-38     	; 0x4a08 <HAL_LCD_u8SendChar+0x1d8>
    4a2e:	14 c0       	rjmp	.+40     	; 0x4a58 <HAL_LCD_u8SendChar+0x228>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a30:	6f 81       	ldd	r22, Y+7	; 0x07
    4a32:	78 85       	ldd	r23, Y+8	; 0x08
    4a34:	89 85       	ldd	r24, Y+9	; 0x09
    4a36:	9a 85       	ldd	r25, Y+10	; 0x0a
    4a38:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a3c:	dc 01       	movw	r26, r24
    4a3e:	cb 01       	movw	r24, r22
    4a40:	9e 83       	std	Y+6, r25	; 0x06
    4a42:	8d 83       	std	Y+5, r24	; 0x05
    4a44:	8d 81       	ldd	r24, Y+5	; 0x05
    4a46:	9e 81       	ldd	r25, Y+6	; 0x06
    4a48:	9a 83       	std	Y+2, r25	; 0x02
    4a4a:	89 83       	std	Y+1, r24	; 0x01
    4a4c:	89 81       	ldd	r24, Y+1	; 0x01
    4a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a50:	01 97       	sbiw	r24, 0x01	; 1
    4a52:	f1 f7       	brne	.-4      	; 0x4a50 <HAL_LCD_u8SendChar+0x220>
    4a54:	9a 83       	std	Y+2, r25	; 0x02
    4a56:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    4a58:	81 e0       	ldi	r24, 0x01	; 1
    4a5a:	63 e0       	ldi	r22, 0x03	; 3
    4a5c:	40 e0       	ldi	r20, 0x00	; 0
    4a5e:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
}
    4a62:	6d 96       	adiw	r28, 0x1d	; 29
    4a64:	0f b6       	in	r0, 0x3f	; 63
    4a66:	f8 94       	cli
    4a68:	de bf       	out	0x3e, r29	; 62
    4a6a:	0f be       	out	0x3f, r0	; 63
    4a6c:	cd bf       	out	0x3d, r28	; 61
    4a6e:	cf 91       	pop	r28
    4a70:	df 91       	pop	r29
    4a72:	08 95       	ret

00004a74 <HAL_LCD_u8SendString>:

void HAL_LCD_u8SendString(u8* Loc_u8LCD_String) {
    4a74:	df 93       	push	r29
    4a76:	cf 93       	push	r28
    4a78:	00 d0       	rcall	.+0      	; 0x4a7a <HAL_LCD_u8SendString+0x6>
    4a7a:	00 d0       	rcall	.+0      	; 0x4a7c <HAL_LCD_u8SendString+0x8>
    4a7c:	00 d0       	rcall	.+0      	; 0x4a7e <HAL_LCD_u8SendString+0xa>
    4a7e:	cd b7       	in	r28, 0x3d	; 61
    4a80:	de b7       	in	r29, 0x3e	; 62
    4a82:	9e 83       	std	Y+6, r25	; 0x06
    4a84:	8d 83       	std	Y+5, r24	; 0x05
	for (u32 count = 0; Loc_u8LCD_String[count] != '\0'; count++) {
    4a86:	19 82       	std	Y+1, r1	; 0x01
    4a88:	1a 82       	std	Y+2, r1	; 0x02
    4a8a:	1b 82       	std	Y+3, r1	; 0x03
    4a8c:	1c 82       	std	Y+4, r1	; 0x04
    4a8e:	15 c0       	rjmp	.+42     	; 0x4aba <HAL_LCD_u8SendString+0x46>
		HAL_LCD_u8SendChar(Loc_u8LCD_String[count]);
    4a90:	29 81       	ldd	r18, Y+1	; 0x01
    4a92:	3a 81       	ldd	r19, Y+2	; 0x02
    4a94:	8d 81       	ldd	r24, Y+5	; 0x05
    4a96:	9e 81       	ldd	r25, Y+6	; 0x06
    4a98:	fc 01       	movw	r30, r24
    4a9a:	e2 0f       	add	r30, r18
    4a9c:	f3 1f       	adc	r31, r19
    4a9e:	80 81       	ld	r24, Z
    4aa0:	0e 94 18 24 	call	0x4830	; 0x4830 <HAL_LCD_u8SendChar>
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
}

void HAL_LCD_u8SendString(u8* Loc_u8LCD_String) {
	for (u32 count = 0; Loc_u8LCD_String[count] != '\0'; count++) {
    4aa4:	89 81       	ldd	r24, Y+1	; 0x01
    4aa6:	9a 81       	ldd	r25, Y+2	; 0x02
    4aa8:	ab 81       	ldd	r26, Y+3	; 0x03
    4aaa:	bc 81       	ldd	r27, Y+4	; 0x04
    4aac:	01 96       	adiw	r24, 0x01	; 1
    4aae:	a1 1d       	adc	r26, r1
    4ab0:	b1 1d       	adc	r27, r1
    4ab2:	89 83       	std	Y+1, r24	; 0x01
    4ab4:	9a 83       	std	Y+2, r25	; 0x02
    4ab6:	ab 83       	std	Y+3, r26	; 0x03
    4ab8:	bc 83       	std	Y+4, r27	; 0x04
    4aba:	29 81       	ldd	r18, Y+1	; 0x01
    4abc:	3a 81       	ldd	r19, Y+2	; 0x02
    4abe:	8d 81       	ldd	r24, Y+5	; 0x05
    4ac0:	9e 81       	ldd	r25, Y+6	; 0x06
    4ac2:	fc 01       	movw	r30, r24
    4ac4:	e2 0f       	add	r30, r18
    4ac6:	f3 1f       	adc	r31, r19
    4ac8:	80 81       	ld	r24, Z
    4aca:	88 23       	and	r24, r24
    4acc:	09 f7       	brne	.-62     	; 0x4a90 <HAL_LCD_u8SendString+0x1c>
		HAL_LCD_u8SendChar(Loc_u8LCD_String[count]);
	}
}
    4ace:	26 96       	adiw	r28, 0x06	; 6
    4ad0:	0f b6       	in	r0, 0x3f	; 63
    4ad2:	f8 94       	cli
    4ad4:	de bf       	out	0x3e, r29	; 62
    4ad6:	0f be       	out	0x3f, r0	; 63
    4ad8:	cd bf       	out	0x3d, r28	; 61
    4ada:	cf 91       	pop	r28
    4adc:	df 91       	pop	r29
    4ade:	08 95       	ret

00004ae0 <HAL_LCD_u8SendNumber>:

void HAL_LCD_u8SendNumber(u16 Loc_u8LCD_Number) {
    4ae0:	df 93       	push	r29
    4ae2:	cf 93       	push	r28
    4ae4:	cd b7       	in	r28, 0x3d	; 61
    4ae6:	de b7       	in	r29, 0x3e	; 62
    4ae8:	2c 97       	sbiw	r28, 0x0c	; 12
    4aea:	0f b6       	in	r0, 0x3f	; 63
    4aec:	f8 94       	cli
    4aee:	de bf       	out	0x3e, r29	; 62
    4af0:	0f be       	out	0x3f, r0	; 63
    4af2:	cd bf       	out	0x3d, r28	; 61
    4af4:	9c 87       	std	Y+12, r25	; 0x0c
    4af6:	8b 87       	std	Y+11, r24	; 0x0b
	u8 str[10];
	itoa(Loc_u8LCD_Number, str, 10);
    4af8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4afa:	9c 85       	ldd	r25, Y+12	; 0x0c
    4afc:	9e 01       	movw	r18, r28
    4afe:	2f 5f       	subi	r18, 0xFF	; 255
    4b00:	3f 4f       	sbci	r19, 0xFF	; 255
    4b02:	b9 01       	movw	r22, r18
    4b04:	4a e0       	ldi	r20, 0x0A	; 10
    4b06:	50 e0       	ldi	r21, 0x00	; 0
    4b08:	0e 94 1e 47 	call	0x8e3c	; 0x8e3c <itoa>
	HAL_LCD_u8SendString(str);
    4b0c:	ce 01       	movw	r24, r28
    4b0e:	01 96       	adiw	r24, 0x01	; 1
    4b10:	0e 94 3a 25 	call	0x4a74	; 0x4a74 <HAL_LCD_u8SendString>
}
    4b14:	2c 96       	adiw	r28, 0x0c	; 12
    4b16:	0f b6       	in	r0, 0x3f	; 63
    4b18:	f8 94       	cli
    4b1a:	de bf       	out	0x3e, r29	; 62
    4b1c:	0f be       	out	0x3f, r0	; 63
    4b1e:	cd bf       	out	0x3d, r28	; 61
    4b20:	cf 91       	pop	r28
    4b22:	df 91       	pop	r29
    4b24:	08 95       	ret

00004b26 <HAL_LCD_u8GoTo>:

void HAL_LCD_u8GoTo(u8 Loc_u8TypeOfShift, u8 Loc_u8NumOfShift) {
    4b26:	df 93       	push	r29
    4b28:	cf 93       	push	r28
    4b2a:	cd b7       	in	r28, 0x3d	; 61
    4b2c:	de b7       	in	r29, 0x3e	; 62
    4b2e:	c2 54       	subi	r28, 0x42	; 66
    4b30:	d0 40       	sbci	r29, 0x00	; 0
    4b32:	0f b6       	in	r0, 0x3f	; 63
    4b34:	f8 94       	cli
    4b36:	de bf       	out	0x3e, r29	; 62
    4b38:	0f be       	out	0x3f, r0	; 63
    4b3a:	cd bf       	out	0x3d, r28	; 61
    4b3c:	fe 01       	movw	r30, r28
    4b3e:	ef 5b       	subi	r30, 0xBF	; 191
    4b40:	ff 4f       	sbci	r31, 0xFF	; 255
    4b42:	80 83       	st	Z, r24
    4b44:	fe 01       	movw	r30, r28
    4b46:	ee 5b       	subi	r30, 0xBE	; 190
    4b48:	ff 4f       	sbci	r31, 0xFF	; 255
    4b4a:	60 83       	st	Z, r22
	if (Loc_u8TypeOfShift == Right_Shift) {
    4b4c:	fe 01       	movw	r30, r28
    4b4e:	ef 5b       	subi	r30, 0xBF	; 191
    4b50:	ff 4f       	sbci	r31, 0xFF	; 255
    4b52:	80 81       	ld	r24, Z
    4b54:	81 30       	cpi	r24, 0x01	; 1
    4b56:	09 f0       	breq	.+2      	; 0x4b5a <HAL_LCD_u8GoTo+0x34>
    4b58:	a0 c0       	rjmp	.+320    	; 0x4c9a <HAL_LCD_u8GoTo+0x174>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    4b5a:	fe 01       	movw	r30, r28
    4b5c:	fd 96       	adiw	r30, 0x3d	; 61
    4b5e:	10 82       	st	Z, r1
    4b60:	11 82       	std	Z+1, r1	; 0x01
    4b62:	12 82       	std	Z+2, r1	; 0x02
    4b64:	13 82       	std	Z+3, r1	; 0x03
    4b66:	84 c0       	rjmp	.+264    	; 0x4c70 <HAL_LCD_u8GoTo+0x14a>
    4b68:	80 e0       	ldi	r24, 0x00	; 0
    4b6a:	90 e0       	ldi	r25, 0x00	; 0
    4b6c:	a0 e0       	ldi	r26, 0x00	; 0
    4b6e:	b0 e4       	ldi	r27, 0x40	; 64
    4b70:	8d ab       	std	Y+53, r24	; 0x35
    4b72:	9e ab       	std	Y+54, r25	; 0x36
    4b74:	af ab       	std	Y+55, r26	; 0x37
    4b76:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4b78:	6d a9       	ldd	r22, Y+53	; 0x35
    4b7a:	7e a9       	ldd	r23, Y+54	; 0x36
    4b7c:	8f a9       	ldd	r24, Y+55	; 0x37
    4b7e:	98 ad       	ldd	r25, Y+56	; 0x38
    4b80:	20 e0       	ldi	r18, 0x00	; 0
    4b82:	30 e0       	ldi	r19, 0x00	; 0
    4b84:	4a e7       	ldi	r20, 0x7A	; 122
    4b86:	55 e4       	ldi	r21, 0x45	; 69
    4b88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4b8c:	dc 01       	movw	r26, r24
    4b8e:	cb 01       	movw	r24, r22
    4b90:	89 ab       	std	Y+49, r24	; 0x31
    4b92:	9a ab       	std	Y+50, r25	; 0x32
    4b94:	ab ab       	std	Y+51, r26	; 0x33
    4b96:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    4b98:	69 a9       	ldd	r22, Y+49	; 0x31
    4b9a:	7a a9       	ldd	r23, Y+50	; 0x32
    4b9c:	8b a9       	ldd	r24, Y+51	; 0x33
    4b9e:	9c a9       	ldd	r25, Y+52	; 0x34
    4ba0:	20 e0       	ldi	r18, 0x00	; 0
    4ba2:	30 e0       	ldi	r19, 0x00	; 0
    4ba4:	40 e8       	ldi	r20, 0x80	; 128
    4ba6:	5f e3       	ldi	r21, 0x3F	; 63
    4ba8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4bac:	88 23       	and	r24, r24
    4bae:	2c f4       	brge	.+10     	; 0x4bba <HAL_LCD_u8GoTo+0x94>
		__ticks = 1;
    4bb0:	81 e0       	ldi	r24, 0x01	; 1
    4bb2:	90 e0       	ldi	r25, 0x00	; 0
    4bb4:	98 ab       	std	Y+48, r25	; 0x30
    4bb6:	8f a7       	std	Y+47, r24	; 0x2f
    4bb8:	3f c0       	rjmp	.+126    	; 0x4c38 <HAL_LCD_u8GoTo+0x112>
	else if (__tmp > 65535)
    4bba:	69 a9       	ldd	r22, Y+49	; 0x31
    4bbc:	7a a9       	ldd	r23, Y+50	; 0x32
    4bbe:	8b a9       	ldd	r24, Y+51	; 0x33
    4bc0:	9c a9       	ldd	r25, Y+52	; 0x34
    4bc2:	20 e0       	ldi	r18, 0x00	; 0
    4bc4:	3f ef       	ldi	r19, 0xFF	; 255
    4bc6:	4f e7       	ldi	r20, 0x7F	; 127
    4bc8:	57 e4       	ldi	r21, 0x47	; 71
    4bca:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4bce:	18 16       	cp	r1, r24
    4bd0:	4c f5       	brge	.+82     	; 0x4c24 <HAL_LCD_u8GoTo+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4bd2:	6d a9       	ldd	r22, Y+53	; 0x35
    4bd4:	7e a9       	ldd	r23, Y+54	; 0x36
    4bd6:	8f a9       	ldd	r24, Y+55	; 0x37
    4bd8:	98 ad       	ldd	r25, Y+56	; 0x38
    4bda:	20 e0       	ldi	r18, 0x00	; 0
    4bdc:	30 e0       	ldi	r19, 0x00	; 0
    4bde:	40 e2       	ldi	r20, 0x20	; 32
    4be0:	51 e4       	ldi	r21, 0x41	; 65
    4be2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4be6:	dc 01       	movw	r26, r24
    4be8:	cb 01       	movw	r24, r22
    4bea:	bc 01       	movw	r22, r24
    4bec:	cd 01       	movw	r24, r26
    4bee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4bf2:	dc 01       	movw	r26, r24
    4bf4:	cb 01       	movw	r24, r22
    4bf6:	98 ab       	std	Y+48, r25	; 0x30
    4bf8:	8f a7       	std	Y+47, r24	; 0x2f
    4bfa:	0f c0       	rjmp	.+30     	; 0x4c1a <HAL_LCD_u8GoTo+0xf4>
    4bfc:	80 e9       	ldi	r24, 0x90	; 144
    4bfe:	91 e0       	ldi	r25, 0x01	; 1
    4c00:	9e a7       	std	Y+46, r25	; 0x2e
    4c02:	8d a7       	std	Y+45, r24	; 0x2d
    4c04:	8d a5       	ldd	r24, Y+45	; 0x2d
    4c06:	9e a5       	ldd	r25, Y+46	; 0x2e
    4c08:	01 97       	sbiw	r24, 0x01	; 1
    4c0a:	f1 f7       	brne	.-4      	; 0x4c08 <HAL_LCD_u8GoTo+0xe2>
    4c0c:	9e a7       	std	Y+46, r25	; 0x2e
    4c0e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c10:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c12:	98 a9       	ldd	r25, Y+48	; 0x30
    4c14:	01 97       	sbiw	r24, 0x01	; 1
    4c16:	98 ab       	std	Y+48, r25	; 0x30
    4c18:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c1a:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c1c:	98 a9       	ldd	r25, Y+48	; 0x30
    4c1e:	00 97       	sbiw	r24, 0x00	; 0
    4c20:	69 f7       	brne	.-38     	; 0x4bfc <HAL_LCD_u8GoTo+0xd6>
    4c22:	14 c0       	rjmp	.+40     	; 0x4c4c <HAL_LCD_u8GoTo+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4c24:	69 a9       	ldd	r22, Y+49	; 0x31
    4c26:	7a a9       	ldd	r23, Y+50	; 0x32
    4c28:	8b a9       	ldd	r24, Y+51	; 0x33
    4c2a:	9c a9       	ldd	r25, Y+52	; 0x34
    4c2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4c30:	dc 01       	movw	r26, r24
    4c32:	cb 01       	movw	r24, r22
    4c34:	98 ab       	std	Y+48, r25	; 0x30
    4c36:	8f a7       	std	Y+47, r24	; 0x2f
    4c38:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c3a:	98 a9       	ldd	r25, Y+48	; 0x30
    4c3c:	9c a7       	std	Y+44, r25	; 0x2c
    4c3e:	8b a7       	std	Y+43, r24	; 0x2b
    4c40:	8b a5       	ldd	r24, Y+43	; 0x2b
    4c42:	9c a5       	ldd	r25, Y+44	; 0x2c
    4c44:	01 97       	sbiw	r24, 0x01	; 1
    4c46:	f1 f7       	brne	.-4      	; 0x4c44 <HAL_LCD_u8GoTo+0x11e>
    4c48:	9c a7       	std	Y+44, r25	; 0x2c
    4c4a:	8b a7       	std	Y+43, r24	; 0x2b
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
    4c4c:	8c e1       	ldi	r24, 0x1C	; 28
    4c4e:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
	HAL_LCD_u8SendString(str);
}

void HAL_LCD_u8GoTo(u8 Loc_u8TypeOfShift, u8 Loc_u8NumOfShift) {
	if (Loc_u8TypeOfShift == Right_Shift) {
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    4c52:	fe 01       	movw	r30, r28
    4c54:	fd 96       	adiw	r30, 0x3d	; 61
    4c56:	80 81       	ld	r24, Z
    4c58:	91 81       	ldd	r25, Z+1	; 0x01
    4c5a:	a2 81       	ldd	r26, Z+2	; 0x02
    4c5c:	b3 81       	ldd	r27, Z+3	; 0x03
    4c5e:	01 96       	adiw	r24, 0x01	; 1
    4c60:	a1 1d       	adc	r26, r1
    4c62:	b1 1d       	adc	r27, r1
    4c64:	fe 01       	movw	r30, r28
    4c66:	fd 96       	adiw	r30, 0x3d	; 61
    4c68:	80 83       	st	Z, r24
    4c6a:	91 83       	std	Z+1, r25	; 0x01
    4c6c:	a2 83       	std	Z+2, r26	; 0x02
    4c6e:	b3 83       	std	Z+3, r27	; 0x03
    4c70:	fe 01       	movw	r30, r28
    4c72:	ee 5b       	subi	r30, 0xBE	; 190
    4c74:	ff 4f       	sbci	r31, 0xFF	; 255
    4c76:	80 81       	ld	r24, Z
    4c78:	28 2f       	mov	r18, r24
    4c7a:	30 e0       	ldi	r19, 0x00	; 0
    4c7c:	40 e0       	ldi	r20, 0x00	; 0
    4c7e:	50 e0       	ldi	r21, 0x00	; 0
    4c80:	fe 01       	movw	r30, r28
    4c82:	fd 96       	adiw	r30, 0x3d	; 61
    4c84:	80 81       	ld	r24, Z
    4c86:	91 81       	ldd	r25, Z+1	; 0x01
    4c88:	a2 81       	ldd	r26, Z+2	; 0x02
    4c8a:	b3 81       	ldd	r27, Z+3	; 0x03
    4c8c:	82 17       	cp	r24, r18
    4c8e:	93 07       	cpc	r25, r19
    4c90:	a4 07       	cpc	r26, r20
    4c92:	b5 07       	cpc	r27, r21
    4c94:	08 f4       	brcc	.+2      	; 0x4c98 <HAL_LCD_u8GoTo+0x172>
    4c96:	68 cf       	rjmp	.-304    	; 0x4b68 <HAL_LCD_u8GoTo+0x42>
    4c98:	98 c1       	rjmp	.+816    	; 0x4fca <HAL_LCD_u8GoTo+0x4a4>
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == Left_Shift) {
    4c9a:	fe 01       	movw	r30, r28
    4c9c:	ef 5b       	subi	r30, 0xBF	; 191
    4c9e:	ff 4f       	sbci	r31, 0xFF	; 255
    4ca0:	80 81       	ld	r24, Z
    4ca2:	88 23       	and	r24, r24
    4ca4:	09 f0       	breq	.+2      	; 0x4ca8 <HAL_LCD_u8GoTo+0x182>
    4ca6:	98 c0       	rjmp	.+304    	; 0x4dd8 <HAL_LCD_u8GoTo+0x2b2>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    4ca8:	19 ae       	std	Y+57, r1	; 0x39
    4caa:	1a ae       	std	Y+58, r1	; 0x3a
    4cac:	1b ae       	std	Y+59, r1	; 0x3b
    4cae:	1c ae       	std	Y+60, r1	; 0x3c
    4cb0:	80 c0       	rjmp	.+256    	; 0x4db2 <HAL_LCD_u8GoTo+0x28c>
    4cb2:	80 e0       	ldi	r24, 0x00	; 0
    4cb4:	90 e0       	ldi	r25, 0x00	; 0
    4cb6:	a0 e0       	ldi	r26, 0x00	; 0
    4cb8:	b0 e4       	ldi	r27, 0x40	; 64
    4cba:	8f a3       	std	Y+39, r24	; 0x27
    4cbc:	98 a7       	std	Y+40, r25	; 0x28
    4cbe:	a9 a7       	std	Y+41, r26	; 0x29
    4cc0:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4cc2:	6f a1       	ldd	r22, Y+39	; 0x27
    4cc4:	78 a5       	ldd	r23, Y+40	; 0x28
    4cc6:	89 a5       	ldd	r24, Y+41	; 0x29
    4cc8:	9a a5       	ldd	r25, Y+42	; 0x2a
    4cca:	20 e0       	ldi	r18, 0x00	; 0
    4ccc:	30 e0       	ldi	r19, 0x00	; 0
    4cce:	4a e7       	ldi	r20, 0x7A	; 122
    4cd0:	55 e4       	ldi	r21, 0x45	; 69
    4cd2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4cd6:	dc 01       	movw	r26, r24
    4cd8:	cb 01       	movw	r24, r22
    4cda:	8b a3       	std	Y+35, r24	; 0x23
    4cdc:	9c a3       	std	Y+36, r25	; 0x24
    4cde:	ad a3       	std	Y+37, r26	; 0x25
    4ce0:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4ce2:	6b a1       	ldd	r22, Y+35	; 0x23
    4ce4:	7c a1       	ldd	r23, Y+36	; 0x24
    4ce6:	8d a1       	ldd	r24, Y+37	; 0x25
    4ce8:	9e a1       	ldd	r25, Y+38	; 0x26
    4cea:	20 e0       	ldi	r18, 0x00	; 0
    4cec:	30 e0       	ldi	r19, 0x00	; 0
    4cee:	40 e8       	ldi	r20, 0x80	; 128
    4cf0:	5f e3       	ldi	r21, 0x3F	; 63
    4cf2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4cf6:	88 23       	and	r24, r24
    4cf8:	2c f4       	brge	.+10     	; 0x4d04 <HAL_LCD_u8GoTo+0x1de>
		__ticks = 1;
    4cfa:	81 e0       	ldi	r24, 0x01	; 1
    4cfc:	90 e0       	ldi	r25, 0x00	; 0
    4cfe:	9a a3       	std	Y+34, r25	; 0x22
    4d00:	89 a3       	std	Y+33, r24	; 0x21
    4d02:	3f c0       	rjmp	.+126    	; 0x4d82 <HAL_LCD_u8GoTo+0x25c>
	else if (__tmp > 65535)
    4d04:	6b a1       	ldd	r22, Y+35	; 0x23
    4d06:	7c a1       	ldd	r23, Y+36	; 0x24
    4d08:	8d a1       	ldd	r24, Y+37	; 0x25
    4d0a:	9e a1       	ldd	r25, Y+38	; 0x26
    4d0c:	20 e0       	ldi	r18, 0x00	; 0
    4d0e:	3f ef       	ldi	r19, 0xFF	; 255
    4d10:	4f e7       	ldi	r20, 0x7F	; 127
    4d12:	57 e4       	ldi	r21, 0x47	; 71
    4d14:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4d18:	18 16       	cp	r1, r24
    4d1a:	4c f5       	brge	.+82     	; 0x4d6e <HAL_LCD_u8GoTo+0x248>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4d1c:	6f a1       	ldd	r22, Y+39	; 0x27
    4d1e:	78 a5       	ldd	r23, Y+40	; 0x28
    4d20:	89 a5       	ldd	r24, Y+41	; 0x29
    4d22:	9a a5       	ldd	r25, Y+42	; 0x2a
    4d24:	20 e0       	ldi	r18, 0x00	; 0
    4d26:	30 e0       	ldi	r19, 0x00	; 0
    4d28:	40 e2       	ldi	r20, 0x20	; 32
    4d2a:	51 e4       	ldi	r21, 0x41	; 65
    4d2c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d30:	dc 01       	movw	r26, r24
    4d32:	cb 01       	movw	r24, r22
    4d34:	bc 01       	movw	r22, r24
    4d36:	cd 01       	movw	r24, r26
    4d38:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d3c:	dc 01       	movw	r26, r24
    4d3e:	cb 01       	movw	r24, r22
    4d40:	9a a3       	std	Y+34, r25	; 0x22
    4d42:	89 a3       	std	Y+33, r24	; 0x21
    4d44:	0f c0       	rjmp	.+30     	; 0x4d64 <HAL_LCD_u8GoTo+0x23e>
    4d46:	80 e9       	ldi	r24, 0x90	; 144
    4d48:	91 e0       	ldi	r25, 0x01	; 1
    4d4a:	98 a3       	std	Y+32, r25	; 0x20
    4d4c:	8f 8f       	std	Y+31, r24	; 0x1f
    4d4e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4d50:	98 a1       	ldd	r25, Y+32	; 0x20
    4d52:	01 97       	sbiw	r24, 0x01	; 1
    4d54:	f1 f7       	brne	.-4      	; 0x4d52 <HAL_LCD_u8GoTo+0x22c>
    4d56:	98 a3       	std	Y+32, r25	; 0x20
    4d58:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4d5a:	89 a1       	ldd	r24, Y+33	; 0x21
    4d5c:	9a a1       	ldd	r25, Y+34	; 0x22
    4d5e:	01 97       	sbiw	r24, 0x01	; 1
    4d60:	9a a3       	std	Y+34, r25	; 0x22
    4d62:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4d64:	89 a1       	ldd	r24, Y+33	; 0x21
    4d66:	9a a1       	ldd	r25, Y+34	; 0x22
    4d68:	00 97       	sbiw	r24, 0x00	; 0
    4d6a:	69 f7       	brne	.-38     	; 0x4d46 <HAL_LCD_u8GoTo+0x220>
    4d6c:	14 c0       	rjmp	.+40     	; 0x4d96 <HAL_LCD_u8GoTo+0x270>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4d6e:	6b a1       	ldd	r22, Y+35	; 0x23
    4d70:	7c a1       	ldd	r23, Y+36	; 0x24
    4d72:	8d a1       	ldd	r24, Y+37	; 0x25
    4d74:	9e a1       	ldd	r25, Y+38	; 0x26
    4d76:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d7a:	dc 01       	movw	r26, r24
    4d7c:	cb 01       	movw	r24, r22
    4d7e:	9a a3       	std	Y+34, r25	; 0x22
    4d80:	89 a3       	std	Y+33, r24	; 0x21
    4d82:	89 a1       	ldd	r24, Y+33	; 0x21
    4d84:	9a a1       	ldd	r25, Y+34	; 0x22
    4d86:	9e 8f       	std	Y+30, r25	; 0x1e
    4d88:	8d 8f       	std	Y+29, r24	; 0x1d
    4d8a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4d8c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4d8e:	01 97       	sbiw	r24, 0x01	; 1
    4d90:	f1 f7       	brne	.-4      	; 0x4d8e <HAL_LCD_u8GoTo+0x268>
    4d92:	9e 8f       	std	Y+30, r25	; 0x1e
    4d94:	8d 8f       	std	Y+29, r24	; 0x1d
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Left_Shift_Command);
    4d96:	88 e1       	ldi	r24, 0x18	; 24
    4d98:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == Left_Shift) {
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    4d9c:	89 ad       	ldd	r24, Y+57	; 0x39
    4d9e:	9a ad       	ldd	r25, Y+58	; 0x3a
    4da0:	ab ad       	ldd	r26, Y+59	; 0x3b
    4da2:	bc ad       	ldd	r27, Y+60	; 0x3c
    4da4:	01 96       	adiw	r24, 0x01	; 1
    4da6:	a1 1d       	adc	r26, r1
    4da8:	b1 1d       	adc	r27, r1
    4daa:	89 af       	std	Y+57, r24	; 0x39
    4dac:	9a af       	std	Y+58, r25	; 0x3a
    4dae:	ab af       	std	Y+59, r26	; 0x3b
    4db0:	bc af       	std	Y+60, r27	; 0x3c
    4db2:	fe 01       	movw	r30, r28
    4db4:	ee 5b       	subi	r30, 0xBE	; 190
    4db6:	ff 4f       	sbci	r31, 0xFF	; 255
    4db8:	80 81       	ld	r24, Z
    4dba:	28 2f       	mov	r18, r24
    4dbc:	30 e0       	ldi	r19, 0x00	; 0
    4dbe:	40 e0       	ldi	r20, 0x00	; 0
    4dc0:	50 e0       	ldi	r21, 0x00	; 0
    4dc2:	89 ad       	ldd	r24, Y+57	; 0x39
    4dc4:	9a ad       	ldd	r25, Y+58	; 0x3a
    4dc6:	ab ad       	ldd	r26, Y+59	; 0x3b
    4dc8:	bc ad       	ldd	r27, Y+60	; 0x3c
    4dca:	82 17       	cp	r24, r18
    4dcc:	93 07       	cpc	r25, r19
    4dce:	a4 07       	cpc	r26, r20
    4dd0:	b5 07       	cpc	r27, r21
    4dd2:	08 f4       	brcc	.+2      	; 0x4dd6 <HAL_LCD_u8GoTo+0x2b0>
    4dd4:	6e cf       	rjmp	.-292    	; 0x4cb2 <HAL_LCD_u8GoTo+0x18c>
    4dd6:	f9 c0       	rjmp	.+498    	; 0x4fca <HAL_LCD_u8GoTo+0x4a4>
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Left_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == First_Line) {
    4dd8:	fe 01       	movw	r30, r28
    4dda:	ef 5b       	subi	r30, 0xBF	; 191
    4ddc:	ff 4f       	sbci	r31, 0xFF	; 255
    4dde:	80 81       	ld	r24, Z
    4de0:	82 30       	cpi	r24, 0x02	; 2
    4de2:	09 f0       	breq	.+2      	; 0x4de6 <HAL_LCD_u8GoTo+0x2c0>
    4de4:	76 c0       	rjmp	.+236    	; 0x4ed2 <HAL_LCD_u8GoTo+0x3ac>
    4de6:	80 e0       	ldi	r24, 0x00	; 0
    4de8:	90 e0       	ldi	r25, 0x00	; 0
    4dea:	a0 e0       	ldi	r26, 0x00	; 0
    4dec:	b0 e4       	ldi	r27, 0x40	; 64
    4dee:	89 8f       	std	Y+25, r24	; 0x19
    4df0:	9a 8f       	std	Y+26, r25	; 0x1a
    4df2:	ab 8f       	std	Y+27, r26	; 0x1b
    4df4:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4df6:	69 8d       	ldd	r22, Y+25	; 0x19
    4df8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4dfa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4dfc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4dfe:	20 e0       	ldi	r18, 0x00	; 0
    4e00:	30 e0       	ldi	r19, 0x00	; 0
    4e02:	4a e7       	ldi	r20, 0x7A	; 122
    4e04:	55 e4       	ldi	r21, 0x45	; 69
    4e06:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e0a:	dc 01       	movw	r26, r24
    4e0c:	cb 01       	movw	r24, r22
    4e0e:	8d 8b       	std	Y+21, r24	; 0x15
    4e10:	9e 8b       	std	Y+22, r25	; 0x16
    4e12:	af 8b       	std	Y+23, r26	; 0x17
    4e14:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4e16:	6d 89       	ldd	r22, Y+21	; 0x15
    4e18:	7e 89       	ldd	r23, Y+22	; 0x16
    4e1a:	8f 89       	ldd	r24, Y+23	; 0x17
    4e1c:	98 8d       	ldd	r25, Y+24	; 0x18
    4e1e:	20 e0       	ldi	r18, 0x00	; 0
    4e20:	30 e0       	ldi	r19, 0x00	; 0
    4e22:	40 e8       	ldi	r20, 0x80	; 128
    4e24:	5f e3       	ldi	r21, 0x3F	; 63
    4e26:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4e2a:	88 23       	and	r24, r24
    4e2c:	2c f4       	brge	.+10     	; 0x4e38 <HAL_LCD_u8GoTo+0x312>
		__ticks = 1;
    4e2e:	81 e0       	ldi	r24, 0x01	; 1
    4e30:	90 e0       	ldi	r25, 0x00	; 0
    4e32:	9c 8b       	std	Y+20, r25	; 0x14
    4e34:	8b 8b       	std	Y+19, r24	; 0x13
    4e36:	3f c0       	rjmp	.+126    	; 0x4eb6 <HAL_LCD_u8GoTo+0x390>
	else if (__tmp > 65535)
    4e38:	6d 89       	ldd	r22, Y+21	; 0x15
    4e3a:	7e 89       	ldd	r23, Y+22	; 0x16
    4e3c:	8f 89       	ldd	r24, Y+23	; 0x17
    4e3e:	98 8d       	ldd	r25, Y+24	; 0x18
    4e40:	20 e0       	ldi	r18, 0x00	; 0
    4e42:	3f ef       	ldi	r19, 0xFF	; 255
    4e44:	4f e7       	ldi	r20, 0x7F	; 127
    4e46:	57 e4       	ldi	r21, 0x47	; 71
    4e48:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4e4c:	18 16       	cp	r1, r24
    4e4e:	4c f5       	brge	.+82     	; 0x4ea2 <HAL_LCD_u8GoTo+0x37c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e50:	69 8d       	ldd	r22, Y+25	; 0x19
    4e52:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4e54:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4e56:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4e58:	20 e0       	ldi	r18, 0x00	; 0
    4e5a:	30 e0       	ldi	r19, 0x00	; 0
    4e5c:	40 e2       	ldi	r20, 0x20	; 32
    4e5e:	51 e4       	ldi	r21, 0x41	; 65
    4e60:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e64:	dc 01       	movw	r26, r24
    4e66:	cb 01       	movw	r24, r22
    4e68:	bc 01       	movw	r22, r24
    4e6a:	cd 01       	movw	r24, r26
    4e6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4e70:	dc 01       	movw	r26, r24
    4e72:	cb 01       	movw	r24, r22
    4e74:	9c 8b       	std	Y+20, r25	; 0x14
    4e76:	8b 8b       	std	Y+19, r24	; 0x13
    4e78:	0f c0       	rjmp	.+30     	; 0x4e98 <HAL_LCD_u8GoTo+0x372>
    4e7a:	80 e9       	ldi	r24, 0x90	; 144
    4e7c:	91 e0       	ldi	r25, 0x01	; 1
    4e7e:	9a 8b       	std	Y+18, r25	; 0x12
    4e80:	89 8b       	std	Y+17, r24	; 0x11
    4e82:	89 89       	ldd	r24, Y+17	; 0x11
    4e84:	9a 89       	ldd	r25, Y+18	; 0x12
    4e86:	01 97       	sbiw	r24, 0x01	; 1
    4e88:	f1 f7       	brne	.-4      	; 0x4e86 <HAL_LCD_u8GoTo+0x360>
    4e8a:	9a 8b       	std	Y+18, r25	; 0x12
    4e8c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4e8e:	8b 89       	ldd	r24, Y+19	; 0x13
    4e90:	9c 89       	ldd	r25, Y+20	; 0x14
    4e92:	01 97       	sbiw	r24, 0x01	; 1
    4e94:	9c 8b       	std	Y+20, r25	; 0x14
    4e96:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4e98:	8b 89       	ldd	r24, Y+19	; 0x13
    4e9a:	9c 89       	ldd	r25, Y+20	; 0x14
    4e9c:	00 97       	sbiw	r24, 0x00	; 0
    4e9e:	69 f7       	brne	.-38     	; 0x4e7a <HAL_LCD_u8GoTo+0x354>
    4ea0:	14 c0       	rjmp	.+40     	; 0x4eca <HAL_LCD_u8GoTo+0x3a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ea2:	6d 89       	ldd	r22, Y+21	; 0x15
    4ea4:	7e 89       	ldd	r23, Y+22	; 0x16
    4ea6:	8f 89       	ldd	r24, Y+23	; 0x17
    4ea8:	98 8d       	ldd	r25, Y+24	; 0x18
    4eaa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4eae:	dc 01       	movw	r26, r24
    4eb0:	cb 01       	movw	r24, r22
    4eb2:	9c 8b       	std	Y+20, r25	; 0x14
    4eb4:	8b 8b       	std	Y+19, r24	; 0x13
    4eb6:	8b 89       	ldd	r24, Y+19	; 0x13
    4eb8:	9c 89       	ldd	r25, Y+20	; 0x14
    4eba:	98 8b       	std	Y+16, r25	; 0x10
    4ebc:	8f 87       	std	Y+15, r24	; 0x0f
    4ebe:	8f 85       	ldd	r24, Y+15	; 0x0f
    4ec0:	98 89       	ldd	r25, Y+16	; 0x10
    4ec2:	01 97       	sbiw	r24, 0x01	; 1
    4ec4:	f1 f7       	brne	.-4      	; 0x4ec2 <HAL_LCD_u8GoTo+0x39c>
    4ec6:	98 8b       	std	Y+16, r25	; 0x10
    4ec8:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(2);
		HAL_LCD_u8SendCommands(beginning_1stLine);
    4eca:	80 e8       	ldi	r24, 0x80	; 128
    4ecc:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
    4ed0:	7c c0       	rjmp	.+248    	; 0x4fca <HAL_LCD_u8GoTo+0x4a4>
	} else if (Loc_u8TypeOfShift == Second_Line) {
    4ed2:	fe 01       	movw	r30, r28
    4ed4:	ef 5b       	subi	r30, 0xBF	; 191
    4ed6:	ff 4f       	sbci	r31, 0xFF	; 255
    4ed8:	80 81       	ld	r24, Z
    4eda:	83 30       	cpi	r24, 0x03	; 3
    4edc:	09 f0       	breq	.+2      	; 0x4ee0 <HAL_LCD_u8GoTo+0x3ba>
    4ede:	75 c0       	rjmp	.+234    	; 0x4fca <HAL_LCD_u8GoTo+0x4a4>
    4ee0:	80 e0       	ldi	r24, 0x00	; 0
    4ee2:	90 e0       	ldi	r25, 0x00	; 0
    4ee4:	a0 e0       	ldi	r26, 0x00	; 0
    4ee6:	b0 e4       	ldi	r27, 0x40	; 64
    4ee8:	8b 87       	std	Y+11, r24	; 0x0b
    4eea:	9c 87       	std	Y+12, r25	; 0x0c
    4eec:	ad 87       	std	Y+13, r26	; 0x0d
    4eee:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4ef0:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ef2:	7c 85       	ldd	r23, Y+12	; 0x0c
    4ef4:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ef6:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ef8:	20 e0       	ldi	r18, 0x00	; 0
    4efa:	30 e0       	ldi	r19, 0x00	; 0
    4efc:	4a e7       	ldi	r20, 0x7A	; 122
    4efe:	55 e4       	ldi	r21, 0x45	; 69
    4f00:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4f04:	dc 01       	movw	r26, r24
    4f06:	cb 01       	movw	r24, r22
    4f08:	8f 83       	std	Y+7, r24	; 0x07
    4f0a:	98 87       	std	Y+8, r25	; 0x08
    4f0c:	a9 87       	std	Y+9, r26	; 0x09
    4f0e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4f10:	6f 81       	ldd	r22, Y+7	; 0x07
    4f12:	78 85       	ldd	r23, Y+8	; 0x08
    4f14:	89 85       	ldd	r24, Y+9	; 0x09
    4f16:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f18:	20 e0       	ldi	r18, 0x00	; 0
    4f1a:	30 e0       	ldi	r19, 0x00	; 0
    4f1c:	40 e8       	ldi	r20, 0x80	; 128
    4f1e:	5f e3       	ldi	r21, 0x3F	; 63
    4f20:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4f24:	88 23       	and	r24, r24
    4f26:	2c f4       	brge	.+10     	; 0x4f32 <HAL_LCD_u8GoTo+0x40c>
		__ticks = 1;
    4f28:	81 e0       	ldi	r24, 0x01	; 1
    4f2a:	90 e0       	ldi	r25, 0x00	; 0
    4f2c:	9e 83       	std	Y+6, r25	; 0x06
    4f2e:	8d 83       	std	Y+5, r24	; 0x05
    4f30:	3f c0       	rjmp	.+126    	; 0x4fb0 <HAL_LCD_u8GoTo+0x48a>
	else if (__tmp > 65535)
    4f32:	6f 81       	ldd	r22, Y+7	; 0x07
    4f34:	78 85       	ldd	r23, Y+8	; 0x08
    4f36:	89 85       	ldd	r24, Y+9	; 0x09
    4f38:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f3a:	20 e0       	ldi	r18, 0x00	; 0
    4f3c:	3f ef       	ldi	r19, 0xFF	; 255
    4f3e:	4f e7       	ldi	r20, 0x7F	; 127
    4f40:	57 e4       	ldi	r21, 0x47	; 71
    4f42:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4f46:	18 16       	cp	r1, r24
    4f48:	4c f5       	brge	.+82     	; 0x4f9c <HAL_LCD_u8GoTo+0x476>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4f4a:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f4c:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f4e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f50:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f52:	20 e0       	ldi	r18, 0x00	; 0
    4f54:	30 e0       	ldi	r19, 0x00	; 0
    4f56:	40 e2       	ldi	r20, 0x20	; 32
    4f58:	51 e4       	ldi	r21, 0x41	; 65
    4f5a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4f5e:	dc 01       	movw	r26, r24
    4f60:	cb 01       	movw	r24, r22
    4f62:	bc 01       	movw	r22, r24
    4f64:	cd 01       	movw	r24, r26
    4f66:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4f6a:	dc 01       	movw	r26, r24
    4f6c:	cb 01       	movw	r24, r22
    4f6e:	9e 83       	std	Y+6, r25	; 0x06
    4f70:	8d 83       	std	Y+5, r24	; 0x05
    4f72:	0f c0       	rjmp	.+30     	; 0x4f92 <HAL_LCD_u8GoTo+0x46c>
    4f74:	80 e9       	ldi	r24, 0x90	; 144
    4f76:	91 e0       	ldi	r25, 0x01	; 1
    4f78:	9c 83       	std	Y+4, r25	; 0x04
    4f7a:	8b 83       	std	Y+3, r24	; 0x03
    4f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f7e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f80:	01 97       	sbiw	r24, 0x01	; 1
    4f82:	f1 f7       	brne	.-4      	; 0x4f80 <HAL_LCD_u8GoTo+0x45a>
    4f84:	9c 83       	std	Y+4, r25	; 0x04
    4f86:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4f88:	8d 81       	ldd	r24, Y+5	; 0x05
    4f8a:	9e 81       	ldd	r25, Y+6	; 0x06
    4f8c:	01 97       	sbiw	r24, 0x01	; 1
    4f8e:	9e 83       	std	Y+6, r25	; 0x06
    4f90:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4f92:	8d 81       	ldd	r24, Y+5	; 0x05
    4f94:	9e 81       	ldd	r25, Y+6	; 0x06
    4f96:	00 97       	sbiw	r24, 0x00	; 0
    4f98:	69 f7       	brne	.-38     	; 0x4f74 <HAL_LCD_u8GoTo+0x44e>
    4f9a:	14 c0       	rjmp	.+40     	; 0x4fc4 <HAL_LCD_u8GoTo+0x49e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4f9c:	6f 81       	ldd	r22, Y+7	; 0x07
    4f9e:	78 85       	ldd	r23, Y+8	; 0x08
    4fa0:	89 85       	ldd	r24, Y+9	; 0x09
    4fa2:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fa4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4fa8:	dc 01       	movw	r26, r24
    4faa:	cb 01       	movw	r24, r22
    4fac:	9e 83       	std	Y+6, r25	; 0x06
    4fae:	8d 83       	std	Y+5, r24	; 0x05
    4fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    4fb2:	9e 81       	ldd	r25, Y+6	; 0x06
    4fb4:	9a 83       	std	Y+2, r25	; 0x02
    4fb6:	89 83       	std	Y+1, r24	; 0x01
    4fb8:	89 81       	ldd	r24, Y+1	; 0x01
    4fba:	9a 81       	ldd	r25, Y+2	; 0x02
    4fbc:	01 97       	sbiw	r24, 0x01	; 1
    4fbe:	f1 f7       	brne	.-4      	; 0x4fbc <HAL_LCD_u8GoTo+0x496>
    4fc0:	9a 83       	std	Y+2, r25	; 0x02
    4fc2:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(2);
		HAL_LCD_u8SendCommands(beginning_2stLine);
    4fc4:	80 ec       	ldi	r24, 0xC0	; 192
    4fc6:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
	}
}
    4fca:	ce 5b       	subi	r28, 0xBE	; 190
    4fcc:	df 4f       	sbci	r29, 0xFF	; 255
    4fce:	0f b6       	in	r0, 0x3f	; 63
    4fd0:	f8 94       	cli
    4fd2:	de bf       	out	0x3e, r29	; 62
    4fd4:	0f be       	out	0x3f, r0	; 63
    4fd6:	cd bf       	out	0x3d, r28	; 61
    4fd8:	cf 91       	pop	r28
    4fda:	df 91       	pop	r29
    4fdc:	08 95       	ret

00004fde <HAL_LCD_u8Clear>:

void HAL_LCD_u8Clear() {
    4fde:	df 93       	push	r29
    4fe0:	cf 93       	push	r28
    4fe2:	cd b7       	in	r28, 0x3d	; 61
    4fe4:	de b7       	in	r29, 0x3e	; 62
    4fe6:	2e 97       	sbiw	r28, 0x0e	; 14
    4fe8:	0f b6       	in	r0, 0x3f	; 63
    4fea:	f8 94       	cli
    4fec:	de bf       	out	0x3e, r29	; 62
    4fee:	0f be       	out	0x3f, r0	; 63
    4ff0:	cd bf       	out	0x3d, r28	; 61
    4ff2:	80 e0       	ldi	r24, 0x00	; 0
    4ff4:	90 e0       	ldi	r25, 0x00	; 0
    4ff6:	a0 e0       	ldi	r26, 0x00	; 0
    4ff8:	b0 e4       	ldi	r27, 0x40	; 64
    4ffa:	8b 87       	std	Y+11, r24	; 0x0b
    4ffc:	9c 87       	std	Y+12, r25	; 0x0c
    4ffe:	ad 87       	std	Y+13, r26	; 0x0d
    5000:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5002:	6b 85       	ldd	r22, Y+11	; 0x0b
    5004:	7c 85       	ldd	r23, Y+12	; 0x0c
    5006:	8d 85       	ldd	r24, Y+13	; 0x0d
    5008:	9e 85       	ldd	r25, Y+14	; 0x0e
    500a:	20 e0       	ldi	r18, 0x00	; 0
    500c:	30 e0       	ldi	r19, 0x00	; 0
    500e:	4a e7       	ldi	r20, 0x7A	; 122
    5010:	55 e4       	ldi	r21, 0x45	; 69
    5012:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5016:	dc 01       	movw	r26, r24
    5018:	cb 01       	movw	r24, r22
    501a:	8f 83       	std	Y+7, r24	; 0x07
    501c:	98 87       	std	Y+8, r25	; 0x08
    501e:	a9 87       	std	Y+9, r26	; 0x09
    5020:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5022:	6f 81       	ldd	r22, Y+7	; 0x07
    5024:	78 85       	ldd	r23, Y+8	; 0x08
    5026:	89 85       	ldd	r24, Y+9	; 0x09
    5028:	9a 85       	ldd	r25, Y+10	; 0x0a
    502a:	20 e0       	ldi	r18, 0x00	; 0
    502c:	30 e0       	ldi	r19, 0x00	; 0
    502e:	40 e8       	ldi	r20, 0x80	; 128
    5030:	5f e3       	ldi	r21, 0x3F	; 63
    5032:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5036:	88 23       	and	r24, r24
    5038:	2c f4       	brge	.+10     	; 0x5044 <HAL_LCD_u8Clear+0x66>
		__ticks = 1;
    503a:	81 e0       	ldi	r24, 0x01	; 1
    503c:	90 e0       	ldi	r25, 0x00	; 0
    503e:	9e 83       	std	Y+6, r25	; 0x06
    5040:	8d 83       	std	Y+5, r24	; 0x05
    5042:	3f c0       	rjmp	.+126    	; 0x50c2 <HAL_LCD_u8Clear+0xe4>
	else if (__tmp > 65535)
    5044:	6f 81       	ldd	r22, Y+7	; 0x07
    5046:	78 85       	ldd	r23, Y+8	; 0x08
    5048:	89 85       	ldd	r24, Y+9	; 0x09
    504a:	9a 85       	ldd	r25, Y+10	; 0x0a
    504c:	20 e0       	ldi	r18, 0x00	; 0
    504e:	3f ef       	ldi	r19, 0xFF	; 255
    5050:	4f e7       	ldi	r20, 0x7F	; 127
    5052:	57 e4       	ldi	r21, 0x47	; 71
    5054:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5058:	18 16       	cp	r1, r24
    505a:	4c f5       	brge	.+82     	; 0x50ae <HAL_LCD_u8Clear+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    505c:	6b 85       	ldd	r22, Y+11	; 0x0b
    505e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5060:	8d 85       	ldd	r24, Y+13	; 0x0d
    5062:	9e 85       	ldd	r25, Y+14	; 0x0e
    5064:	20 e0       	ldi	r18, 0x00	; 0
    5066:	30 e0       	ldi	r19, 0x00	; 0
    5068:	40 e2       	ldi	r20, 0x20	; 32
    506a:	51 e4       	ldi	r21, 0x41	; 65
    506c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5070:	dc 01       	movw	r26, r24
    5072:	cb 01       	movw	r24, r22
    5074:	bc 01       	movw	r22, r24
    5076:	cd 01       	movw	r24, r26
    5078:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    507c:	dc 01       	movw	r26, r24
    507e:	cb 01       	movw	r24, r22
    5080:	9e 83       	std	Y+6, r25	; 0x06
    5082:	8d 83       	std	Y+5, r24	; 0x05
    5084:	0f c0       	rjmp	.+30     	; 0x50a4 <HAL_LCD_u8Clear+0xc6>
    5086:	80 e9       	ldi	r24, 0x90	; 144
    5088:	91 e0       	ldi	r25, 0x01	; 1
    508a:	9c 83       	std	Y+4, r25	; 0x04
    508c:	8b 83       	std	Y+3, r24	; 0x03
    508e:	8b 81       	ldd	r24, Y+3	; 0x03
    5090:	9c 81       	ldd	r25, Y+4	; 0x04
    5092:	01 97       	sbiw	r24, 0x01	; 1
    5094:	f1 f7       	brne	.-4      	; 0x5092 <HAL_LCD_u8Clear+0xb4>
    5096:	9c 83       	std	Y+4, r25	; 0x04
    5098:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    509a:	8d 81       	ldd	r24, Y+5	; 0x05
    509c:	9e 81       	ldd	r25, Y+6	; 0x06
    509e:	01 97       	sbiw	r24, 0x01	; 1
    50a0:	9e 83       	std	Y+6, r25	; 0x06
    50a2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    50a4:	8d 81       	ldd	r24, Y+5	; 0x05
    50a6:	9e 81       	ldd	r25, Y+6	; 0x06
    50a8:	00 97       	sbiw	r24, 0x00	; 0
    50aa:	69 f7       	brne	.-38     	; 0x5086 <HAL_LCD_u8Clear+0xa8>
    50ac:	14 c0       	rjmp	.+40     	; 0x50d6 <HAL_LCD_u8Clear+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    50ae:	6f 81       	ldd	r22, Y+7	; 0x07
    50b0:	78 85       	ldd	r23, Y+8	; 0x08
    50b2:	89 85       	ldd	r24, Y+9	; 0x09
    50b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    50b6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    50ba:	dc 01       	movw	r26, r24
    50bc:	cb 01       	movw	r24, r22
    50be:	9e 83       	std	Y+6, r25	; 0x06
    50c0:	8d 83       	std	Y+5, r24	; 0x05
    50c2:	8d 81       	ldd	r24, Y+5	; 0x05
    50c4:	9e 81       	ldd	r25, Y+6	; 0x06
    50c6:	9a 83       	std	Y+2, r25	; 0x02
    50c8:	89 83       	std	Y+1, r24	; 0x01
    50ca:	89 81       	ldd	r24, Y+1	; 0x01
    50cc:	9a 81       	ldd	r25, Y+2	; 0x02
    50ce:	01 97       	sbiw	r24, 0x01	; 1
    50d0:	f1 f7       	brne	.-4      	; 0x50ce <HAL_LCD_u8Clear+0xf0>
    50d2:	9a 83       	std	Y+2, r25	; 0x02
    50d4:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Clear);
    50d6:	81 e0       	ldi	r24, 0x01	; 1
    50d8:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
}
    50dc:	2e 96       	adiw	r28, 0x0e	; 14
    50de:	0f b6       	in	r0, 0x3f	; 63
    50e0:	f8 94       	cli
    50e2:	de bf       	out	0x3e, r29	; 62
    50e4:	0f be       	out	0x3f, r0	; 63
    50e6:	cd bf       	out	0x3d, r28	; 61
    50e8:	cf 91       	pop	r28
    50ea:	df 91       	pop	r29
    50ec:	08 95       	ret

000050ee <HAL_LCD_u8CustomChar>:

void HAL_LCD_u8CustomChar(u8 Loc_u8Location, u8* Loc_u8msg) {
    50ee:	df 93       	push	r29
    50f0:	cf 93       	push	r28
    50f2:	00 d0       	rcall	.+0      	; 0x50f4 <HAL_LCD_u8CustomChar+0x6>
    50f4:	00 d0       	rcall	.+0      	; 0x50f6 <HAL_LCD_u8CustomChar+0x8>
    50f6:	cd b7       	in	r28, 0x3d	; 61
    50f8:	de b7       	in	r29, 0x3e	; 62
    50fa:	8a 83       	std	Y+2, r24	; 0x02
    50fc:	7c 83       	std	Y+4, r23	; 0x04
    50fe:	6b 83       	std	Y+3, r22	; 0x03
	if (Loc_u8Location < 8) {
    5100:	8a 81       	ldd	r24, Y+2	; 0x02
    5102:	88 30       	cpi	r24, 0x08	; 8
    5104:	f8 f4       	brcc	.+62     	; 0x5144 <HAL_LCD_u8CustomChar+0x56>
		HAL_LCD_u8SendCommands(0x40 + (Loc_u8Location*8));
    5106:	8a 81       	ldd	r24, Y+2	; 0x02
    5108:	88 2f       	mov	r24, r24
    510a:	90 e0       	ldi	r25, 0x00	; 0
    510c:	08 96       	adiw	r24, 0x08	; 8
    510e:	88 0f       	add	r24, r24
    5110:	99 1f       	adc	r25, r25
    5112:	88 0f       	add	r24, r24
    5114:	99 1f       	adc	r25, r25
    5116:	88 0f       	add	r24, r24
    5118:	99 1f       	adc	r25, r25
    511a:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
		for( u8 count = 0; count < 8; count++)
    511e:	19 82       	std	Y+1, r1	; 0x01
    5120:	0e c0       	rjmp	.+28     	; 0x513e <HAL_LCD_u8CustomChar+0x50>
			HAL_LCD_u8SendChar(Loc_u8msg[count]);
    5122:	89 81       	ldd	r24, Y+1	; 0x01
    5124:	28 2f       	mov	r18, r24
    5126:	30 e0       	ldi	r19, 0x00	; 0
    5128:	8b 81       	ldd	r24, Y+3	; 0x03
    512a:	9c 81       	ldd	r25, Y+4	; 0x04
    512c:	fc 01       	movw	r30, r24
    512e:	e2 0f       	add	r30, r18
    5130:	f3 1f       	adc	r31, r19
    5132:	80 81       	ld	r24, Z
    5134:	0e 94 18 24 	call	0x4830	; 0x4830 <HAL_LCD_u8SendChar>
}

void HAL_LCD_u8CustomChar(u8 Loc_u8Location, u8* Loc_u8msg) {
	if (Loc_u8Location < 8) {
		HAL_LCD_u8SendCommands(0x40 + (Loc_u8Location*8));
		for( u8 count = 0; count < 8; count++)
    5138:	89 81       	ldd	r24, Y+1	; 0x01
    513a:	8f 5f       	subi	r24, 0xFF	; 255
    513c:	89 83       	std	Y+1, r24	; 0x01
    513e:	89 81       	ldd	r24, Y+1	; 0x01
    5140:	88 30       	cpi	r24, 0x08	; 8
    5142:	78 f3       	brcs	.-34     	; 0x5122 <HAL_LCD_u8CustomChar+0x34>
			HAL_LCD_u8SendChar(Loc_u8msg[count]);
	}
	HAL_LCD_u8SendCommands(0x02);
    5144:	82 e0       	ldi	r24, 0x02	; 2
    5146:	0e 94 f6 22 	call	0x45ec	; 0x45ec <HAL_LCD_u8SendCommands>
}
    514a:	0f 90       	pop	r0
    514c:	0f 90       	pop	r0
    514e:	0f 90       	pop	r0
    5150:	0f 90       	pop	r0
    5152:	cf 91       	pop	r28
    5154:	df 91       	pop	r29
    5156:	08 95       	ret

00005158 <HAL_KeyPad_u8KeyPadInit>:

u8 array[4][4] = { { '1', '2', '3', 'A' }, { '4', '5', '6', 'B' }, { '7', '8',
		'9', 'C' }, { '*', '0', '#', 'D' } };
u8 KetPadValue = 0;

void HAL_KeyPad_u8KeyPadInit() {
    5158:	df 93       	push	r29
    515a:	cf 93       	push	r28
    515c:	cd b7       	in	r28, 0x3d	; 61
    515e:	de b7       	in	r29, 0x3e	; 62
	MCAL_DIO_u8SetPortDirection(2, 0x0F);
    5160:	82 e0       	ldi	r24, 0x02	; 2
    5162:	6f e0       	ldi	r22, 0x0F	; 15
    5164:	0e 94 c4 18 	call	0x3188	; 0x3188 <MCAL_DIO_u8SetPortDirection>
	MCAL_DIO_u8SetPortValue(2, PORT_OUTPUT);
    5168:	82 e0       	ldi	r24, 0x02	; 2
    516a:	6f ef       	ldi	r22, 0xFF	; 255
    516c:	0e 94 32 1a 	call	0x3464	; 0x3464 <MCAL_DIO_u8SetPortValue>
}
    5170:	cf 91       	pop	r28
    5172:	df 91       	pop	r29
    5174:	08 95       	ret

00005176 <HAL_KeyPad_u8GetKeyPressed>:
//		c--;
//		MCAL_DIO_u8SetPinValue(2, col, 1);
//	}
//}

void HAL_KeyPad_u8GetKeyPressed(u8 *Button) {
    5176:	df 93       	push	r29
    5178:	cf 93       	push	r28
    517a:	cd b7       	in	r28, 0x3d	; 61
    517c:	de b7       	in	r29, 0x3e	; 62
    517e:	a2 97       	sbiw	r28, 0x22	; 34
    5180:	0f b6       	in	r0, 0x3f	; 63
    5182:	f8 94       	cli
    5184:	de bf       	out	0x3e, r29	; 62
    5186:	0f be       	out	0x3f, r0	; 63
    5188:	cd bf       	out	0x3d, r28	; 61
    518a:	9a a3       	std	Y+34, r25	; 0x22
    518c:	89 a3       	std	Y+33, r24	; 0x21

	u8 LOC_u8Col, LOC_u8Row, LOC_u8Status = 7, LOC_u8PinValue;
    518e:	87 e0       	ldi	r24, 0x07	; 7
    5190:	8d 8f       	std	Y+29, r24	; 0x1d
	*Button = 0;
    5192:	e9 a1       	ldd	r30, Y+33	; 0x21
    5194:	fa a1       	ldd	r31, Y+34	; 0x22
    5196:	10 82       	st	Z, r1
	for (LOC_u8Row = 0; LOC_u8Row < 4; LOC_u8Row++) {
    5198:	1e 8e       	std	Y+30, r1	; 0x1e
    519a:	2f c1       	rjmp	.+606    	; 0x53fa <HAL_KeyPad_u8GetKeyPressed+0x284>
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R0,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R1,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R2,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R3,Pin_HIGH);
		MCAL_DIO_u8SetPinValue(2, LOC_u8Row, 0);
    519c:	82 e0       	ldi	r24, 0x02	; 2
    519e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    51a0:	40 e0       	ldi	r20, 0x00	; 0
    51a2:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
		for (LOC_u8Col = 0; LOC_u8Col < 4; LOC_u8Col++) {
    51a6:	1f 8e       	std	Y+31, r1	; 0x1f
    51a8:	1c c1       	rjmp	.+568    	; 0x53e2 <HAL_KeyPad_u8GetKeyPressed+0x26c>
			MCAL_DIO_u8GetPinValue(2, (LOC_u8Col + 4), &LOC_u8PinValue);
    51aa:	8f 8d       	ldd	r24, Y+31	; 0x1f
    51ac:	98 2f       	mov	r25, r24
    51ae:	9c 5f       	subi	r25, 0xFC	; 252
    51b0:	9e 01       	movw	r18, r28
    51b2:	20 5e       	subi	r18, 0xE0	; 224
    51b4:	3f 4f       	sbci	r19, 0xFF	; 255
    51b6:	82 e0       	ldi	r24, 0x02	; 2
    51b8:	69 2f       	mov	r22, r25
    51ba:	a9 01       	movw	r20, r18
    51bc:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <MCAL_DIO_u8GetPinValue>
			LOC_u8Status = LOC_u8PinValue; //new
    51c0:	88 a1       	ldd	r24, Y+32	; 0x20
    51c2:	8d 8f       	std	Y+29, r24	; 0x1d
			if (LOC_u8PinValue == 0) {
    51c4:	88 a1       	ldd	r24, Y+32	; 0x20
    51c6:	88 23       	and	r24, r24
    51c8:	09 f0       	breq	.+2      	; 0x51cc <HAL_KeyPad_u8GetKeyPressed+0x56>
    51ca:	08 c1       	rjmp	.+528    	; 0x53dc <HAL_KeyPad_u8GetKeyPressed+0x266>
    51cc:	80 e0       	ldi	r24, 0x00	; 0
    51ce:	90 e0       	ldi	r25, 0x00	; 0
    51d0:	a0 ea       	ldi	r26, 0xA0	; 160
    51d2:	b0 e4       	ldi	r27, 0x40	; 64
    51d4:	89 8f       	std	Y+25, r24	; 0x19
    51d6:	9a 8f       	std	Y+26, r25	; 0x1a
    51d8:	ab 8f       	std	Y+27, r26	; 0x1b
    51da:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    51dc:	69 8d       	ldd	r22, Y+25	; 0x19
    51de:	7a 8d       	ldd	r23, Y+26	; 0x1a
    51e0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    51e2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    51e4:	20 e0       	ldi	r18, 0x00	; 0
    51e6:	30 e0       	ldi	r19, 0x00	; 0
    51e8:	4a e7       	ldi	r20, 0x7A	; 122
    51ea:	55 e4       	ldi	r21, 0x45	; 69
    51ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    51f0:	dc 01       	movw	r26, r24
    51f2:	cb 01       	movw	r24, r22
    51f4:	8d 8b       	std	Y+21, r24	; 0x15
    51f6:	9e 8b       	std	Y+22, r25	; 0x16
    51f8:	af 8b       	std	Y+23, r26	; 0x17
    51fa:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    51fc:	6d 89       	ldd	r22, Y+21	; 0x15
    51fe:	7e 89       	ldd	r23, Y+22	; 0x16
    5200:	8f 89       	ldd	r24, Y+23	; 0x17
    5202:	98 8d       	ldd	r25, Y+24	; 0x18
    5204:	20 e0       	ldi	r18, 0x00	; 0
    5206:	30 e0       	ldi	r19, 0x00	; 0
    5208:	40 e8       	ldi	r20, 0x80	; 128
    520a:	5f e3       	ldi	r21, 0x3F	; 63
    520c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5210:	88 23       	and	r24, r24
    5212:	2c f4       	brge	.+10     	; 0x521e <HAL_KeyPad_u8GetKeyPressed+0xa8>
		__ticks = 1;
    5214:	81 e0       	ldi	r24, 0x01	; 1
    5216:	90 e0       	ldi	r25, 0x00	; 0
    5218:	9c 8b       	std	Y+20, r25	; 0x14
    521a:	8b 8b       	std	Y+19, r24	; 0x13
    521c:	3f c0       	rjmp	.+126    	; 0x529c <HAL_KeyPad_u8GetKeyPressed+0x126>
	else if (__tmp > 65535)
    521e:	6d 89       	ldd	r22, Y+21	; 0x15
    5220:	7e 89       	ldd	r23, Y+22	; 0x16
    5222:	8f 89       	ldd	r24, Y+23	; 0x17
    5224:	98 8d       	ldd	r25, Y+24	; 0x18
    5226:	20 e0       	ldi	r18, 0x00	; 0
    5228:	3f ef       	ldi	r19, 0xFF	; 255
    522a:	4f e7       	ldi	r20, 0x7F	; 127
    522c:	57 e4       	ldi	r21, 0x47	; 71
    522e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5232:	18 16       	cp	r1, r24
    5234:	4c f5       	brge	.+82     	; 0x5288 <HAL_KeyPad_u8GetKeyPressed+0x112>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5236:	69 8d       	ldd	r22, Y+25	; 0x19
    5238:	7a 8d       	ldd	r23, Y+26	; 0x1a
    523a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    523c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    523e:	20 e0       	ldi	r18, 0x00	; 0
    5240:	30 e0       	ldi	r19, 0x00	; 0
    5242:	40 e2       	ldi	r20, 0x20	; 32
    5244:	51 e4       	ldi	r21, 0x41	; 65
    5246:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    524a:	dc 01       	movw	r26, r24
    524c:	cb 01       	movw	r24, r22
    524e:	bc 01       	movw	r22, r24
    5250:	cd 01       	movw	r24, r26
    5252:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5256:	dc 01       	movw	r26, r24
    5258:	cb 01       	movw	r24, r22
    525a:	9c 8b       	std	Y+20, r25	; 0x14
    525c:	8b 8b       	std	Y+19, r24	; 0x13
    525e:	0f c0       	rjmp	.+30     	; 0x527e <HAL_KeyPad_u8GetKeyPressed+0x108>
    5260:	80 e9       	ldi	r24, 0x90	; 144
    5262:	91 e0       	ldi	r25, 0x01	; 1
    5264:	9a 8b       	std	Y+18, r25	; 0x12
    5266:	89 8b       	std	Y+17, r24	; 0x11
    5268:	89 89       	ldd	r24, Y+17	; 0x11
    526a:	9a 89       	ldd	r25, Y+18	; 0x12
    526c:	01 97       	sbiw	r24, 0x01	; 1
    526e:	f1 f7       	brne	.-4      	; 0x526c <HAL_KeyPad_u8GetKeyPressed+0xf6>
    5270:	9a 8b       	std	Y+18, r25	; 0x12
    5272:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5274:	8b 89       	ldd	r24, Y+19	; 0x13
    5276:	9c 89       	ldd	r25, Y+20	; 0x14
    5278:	01 97       	sbiw	r24, 0x01	; 1
    527a:	9c 8b       	std	Y+20, r25	; 0x14
    527c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    527e:	8b 89       	ldd	r24, Y+19	; 0x13
    5280:	9c 89       	ldd	r25, Y+20	; 0x14
    5282:	00 97       	sbiw	r24, 0x00	; 0
    5284:	69 f7       	brne	.-38     	; 0x5260 <HAL_KeyPad_u8GetKeyPressed+0xea>
    5286:	14 c0       	rjmp	.+40     	; 0x52b0 <HAL_KeyPad_u8GetKeyPressed+0x13a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5288:	6d 89       	ldd	r22, Y+21	; 0x15
    528a:	7e 89       	ldd	r23, Y+22	; 0x16
    528c:	8f 89       	ldd	r24, Y+23	; 0x17
    528e:	98 8d       	ldd	r25, Y+24	; 0x18
    5290:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5294:	dc 01       	movw	r26, r24
    5296:	cb 01       	movw	r24, r22
    5298:	9c 8b       	std	Y+20, r25	; 0x14
    529a:	8b 8b       	std	Y+19, r24	; 0x13
    529c:	8b 89       	ldd	r24, Y+19	; 0x13
    529e:	9c 89       	ldd	r25, Y+20	; 0x14
    52a0:	98 8b       	std	Y+16, r25	; 0x10
    52a2:	8f 87       	std	Y+15, r24	; 0x0f
    52a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    52a6:	98 89       	ldd	r25, Y+16	; 0x10
    52a8:	01 97       	sbiw	r24, 0x01	; 1
    52aa:	f1 f7       	brne	.-4      	; 0x52a8 <HAL_KeyPad_u8GetKeyPressed+0x132>
    52ac:	98 8b       	std	Y+16, r25	; 0x10
    52ae:	8f 87       	std	Y+15, r24	; 0x0f
				_delay_ms(5); //new
				MCAL_DIO_u8GetPinValue(2, (LOC_u8Col + 4), &LOC_u8PinValue); //new
    52b0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    52b2:	98 2f       	mov	r25, r24
    52b4:	9c 5f       	subi	r25, 0xFC	; 252
    52b6:	9e 01       	movw	r18, r28
    52b8:	20 5e       	subi	r18, 0xE0	; 224
    52ba:	3f 4f       	sbci	r19, 0xFF	; 255
    52bc:	82 e0       	ldi	r24, 0x02	; 2
    52be:	69 2f       	mov	r22, r25
    52c0:	a9 01       	movw	r20, r18
    52c2:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <MCAL_DIO_u8GetPinValue>
				if (LOC_u8PinValue == 1) //new
    52c6:	88 a1       	ldd	r24, Y+32	; 0x20
    52c8:	81 30       	cpi	r24, 0x01	; 1
    52ca:	09 f0       	breq	.+2      	; 0x52ce <HAL_KeyPad_u8GetKeyPressed+0x158>
    52cc:	8e c0       	rjmp	.+284    	; 0x53ea <HAL_KeyPad_u8GetKeyPressed+0x274>
    52ce:	80 e0       	ldi	r24, 0x00	; 0
    52d0:	90 e0       	ldi	r25, 0x00	; 0
    52d2:	a0 ea       	ldi	r26, 0xA0	; 160
    52d4:	b0 e4       	ldi	r27, 0x40	; 64
    52d6:	8b 87       	std	Y+11, r24	; 0x0b
    52d8:	9c 87       	std	Y+12, r25	; 0x0c
    52da:	ad 87       	std	Y+13, r26	; 0x0d
    52dc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    52de:	6b 85       	ldd	r22, Y+11	; 0x0b
    52e0:	7c 85       	ldd	r23, Y+12	; 0x0c
    52e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    52e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    52e6:	20 e0       	ldi	r18, 0x00	; 0
    52e8:	30 e0       	ldi	r19, 0x00	; 0
    52ea:	4a e7       	ldi	r20, 0x7A	; 122
    52ec:	55 e4       	ldi	r21, 0x45	; 69
    52ee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    52f2:	dc 01       	movw	r26, r24
    52f4:	cb 01       	movw	r24, r22
    52f6:	8f 83       	std	Y+7, r24	; 0x07
    52f8:	98 87       	std	Y+8, r25	; 0x08
    52fa:	a9 87       	std	Y+9, r26	; 0x09
    52fc:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    52fe:	6f 81       	ldd	r22, Y+7	; 0x07
    5300:	78 85       	ldd	r23, Y+8	; 0x08
    5302:	89 85       	ldd	r24, Y+9	; 0x09
    5304:	9a 85       	ldd	r25, Y+10	; 0x0a
    5306:	20 e0       	ldi	r18, 0x00	; 0
    5308:	30 e0       	ldi	r19, 0x00	; 0
    530a:	40 e8       	ldi	r20, 0x80	; 128
    530c:	5f e3       	ldi	r21, 0x3F	; 63
    530e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5312:	88 23       	and	r24, r24
    5314:	2c f4       	brge	.+10     	; 0x5320 <HAL_KeyPad_u8GetKeyPressed+0x1aa>
		__ticks = 1;
    5316:	81 e0       	ldi	r24, 0x01	; 1
    5318:	90 e0       	ldi	r25, 0x00	; 0
    531a:	9e 83       	std	Y+6, r25	; 0x06
    531c:	8d 83       	std	Y+5, r24	; 0x05
    531e:	3f c0       	rjmp	.+126    	; 0x539e <HAL_KeyPad_u8GetKeyPressed+0x228>
	else if (__tmp > 65535)
    5320:	6f 81       	ldd	r22, Y+7	; 0x07
    5322:	78 85       	ldd	r23, Y+8	; 0x08
    5324:	89 85       	ldd	r24, Y+9	; 0x09
    5326:	9a 85       	ldd	r25, Y+10	; 0x0a
    5328:	20 e0       	ldi	r18, 0x00	; 0
    532a:	3f ef       	ldi	r19, 0xFF	; 255
    532c:	4f e7       	ldi	r20, 0x7F	; 127
    532e:	57 e4       	ldi	r21, 0x47	; 71
    5330:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5334:	18 16       	cp	r1, r24
    5336:	4c f5       	brge	.+82     	; 0x538a <HAL_KeyPad_u8GetKeyPressed+0x214>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5338:	6b 85       	ldd	r22, Y+11	; 0x0b
    533a:	7c 85       	ldd	r23, Y+12	; 0x0c
    533c:	8d 85       	ldd	r24, Y+13	; 0x0d
    533e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5340:	20 e0       	ldi	r18, 0x00	; 0
    5342:	30 e0       	ldi	r19, 0x00	; 0
    5344:	40 e2       	ldi	r20, 0x20	; 32
    5346:	51 e4       	ldi	r21, 0x41	; 65
    5348:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    534c:	dc 01       	movw	r26, r24
    534e:	cb 01       	movw	r24, r22
    5350:	bc 01       	movw	r22, r24
    5352:	cd 01       	movw	r24, r26
    5354:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5358:	dc 01       	movw	r26, r24
    535a:	cb 01       	movw	r24, r22
    535c:	9e 83       	std	Y+6, r25	; 0x06
    535e:	8d 83       	std	Y+5, r24	; 0x05
    5360:	0f c0       	rjmp	.+30     	; 0x5380 <HAL_KeyPad_u8GetKeyPressed+0x20a>
    5362:	80 e9       	ldi	r24, 0x90	; 144
    5364:	91 e0       	ldi	r25, 0x01	; 1
    5366:	9c 83       	std	Y+4, r25	; 0x04
    5368:	8b 83       	std	Y+3, r24	; 0x03
    536a:	8b 81       	ldd	r24, Y+3	; 0x03
    536c:	9c 81       	ldd	r25, Y+4	; 0x04
    536e:	01 97       	sbiw	r24, 0x01	; 1
    5370:	f1 f7       	brne	.-4      	; 0x536e <HAL_KeyPad_u8GetKeyPressed+0x1f8>
    5372:	9c 83       	std	Y+4, r25	; 0x04
    5374:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5376:	8d 81       	ldd	r24, Y+5	; 0x05
    5378:	9e 81       	ldd	r25, Y+6	; 0x06
    537a:	01 97       	sbiw	r24, 0x01	; 1
    537c:	9e 83       	std	Y+6, r25	; 0x06
    537e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5380:	8d 81       	ldd	r24, Y+5	; 0x05
    5382:	9e 81       	ldd	r25, Y+6	; 0x06
    5384:	00 97       	sbiw	r24, 0x00	; 0
    5386:	69 f7       	brne	.-38     	; 0x5362 <HAL_KeyPad_u8GetKeyPressed+0x1ec>
    5388:	14 c0       	rjmp	.+40     	; 0x53b2 <HAL_KeyPad_u8GetKeyPressed+0x23c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    538a:	6f 81       	ldd	r22, Y+7	; 0x07
    538c:	78 85       	ldd	r23, Y+8	; 0x08
    538e:	89 85       	ldd	r24, Y+9	; 0x09
    5390:	9a 85       	ldd	r25, Y+10	; 0x0a
    5392:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5396:	dc 01       	movw	r26, r24
    5398:	cb 01       	movw	r24, r22
    539a:	9e 83       	std	Y+6, r25	; 0x06
    539c:	8d 83       	std	Y+5, r24	; 0x05
    539e:	8d 81       	ldd	r24, Y+5	; 0x05
    53a0:	9e 81       	ldd	r25, Y+6	; 0x06
    53a2:	9a 83       	std	Y+2, r25	; 0x02
    53a4:	89 83       	std	Y+1, r24	; 0x01
    53a6:	89 81       	ldd	r24, Y+1	; 0x01
    53a8:	9a 81       	ldd	r25, Y+2	; 0x02
    53aa:	01 97       	sbiw	r24, 0x01	; 1
    53ac:	f1 f7       	brne	.-4      	; 0x53aa <HAL_KeyPad_u8GetKeyPressed+0x234>
    53ae:	9a 83       	std	Y+2, r25	; 0x02
    53b0:	89 83       	std	Y+1, r24	; 0x01
						{
					_delay_ms(5);
					*Button = array[LOC_u8Row][LOC_u8Col];
    53b2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    53b4:	48 2f       	mov	r20, r24
    53b6:	50 e0       	ldi	r21, 0x00	; 0
    53b8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    53ba:	28 2f       	mov	r18, r24
    53bc:	30 e0       	ldi	r19, 0x00	; 0
    53be:	ca 01       	movw	r24, r20
    53c0:	88 0f       	add	r24, r24
    53c2:	99 1f       	adc	r25, r25
    53c4:	88 0f       	add	r24, r24
    53c6:	99 1f       	adc	r25, r25
    53c8:	82 0f       	add	r24, r18
    53ca:	93 1f       	adc	r25, r19
    53cc:	fc 01       	movw	r30, r24
    53ce:	e3 59       	subi	r30, 0x93	; 147
    53d0:	fe 4f       	sbci	r31, 0xFE	; 254
    53d2:	80 81       	ld	r24, Z
    53d4:	e9 a1       	ldd	r30, Y+33	; 0x21
    53d6:	fa a1       	ldd	r31, Y+34	; 0x22
    53d8:	80 83       	st	Z, r24
    53da:	07 c0       	rjmp	.+14     	; 0x53ea <HAL_KeyPad_u8GetKeyPressed+0x274>
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R0,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R1,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R2,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R3,Pin_HIGH);
		MCAL_DIO_u8SetPinValue(2, LOC_u8Row, 0);
		for (LOC_u8Col = 0; LOC_u8Col < 4; LOC_u8Col++) {
    53dc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    53de:	8f 5f       	subi	r24, 0xFF	; 255
    53e0:	8f 8f       	std	Y+31, r24	; 0x1f
    53e2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    53e4:	84 30       	cpi	r24, 0x04	; 4
    53e6:	08 f4       	brcc	.+2      	; 0x53ea <HAL_KeyPad_u8GetKeyPressed+0x274>
    53e8:	e0 ce       	rjmp	.-576    	; 0x51aa <HAL_KeyPad_u8GetKeyPressed+0x34>
					*Button = array[LOC_u8Row][LOC_u8Col];
				}
				break;
			}
		}
		MCAL_DIO_u8SetPinValue(2, LOC_u8Row, 1);
    53ea:	82 e0       	ldi	r24, 0x02	; 2
    53ec:	6e 8d       	ldd	r22, Y+30	; 0x1e
    53ee:	41 e0       	ldi	r20, 0x01	; 1
    53f0:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>

void HAL_KeyPad_u8GetKeyPressed(u8 *Button) {

	u8 LOC_u8Col, LOC_u8Row, LOC_u8Status = 7, LOC_u8PinValue;
	*Button = 0;
	for (LOC_u8Row = 0; LOC_u8Row < 4; LOC_u8Row++) {
    53f4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    53f6:	8f 5f       	subi	r24, 0xFF	; 255
    53f8:	8e 8f       	std	Y+30, r24	; 0x1e
    53fa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    53fc:	84 30       	cpi	r24, 0x04	; 4
    53fe:	08 f4       	brcc	.+2      	; 0x5402 <HAL_KeyPad_u8GetKeyPressed+0x28c>
    5400:	cd ce       	rjmp	.-614    	; 0x519c <HAL_KeyPad_u8GetKeyPressed+0x26>
		 {
		 break;
		 }
		 */
	}
}
    5402:	a2 96       	adiw	r28, 0x22	; 34
    5404:	0f b6       	in	r0, 0x3f	; 63
    5406:	f8 94       	cli
    5408:	de bf       	out	0x3e, r29	; 62
    540a:	0f be       	out	0x3f, r0	; 63
    540c:	cd bf       	out	0x3d, r28	; 61
    540e:	cf 91       	pop	r28
    5410:	df 91       	pop	r29
    5412:	08 95       	ret

00005414 <HAL_void_H_BridgeInit>:
 *      Author: Mohamed
 */

#include "H_Bridge.h"

void HAL_void_H_BridgeInit() {
    5414:	df 93       	push	r29
    5416:	cf 93       	push	r28
    5418:	cd b7       	in	r28, 0x3d	; 61
    541a:	de b7       	in	r29, 0x3e	; 62
	MCAL_DIO_u8SetPinDirection(PortC, 3, Pin_High);
    541c:	82 e0       	ldi	r24, 0x02	; 2
    541e:	63 e0       	ldi	r22, 0x03	; 3
    5420:	41 e0       	ldi	r20, 0x01	; 1
    5422:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 4, Pin_High);
    5426:	82 e0       	ldi	r24, 0x02	; 2
    5428:	64 e0       	ldi	r22, 0x04	; 4
    542a:	41 e0       	ldi	r20, 0x01	; 1
    542c:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 5, Pin_High);
    5430:	82 e0       	ldi	r24, 0x02	; 2
    5432:	65 e0       	ldi	r22, 0x05	; 5
    5434:	41 e0       	ldi	r20, 0x01	; 1
    5436:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(PortC, 6, Pin_High);
    543a:	82 e0       	ldi	r24, 0x02	; 2
    543c:	66 e0       	ldi	r22, 0x06	; 6
    543e:	41 e0       	ldi	r20, 0x01	; 1
    5440:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
}
    5444:	cf 91       	pop	r28
    5446:	df 91       	pop	r29
    5448:	08 95       	ret

0000544a <HAL_void_H_BridgeCW>:

void HAL_void_H_BridgeCW(u8 copy_u8_speed) {
    544a:	df 93       	push	r29
    544c:	cf 93       	push	r28
    544e:	0f 92       	push	r0
    5450:	cd b7       	in	r28, 0x3d	; 61
    5452:	de b7       	in	r29, 0x3e	; 62
    5454:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    5456:	81 e0       	ldi	r24, 0x01	; 1
    5458:	69 81       	ldd	r22, Y+1	; 0x01
    545a:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    545e:	80 e0       	ldi	r24, 0x00	; 0
    5460:	69 81       	ldd	r22, Y+1	; 0x01
    5462:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    5466:	82 e0       	ldi	r24, 0x02	; 2
    5468:	63 e0       	ldi	r22, 0x03	; 3
    546a:	40 e0       	ldi	r20, 0x00	; 0
    546c:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    5470:	82 e0       	ldi	r24, 0x02	; 2
    5472:	64 e0       	ldi	r22, 0x04	; 4
    5474:	40 e0       	ldi	r20, 0x00	; 0
    5476:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_High);
    547a:	82 e0       	ldi	r24, 0x02	; 2
    547c:	63 e0       	ldi	r22, 0x03	; 3
    547e:	41 e0       	ldi	r20, 0x01	; 1
    5480:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    5484:	82 e0       	ldi	r24, 0x02	; 2
    5486:	64 e0       	ldi	r22, 0x04	; 4
    5488:	40 e0       	ldi	r20, 0x00	; 0
    548a:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
}
    548e:	0f 90       	pop	r0
    5490:	cf 91       	pop	r28
    5492:	df 91       	pop	r29
    5494:	08 95       	ret

00005496 <HAL_void_H_BridgeFront>:
void HAL_void_H_BridgeFront(u8 copy_u8_speed) {
    5496:	df 93       	push	r29
    5498:	cf 93       	push	r28
    549a:	0f 92       	push	r0
    549c:	cd b7       	in	r28, 0x3d	; 61
    549e:	de b7       	in	r29, 0x3e	; 62
    54a0:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    54a2:	81 e0       	ldi	r24, 0x01	; 1
    54a4:	69 81       	ldd	r22, Y+1	; 0x01
    54a6:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    54aa:	80 e0       	ldi	r24, 0x00	; 0
    54ac:	69 81       	ldd	r22, Y+1	; 0x01
    54ae:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_High);
    54b2:	82 e0       	ldi	r24, 0x02	; 2
    54b4:	63 e0       	ldi	r22, 0x03	; 3
    54b6:	41 e0       	ldi	r20, 0x01	; 1
    54b8:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    54bc:	82 e0       	ldi	r24, 0x02	; 2
    54be:	64 e0       	ldi	r22, 0x04	; 4
    54c0:	40 e0       	ldi	r20, 0x00	; 0
    54c2:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_High);
    54c6:	82 e0       	ldi	r24, 0x02	; 2
    54c8:	65 e0       	ldi	r22, 0x05	; 5
    54ca:	41 e0       	ldi	r20, 0x01	; 1
    54cc:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    54d0:	82 e0       	ldi	r24, 0x02	; 2
    54d2:	66 e0       	ldi	r22, 0x06	; 6
    54d4:	40 e0       	ldi	r20, 0x00	; 0
    54d6:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
}
    54da:	0f 90       	pop	r0
    54dc:	cf 91       	pop	r28
    54de:	df 91       	pop	r29
    54e0:	08 95       	ret

000054e2 <HAL_void_H_BridgeBack>:
void HAL_void_H_BridgeBack(u8 copy_u8_speed) {
    54e2:	df 93       	push	r29
    54e4:	cf 93       	push	r28
    54e6:	0f 92       	push	r0
    54e8:	cd b7       	in	r28, 0x3d	; 61
    54ea:	de b7       	in	r29, 0x3e	; 62
    54ec:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    54ee:	81 e0       	ldi	r24, 0x01	; 1
    54f0:	69 81       	ldd	r22, Y+1	; 0x01
    54f2:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    54f6:	80 e0       	ldi	r24, 0x00	; 0
    54f8:	69 81       	ldd	r22, Y+1	; 0x01
    54fa:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    54fe:	82 e0       	ldi	r24, 0x02	; 2
    5500:	63 e0       	ldi	r22, 0x03	; 3
    5502:	40 e0       	ldi	r20, 0x00	; 0
    5504:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_High);
    5508:	82 e0       	ldi	r24, 0x02	; 2
    550a:	64 e0       	ldi	r22, 0x04	; 4
    550c:	41 e0       	ldi	r20, 0x01	; 1
    550e:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    5512:	82 e0       	ldi	r24, 0x02	; 2
    5514:	65 e0       	ldi	r22, 0x05	; 5
    5516:	40 e0       	ldi	r20, 0x00	; 0
    5518:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_High);
    551c:	82 e0       	ldi	r24, 0x02	; 2
    551e:	66 e0       	ldi	r22, 0x06	; 6
    5520:	41 e0       	ldi	r20, 0x01	; 1
    5522:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
}
    5526:	0f 90       	pop	r0
    5528:	cf 91       	pop	r28
    552a:	df 91       	pop	r29
    552c:	08 95       	ret

0000552e <HAL_void_H_BridgeCCW>:
void HAL_void_H_BridgeCCW(u8 copy_u8_speed) {
    552e:	df 93       	push	r29
    5530:	cf 93       	push	r28
    5532:	0f 92       	push	r0
    5534:	cd b7       	in	r28, 0x3d	; 61
    5536:	de b7       	in	r29, 0x3e	; 62
    5538:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    553a:	81 e0       	ldi	r24, 0x01	; 1
    553c:	69 81       	ldd	r22, Y+1	; 0x01
    553e:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    5542:	80 e0       	ldi	r24, 0x00	; 0
    5544:	69 81       	ldd	r22, Y+1	; 0x01
    5546:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_High);
    554a:	82 e0       	ldi	r24, 0x02	; 2
    554c:	63 e0       	ldi	r22, 0x03	; 3
    554e:	41 e0       	ldi	r20, 0x01	; 1
    5550:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    5554:	82 e0       	ldi	r24, 0x02	; 2
    5556:	64 e0       	ldi	r22, 0x04	; 4
    5558:	40 e0       	ldi	r20, 0x00	; 0
    555a:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    555e:	82 e0       	ldi	r24, 0x02	; 2
    5560:	65 e0       	ldi	r22, 0x05	; 5
    5562:	40 e0       	ldi	r20, 0x00	; 0
    5564:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    5568:	82 e0       	ldi	r24, 0x02	; 2
    556a:	66 e0       	ldi	r22, 0x06	; 6
    556c:	40 e0       	ldi	r20, 0x00	; 0
    556e:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
}
    5572:	0f 90       	pop	r0
    5574:	cf 91       	pop	r28
    5576:	df 91       	pop	r29
    5578:	08 95       	ret

0000557a <HAL_void_H_BridgeStop>:

void HAL_void_H_BridgeStop(u8 copy_u8_speed) {
    557a:	df 93       	push	r29
    557c:	cf 93       	push	r28
    557e:	0f 92       	push	r0
    5580:	cd b7       	in	r28, 0x3d	; 61
    5582:	de b7       	in	r29, 0x3e	; 62
    5584:	89 83       	std	Y+1, r24	; 0x01
	MCAL_T1_FPWM_10bitRES(CHENNEL_B, copy_u8_speed);
    5586:	81 e0       	ldi	r24, 0x01	; 1
    5588:	69 81       	ldd	r22, Y+1	; 0x01
    558a:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_T1_FPWM_10bitRES(CHENNEL_A, copy_u8_speed);
    558e:	80 e0       	ldi	r24, 0x00	; 0
    5590:	69 81       	ldd	r22, Y+1	; 0x01
    5592:	0e 94 9d 10 	call	0x213a	; 0x213a <MCAL_T1_FPWM_10bitRES>
	MCAL_DIO_u8SetPinValue(PortC, Pin3, Pin_Low);
    5596:	82 e0       	ldi	r24, 0x02	; 2
    5598:	63 e0       	ldi	r22, 0x03	; 3
    559a:	40 e0       	ldi	r20, 0x00	; 0
    559c:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin4, Pin_Low);
    55a0:	82 e0       	ldi	r24, 0x02	; 2
    55a2:	64 e0       	ldi	r22, 0x04	; 4
    55a4:	40 e0       	ldi	r20, 0x00	; 0
    55a6:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin5, Pin_Low);
    55aa:	82 e0       	ldi	r24, 0x02	; 2
    55ac:	65 e0       	ldi	r22, 0x05	; 5
    55ae:	40 e0       	ldi	r20, 0x00	; 0
    55b0:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(PortC, Pin6, Pin_Low);
    55b4:	82 e0       	ldi	r24, 0x02	; 2
    55b6:	66 e0       	ldi	r22, 0x06	; 6
    55b8:	40 e0       	ldi	r20, 0x00	; 0
    55ba:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
}
    55be:	0f 90       	pop	r0
    55c0:	cf 91       	pop	r28
    55c2:	df 91       	pop	r29
    55c4:	08 95       	ret

000055c6 <HAL_Buzzer_u8BuzzerInit>:
 *      Author: Mohamed
 */

#include "Buzzer.h"

STD_Type HAL_Buzzer_u8BuzzerInit(u8 Loc_u8BuzzerPortID, u8 Loc_u8BuzzerPinID) {
    55c6:	df 93       	push	r29
    55c8:	cf 93       	push	r28
    55ca:	00 d0       	rcall	.+0      	; 0x55cc <HAL_Buzzer_u8BuzzerInit+0x6>
    55cc:	0f 92       	push	r0
    55ce:	cd b7       	in	r28, 0x3d	; 61
    55d0:	de b7       	in	r29, 0x3e	; 62
    55d2:	8a 83       	std	Y+2, r24	; 0x02
    55d4:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    55d6:	81 e0       	ldi	r24, 0x01	; 1
    55d8:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8BuzzerPortID <= PortD && Loc_u8BuzzerPinID <= Num_Of_Pins) {
    55da:	8a 81       	ldd	r24, Y+2	; 0x02
    55dc:	84 30       	cpi	r24, 0x04	; 4
    55de:	48 f4       	brcc	.+18     	; 0x55f2 <HAL_Buzzer_u8BuzzerInit+0x2c>
    55e0:	8b 81       	ldd	r24, Y+3	; 0x03
    55e2:	88 30       	cpi	r24, 0x08	; 8
    55e4:	30 f4       	brcc	.+12     	; 0x55f2 <HAL_Buzzer_u8BuzzerInit+0x2c>
		Loc_u8Return_Value=Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8BuzzerPortID,
    55e6:	8a 81       	ldd	r24, Y+2	; 0x02
    55e8:	6b 81       	ldd	r22, Y+3	; 0x03
    55ea:	41 e0       	ldi	r20, 0x01	; 1
    55ec:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
    55f0:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8BuzzerPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    55f2:	89 81       	ldd	r24, Y+1	; 0x01
}
    55f4:	0f 90       	pop	r0
    55f6:	0f 90       	pop	r0
    55f8:	0f 90       	pop	r0
    55fa:	cf 91       	pop	r28
    55fc:	df 91       	pop	r29
    55fe:	08 95       	ret

00005600 <HAL_Buzzer_u8BuzzerMode>:

STD_Type HAL_Buzzer_u8BuzzerMode(u8 Loc_u8BuzzerPortID, u8 Loc_u8BuzzerPinID,
		u8 Loc_u8BuzzerMode) {
    5600:	df 93       	push	r29
    5602:	cf 93       	push	r28
    5604:	00 d0       	rcall	.+0      	; 0x5606 <HAL_Buzzer_u8BuzzerMode+0x6>
    5606:	00 d0       	rcall	.+0      	; 0x5608 <HAL_Buzzer_u8BuzzerMode+0x8>
    5608:	cd b7       	in	r28, 0x3d	; 61
    560a:	de b7       	in	r29, 0x3e	; 62
    560c:	8a 83       	std	Y+2, r24	; 0x02
    560e:	6b 83       	std	Y+3, r22	; 0x03
    5610:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    5612:	81 e0       	ldi	r24, 0x01	; 1
    5614:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8BuzzerPortID <= PortD && Loc_u8BuzzerPinID <= Num_Of_Pins
    5616:	8a 81       	ldd	r24, Y+2	; 0x02
    5618:	84 30       	cpi	r24, 0x04	; 4
    561a:	10 f5       	brcc	.+68     	; 0x5660 <HAL_Buzzer_u8BuzzerMode+0x60>
    561c:	8b 81       	ldd	r24, Y+3	; 0x03
    561e:	88 30       	cpi	r24, 0x08	; 8
    5620:	f8 f4       	brcc	.+62     	; 0x5660 <HAL_Buzzer_u8BuzzerMode+0x60>
    5622:	8c 81       	ldd	r24, Y+4	; 0x04
    5624:	83 30       	cpi	r24, 0x03	; 3
    5626:	e0 f4       	brcc	.+56     	; 0x5660 <HAL_Buzzer_u8BuzzerMode+0x60>
			&& Loc_u8BuzzerMode <= Buzzer_TOG) {
		if (Loc_u8BuzzerMode == Buzzer_ON) {
    5628:	8c 81       	ldd	r24, Y+4	; 0x04
    562a:	81 30       	cpi	r24, 0x01	; 1
    562c:	39 f4       	brne	.+14     	; 0x563c <HAL_Buzzer_u8BuzzerMode+0x3c>
			Loc_u8Return_Value=MCAL_DIO_u8SetPinValue(Loc_u8BuzzerPortID, Loc_u8BuzzerPinID, Pin_High);
    562e:	8a 81       	ldd	r24, Y+2	; 0x02
    5630:	6b 81       	ldd	r22, Y+3	; 0x03
    5632:	41 e0       	ldi	r20, 0x01	; 1
    5634:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
    5638:	89 83       	std	Y+1, r24	; 0x01
    563a:	12 c0       	rjmp	.+36     	; 0x5660 <HAL_Buzzer_u8BuzzerMode+0x60>
		} else if (Loc_u8BuzzerMode == Buzzer_OFF) {
    563c:	8c 81       	ldd	r24, Y+4	; 0x04
    563e:	88 23       	and	r24, r24
    5640:	39 f4       	brne	.+14     	; 0x5650 <HAL_Buzzer_u8BuzzerMode+0x50>
			Loc_u8Return_Value=MCAL_DIO_u8SetPinValue(Loc_u8BuzzerPortID, Loc_u8BuzzerPinID, Pin_Low);
    5642:	8a 81       	ldd	r24, Y+2	; 0x02
    5644:	6b 81       	ldd	r22, Y+3	; 0x03
    5646:	40 e0       	ldi	r20, 0x00	; 0
    5648:	0e 94 b5 1a 	call	0x356a	; 0x356a <MCAL_DIO_u8SetPinValue>
    564c:	89 83       	std	Y+1, r24	; 0x01
    564e:	08 c0       	rjmp	.+16     	; 0x5660 <HAL_Buzzer_u8BuzzerMode+0x60>
		} else if (Loc_u8BuzzerMode == Buzzer_TOG) {
    5650:	8c 81       	ldd	r24, Y+4	; 0x04
    5652:	82 30       	cpi	r24, 0x02	; 2
    5654:	29 f4       	brne	.+10     	; 0x5660 <HAL_Buzzer_u8BuzzerMode+0x60>
			Loc_u8Return_Value=MCAL_DIO_u8TogglePinValue(Loc_u8BuzzerPortID,Loc_u8BuzzerPinID);
    5656:	8a 81       	ldd	r24, Y+2	; 0x02
    5658:	6b 81       	ldd	r22, Y+3	; 0x03
    565a:	0e 94 9e 1c 	call	0x393c	; 0x393c <MCAL_DIO_u8TogglePinValue>
    565e:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    5660:	89 81       	ldd	r24, Y+1	; 0x01
}
    5662:	0f 90       	pop	r0
    5664:	0f 90       	pop	r0
    5666:	0f 90       	pop	r0
    5668:	0f 90       	pop	r0
    566a:	cf 91       	pop	r28
    566c:	df 91       	pop	r29
    566e:	08 95       	ret

00005670 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    5670:	df 93       	push	r29
    5672:	cf 93       	push	r28
    5674:	cd b7       	in	r28, 0x3d	; 61
    5676:	de b7       	in	r29, 0x3e	; 62
    5678:	2e 97       	sbiw	r28, 0x0e	; 14
    567a:	0f b6       	in	r0, 0x3f	; 63
    567c:	f8 94       	cli
    567e:	de bf       	out	0x3e, r29	; 62
    5680:	0f be       	out	0x3f, r0	; 63
    5682:	cd bf       	out	0x3d, r28	; 61
    5684:	9e 87       	std	Y+14, r25	; 0x0e
    5686:	8d 87       	std	Y+13, r24	; 0x0d
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    5688:	1e 82       	std	Y+6, r1	; 0x06
    568a:	1d 82       	std	Y+5, r1	; 0x05

	vTaskSuspendAll();
    568c:	0e 94 44 3c 	call	0x7888	; 0x7888 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    5690:	80 91 9b 01 	lds	r24, 0x019B
    5694:	88 23       	and	r24, r24
    5696:	29 f4       	brne	.+10     	; 0x56a2 <pvPortMalloc+0x32>
		{
			prvHeapInit();
    5698:	0e 94 9f 2c 	call	0x593e	; 0x593e <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
    569c:	81 e0       	ldi	r24, 0x01	; 1
    569e:	80 93 9b 01 	sts	0x019B, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    56a2:	8d 85       	ldd	r24, Y+13	; 0x0d
    56a4:	9e 85       	ldd	r25, Y+14	; 0x0e
    56a6:	00 97       	sbiw	r24, 0x00	; 0
    56a8:	51 f0       	breq	.+20     	; 0x56be <pvPortMalloc+0x4e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    56aa:	80 91 7f 01 	lds	r24, 0x017F
    56ae:	90 91 80 01 	lds	r25, 0x0180
    56b2:	2d 85       	ldd	r18, Y+13	; 0x0d
    56b4:	3e 85       	ldd	r19, Y+14	; 0x0e
    56b6:	82 0f       	add	r24, r18
    56b8:	93 1f       	adc	r25, r19
    56ba:	9e 87       	std	Y+14, r25	; 0x0e
    56bc:	8d 87       	std	Y+13, r24	; 0x0d
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    56be:	8d 85       	ldd	r24, Y+13	; 0x0d
    56c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    56c2:	00 97       	sbiw	r24, 0x00	; 0
    56c4:	09 f4       	brne	.+2      	; 0x56c8 <pvPortMalloc+0x58>
    56c6:	af c0       	rjmp	.+350    	; 0x5826 <pvPortMalloc+0x1b6>
    56c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    56ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    56cc:	23 e0       	ldi	r18, 0x03	; 3
    56ce:	87 3e       	cpi	r24, 0xE7	; 231
    56d0:	92 07       	cpc	r25, r18
    56d2:	08 f0       	brcs	.+2      	; 0x56d6 <pvPortMalloc+0x66>
    56d4:	a8 c0       	rjmp	.+336    	; 0x5826 <pvPortMalloc+0x1b6>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    56d6:	84 e8       	ldi	r24, 0x84	; 132
    56d8:	95 e0       	ldi	r25, 0x05	; 5
    56da:	9a 87       	std	Y+10, r25	; 0x0a
    56dc:	89 87       	std	Y+9, r24	; 0x09
			pxBlock = xStart.pxNextFreeBlock;
    56de:	80 91 84 05 	lds	r24, 0x0584
    56e2:	90 91 85 05 	lds	r25, 0x0585
    56e6:	9c 87       	std	Y+12, r25	; 0x0c
    56e8:	8b 87       	std	Y+11, r24	; 0x0b
    56ea:	0a c0       	rjmp	.+20     	; 0x5700 <pvPortMalloc+0x90>
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
			{
				pxPreviousBlock = pxBlock;
    56ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    56ee:	9c 85       	ldd	r25, Y+12	; 0x0c
    56f0:	9a 87       	std	Y+10, r25	; 0x0a
    56f2:	89 87       	std	Y+9, r24	; 0x09
				pxBlock = pxBlock->pxNextFreeBlock;
    56f4:	eb 85       	ldd	r30, Y+11	; 0x0b
    56f6:	fc 85       	ldd	r31, Y+12	; 0x0c
    56f8:	80 81       	ld	r24, Z
    56fa:	91 81       	ldd	r25, Z+1	; 0x01
    56fc:	9c 87       	std	Y+12, r25	; 0x0c
    56fe:	8b 87       	std	Y+11, r24	; 0x0b
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    5700:	eb 85       	ldd	r30, Y+11	; 0x0b
    5702:	fc 85       	ldd	r31, Y+12	; 0x0c
    5704:	22 81       	ldd	r18, Z+2	; 0x02
    5706:	33 81       	ldd	r19, Z+3	; 0x03
    5708:	8d 85       	ldd	r24, Y+13	; 0x0d
    570a:	9e 85       	ldd	r25, Y+14	; 0x0e
    570c:	28 17       	cp	r18, r24
    570e:	39 07       	cpc	r19, r25
    5710:	30 f4       	brcc	.+12     	; 0x571e <pvPortMalloc+0xae>
    5712:	eb 85       	ldd	r30, Y+11	; 0x0b
    5714:	fc 85       	ldd	r31, Y+12	; 0x0c
    5716:	80 81       	ld	r24, Z
    5718:	91 81       	ldd	r25, Z+1	; 0x01
    571a:	00 97       	sbiw	r24, 0x00	; 0
    571c:	39 f7       	brne	.-50     	; 0x56ec <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    571e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5720:	9c 85       	ldd	r25, Y+12	; 0x0c
    5722:	45 e0       	ldi	r20, 0x05	; 5
    5724:	88 38       	cpi	r24, 0x88	; 136
    5726:	94 07       	cpc	r25, r20
    5728:	09 f4       	brne	.+2      	; 0x572c <pvPortMalloc+0xbc>
    572a:	7d c0       	rjmp	.+250    	; 0x5826 <pvPortMalloc+0x1b6>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    572c:	e9 85       	ldd	r30, Y+9	; 0x09
    572e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5730:	20 81       	ld	r18, Z
    5732:	31 81       	ldd	r19, Z+1	; 0x01
    5734:	80 91 7f 01 	lds	r24, 0x017F
    5738:	90 91 80 01 	lds	r25, 0x0180
    573c:	82 0f       	add	r24, r18
    573e:	93 1f       	adc	r25, r19
    5740:	9e 83       	std	Y+6, r25	; 0x06
    5742:	8d 83       	std	Y+5, r24	; 0x05

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    5744:	eb 85       	ldd	r30, Y+11	; 0x0b
    5746:	fc 85       	ldd	r31, Y+12	; 0x0c
    5748:	80 81       	ld	r24, Z
    574a:	91 81       	ldd	r25, Z+1	; 0x01
    574c:	e9 85       	ldd	r30, Y+9	; 0x09
    574e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5750:	91 83       	std	Z+1, r25	; 0x01
    5752:	80 83       	st	Z, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    5754:	eb 85       	ldd	r30, Y+11	; 0x0b
    5756:	fc 85       	ldd	r31, Y+12	; 0x0c
    5758:	22 81       	ldd	r18, Z+2	; 0x02
    575a:	33 81       	ldd	r19, Z+3	; 0x03
    575c:	8d 85       	ldd	r24, Y+13	; 0x0d
    575e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5760:	28 1b       	sub	r18, r24
    5762:	39 0b       	sbc	r19, r25
    5764:	80 91 7f 01 	lds	r24, 0x017F
    5768:	90 91 80 01 	lds	r25, 0x0180
    576c:	88 0f       	add	r24, r24
    576e:	99 1f       	adc	r25, r25
    5770:	82 17       	cp	r24, r18
    5772:	93 07       	cpc	r25, r19
    5774:	08 f0       	brcs	.+2      	; 0x5778 <pvPortMalloc+0x108>
    5776:	47 c0       	rjmp	.+142    	; 0x5806 <pvPortMalloc+0x196>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    5778:	2b 85       	ldd	r18, Y+11	; 0x0b
    577a:	3c 85       	ldd	r19, Y+12	; 0x0c
    577c:	8d 85       	ldd	r24, Y+13	; 0x0d
    577e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5780:	82 0f       	add	r24, r18
    5782:	93 1f       	adc	r25, r19
    5784:	98 87       	std	Y+8, r25	; 0x08
    5786:	8f 83       	std	Y+7, r24	; 0x07

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    5788:	eb 85       	ldd	r30, Y+11	; 0x0b
    578a:	fc 85       	ldd	r31, Y+12	; 0x0c
    578c:	22 81       	ldd	r18, Z+2	; 0x02
    578e:	33 81       	ldd	r19, Z+3	; 0x03
    5790:	8d 85       	ldd	r24, Y+13	; 0x0d
    5792:	9e 85       	ldd	r25, Y+14	; 0x0e
    5794:	a9 01       	movw	r20, r18
    5796:	48 1b       	sub	r20, r24
    5798:	59 0b       	sbc	r21, r25
    579a:	ca 01       	movw	r24, r20
    579c:	ef 81       	ldd	r30, Y+7	; 0x07
    579e:	f8 85       	ldd	r31, Y+8	; 0x08
    57a0:	93 83       	std	Z+3, r25	; 0x03
    57a2:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->xBlockSize = xWantedSize;
    57a4:	eb 85       	ldd	r30, Y+11	; 0x0b
    57a6:	fc 85       	ldd	r31, Y+12	; 0x0c
    57a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    57aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    57ac:	93 83       	std	Z+3, r25	; 0x03
    57ae:	82 83       	std	Z+2, r24	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    57b0:	ef 81       	ldd	r30, Y+7	; 0x07
    57b2:	f8 85       	ldd	r31, Y+8	; 0x08
    57b4:	82 81       	ldd	r24, Z+2	; 0x02
    57b6:	93 81       	ldd	r25, Z+3	; 0x03
    57b8:	9a 83       	std	Y+2, r25	; 0x02
    57ba:	89 83       	std	Y+1, r24	; 0x01
    57bc:	84 e8       	ldi	r24, 0x84	; 132
    57be:	95 e0       	ldi	r25, 0x05	; 5
    57c0:	9c 83       	std	Y+4, r25	; 0x04
    57c2:	8b 83       	std	Y+3, r24	; 0x03
    57c4:	06 c0       	rjmp	.+12     	; 0x57d2 <pvPortMalloc+0x162>
    57c6:	eb 81       	ldd	r30, Y+3	; 0x03
    57c8:	fc 81       	ldd	r31, Y+4	; 0x04
    57ca:	80 81       	ld	r24, Z
    57cc:	91 81       	ldd	r25, Z+1	; 0x01
    57ce:	9c 83       	std	Y+4, r25	; 0x04
    57d0:	8b 83       	std	Y+3, r24	; 0x03
    57d2:	eb 81       	ldd	r30, Y+3	; 0x03
    57d4:	fc 81       	ldd	r31, Y+4	; 0x04
    57d6:	01 90       	ld	r0, Z+
    57d8:	f0 81       	ld	r31, Z
    57da:	e0 2d       	mov	r30, r0
    57dc:	22 81       	ldd	r18, Z+2	; 0x02
    57de:	33 81       	ldd	r19, Z+3	; 0x03
    57e0:	89 81       	ldd	r24, Y+1	; 0x01
    57e2:	9a 81       	ldd	r25, Y+2	; 0x02
    57e4:	28 17       	cp	r18, r24
    57e6:	39 07       	cpc	r19, r25
    57e8:	70 f3       	brcs	.-36     	; 0x57c6 <pvPortMalloc+0x156>
    57ea:	eb 81       	ldd	r30, Y+3	; 0x03
    57ec:	fc 81       	ldd	r31, Y+4	; 0x04
    57ee:	80 81       	ld	r24, Z
    57f0:	91 81       	ldd	r25, Z+1	; 0x01
    57f2:	ef 81       	ldd	r30, Y+7	; 0x07
    57f4:	f8 85       	ldd	r31, Y+8	; 0x08
    57f6:	91 83       	std	Z+1, r25	; 0x01
    57f8:	80 83       	st	Z, r24
    57fa:	eb 81       	ldd	r30, Y+3	; 0x03
    57fc:	fc 81       	ldd	r31, Y+4	; 0x04
    57fe:	8f 81       	ldd	r24, Y+7	; 0x07
    5800:	98 85       	ldd	r25, Y+8	; 0x08
    5802:	91 83       	std	Z+1, r25	; 0x01
    5804:	80 83       	st	Z, r24
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    5806:	20 91 7d 01 	lds	r18, 0x017D
    580a:	30 91 7e 01 	lds	r19, 0x017E
    580e:	eb 85       	ldd	r30, Y+11	; 0x0b
    5810:	fc 85       	ldd	r31, Y+12	; 0x0c
    5812:	82 81       	ldd	r24, Z+2	; 0x02
    5814:	93 81       	ldd	r25, Z+3	; 0x03
    5816:	a9 01       	movw	r20, r18
    5818:	48 1b       	sub	r20, r24
    581a:	59 0b       	sbc	r21, r25
    581c:	ca 01       	movw	r24, r20
    581e:	90 93 7e 01 	sts	0x017E, r25
    5822:	80 93 7d 01 	sts	0x017D, r24
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    5826:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    582a:	8d 81       	ldd	r24, Y+5	; 0x05
    582c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    582e:	2e 96       	adiw	r28, 0x0e	; 14
    5830:	0f b6       	in	r0, 0x3f	; 63
    5832:	f8 94       	cli
    5834:	de bf       	out	0x3e, r29	; 62
    5836:	0f be       	out	0x3f, r0	; 63
    5838:	cd bf       	out	0x3d, r28	; 61
    583a:	cf 91       	pop	r28
    583c:	df 91       	pop	r29
    583e:	08 95       	ret

00005840 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    5840:	df 93       	push	r29
    5842:	cf 93       	push	r28
    5844:	cd b7       	in	r28, 0x3d	; 61
    5846:	de b7       	in	r29, 0x3e	; 62
    5848:	2a 97       	sbiw	r28, 0x0a	; 10
    584a:	0f b6       	in	r0, 0x3f	; 63
    584c:	f8 94       	cli
    584e:	de bf       	out	0x3e, r29	; 62
    5850:	0f be       	out	0x3f, r0	; 63
    5852:	cd bf       	out	0x3d, r28	; 61
    5854:	9a 87       	std	Y+10, r25	; 0x0a
    5856:	89 87       	std	Y+9, r24	; 0x09
uint8_t *puc = ( uint8_t * ) pv;
    5858:	89 85       	ldd	r24, Y+9	; 0x09
    585a:	9a 85       	ldd	r25, Y+10	; 0x0a
    585c:	98 87       	std	Y+8, r25	; 0x08
    585e:	8f 83       	std	Y+7, r24	; 0x07
BlockLink_t *pxLink;

	if( pv != NULL )
    5860:	89 85       	ldd	r24, Y+9	; 0x09
    5862:	9a 85       	ldd	r25, Y+10	; 0x0a
    5864:	00 97       	sbiw	r24, 0x00	; 0
    5866:	09 f4       	brne	.+2      	; 0x586a <vPortFree+0x2a>
    5868:	4f c0       	rjmp	.+158    	; 0x5908 <vPortFree+0xc8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    586a:	80 91 7f 01 	lds	r24, 0x017F
    586e:	90 91 80 01 	lds	r25, 0x0180
    5872:	22 27       	eor	r18, r18
    5874:	33 27       	eor	r19, r19
    5876:	28 1b       	sub	r18, r24
    5878:	39 0b       	sbc	r19, r25
    587a:	8f 81       	ldd	r24, Y+7	; 0x07
    587c:	98 85       	ldd	r25, Y+8	; 0x08
    587e:	82 0f       	add	r24, r18
    5880:	93 1f       	adc	r25, r19
    5882:	98 87       	std	Y+8, r25	; 0x08
    5884:	8f 83       	std	Y+7, r24	; 0x07

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
    5886:	8f 81       	ldd	r24, Y+7	; 0x07
    5888:	98 85       	ldd	r25, Y+8	; 0x08
    588a:	9e 83       	std	Y+6, r25	; 0x06
    588c:	8d 83       	std	Y+5, r24	; 0x05

		vTaskSuspendAll();
    588e:	0e 94 44 3c 	call	0x7888	; 0x7888 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    5892:	ed 81       	ldd	r30, Y+5	; 0x05
    5894:	fe 81       	ldd	r31, Y+6	; 0x06
    5896:	82 81       	ldd	r24, Z+2	; 0x02
    5898:	93 81       	ldd	r25, Z+3	; 0x03
    589a:	9a 83       	std	Y+2, r25	; 0x02
    589c:	89 83       	std	Y+1, r24	; 0x01
    589e:	84 e8       	ldi	r24, 0x84	; 132
    58a0:	95 e0       	ldi	r25, 0x05	; 5
    58a2:	9c 83       	std	Y+4, r25	; 0x04
    58a4:	8b 83       	std	Y+3, r24	; 0x03
    58a6:	06 c0       	rjmp	.+12     	; 0x58b4 <vPortFree+0x74>
    58a8:	eb 81       	ldd	r30, Y+3	; 0x03
    58aa:	fc 81       	ldd	r31, Y+4	; 0x04
    58ac:	80 81       	ld	r24, Z
    58ae:	91 81       	ldd	r25, Z+1	; 0x01
    58b0:	9c 83       	std	Y+4, r25	; 0x04
    58b2:	8b 83       	std	Y+3, r24	; 0x03
    58b4:	eb 81       	ldd	r30, Y+3	; 0x03
    58b6:	fc 81       	ldd	r31, Y+4	; 0x04
    58b8:	01 90       	ld	r0, Z+
    58ba:	f0 81       	ld	r31, Z
    58bc:	e0 2d       	mov	r30, r0
    58be:	22 81       	ldd	r18, Z+2	; 0x02
    58c0:	33 81       	ldd	r19, Z+3	; 0x03
    58c2:	89 81       	ldd	r24, Y+1	; 0x01
    58c4:	9a 81       	ldd	r25, Y+2	; 0x02
    58c6:	28 17       	cp	r18, r24
    58c8:	39 07       	cpc	r19, r25
    58ca:	70 f3       	brcs	.-36     	; 0x58a8 <vPortFree+0x68>
    58cc:	eb 81       	ldd	r30, Y+3	; 0x03
    58ce:	fc 81       	ldd	r31, Y+4	; 0x04
    58d0:	80 81       	ld	r24, Z
    58d2:	91 81       	ldd	r25, Z+1	; 0x01
    58d4:	ed 81       	ldd	r30, Y+5	; 0x05
    58d6:	fe 81       	ldd	r31, Y+6	; 0x06
    58d8:	91 83       	std	Z+1, r25	; 0x01
    58da:	80 83       	st	Z, r24
    58dc:	eb 81       	ldd	r30, Y+3	; 0x03
    58de:	fc 81       	ldd	r31, Y+4	; 0x04
    58e0:	8d 81       	ldd	r24, Y+5	; 0x05
    58e2:	9e 81       	ldd	r25, Y+6	; 0x06
    58e4:	91 83       	std	Z+1, r25	; 0x01
    58e6:	80 83       	st	Z, r24
			xFreeBytesRemaining += pxLink->xBlockSize;
    58e8:	ed 81       	ldd	r30, Y+5	; 0x05
    58ea:	fe 81       	ldd	r31, Y+6	; 0x06
    58ec:	22 81       	ldd	r18, Z+2	; 0x02
    58ee:	33 81       	ldd	r19, Z+3	; 0x03
    58f0:	80 91 7d 01 	lds	r24, 0x017D
    58f4:	90 91 7e 01 	lds	r25, 0x017E
    58f8:	82 0f       	add	r24, r18
    58fa:	93 1f       	adc	r25, r19
    58fc:	90 93 7e 01 	sts	0x017E, r25
    5900:	80 93 7d 01 	sts	0x017D, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    5904:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>
	}
}
    5908:	2a 96       	adiw	r28, 0x0a	; 10
    590a:	0f b6       	in	r0, 0x3f	; 63
    590c:	f8 94       	cli
    590e:	de bf       	out	0x3e, r29	; 62
    5910:	0f be       	out	0x3f, r0	; 63
    5912:	cd bf       	out	0x3d, r28	; 61
    5914:	cf 91       	pop	r28
    5916:	df 91       	pop	r29
    5918:	08 95       	ret

0000591a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    591a:	df 93       	push	r29
    591c:	cf 93       	push	r28
    591e:	cd b7       	in	r28, 0x3d	; 61
    5920:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
    5922:	80 91 7d 01 	lds	r24, 0x017D
    5926:	90 91 7e 01 	lds	r25, 0x017E
}
    592a:	cf 91       	pop	r28
    592c:	df 91       	pop	r29
    592e:	08 95       	ret

00005930 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    5930:	df 93       	push	r29
    5932:	cf 93       	push	r28
    5934:	cd b7       	in	r28, 0x3d	; 61
    5936:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
    5938:	cf 91       	pop	r28
    593a:	df 91       	pop	r29
    593c:	08 95       	ret

0000593e <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    593e:	df 93       	push	r29
    5940:	cf 93       	push	r28
    5942:	00 d0       	rcall	.+0      	; 0x5944 <prvHeapInit+0x6>
    5944:	00 d0       	rcall	.+0      	; 0x5946 <prvHeapInit+0x8>
    5946:	cd b7       	in	r28, 0x3d	; 61
    5948:	de b7       	in	r29, 0x3e	; 62
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    594a:	8d e9       	ldi	r24, 0x9D	; 157
    594c:	91 e0       	ldi	r25, 0x01	; 1
    594e:	9a 83       	std	Y+2, r25	; 0x02
    5950:	89 83       	std	Y+1, r24	; 0x01

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    5952:	89 81       	ldd	r24, Y+1	; 0x01
    5954:	9a 81       	ldd	r25, Y+2	; 0x02
    5956:	90 93 85 05 	sts	0x0585, r25
    595a:	80 93 84 05 	sts	0x0584, r24
	xStart.xBlockSize = ( size_t ) 0;
    595e:	10 92 87 05 	sts	0x0587, r1
    5962:	10 92 86 05 	sts	0x0586, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    5966:	87 ee       	ldi	r24, 0xE7	; 231
    5968:	93 e0       	ldi	r25, 0x03	; 3
    596a:	90 93 8b 05 	sts	0x058B, r25
    596e:	80 93 8a 05 	sts	0x058A, r24
	xEnd.pxNextFreeBlock = NULL;
    5972:	10 92 89 05 	sts	0x0589, r1
    5976:	10 92 88 05 	sts	0x0588, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    597a:	89 81       	ldd	r24, Y+1	; 0x01
    597c:	9a 81       	ldd	r25, Y+2	; 0x02
    597e:	9c 83       	std	Y+4, r25	; 0x04
    5980:	8b 83       	std	Y+3, r24	; 0x03
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    5982:	eb 81       	ldd	r30, Y+3	; 0x03
    5984:	fc 81       	ldd	r31, Y+4	; 0x04
    5986:	87 ee       	ldi	r24, 0xE7	; 231
    5988:	93 e0       	ldi	r25, 0x03	; 3
    598a:	93 83       	std	Z+3, r25	; 0x03
    598c:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    598e:	eb 81       	ldd	r30, Y+3	; 0x03
    5990:	fc 81       	ldd	r31, Y+4	; 0x04
    5992:	88 e8       	ldi	r24, 0x88	; 136
    5994:	95 e0       	ldi	r25, 0x05	; 5
    5996:	91 83       	std	Z+1, r25	; 0x01
    5998:	80 83       	st	Z, r24
}
    599a:	0f 90       	pop	r0
    599c:	0f 90       	pop	r0
    599e:	0f 90       	pop	r0
    59a0:	0f 90       	pop	r0
    59a2:	cf 91       	pop	r28
    59a4:	df 91       	pop	r29
    59a6:	08 95       	ret

000059a8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    59a8:	df 93       	push	r29
    59aa:	cf 93       	push	r28
    59ac:	00 d0       	rcall	.+0      	; 0x59ae <vListInitialise+0x6>
    59ae:	cd b7       	in	r28, 0x3d	; 61
    59b0:	de b7       	in	r29, 0x3e	; 62
    59b2:	9a 83       	std	Y+2, r25	; 0x02
    59b4:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    59b6:	89 81       	ldd	r24, Y+1	; 0x01
    59b8:	9a 81       	ldd	r25, Y+2	; 0x02
    59ba:	03 96       	adiw	r24, 0x03	; 3
    59bc:	e9 81       	ldd	r30, Y+1	; 0x01
    59be:	fa 81       	ldd	r31, Y+2	; 0x02
    59c0:	92 83       	std	Z+2, r25	; 0x02
    59c2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    59c4:	e9 81       	ldd	r30, Y+1	; 0x01
    59c6:	fa 81       	ldd	r31, Y+2	; 0x02
    59c8:	8f ef       	ldi	r24, 0xFF	; 255
    59ca:	9f ef       	ldi	r25, 0xFF	; 255
    59cc:	94 83       	std	Z+4, r25	; 0x04
    59ce:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    59d0:	89 81       	ldd	r24, Y+1	; 0x01
    59d2:	9a 81       	ldd	r25, Y+2	; 0x02
    59d4:	03 96       	adiw	r24, 0x03	; 3
    59d6:	e9 81       	ldd	r30, Y+1	; 0x01
    59d8:	fa 81       	ldd	r31, Y+2	; 0x02
    59da:	96 83       	std	Z+6, r25	; 0x06
    59dc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    59de:	89 81       	ldd	r24, Y+1	; 0x01
    59e0:	9a 81       	ldd	r25, Y+2	; 0x02
    59e2:	03 96       	adiw	r24, 0x03	; 3
    59e4:	e9 81       	ldd	r30, Y+1	; 0x01
    59e6:	fa 81       	ldd	r31, Y+2	; 0x02
    59e8:	90 87       	std	Z+8, r25	; 0x08
    59ea:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    59ec:	e9 81       	ldd	r30, Y+1	; 0x01
    59ee:	fa 81       	ldd	r31, Y+2	; 0x02
    59f0:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    59f2:	0f 90       	pop	r0
    59f4:	0f 90       	pop	r0
    59f6:	cf 91       	pop	r28
    59f8:	df 91       	pop	r29
    59fa:	08 95       	ret

000059fc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    59fc:	df 93       	push	r29
    59fe:	cf 93       	push	r28
    5a00:	00 d0       	rcall	.+0      	; 0x5a02 <vListInitialiseItem+0x6>
    5a02:	cd b7       	in	r28, 0x3d	; 61
    5a04:	de b7       	in	r29, 0x3e	; 62
    5a06:	9a 83       	std	Y+2, r25	; 0x02
    5a08:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    5a0a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a0c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a0e:	11 86       	std	Z+9, r1	; 0x09
    5a10:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    5a12:	0f 90       	pop	r0
    5a14:	0f 90       	pop	r0
    5a16:	cf 91       	pop	r28
    5a18:	df 91       	pop	r29
    5a1a:	08 95       	ret

00005a1c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    5a1c:	df 93       	push	r29
    5a1e:	cf 93       	push	r28
    5a20:	00 d0       	rcall	.+0      	; 0x5a22 <vListInsertEnd+0x6>
    5a22:	00 d0       	rcall	.+0      	; 0x5a24 <vListInsertEnd+0x8>
    5a24:	00 d0       	rcall	.+0      	; 0x5a26 <vListInsertEnd+0xa>
    5a26:	cd b7       	in	r28, 0x3d	; 61
    5a28:	de b7       	in	r29, 0x3e	; 62
    5a2a:	9c 83       	std	Y+4, r25	; 0x04
    5a2c:	8b 83       	std	Y+3, r24	; 0x03
    5a2e:	7e 83       	std	Y+6, r23	; 0x06
    5a30:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    5a32:	eb 81       	ldd	r30, Y+3	; 0x03
    5a34:	fc 81       	ldd	r31, Y+4	; 0x04
    5a36:	81 81       	ldd	r24, Z+1	; 0x01
    5a38:	92 81       	ldd	r25, Z+2	; 0x02
    5a3a:	9a 83       	std	Y+2, r25	; 0x02
    5a3c:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    5a3e:	ed 81       	ldd	r30, Y+5	; 0x05
    5a40:	fe 81       	ldd	r31, Y+6	; 0x06
    5a42:	89 81       	ldd	r24, Y+1	; 0x01
    5a44:	9a 81       	ldd	r25, Y+2	; 0x02
    5a46:	93 83       	std	Z+3, r25	; 0x03
    5a48:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    5a4a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a4c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a4e:	84 81       	ldd	r24, Z+4	; 0x04
    5a50:	95 81       	ldd	r25, Z+5	; 0x05
    5a52:	ed 81       	ldd	r30, Y+5	; 0x05
    5a54:	fe 81       	ldd	r31, Y+6	; 0x06
    5a56:	95 83       	std	Z+5, r25	; 0x05
    5a58:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    5a5a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a5c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a5e:	04 80       	ldd	r0, Z+4	; 0x04
    5a60:	f5 81       	ldd	r31, Z+5	; 0x05
    5a62:	e0 2d       	mov	r30, r0
    5a64:	8d 81       	ldd	r24, Y+5	; 0x05
    5a66:	9e 81       	ldd	r25, Y+6	; 0x06
    5a68:	93 83       	std	Z+3, r25	; 0x03
    5a6a:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    5a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    5a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    5a70:	8d 81       	ldd	r24, Y+5	; 0x05
    5a72:	9e 81       	ldd	r25, Y+6	; 0x06
    5a74:	95 83       	std	Z+5, r25	; 0x05
    5a76:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    5a78:	ed 81       	ldd	r30, Y+5	; 0x05
    5a7a:	fe 81       	ldd	r31, Y+6	; 0x06
    5a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a80:	91 87       	std	Z+9, r25	; 0x09
    5a82:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    5a84:	eb 81       	ldd	r30, Y+3	; 0x03
    5a86:	fc 81       	ldd	r31, Y+4	; 0x04
    5a88:	80 81       	ld	r24, Z
    5a8a:	8f 5f       	subi	r24, 0xFF	; 255
    5a8c:	eb 81       	ldd	r30, Y+3	; 0x03
    5a8e:	fc 81       	ldd	r31, Y+4	; 0x04
    5a90:	80 83       	st	Z, r24
}
    5a92:	26 96       	adiw	r28, 0x06	; 6
    5a94:	0f b6       	in	r0, 0x3f	; 63
    5a96:	f8 94       	cli
    5a98:	de bf       	out	0x3e, r29	; 62
    5a9a:	0f be       	out	0x3f, r0	; 63
    5a9c:	cd bf       	out	0x3d, r28	; 61
    5a9e:	cf 91       	pop	r28
    5aa0:	df 91       	pop	r29
    5aa2:	08 95       	ret

00005aa4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    5aa4:	df 93       	push	r29
    5aa6:	cf 93       	push	r28
    5aa8:	cd b7       	in	r28, 0x3d	; 61
    5aaa:	de b7       	in	r29, 0x3e	; 62
    5aac:	28 97       	sbiw	r28, 0x08	; 8
    5aae:	0f b6       	in	r0, 0x3f	; 63
    5ab0:	f8 94       	cli
    5ab2:	de bf       	out	0x3e, r29	; 62
    5ab4:	0f be       	out	0x3f, r0	; 63
    5ab6:	cd bf       	out	0x3d, r28	; 61
    5ab8:	9e 83       	std	Y+6, r25	; 0x06
    5aba:	8d 83       	std	Y+5, r24	; 0x05
    5abc:	78 87       	std	Y+8, r23	; 0x08
    5abe:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    5ac0:	ef 81       	ldd	r30, Y+7	; 0x07
    5ac2:	f8 85       	ldd	r31, Y+8	; 0x08
    5ac4:	80 81       	ld	r24, Z
    5ac6:	91 81       	ldd	r25, Z+1	; 0x01
    5ac8:	9a 83       	std	Y+2, r25	; 0x02
    5aca:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    5acc:	89 81       	ldd	r24, Y+1	; 0x01
    5ace:	9a 81       	ldd	r25, Y+2	; 0x02
    5ad0:	2f ef       	ldi	r18, 0xFF	; 255
    5ad2:	8f 3f       	cpi	r24, 0xFF	; 255
    5ad4:	92 07       	cpc	r25, r18
    5ad6:	39 f4       	brne	.+14     	; 0x5ae6 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    5ad8:	ed 81       	ldd	r30, Y+5	; 0x05
    5ada:	fe 81       	ldd	r31, Y+6	; 0x06
    5adc:	87 81       	ldd	r24, Z+7	; 0x07
    5ade:	90 85       	ldd	r25, Z+8	; 0x08
    5ae0:	9c 83       	std	Y+4, r25	; 0x04
    5ae2:	8b 83       	std	Y+3, r24	; 0x03
    5ae4:	18 c0       	rjmp	.+48     	; 0x5b16 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    5ae6:	8d 81       	ldd	r24, Y+5	; 0x05
    5ae8:	9e 81       	ldd	r25, Y+6	; 0x06
    5aea:	03 96       	adiw	r24, 0x03	; 3
    5aec:	9c 83       	std	Y+4, r25	; 0x04
    5aee:	8b 83       	std	Y+3, r24	; 0x03
    5af0:	06 c0       	rjmp	.+12     	; 0x5afe <vListInsert+0x5a>
    5af2:	eb 81       	ldd	r30, Y+3	; 0x03
    5af4:	fc 81       	ldd	r31, Y+4	; 0x04
    5af6:	82 81       	ldd	r24, Z+2	; 0x02
    5af8:	93 81       	ldd	r25, Z+3	; 0x03
    5afa:	9c 83       	std	Y+4, r25	; 0x04
    5afc:	8b 83       	std	Y+3, r24	; 0x03
    5afe:	eb 81       	ldd	r30, Y+3	; 0x03
    5b00:	fc 81       	ldd	r31, Y+4	; 0x04
    5b02:	02 80       	ldd	r0, Z+2	; 0x02
    5b04:	f3 81       	ldd	r31, Z+3	; 0x03
    5b06:	e0 2d       	mov	r30, r0
    5b08:	20 81       	ld	r18, Z
    5b0a:	31 81       	ldd	r19, Z+1	; 0x01
    5b0c:	89 81       	ldd	r24, Y+1	; 0x01
    5b0e:	9a 81       	ldd	r25, Y+2	; 0x02
    5b10:	82 17       	cp	r24, r18
    5b12:	93 07       	cpc	r25, r19
    5b14:	70 f7       	brcc	.-36     	; 0x5af2 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    5b16:	eb 81       	ldd	r30, Y+3	; 0x03
    5b18:	fc 81       	ldd	r31, Y+4	; 0x04
    5b1a:	82 81       	ldd	r24, Z+2	; 0x02
    5b1c:	93 81       	ldd	r25, Z+3	; 0x03
    5b1e:	ef 81       	ldd	r30, Y+7	; 0x07
    5b20:	f8 85       	ldd	r31, Y+8	; 0x08
    5b22:	93 83       	std	Z+3, r25	; 0x03
    5b24:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    5b26:	ef 81       	ldd	r30, Y+7	; 0x07
    5b28:	f8 85       	ldd	r31, Y+8	; 0x08
    5b2a:	02 80       	ldd	r0, Z+2	; 0x02
    5b2c:	f3 81       	ldd	r31, Z+3	; 0x03
    5b2e:	e0 2d       	mov	r30, r0
    5b30:	8f 81       	ldd	r24, Y+7	; 0x07
    5b32:	98 85       	ldd	r25, Y+8	; 0x08
    5b34:	95 83       	std	Z+5, r25	; 0x05
    5b36:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    5b38:	ef 81       	ldd	r30, Y+7	; 0x07
    5b3a:	f8 85       	ldd	r31, Y+8	; 0x08
    5b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    5b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    5b40:	95 83       	std	Z+5, r25	; 0x05
    5b42:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    5b44:	eb 81       	ldd	r30, Y+3	; 0x03
    5b46:	fc 81       	ldd	r31, Y+4	; 0x04
    5b48:	8f 81       	ldd	r24, Y+7	; 0x07
    5b4a:	98 85       	ldd	r25, Y+8	; 0x08
    5b4c:	93 83       	std	Z+3, r25	; 0x03
    5b4e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    5b50:	ef 81       	ldd	r30, Y+7	; 0x07
    5b52:	f8 85       	ldd	r31, Y+8	; 0x08
    5b54:	8d 81       	ldd	r24, Y+5	; 0x05
    5b56:	9e 81       	ldd	r25, Y+6	; 0x06
    5b58:	91 87       	std	Z+9, r25	; 0x09
    5b5a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    5b5c:	ed 81       	ldd	r30, Y+5	; 0x05
    5b5e:	fe 81       	ldd	r31, Y+6	; 0x06
    5b60:	80 81       	ld	r24, Z
    5b62:	8f 5f       	subi	r24, 0xFF	; 255
    5b64:	ed 81       	ldd	r30, Y+5	; 0x05
    5b66:	fe 81       	ldd	r31, Y+6	; 0x06
    5b68:	80 83       	st	Z, r24
}
    5b6a:	28 96       	adiw	r28, 0x08	; 8
    5b6c:	0f b6       	in	r0, 0x3f	; 63
    5b6e:	f8 94       	cli
    5b70:	de bf       	out	0x3e, r29	; 62
    5b72:	0f be       	out	0x3f, r0	; 63
    5b74:	cd bf       	out	0x3d, r28	; 61
    5b76:	cf 91       	pop	r28
    5b78:	df 91       	pop	r29
    5b7a:	08 95       	ret

00005b7c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    5b7c:	df 93       	push	r29
    5b7e:	cf 93       	push	r28
    5b80:	00 d0       	rcall	.+0      	; 0x5b82 <uxListRemove+0x6>
    5b82:	00 d0       	rcall	.+0      	; 0x5b84 <uxListRemove+0x8>
    5b84:	cd b7       	in	r28, 0x3d	; 61
    5b86:	de b7       	in	r29, 0x3e	; 62
    5b88:	9c 83       	std	Y+4, r25	; 0x04
    5b8a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    5b8c:	eb 81       	ldd	r30, Y+3	; 0x03
    5b8e:	fc 81       	ldd	r31, Y+4	; 0x04
    5b90:	80 85       	ldd	r24, Z+8	; 0x08
    5b92:	91 85       	ldd	r25, Z+9	; 0x09
    5b94:	9a 83       	std	Y+2, r25	; 0x02
    5b96:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    5b98:	eb 81       	ldd	r30, Y+3	; 0x03
    5b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    5b9c:	a2 81       	ldd	r26, Z+2	; 0x02
    5b9e:	b3 81       	ldd	r27, Z+3	; 0x03
    5ba0:	eb 81       	ldd	r30, Y+3	; 0x03
    5ba2:	fc 81       	ldd	r31, Y+4	; 0x04
    5ba4:	84 81       	ldd	r24, Z+4	; 0x04
    5ba6:	95 81       	ldd	r25, Z+5	; 0x05
    5ba8:	15 96       	adiw	r26, 0x05	; 5
    5baa:	9c 93       	st	X, r25
    5bac:	8e 93       	st	-X, r24
    5bae:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    5bb0:	eb 81       	ldd	r30, Y+3	; 0x03
    5bb2:	fc 81       	ldd	r31, Y+4	; 0x04
    5bb4:	a4 81       	ldd	r26, Z+4	; 0x04
    5bb6:	b5 81       	ldd	r27, Z+5	; 0x05
    5bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    5bba:	fc 81       	ldd	r31, Y+4	; 0x04
    5bbc:	82 81       	ldd	r24, Z+2	; 0x02
    5bbe:	93 81       	ldd	r25, Z+3	; 0x03
    5bc0:	13 96       	adiw	r26, 0x03	; 3
    5bc2:	9c 93       	st	X, r25
    5bc4:	8e 93       	st	-X, r24
    5bc6:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    5bc8:	e9 81       	ldd	r30, Y+1	; 0x01
    5bca:	fa 81       	ldd	r31, Y+2	; 0x02
    5bcc:	21 81       	ldd	r18, Z+1	; 0x01
    5bce:	32 81       	ldd	r19, Z+2	; 0x02
    5bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    5bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    5bd4:	28 17       	cp	r18, r24
    5bd6:	39 07       	cpc	r19, r25
    5bd8:	41 f4       	brne	.+16     	; 0x5bea <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    5bda:	eb 81       	ldd	r30, Y+3	; 0x03
    5bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    5bde:	84 81       	ldd	r24, Z+4	; 0x04
    5be0:	95 81       	ldd	r25, Z+5	; 0x05
    5be2:	e9 81       	ldd	r30, Y+1	; 0x01
    5be4:	fa 81       	ldd	r31, Y+2	; 0x02
    5be6:	92 83       	std	Z+2, r25	; 0x02
    5be8:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    5bea:	eb 81       	ldd	r30, Y+3	; 0x03
    5bec:	fc 81       	ldd	r31, Y+4	; 0x04
    5bee:	11 86       	std	Z+9, r1	; 0x09
    5bf0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    5bf2:	e9 81       	ldd	r30, Y+1	; 0x01
    5bf4:	fa 81       	ldd	r31, Y+2	; 0x02
    5bf6:	80 81       	ld	r24, Z
    5bf8:	81 50       	subi	r24, 0x01	; 1
    5bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    5bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    5bfe:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    5c00:	e9 81       	ldd	r30, Y+1	; 0x01
    5c02:	fa 81       	ldd	r31, Y+2	; 0x02
    5c04:	80 81       	ld	r24, Z
}
    5c06:	0f 90       	pop	r0
    5c08:	0f 90       	pop	r0
    5c0a:	0f 90       	pop	r0
    5c0c:	0f 90       	pop	r0
    5c0e:	cf 91       	pop	r28
    5c10:	df 91       	pop	r29
    5c12:	08 95       	ret

00005c14 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    5c14:	df 93       	push	r29
    5c16:	cf 93       	push	r28
    5c18:	cd b7       	in	r28, 0x3d	; 61
    5c1a:	de b7       	in	r29, 0x3e	; 62
    5c1c:	28 97       	sbiw	r28, 0x08	; 8
    5c1e:	0f b6       	in	r0, 0x3f	; 63
    5c20:	f8 94       	cli
    5c22:	de bf       	out	0x3e, r29	; 62
    5c24:	0f be       	out	0x3f, r0	; 63
    5c26:	cd bf       	out	0x3d, r28	; 61
    5c28:	9c 83       	std	Y+4, r25	; 0x04
    5c2a:	8b 83       	std	Y+3, r24	; 0x03
    5c2c:	7e 83       	std	Y+6, r23	; 0x06
    5c2e:	6d 83       	std	Y+5, r22	; 0x05
    5c30:	58 87       	std	Y+8, r21	; 0x08
    5c32:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    5c34:	eb 81       	ldd	r30, Y+3	; 0x03
    5c36:	fc 81       	ldd	r31, Y+4	; 0x04
    5c38:	81 e1       	ldi	r24, 0x11	; 17
    5c3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    5c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    5c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    5c40:	01 97       	sbiw	r24, 0x01	; 1
    5c42:	9c 83       	std	Y+4, r25	; 0x04
    5c44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    5c46:	eb 81       	ldd	r30, Y+3	; 0x03
    5c48:	fc 81       	ldd	r31, Y+4	; 0x04
    5c4a:	82 e2       	ldi	r24, 0x22	; 34
    5c4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    5c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    5c50:	9c 81       	ldd	r25, Y+4	; 0x04
    5c52:	01 97       	sbiw	r24, 0x01	; 1
    5c54:	9c 83       	std	Y+4, r25	; 0x04
    5c56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    5c58:	eb 81       	ldd	r30, Y+3	; 0x03
    5c5a:	fc 81       	ldd	r31, Y+4	; 0x04
    5c5c:	83 e3       	ldi	r24, 0x33	; 51
    5c5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5c60:	8b 81       	ldd	r24, Y+3	; 0x03
    5c62:	9c 81       	ldd	r25, Y+4	; 0x04
    5c64:	01 97       	sbiw	r24, 0x01	; 1
    5c66:	9c 83       	std	Y+4, r25	; 0x04
    5c68:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    5c6a:	8d 81       	ldd	r24, Y+5	; 0x05
    5c6c:	9e 81       	ldd	r25, Y+6	; 0x06
    5c6e:	9a 83       	std	Y+2, r25	; 0x02
    5c70:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    5c72:	89 81       	ldd	r24, Y+1	; 0x01
    5c74:	eb 81       	ldd	r30, Y+3	; 0x03
    5c76:	fc 81       	ldd	r31, Y+4	; 0x04
    5c78:	80 83       	st	Z, r24
	pxTopOfStack--;
    5c7a:	8b 81       	ldd	r24, Y+3	; 0x03
    5c7c:	9c 81       	ldd	r25, Y+4	; 0x04
    5c7e:	01 97       	sbiw	r24, 0x01	; 1
    5c80:	9c 83       	std	Y+4, r25	; 0x04
    5c82:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    5c84:	89 81       	ldd	r24, Y+1	; 0x01
    5c86:	9a 81       	ldd	r25, Y+2	; 0x02
    5c88:	89 2f       	mov	r24, r25
    5c8a:	99 27       	eor	r25, r25
    5c8c:	9a 83       	std	Y+2, r25	; 0x02
    5c8e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    5c90:	89 81       	ldd	r24, Y+1	; 0x01
    5c92:	eb 81       	ldd	r30, Y+3	; 0x03
    5c94:	fc 81       	ldd	r31, Y+4	; 0x04
    5c96:	80 83       	st	Z, r24
	pxTopOfStack--;
    5c98:	8b 81       	ldd	r24, Y+3	; 0x03
    5c9a:	9c 81       	ldd	r25, Y+4	; 0x04
    5c9c:	01 97       	sbiw	r24, 0x01	; 1
    5c9e:	9c 83       	std	Y+4, r25	; 0x04
    5ca0:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    5ca2:	eb 81       	ldd	r30, Y+3	; 0x03
    5ca4:	fc 81       	ldd	r31, Y+4	; 0x04
    5ca6:	10 82       	st	Z, r1
	pxTopOfStack--;
    5ca8:	8b 81       	ldd	r24, Y+3	; 0x03
    5caa:	9c 81       	ldd	r25, Y+4	; 0x04
    5cac:	01 97       	sbiw	r24, 0x01	; 1
    5cae:	9c 83       	std	Y+4, r25	; 0x04
    5cb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    5cb2:	eb 81       	ldd	r30, Y+3	; 0x03
    5cb4:	fc 81       	ldd	r31, Y+4	; 0x04
    5cb6:	80 e8       	ldi	r24, 0x80	; 128
    5cb8:	80 83       	st	Z, r24
	pxTopOfStack--;
    5cba:	8b 81       	ldd	r24, Y+3	; 0x03
    5cbc:	9c 81       	ldd	r25, Y+4	; 0x04
    5cbe:	01 97       	sbiw	r24, 0x01	; 1
    5cc0:	9c 83       	std	Y+4, r25	; 0x04
    5cc2:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    5cc4:	eb 81       	ldd	r30, Y+3	; 0x03
    5cc6:	fc 81       	ldd	r31, Y+4	; 0x04
    5cc8:	10 82       	st	Z, r1
	pxTopOfStack--;
    5cca:	8b 81       	ldd	r24, Y+3	; 0x03
    5ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    5cce:	01 97       	sbiw	r24, 0x01	; 1
    5cd0:	9c 83       	std	Y+4, r25	; 0x04
    5cd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    5cd4:	eb 81       	ldd	r30, Y+3	; 0x03
    5cd6:	fc 81       	ldd	r31, Y+4	; 0x04
    5cd8:	82 e0       	ldi	r24, 0x02	; 2
    5cda:	80 83       	st	Z, r24
	pxTopOfStack--;
    5cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    5cde:	9c 81       	ldd	r25, Y+4	; 0x04
    5ce0:	01 97       	sbiw	r24, 0x01	; 1
    5ce2:	9c 83       	std	Y+4, r25	; 0x04
    5ce4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    5ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    5ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    5cea:	83 e0       	ldi	r24, 0x03	; 3
    5cec:	80 83       	st	Z, r24
	pxTopOfStack--;
    5cee:	8b 81       	ldd	r24, Y+3	; 0x03
    5cf0:	9c 81       	ldd	r25, Y+4	; 0x04
    5cf2:	01 97       	sbiw	r24, 0x01	; 1
    5cf4:	9c 83       	std	Y+4, r25	; 0x04
    5cf6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    5cf8:	eb 81       	ldd	r30, Y+3	; 0x03
    5cfa:	fc 81       	ldd	r31, Y+4	; 0x04
    5cfc:	84 e0       	ldi	r24, 0x04	; 4
    5cfe:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d00:	8b 81       	ldd	r24, Y+3	; 0x03
    5d02:	9c 81       	ldd	r25, Y+4	; 0x04
    5d04:	01 97       	sbiw	r24, 0x01	; 1
    5d06:	9c 83       	std	Y+4, r25	; 0x04
    5d08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    5d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    5d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    5d0e:	85 e0       	ldi	r24, 0x05	; 5
    5d10:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d12:	8b 81       	ldd	r24, Y+3	; 0x03
    5d14:	9c 81       	ldd	r25, Y+4	; 0x04
    5d16:	01 97       	sbiw	r24, 0x01	; 1
    5d18:	9c 83       	std	Y+4, r25	; 0x04
    5d1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    5d1c:	eb 81       	ldd	r30, Y+3	; 0x03
    5d1e:	fc 81       	ldd	r31, Y+4	; 0x04
    5d20:	86 e0       	ldi	r24, 0x06	; 6
    5d22:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d24:	8b 81       	ldd	r24, Y+3	; 0x03
    5d26:	9c 81       	ldd	r25, Y+4	; 0x04
    5d28:	01 97       	sbiw	r24, 0x01	; 1
    5d2a:	9c 83       	std	Y+4, r25	; 0x04
    5d2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    5d2e:	eb 81       	ldd	r30, Y+3	; 0x03
    5d30:	fc 81       	ldd	r31, Y+4	; 0x04
    5d32:	87 e0       	ldi	r24, 0x07	; 7
    5d34:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d36:	8b 81       	ldd	r24, Y+3	; 0x03
    5d38:	9c 81       	ldd	r25, Y+4	; 0x04
    5d3a:	01 97       	sbiw	r24, 0x01	; 1
    5d3c:	9c 83       	std	Y+4, r25	; 0x04
    5d3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    5d40:	eb 81       	ldd	r30, Y+3	; 0x03
    5d42:	fc 81       	ldd	r31, Y+4	; 0x04
    5d44:	88 e0       	ldi	r24, 0x08	; 8
    5d46:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d48:	8b 81       	ldd	r24, Y+3	; 0x03
    5d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    5d4c:	01 97       	sbiw	r24, 0x01	; 1
    5d4e:	9c 83       	std	Y+4, r25	; 0x04
    5d50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    5d52:	eb 81       	ldd	r30, Y+3	; 0x03
    5d54:	fc 81       	ldd	r31, Y+4	; 0x04
    5d56:	89 e0       	ldi	r24, 0x09	; 9
    5d58:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d5a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d5c:	9c 81       	ldd	r25, Y+4	; 0x04
    5d5e:	01 97       	sbiw	r24, 0x01	; 1
    5d60:	9c 83       	std	Y+4, r25	; 0x04
    5d62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    5d64:	eb 81       	ldd	r30, Y+3	; 0x03
    5d66:	fc 81       	ldd	r31, Y+4	; 0x04
    5d68:	80 e1       	ldi	r24, 0x10	; 16
    5d6a:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    5d6e:	9c 81       	ldd	r25, Y+4	; 0x04
    5d70:	01 97       	sbiw	r24, 0x01	; 1
    5d72:	9c 83       	std	Y+4, r25	; 0x04
    5d74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    5d76:	eb 81       	ldd	r30, Y+3	; 0x03
    5d78:	fc 81       	ldd	r31, Y+4	; 0x04
    5d7a:	81 e1       	ldi	r24, 0x11	; 17
    5d7c:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    5d80:	9c 81       	ldd	r25, Y+4	; 0x04
    5d82:	01 97       	sbiw	r24, 0x01	; 1
    5d84:	9c 83       	std	Y+4, r25	; 0x04
    5d86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    5d88:	eb 81       	ldd	r30, Y+3	; 0x03
    5d8a:	fc 81       	ldd	r31, Y+4	; 0x04
    5d8c:	82 e1       	ldi	r24, 0x12	; 18
    5d8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5d90:	8b 81       	ldd	r24, Y+3	; 0x03
    5d92:	9c 81       	ldd	r25, Y+4	; 0x04
    5d94:	01 97       	sbiw	r24, 0x01	; 1
    5d96:	9c 83       	std	Y+4, r25	; 0x04
    5d98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    5d9a:	eb 81       	ldd	r30, Y+3	; 0x03
    5d9c:	fc 81       	ldd	r31, Y+4	; 0x04
    5d9e:	83 e1       	ldi	r24, 0x13	; 19
    5da0:	80 83       	st	Z, r24
	pxTopOfStack--;
    5da2:	8b 81       	ldd	r24, Y+3	; 0x03
    5da4:	9c 81       	ldd	r25, Y+4	; 0x04
    5da6:	01 97       	sbiw	r24, 0x01	; 1
    5da8:	9c 83       	std	Y+4, r25	; 0x04
    5daa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    5dac:	eb 81       	ldd	r30, Y+3	; 0x03
    5dae:	fc 81       	ldd	r31, Y+4	; 0x04
    5db0:	84 e1       	ldi	r24, 0x14	; 20
    5db2:	80 83       	st	Z, r24
	pxTopOfStack--;
    5db4:	8b 81       	ldd	r24, Y+3	; 0x03
    5db6:	9c 81       	ldd	r25, Y+4	; 0x04
    5db8:	01 97       	sbiw	r24, 0x01	; 1
    5dba:	9c 83       	std	Y+4, r25	; 0x04
    5dbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    5dbe:	eb 81       	ldd	r30, Y+3	; 0x03
    5dc0:	fc 81       	ldd	r31, Y+4	; 0x04
    5dc2:	85 e1       	ldi	r24, 0x15	; 21
    5dc4:	80 83       	st	Z, r24
	pxTopOfStack--;
    5dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    5dc8:	9c 81       	ldd	r25, Y+4	; 0x04
    5dca:	01 97       	sbiw	r24, 0x01	; 1
    5dcc:	9c 83       	std	Y+4, r25	; 0x04
    5dce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    5dd0:	eb 81       	ldd	r30, Y+3	; 0x03
    5dd2:	fc 81       	ldd	r31, Y+4	; 0x04
    5dd4:	86 e1       	ldi	r24, 0x16	; 22
    5dd6:	80 83       	st	Z, r24
	pxTopOfStack--;
    5dd8:	8b 81       	ldd	r24, Y+3	; 0x03
    5dda:	9c 81       	ldd	r25, Y+4	; 0x04
    5ddc:	01 97       	sbiw	r24, 0x01	; 1
    5dde:	9c 83       	std	Y+4, r25	; 0x04
    5de0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    5de2:	eb 81       	ldd	r30, Y+3	; 0x03
    5de4:	fc 81       	ldd	r31, Y+4	; 0x04
    5de6:	87 e1       	ldi	r24, 0x17	; 23
    5de8:	80 83       	st	Z, r24
	pxTopOfStack--;
    5dea:	8b 81       	ldd	r24, Y+3	; 0x03
    5dec:	9c 81       	ldd	r25, Y+4	; 0x04
    5dee:	01 97       	sbiw	r24, 0x01	; 1
    5df0:	9c 83       	std	Y+4, r25	; 0x04
    5df2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    5df4:	eb 81       	ldd	r30, Y+3	; 0x03
    5df6:	fc 81       	ldd	r31, Y+4	; 0x04
    5df8:	88 e1       	ldi	r24, 0x18	; 24
    5dfa:	80 83       	st	Z, r24
	pxTopOfStack--;
    5dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    5dfe:	9c 81       	ldd	r25, Y+4	; 0x04
    5e00:	01 97       	sbiw	r24, 0x01	; 1
    5e02:	9c 83       	std	Y+4, r25	; 0x04
    5e04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    5e06:	eb 81       	ldd	r30, Y+3	; 0x03
    5e08:	fc 81       	ldd	r31, Y+4	; 0x04
    5e0a:	89 e1       	ldi	r24, 0x19	; 25
    5e0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    5e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    5e10:	9c 81       	ldd	r25, Y+4	; 0x04
    5e12:	01 97       	sbiw	r24, 0x01	; 1
    5e14:	9c 83       	std	Y+4, r25	; 0x04
    5e16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    5e18:	eb 81       	ldd	r30, Y+3	; 0x03
    5e1a:	fc 81       	ldd	r31, Y+4	; 0x04
    5e1c:	80 e2       	ldi	r24, 0x20	; 32
    5e1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5e20:	8b 81       	ldd	r24, Y+3	; 0x03
    5e22:	9c 81       	ldd	r25, Y+4	; 0x04
    5e24:	01 97       	sbiw	r24, 0x01	; 1
    5e26:	9c 83       	std	Y+4, r25	; 0x04
    5e28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    5e2a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e2c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e2e:	81 e2       	ldi	r24, 0x21	; 33
    5e30:	80 83       	st	Z, r24
	pxTopOfStack--;
    5e32:	8b 81       	ldd	r24, Y+3	; 0x03
    5e34:	9c 81       	ldd	r25, Y+4	; 0x04
    5e36:	01 97       	sbiw	r24, 0x01	; 1
    5e38:	9c 83       	std	Y+4, r25	; 0x04
    5e3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    5e3c:	eb 81       	ldd	r30, Y+3	; 0x03
    5e3e:	fc 81       	ldd	r31, Y+4	; 0x04
    5e40:	82 e2       	ldi	r24, 0x22	; 34
    5e42:	80 83       	st	Z, r24
	pxTopOfStack--;
    5e44:	8b 81       	ldd	r24, Y+3	; 0x03
    5e46:	9c 81       	ldd	r25, Y+4	; 0x04
    5e48:	01 97       	sbiw	r24, 0x01	; 1
    5e4a:	9c 83       	std	Y+4, r25	; 0x04
    5e4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    5e4e:	eb 81       	ldd	r30, Y+3	; 0x03
    5e50:	fc 81       	ldd	r31, Y+4	; 0x04
    5e52:	83 e2       	ldi	r24, 0x23	; 35
    5e54:	80 83       	st	Z, r24
	pxTopOfStack--;
    5e56:	8b 81       	ldd	r24, Y+3	; 0x03
    5e58:	9c 81       	ldd	r25, Y+4	; 0x04
    5e5a:	01 97       	sbiw	r24, 0x01	; 1
    5e5c:	9c 83       	std	Y+4, r25	; 0x04
    5e5e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    5e60:	8f 81       	ldd	r24, Y+7	; 0x07
    5e62:	98 85       	ldd	r25, Y+8	; 0x08
    5e64:	9a 83       	std	Y+2, r25	; 0x02
    5e66:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    5e68:	89 81       	ldd	r24, Y+1	; 0x01
    5e6a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e6c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e6e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5e70:	8b 81       	ldd	r24, Y+3	; 0x03
    5e72:	9c 81       	ldd	r25, Y+4	; 0x04
    5e74:	01 97       	sbiw	r24, 0x01	; 1
    5e76:	9c 83       	std	Y+4, r25	; 0x04
    5e78:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    5e7a:	89 81       	ldd	r24, Y+1	; 0x01
    5e7c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e7e:	89 2f       	mov	r24, r25
    5e80:	99 27       	eor	r25, r25
    5e82:	9a 83       	std	Y+2, r25	; 0x02
    5e84:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    5e86:	89 81       	ldd	r24, Y+1	; 0x01
    5e88:	eb 81       	ldd	r30, Y+3	; 0x03
    5e8a:	fc 81       	ldd	r31, Y+4	; 0x04
    5e8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    5e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    5e90:	9c 81       	ldd	r25, Y+4	; 0x04
    5e92:	01 97       	sbiw	r24, 0x01	; 1
    5e94:	9c 83       	std	Y+4, r25	; 0x04
    5e96:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    5e98:	eb 81       	ldd	r30, Y+3	; 0x03
    5e9a:	fc 81       	ldd	r31, Y+4	; 0x04
    5e9c:	86 e2       	ldi	r24, 0x26	; 38
    5e9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    5ea4:	01 97       	sbiw	r24, 0x01	; 1
    5ea6:	9c 83       	std	Y+4, r25	; 0x04
    5ea8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    5eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    5eac:	fc 81       	ldd	r31, Y+4	; 0x04
    5eae:	87 e2       	ldi	r24, 0x27	; 39
    5eb0:	80 83       	st	Z, r24
	pxTopOfStack--;
    5eb2:	8b 81       	ldd	r24, Y+3	; 0x03
    5eb4:	9c 81       	ldd	r25, Y+4	; 0x04
    5eb6:	01 97       	sbiw	r24, 0x01	; 1
    5eb8:	9c 83       	std	Y+4, r25	; 0x04
    5eba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    5ebc:	eb 81       	ldd	r30, Y+3	; 0x03
    5ebe:	fc 81       	ldd	r31, Y+4	; 0x04
    5ec0:	88 e2       	ldi	r24, 0x28	; 40
    5ec2:	80 83       	st	Z, r24
	pxTopOfStack--;
    5ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    5ec6:	9c 81       	ldd	r25, Y+4	; 0x04
    5ec8:	01 97       	sbiw	r24, 0x01	; 1
    5eca:	9c 83       	std	Y+4, r25	; 0x04
    5ecc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    5ece:	eb 81       	ldd	r30, Y+3	; 0x03
    5ed0:	fc 81       	ldd	r31, Y+4	; 0x04
    5ed2:	89 e2       	ldi	r24, 0x29	; 41
    5ed4:	80 83       	st	Z, r24
	pxTopOfStack--;
    5ed6:	8b 81       	ldd	r24, Y+3	; 0x03
    5ed8:	9c 81       	ldd	r25, Y+4	; 0x04
    5eda:	01 97       	sbiw	r24, 0x01	; 1
    5edc:	9c 83       	std	Y+4, r25	; 0x04
    5ede:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    5ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    5ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    5ee4:	80 e3       	ldi	r24, 0x30	; 48
    5ee6:	80 83       	st	Z, r24
	pxTopOfStack--;
    5ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    5eea:	9c 81       	ldd	r25, Y+4	; 0x04
    5eec:	01 97       	sbiw	r24, 0x01	; 1
    5eee:	9c 83       	std	Y+4, r25	; 0x04
    5ef0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    5ef2:	eb 81       	ldd	r30, Y+3	; 0x03
    5ef4:	fc 81       	ldd	r31, Y+4	; 0x04
    5ef6:	81 e3       	ldi	r24, 0x31	; 49
    5ef8:	80 83       	st	Z, r24
	pxTopOfStack--;
    5efa:	8b 81       	ldd	r24, Y+3	; 0x03
    5efc:	9c 81       	ldd	r25, Y+4	; 0x04
    5efe:	01 97       	sbiw	r24, 0x01	; 1
    5f00:	9c 83       	std	Y+4, r25	; 0x04
    5f02:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    5f04:	8b 81       	ldd	r24, Y+3	; 0x03
    5f06:	9c 81       	ldd	r25, Y+4	; 0x04
}
    5f08:	28 96       	adiw	r28, 0x08	; 8
    5f0a:	0f b6       	in	r0, 0x3f	; 63
    5f0c:	f8 94       	cli
    5f0e:	de bf       	out	0x3e, r29	; 62
    5f10:	0f be       	out	0x3f, r0	; 63
    5f12:	cd bf       	out	0x3d, r28	; 61
    5f14:	cf 91       	pop	r28
    5f16:	df 91       	pop	r29
    5f18:	08 95       	ret

00005f1a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    5f1a:	df 93       	push	r29
    5f1c:	cf 93       	push	r28
    5f1e:	cd b7       	in	r28, 0x3d	; 61
    5f20:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    5f22:	0e 94 7f 30 	call	0x60fe	; 0x60fe <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    5f26:	a0 91 8c 05 	lds	r26, 0x058C
    5f2a:	b0 91 8d 05 	lds	r27, 0x058D
    5f2e:	cd 91       	ld	r28, X+
    5f30:	cd bf       	out	0x3d, r28	; 61
    5f32:	dd 91       	ld	r29, X+
    5f34:	de bf       	out	0x3e, r29	; 62
    5f36:	ff 91       	pop	r31
    5f38:	ef 91       	pop	r30
    5f3a:	df 91       	pop	r29
    5f3c:	cf 91       	pop	r28
    5f3e:	bf 91       	pop	r27
    5f40:	af 91       	pop	r26
    5f42:	9f 91       	pop	r25
    5f44:	8f 91       	pop	r24
    5f46:	7f 91       	pop	r23
    5f48:	6f 91       	pop	r22
    5f4a:	5f 91       	pop	r21
    5f4c:	4f 91       	pop	r20
    5f4e:	3f 91       	pop	r19
    5f50:	2f 91       	pop	r18
    5f52:	1f 91       	pop	r17
    5f54:	0f 91       	pop	r16
    5f56:	ff 90       	pop	r15
    5f58:	ef 90       	pop	r14
    5f5a:	df 90       	pop	r13
    5f5c:	cf 90       	pop	r12
    5f5e:	bf 90       	pop	r11
    5f60:	af 90       	pop	r10
    5f62:	9f 90       	pop	r9
    5f64:	8f 90       	pop	r8
    5f66:	7f 90       	pop	r7
    5f68:	6f 90       	pop	r6
    5f6a:	5f 90       	pop	r5
    5f6c:	4f 90       	pop	r4
    5f6e:	3f 90       	pop	r3
    5f70:	2f 90       	pop	r2
    5f72:	1f 90       	pop	r1
    5f74:	0f 90       	pop	r0
    5f76:	0f be       	out	0x3f, r0	; 63
    5f78:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    5f7a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    5f7c:	81 e0       	ldi	r24, 0x01	; 1
}
    5f7e:	cf 91       	pop	r28
    5f80:	df 91       	pop	r29
    5f82:	08 95       	ret

00005f84 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    5f84:	df 93       	push	r29
    5f86:	cf 93       	push	r28
    5f88:	cd b7       	in	r28, 0x3d	; 61
    5f8a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    5f8c:	cf 91       	pop	r28
    5f8e:	df 91       	pop	r29
    5f90:	08 95       	ret

00005f92 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    5f92:	0f 92       	push	r0
    5f94:	0f b6       	in	r0, 0x3f	; 63
    5f96:	f8 94       	cli
    5f98:	0f 92       	push	r0
    5f9a:	1f 92       	push	r1
    5f9c:	11 24       	eor	r1, r1
    5f9e:	2f 92       	push	r2
    5fa0:	3f 92       	push	r3
    5fa2:	4f 92       	push	r4
    5fa4:	5f 92       	push	r5
    5fa6:	6f 92       	push	r6
    5fa8:	7f 92       	push	r7
    5faa:	8f 92       	push	r8
    5fac:	9f 92       	push	r9
    5fae:	af 92       	push	r10
    5fb0:	bf 92       	push	r11
    5fb2:	cf 92       	push	r12
    5fb4:	df 92       	push	r13
    5fb6:	ef 92       	push	r14
    5fb8:	ff 92       	push	r15
    5fba:	0f 93       	push	r16
    5fbc:	1f 93       	push	r17
    5fbe:	2f 93       	push	r18
    5fc0:	3f 93       	push	r19
    5fc2:	4f 93       	push	r20
    5fc4:	5f 93       	push	r21
    5fc6:	6f 93       	push	r22
    5fc8:	7f 93       	push	r23
    5fca:	8f 93       	push	r24
    5fcc:	9f 93       	push	r25
    5fce:	af 93       	push	r26
    5fd0:	bf 93       	push	r27
    5fd2:	cf 93       	push	r28
    5fd4:	df 93       	push	r29
    5fd6:	ef 93       	push	r30
    5fd8:	ff 93       	push	r31
    5fda:	a0 91 8c 05 	lds	r26, 0x058C
    5fde:	b0 91 8d 05 	lds	r27, 0x058D
    5fe2:	0d b6       	in	r0, 0x3d	; 61
    5fe4:	0d 92       	st	X+, r0
    5fe6:	0e b6       	in	r0, 0x3e	; 62
    5fe8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    5fea:	0e 94 0c 3e 	call	0x7c18	; 0x7c18 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5fee:	a0 91 8c 05 	lds	r26, 0x058C
    5ff2:	b0 91 8d 05 	lds	r27, 0x058D
    5ff6:	cd 91       	ld	r28, X+
    5ff8:	cd bf       	out	0x3d, r28	; 61
    5ffa:	dd 91       	ld	r29, X+
    5ffc:	de bf       	out	0x3e, r29	; 62
    5ffe:	ff 91       	pop	r31
    6000:	ef 91       	pop	r30
    6002:	df 91       	pop	r29
    6004:	cf 91       	pop	r28
    6006:	bf 91       	pop	r27
    6008:	af 91       	pop	r26
    600a:	9f 91       	pop	r25
    600c:	8f 91       	pop	r24
    600e:	7f 91       	pop	r23
    6010:	6f 91       	pop	r22
    6012:	5f 91       	pop	r21
    6014:	4f 91       	pop	r20
    6016:	3f 91       	pop	r19
    6018:	2f 91       	pop	r18
    601a:	1f 91       	pop	r17
    601c:	0f 91       	pop	r16
    601e:	ff 90       	pop	r15
    6020:	ef 90       	pop	r14
    6022:	df 90       	pop	r13
    6024:	cf 90       	pop	r12
    6026:	bf 90       	pop	r11
    6028:	af 90       	pop	r10
    602a:	9f 90       	pop	r9
    602c:	8f 90       	pop	r8
    602e:	7f 90       	pop	r7
    6030:	6f 90       	pop	r6
    6032:	5f 90       	pop	r5
    6034:	4f 90       	pop	r4
    6036:	3f 90       	pop	r3
    6038:	2f 90       	pop	r2
    603a:	1f 90       	pop	r1
    603c:	0f 90       	pop	r0
    603e:	0f be       	out	0x3f, r0	; 63
    6040:	0f 90       	pop	r0

	asm volatile ( "ret" );
    6042:	08 95       	ret

00006044 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    6044:	0f 92       	push	r0
    6046:	0f b6       	in	r0, 0x3f	; 63
    6048:	f8 94       	cli
    604a:	0f 92       	push	r0
    604c:	1f 92       	push	r1
    604e:	11 24       	eor	r1, r1
    6050:	2f 92       	push	r2
    6052:	3f 92       	push	r3
    6054:	4f 92       	push	r4
    6056:	5f 92       	push	r5
    6058:	6f 92       	push	r6
    605a:	7f 92       	push	r7
    605c:	8f 92       	push	r8
    605e:	9f 92       	push	r9
    6060:	af 92       	push	r10
    6062:	bf 92       	push	r11
    6064:	cf 92       	push	r12
    6066:	df 92       	push	r13
    6068:	ef 92       	push	r14
    606a:	ff 92       	push	r15
    606c:	0f 93       	push	r16
    606e:	1f 93       	push	r17
    6070:	2f 93       	push	r18
    6072:	3f 93       	push	r19
    6074:	4f 93       	push	r20
    6076:	5f 93       	push	r21
    6078:	6f 93       	push	r22
    607a:	7f 93       	push	r23
    607c:	8f 93       	push	r24
    607e:	9f 93       	push	r25
    6080:	af 93       	push	r26
    6082:	bf 93       	push	r27
    6084:	cf 93       	push	r28
    6086:	df 93       	push	r29
    6088:	ef 93       	push	r30
    608a:	ff 93       	push	r31
    608c:	a0 91 8c 05 	lds	r26, 0x058C
    6090:	b0 91 8d 05 	lds	r27, 0x058D
    6094:	0d b6       	in	r0, 0x3d	; 61
    6096:	0d 92       	st	X+, r0
    6098:	0e b6       	in	r0, 0x3e	; 62
    609a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    609c:	0e 94 40 3d 	call	0x7a80	; 0x7a80 <xTaskIncrementTick>
    60a0:	88 23       	and	r24, r24
    60a2:	11 f0       	breq	.+4      	; 0x60a8 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    60a4:	0e 94 0c 3e 	call	0x7c18	; 0x7c18 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    60a8:	a0 91 8c 05 	lds	r26, 0x058C
    60ac:	b0 91 8d 05 	lds	r27, 0x058D
    60b0:	cd 91       	ld	r28, X+
    60b2:	cd bf       	out	0x3d, r28	; 61
    60b4:	dd 91       	ld	r29, X+
    60b6:	de bf       	out	0x3e, r29	; 62
    60b8:	ff 91       	pop	r31
    60ba:	ef 91       	pop	r30
    60bc:	df 91       	pop	r29
    60be:	cf 91       	pop	r28
    60c0:	bf 91       	pop	r27
    60c2:	af 91       	pop	r26
    60c4:	9f 91       	pop	r25
    60c6:	8f 91       	pop	r24
    60c8:	7f 91       	pop	r23
    60ca:	6f 91       	pop	r22
    60cc:	5f 91       	pop	r21
    60ce:	4f 91       	pop	r20
    60d0:	3f 91       	pop	r19
    60d2:	2f 91       	pop	r18
    60d4:	1f 91       	pop	r17
    60d6:	0f 91       	pop	r16
    60d8:	ff 90       	pop	r15
    60da:	ef 90       	pop	r14
    60dc:	df 90       	pop	r13
    60de:	cf 90       	pop	r12
    60e0:	bf 90       	pop	r11
    60e2:	af 90       	pop	r10
    60e4:	9f 90       	pop	r9
    60e6:	8f 90       	pop	r8
    60e8:	7f 90       	pop	r7
    60ea:	6f 90       	pop	r6
    60ec:	5f 90       	pop	r5
    60ee:	4f 90       	pop	r4
    60f0:	3f 90       	pop	r3
    60f2:	2f 90       	pop	r2
    60f4:	1f 90       	pop	r1
    60f6:	0f 90       	pop	r0
    60f8:	0f be       	out	0x3f, r0	; 63
    60fa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    60fc:	08 95       	ret

000060fe <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    60fe:	df 93       	push	r29
    6100:	cf 93       	push	r28
    6102:	00 d0       	rcall	.+0      	; 0x6104 <prvSetupTimerInterrupt+0x6>
    6104:	00 d0       	rcall	.+0      	; 0x6106 <prvSetupTimerInterrupt+0x8>
    6106:	00 d0       	rcall	.+0      	; 0x6108 <prvSetupTimerInterrupt+0xa>
    6108:	cd b7       	in	r28, 0x3d	; 61
    610a:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    610c:	80 e8       	ldi	r24, 0x80	; 128
    610e:	9e e3       	ldi	r25, 0x3E	; 62
    6110:	a0 e0       	ldi	r26, 0x00	; 0
    6112:	b0 e0       	ldi	r27, 0x00	; 0
    6114:	8b 83       	std	Y+3, r24	; 0x03
    6116:	9c 83       	std	Y+4, r25	; 0x04
    6118:	ad 83       	std	Y+5, r26	; 0x05
    611a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    611c:	8b 81       	ldd	r24, Y+3	; 0x03
    611e:	9c 81       	ldd	r25, Y+4	; 0x04
    6120:	ad 81       	ldd	r26, Y+5	; 0x05
    6122:	be 81       	ldd	r27, Y+6	; 0x06
    6124:	68 94       	set
    6126:	15 f8       	bld	r1, 5
    6128:	b6 95       	lsr	r27
    612a:	a7 95       	ror	r26
    612c:	97 95       	ror	r25
    612e:	87 95       	ror	r24
    6130:	16 94       	lsr	r1
    6132:	d1 f7       	brne	.-12     	; 0x6128 <prvSetupTimerInterrupt+0x2a>
    6134:	8b 83       	std	Y+3, r24	; 0x03
    6136:	9c 83       	std	Y+4, r25	; 0x04
    6138:	ad 83       	std	Y+5, r26	; 0x05
    613a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    613c:	8b 81       	ldd	r24, Y+3	; 0x03
    613e:	9c 81       	ldd	r25, Y+4	; 0x04
    6140:	ad 81       	ldd	r26, Y+5	; 0x05
    6142:	be 81       	ldd	r27, Y+6	; 0x06
    6144:	01 97       	sbiw	r24, 0x01	; 1
    6146:	a1 09       	sbc	r26, r1
    6148:	b1 09       	sbc	r27, r1
    614a:	8b 83       	std	Y+3, r24	; 0x03
    614c:	9c 83       	std	Y+4, r25	; 0x04
    614e:	ad 83       	std	Y+5, r26	; 0x05
    6150:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    6152:	8b 81       	ldd	r24, Y+3	; 0x03
    6154:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    6156:	8b 81       	ldd	r24, Y+3	; 0x03
    6158:	9c 81       	ldd	r25, Y+4	; 0x04
    615a:	ad 81       	ldd	r26, Y+5	; 0x05
    615c:	be 81       	ldd	r27, Y+6	; 0x06
    615e:	89 2f       	mov	r24, r25
    6160:	9a 2f       	mov	r25, r26
    6162:	ab 2f       	mov	r26, r27
    6164:	bb 27       	eor	r27, r27
    6166:	8b 83       	std	Y+3, r24	; 0x03
    6168:	9c 83       	std	Y+4, r25	; 0x04
    616a:	ad 83       	std	Y+5, r26	; 0x05
    616c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    616e:	8b 81       	ldd	r24, Y+3	; 0x03
    6170:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    6172:	eb e4       	ldi	r30, 0x4B	; 75
    6174:	f0 e0       	ldi	r31, 0x00	; 0
    6176:	8a 81       	ldd	r24, Y+2	; 0x02
    6178:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    617a:	ea e4       	ldi	r30, 0x4A	; 74
    617c:	f0 e0       	ldi	r31, 0x00	; 0
    617e:	89 81       	ldd	r24, Y+1	; 0x01
    6180:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    6182:	8b e0       	ldi	r24, 0x0B	; 11
    6184:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    6186:	ee e4       	ldi	r30, 0x4E	; 78
    6188:	f0 e0       	ldi	r31, 0x00	; 0
    618a:	89 81       	ldd	r24, Y+1	; 0x01
    618c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    618e:	e9 e5       	ldi	r30, 0x59	; 89
    6190:	f0 e0       	ldi	r31, 0x00	; 0
    6192:	80 81       	ld	r24, Z
    6194:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    6196:	89 81       	ldd	r24, Y+1	; 0x01
    6198:	80 61       	ori	r24, 0x10	; 16
    619a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    619c:	e9 e5       	ldi	r30, 0x59	; 89
    619e:	f0 e0       	ldi	r31, 0x00	; 0
    61a0:	89 81       	ldd	r24, Y+1	; 0x01
    61a2:	80 83       	st	Z, r24
}
    61a4:	26 96       	adiw	r28, 0x06	; 6
    61a6:	0f b6       	in	r0, 0x3f	; 63
    61a8:	f8 94       	cli
    61aa:	de bf       	out	0x3e, r29	; 62
    61ac:	0f be       	out	0x3f, r0	; 63
    61ae:	cd bf       	out	0x3d, r28	; 61
    61b0:	cf 91       	pop	r28
    61b2:	df 91       	pop	r29
    61b4:	08 95       	ret

000061b6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    61b6:	0e 94 22 30 	call	0x6044	; 0x6044 <vPortYieldFromTick>
		asm volatile ( "reti" );
    61ba:	18 95       	reti

000061bc <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    61bc:	df 93       	push	r29
    61be:	cf 93       	push	r28
    61c0:	00 d0       	rcall	.+0      	; 0x61c2 <xQueueGenericReset+0x6>
    61c2:	00 d0       	rcall	.+0      	; 0x61c4 <xQueueGenericReset+0x8>
    61c4:	0f 92       	push	r0
    61c6:	cd b7       	in	r28, 0x3d	; 61
    61c8:	de b7       	in	r29, 0x3e	; 62
    61ca:	9c 83       	std	Y+4, r25	; 0x04
    61cc:	8b 83       	std	Y+3, r24	; 0x03
    61ce:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    61d0:	8b 81       	ldd	r24, Y+3	; 0x03
    61d2:	9c 81       	ldd	r25, Y+4	; 0x04
    61d4:	9a 83       	std	Y+2, r25	; 0x02
    61d6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    61d8:	0f b6       	in	r0, 0x3f	; 63
    61da:	f8 94       	cli
    61dc:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    61de:	e9 81       	ldd	r30, Y+1	; 0x01
    61e0:	fa 81       	ldd	r31, Y+2	; 0x02
    61e2:	40 81       	ld	r20, Z
    61e4:	51 81       	ldd	r21, Z+1	; 0x01
    61e6:	e9 81       	ldd	r30, Y+1	; 0x01
    61e8:	fa 81       	ldd	r31, Y+2	; 0x02
    61ea:	83 8d       	ldd	r24, Z+27	; 0x1b
    61ec:	28 2f       	mov	r18, r24
    61ee:	30 e0       	ldi	r19, 0x00	; 0
    61f0:	e9 81       	ldd	r30, Y+1	; 0x01
    61f2:	fa 81       	ldd	r31, Y+2	; 0x02
    61f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    61f6:	88 2f       	mov	r24, r24
    61f8:	90 e0       	ldi	r25, 0x00	; 0
    61fa:	bc 01       	movw	r22, r24
    61fc:	26 9f       	mul	r18, r22
    61fe:	c0 01       	movw	r24, r0
    6200:	27 9f       	mul	r18, r23
    6202:	90 0d       	add	r25, r0
    6204:	36 9f       	mul	r19, r22
    6206:	90 0d       	add	r25, r0
    6208:	11 24       	eor	r1, r1
    620a:	84 0f       	add	r24, r20
    620c:	95 1f       	adc	r25, r21
    620e:	e9 81       	ldd	r30, Y+1	; 0x01
    6210:	fa 81       	ldd	r31, Y+2	; 0x02
    6212:	93 83       	std	Z+3, r25	; 0x03
    6214:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    6216:	e9 81       	ldd	r30, Y+1	; 0x01
    6218:	fa 81       	ldd	r31, Y+2	; 0x02
    621a:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    621c:	e9 81       	ldd	r30, Y+1	; 0x01
    621e:	fa 81       	ldd	r31, Y+2	; 0x02
    6220:	80 81       	ld	r24, Z
    6222:	91 81       	ldd	r25, Z+1	; 0x01
    6224:	e9 81       	ldd	r30, Y+1	; 0x01
    6226:	fa 81       	ldd	r31, Y+2	; 0x02
    6228:	95 83       	std	Z+5, r25	; 0x05
    622a:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    622c:	e9 81       	ldd	r30, Y+1	; 0x01
    622e:	fa 81       	ldd	r31, Y+2	; 0x02
    6230:	40 81       	ld	r20, Z
    6232:	51 81       	ldd	r21, Z+1	; 0x01
    6234:	e9 81       	ldd	r30, Y+1	; 0x01
    6236:	fa 81       	ldd	r31, Y+2	; 0x02
    6238:	83 8d       	ldd	r24, Z+27	; 0x1b
    623a:	88 2f       	mov	r24, r24
    623c:	90 e0       	ldi	r25, 0x00	; 0
    623e:	9c 01       	movw	r18, r24
    6240:	21 50       	subi	r18, 0x01	; 1
    6242:	30 40       	sbci	r19, 0x00	; 0
    6244:	e9 81       	ldd	r30, Y+1	; 0x01
    6246:	fa 81       	ldd	r31, Y+2	; 0x02
    6248:	84 8d       	ldd	r24, Z+28	; 0x1c
    624a:	88 2f       	mov	r24, r24
    624c:	90 e0       	ldi	r25, 0x00	; 0
    624e:	bc 01       	movw	r22, r24
    6250:	26 9f       	mul	r18, r22
    6252:	c0 01       	movw	r24, r0
    6254:	27 9f       	mul	r18, r23
    6256:	90 0d       	add	r25, r0
    6258:	36 9f       	mul	r19, r22
    625a:	90 0d       	add	r25, r0
    625c:	11 24       	eor	r1, r1
    625e:	84 0f       	add	r24, r20
    6260:	95 1f       	adc	r25, r21
    6262:	e9 81       	ldd	r30, Y+1	; 0x01
    6264:	fa 81       	ldd	r31, Y+2	; 0x02
    6266:	97 83       	std	Z+7, r25	; 0x07
    6268:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    626a:	e9 81       	ldd	r30, Y+1	; 0x01
    626c:	fa 81       	ldd	r31, Y+2	; 0x02
    626e:	8f ef       	ldi	r24, 0xFF	; 255
    6270:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    6272:	e9 81       	ldd	r30, Y+1	; 0x01
    6274:	fa 81       	ldd	r31, Y+2	; 0x02
    6276:	8f ef       	ldi	r24, 0xFF	; 255
    6278:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    627a:	8d 81       	ldd	r24, Y+5	; 0x05
    627c:	88 23       	and	r24, r24
    627e:	79 f4       	brne	.+30     	; 0x629e <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    6280:	e9 81       	ldd	r30, Y+1	; 0x01
    6282:	fa 81       	ldd	r31, Y+2	; 0x02
    6284:	80 85       	ldd	r24, Z+8	; 0x08
    6286:	88 23       	and	r24, r24
    6288:	a1 f0       	breq	.+40     	; 0x62b2 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    628a:	89 81       	ldd	r24, Y+1	; 0x01
    628c:	9a 81       	ldd	r25, Y+2	; 0x02
    628e:	08 96       	adiw	r24, 0x08	; 8
    6290:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    6294:	88 23       	and	r24, r24
    6296:	69 f0       	breq	.+26     	; 0x62b2 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    6298:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
    629c:	0a c0       	rjmp	.+20     	; 0x62b2 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    629e:	89 81       	ldd	r24, Y+1	; 0x01
    62a0:	9a 81       	ldd	r25, Y+2	; 0x02
    62a2:	08 96       	adiw	r24, 0x08	; 8
    62a4:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    62a8:	89 81       	ldd	r24, Y+1	; 0x01
    62aa:	9a 81       	ldd	r25, Y+2	; 0x02
    62ac:	41 96       	adiw	r24, 0x11	; 17
    62ae:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    62b2:	0f 90       	pop	r0
    62b4:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    62b6:	81 e0       	ldi	r24, 0x01	; 1
}
    62b8:	0f 90       	pop	r0
    62ba:	0f 90       	pop	r0
    62bc:	0f 90       	pop	r0
    62be:	0f 90       	pop	r0
    62c0:	0f 90       	pop	r0
    62c2:	cf 91       	pop	r28
    62c4:	df 91       	pop	r29
    62c6:	08 95       	ret

000062c8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    62c8:	0f 93       	push	r16
    62ca:	1f 93       	push	r17
    62cc:	df 93       	push	r29
    62ce:	cf 93       	push	r28
    62d0:	cd b7       	in	r28, 0x3d	; 61
    62d2:	de b7       	in	r29, 0x3e	; 62
    62d4:	29 97       	sbiw	r28, 0x09	; 9
    62d6:	0f b6       	in	r0, 0x3f	; 63
    62d8:	f8 94       	cli
    62da:	de bf       	out	0x3e, r29	; 62
    62dc:	0f be       	out	0x3f, r0	; 63
    62de:	cd bf       	out	0x3d, r28	; 61
    62e0:	8f 83       	std	Y+7, r24	; 0x07
    62e2:	68 87       	std	Y+8, r22	; 0x08
    62e4:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    62e6:	88 85       	ldd	r24, Y+8	; 0x08
    62e8:	88 23       	and	r24, r24
    62ea:	19 f4       	brne	.+6      	; 0x62f2 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    62ec:	1c 82       	std	Y+4, r1	; 0x04
    62ee:	1b 82       	std	Y+3, r1	; 0x03
    62f0:	10 c0       	rjmp	.+32     	; 0x6312 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    62f2:	8f 81       	ldd	r24, Y+7	; 0x07
    62f4:	28 2f       	mov	r18, r24
    62f6:	30 e0       	ldi	r19, 0x00	; 0
    62f8:	88 85       	ldd	r24, Y+8	; 0x08
    62fa:	88 2f       	mov	r24, r24
    62fc:	90 e0       	ldi	r25, 0x00	; 0
    62fe:	ac 01       	movw	r20, r24
    6300:	24 9f       	mul	r18, r20
    6302:	c0 01       	movw	r24, r0
    6304:	25 9f       	mul	r18, r21
    6306:	90 0d       	add	r25, r0
    6308:	34 9f       	mul	r19, r20
    630a:	90 0d       	add	r25, r0
    630c:	11 24       	eor	r1, r1
    630e:	9c 83       	std	Y+4, r25	; 0x04
    6310:	8b 83       	std	Y+3, r24	; 0x03
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    6312:	8b 81       	ldd	r24, Y+3	; 0x03
    6314:	9c 81       	ldd	r25, Y+4	; 0x04
    6316:	4f 96       	adiw	r24, 0x1f	; 31
    6318:	0e 94 38 2b 	call	0x5670	; 0x5670 <pvPortMalloc>
    631c:	9e 83       	std	Y+6, r25	; 0x06
    631e:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    6320:	8d 81       	ldd	r24, Y+5	; 0x05
    6322:	9e 81       	ldd	r25, Y+6	; 0x06
    6324:	00 97       	sbiw	r24, 0x00	; 0
    6326:	81 f0       	breq	.+32     	; 0x6348 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    6328:	8d 81       	ldd	r24, Y+5	; 0x05
    632a:	9e 81       	ldd	r25, Y+6	; 0x06
    632c:	4f 96       	adiw	r24, 0x1f	; 31
    632e:	9a 83       	std	Y+2, r25	; 0x02
    6330:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    6332:	29 81       	ldd	r18, Y+1	; 0x01
    6334:	3a 81       	ldd	r19, Y+2	; 0x02
    6336:	ed 81       	ldd	r30, Y+5	; 0x05
    6338:	fe 81       	ldd	r31, Y+6	; 0x06
    633a:	8f 81       	ldd	r24, Y+7	; 0x07
    633c:	68 85       	ldd	r22, Y+8	; 0x08
    633e:	a9 01       	movw	r20, r18
    6340:	29 85       	ldd	r18, Y+9	; 0x09
    6342:	8f 01       	movw	r16, r30
    6344:	0e 94 b1 31 	call	0x6362	; 0x6362 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
    6348:	8d 81       	ldd	r24, Y+5	; 0x05
    634a:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    634c:	29 96       	adiw	r28, 0x09	; 9
    634e:	0f b6       	in	r0, 0x3f	; 63
    6350:	f8 94       	cli
    6352:	de bf       	out	0x3e, r29	; 62
    6354:	0f be       	out	0x3f, r0	; 63
    6356:	cd bf       	out	0x3d, r28	; 61
    6358:	cf 91       	pop	r28
    635a:	df 91       	pop	r29
    635c:	1f 91       	pop	r17
    635e:	0f 91       	pop	r16
    6360:	08 95       	ret

00006362 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    6362:	0f 93       	push	r16
    6364:	1f 93       	push	r17
    6366:	df 93       	push	r29
    6368:	cf 93       	push	r28
    636a:	cd b7       	in	r28, 0x3d	; 61
    636c:	de b7       	in	r29, 0x3e	; 62
    636e:	27 97       	sbiw	r28, 0x07	; 7
    6370:	0f b6       	in	r0, 0x3f	; 63
    6372:	f8 94       	cli
    6374:	de bf       	out	0x3e, r29	; 62
    6376:	0f be       	out	0x3f, r0	; 63
    6378:	cd bf       	out	0x3d, r28	; 61
    637a:	89 83       	std	Y+1, r24	; 0x01
    637c:	6a 83       	std	Y+2, r22	; 0x02
    637e:	5c 83       	std	Y+4, r21	; 0x04
    6380:	4b 83       	std	Y+3, r20	; 0x03
    6382:	2d 83       	std	Y+5, r18	; 0x05
    6384:	1f 83       	std	Y+7, r17	; 0x07
    6386:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    6388:	8a 81       	ldd	r24, Y+2	; 0x02
    638a:	88 23       	and	r24, r24
    638c:	39 f4       	brne	.+14     	; 0x639c <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    638e:	8e 81       	ldd	r24, Y+6	; 0x06
    6390:	9f 81       	ldd	r25, Y+7	; 0x07
    6392:	ee 81       	ldd	r30, Y+6	; 0x06
    6394:	ff 81       	ldd	r31, Y+7	; 0x07
    6396:	91 83       	std	Z+1, r25	; 0x01
    6398:	80 83       	st	Z, r24
    639a:	06 c0       	rjmp	.+12     	; 0x63a8 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    639c:	8b 81       	ldd	r24, Y+3	; 0x03
    639e:	9c 81       	ldd	r25, Y+4	; 0x04
    63a0:	ee 81       	ldd	r30, Y+6	; 0x06
    63a2:	ff 81       	ldd	r31, Y+7	; 0x07
    63a4:	91 83       	std	Z+1, r25	; 0x01
    63a6:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    63a8:	ee 81       	ldd	r30, Y+6	; 0x06
    63aa:	ff 81       	ldd	r31, Y+7	; 0x07
    63ac:	89 81       	ldd	r24, Y+1	; 0x01
    63ae:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    63b0:	ee 81       	ldd	r30, Y+6	; 0x06
    63b2:	ff 81       	ldd	r31, Y+7	; 0x07
    63b4:	8a 81       	ldd	r24, Y+2	; 0x02
    63b6:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    63b8:	8e 81       	ldd	r24, Y+6	; 0x06
    63ba:	9f 81       	ldd	r25, Y+7	; 0x07
    63bc:	61 e0       	ldi	r22, 0x01	; 1
    63be:	0e 94 de 30 	call	0x61bc	; 0x61bc <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    63c2:	27 96       	adiw	r28, 0x07	; 7
    63c4:	0f b6       	in	r0, 0x3f	; 63
    63c6:	f8 94       	cli
    63c8:	de bf       	out	0x3e, r29	; 62
    63ca:	0f be       	out	0x3f, r0	; 63
    63cc:	cd bf       	out	0x3d, r28	; 61
    63ce:	cf 91       	pop	r28
    63d0:	df 91       	pop	r29
    63d2:	1f 91       	pop	r17
    63d4:	0f 91       	pop	r16
    63d6:	08 95       	ret

000063d8 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    63d8:	df 93       	push	r29
    63da:	cf 93       	push	r28
    63dc:	00 d0       	rcall	.+0      	; 0x63de <prvInitialiseMutex+0x6>
    63de:	cd b7       	in	r28, 0x3d	; 61
    63e0:	de b7       	in	r29, 0x3e	; 62
    63e2:	9a 83       	std	Y+2, r25	; 0x02
    63e4:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    63e6:	89 81       	ldd	r24, Y+1	; 0x01
    63e8:	9a 81       	ldd	r25, Y+2	; 0x02
    63ea:	00 97       	sbiw	r24, 0x00	; 0
    63ec:	a1 f0       	breq	.+40     	; 0x6416 <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    63ee:	e9 81       	ldd	r30, Y+1	; 0x01
    63f0:	fa 81       	ldd	r31, Y+2	; 0x02
    63f2:	13 82       	std	Z+3, r1	; 0x03
    63f4:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    63f6:	e9 81       	ldd	r30, Y+1	; 0x01
    63f8:	fa 81       	ldd	r31, Y+2	; 0x02
    63fa:	11 82       	std	Z+1, r1	; 0x01
    63fc:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    63fe:	e9 81       	ldd	r30, Y+1	; 0x01
    6400:	fa 81       	ldd	r31, Y+2	; 0x02
    6402:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    6404:	89 81       	ldd	r24, Y+1	; 0x01
    6406:	9a 81       	ldd	r25, Y+2	; 0x02
    6408:	60 e0       	ldi	r22, 0x00	; 0
    640a:	70 e0       	ldi	r23, 0x00	; 0
    640c:	40 e0       	ldi	r20, 0x00	; 0
    640e:	50 e0       	ldi	r21, 0x00	; 0
    6410:	20 e0       	ldi	r18, 0x00	; 0
    6412:	0e 94 30 32 	call	0x6460	; 0x6460 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    6416:	0f 90       	pop	r0
    6418:	0f 90       	pop	r0
    641a:	cf 91       	pop	r28
    641c:	df 91       	pop	r29
    641e:	08 95       	ret

00006420 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    6420:	df 93       	push	r29
    6422:	cf 93       	push	r28
    6424:	00 d0       	rcall	.+0      	; 0x6426 <xQueueCreateMutex+0x6>
    6426:	00 d0       	rcall	.+0      	; 0x6428 <xQueueCreateMutex+0x8>
    6428:	0f 92       	push	r0
    642a:	cd b7       	in	r28, 0x3d	; 61
    642c:	de b7       	in	r29, 0x3e	; 62
    642e:	8d 83       	std	Y+5, r24	; 0x05
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    6430:	81 e0       	ldi	r24, 0x01	; 1
    6432:	8a 83       	std	Y+2, r24	; 0x02
    6434:	19 82       	std	Y+1, r1	; 0x01

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    6436:	8a 81       	ldd	r24, Y+2	; 0x02
    6438:	69 81       	ldd	r22, Y+1	; 0x01
    643a:	4d 81       	ldd	r20, Y+5	; 0x05
    643c:	0e 94 64 31 	call	0x62c8	; 0x62c8 <xQueueGenericCreate>
    6440:	9c 83       	std	Y+4, r25	; 0x04
    6442:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( pxNewQueue );
    6444:	8b 81       	ldd	r24, Y+3	; 0x03
    6446:	9c 81       	ldd	r25, Y+4	; 0x04
    6448:	0e 94 ec 31 	call	0x63d8	; 0x63d8 <prvInitialiseMutex>

		return pxNewQueue;
    644c:	8b 81       	ldd	r24, Y+3	; 0x03
    644e:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    6450:	0f 90       	pop	r0
    6452:	0f 90       	pop	r0
    6454:	0f 90       	pop	r0
    6456:	0f 90       	pop	r0
    6458:	0f 90       	pop	r0
    645a:	cf 91       	pop	r28
    645c:	df 91       	pop	r29
    645e:	08 95       	ret

00006460 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    6460:	df 93       	push	r29
    6462:	cf 93       	push	r28
    6464:	cd b7       	in	r28, 0x3d	; 61
    6466:	de b7       	in	r29, 0x3e	; 62
    6468:	2f 97       	sbiw	r28, 0x0f	; 15
    646a:	0f b6       	in	r0, 0x3f	; 63
    646c:	f8 94       	cli
    646e:	de bf       	out	0x3e, r29	; 62
    6470:	0f be       	out	0x3f, r0	; 63
    6472:	cd bf       	out	0x3d, r28	; 61
    6474:	99 87       	std	Y+9, r25	; 0x09
    6476:	88 87       	std	Y+8, r24	; 0x08
    6478:	7b 87       	std	Y+11, r23	; 0x0b
    647a:	6a 87       	std	Y+10, r22	; 0x0a
    647c:	5d 87       	std	Y+13, r21	; 0x0d
    647e:	4c 87       	std	Y+12, r20	; 0x0c
    6480:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    6482:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    6484:	88 85       	ldd	r24, Y+8	; 0x08
    6486:	99 85       	ldd	r25, Y+9	; 0x09
    6488:	9a 83       	std	Y+2, r25	; 0x02
    648a:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    648c:	0f b6       	in	r0, 0x3f	; 63
    648e:	f8 94       	cli
    6490:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    6492:	e9 81       	ldd	r30, Y+1	; 0x01
    6494:	fa 81       	ldd	r31, Y+2	; 0x02
    6496:	92 8d       	ldd	r25, Z+26	; 0x1a
    6498:	e9 81       	ldd	r30, Y+1	; 0x01
    649a:	fa 81       	ldd	r31, Y+2	; 0x02
    649c:	83 8d       	ldd	r24, Z+27	; 0x1b
    649e:	98 17       	cp	r25, r24
    64a0:	18 f0       	brcs	.+6      	; 0x64a8 <xQueueGenericSend+0x48>
    64a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    64a4:	82 30       	cpi	r24, 0x02	; 2
    64a6:	11 f5       	brne	.+68     	; 0x64ec <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    64a8:	89 81       	ldd	r24, Y+1	; 0x01
    64aa:	9a 81       	ldd	r25, Y+2	; 0x02
    64ac:	2a 85       	ldd	r18, Y+10	; 0x0a
    64ae:	3b 85       	ldd	r19, Y+11	; 0x0b
    64b0:	b9 01       	movw	r22, r18
    64b2:	4e 85       	ldd	r20, Y+14	; 0x0e
    64b4:	0e 94 64 35 	call	0x6ac8	; 0x6ac8 <prvCopyDataToQueue>
    64b8:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    64ba:	e9 81       	ldd	r30, Y+1	; 0x01
    64bc:	fa 81       	ldd	r31, Y+2	; 0x02
    64be:	81 89       	ldd	r24, Z+17	; 0x11
    64c0:	88 23       	and	r24, r24
    64c2:	51 f0       	breq	.+20     	; 0x64d8 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    64c4:	89 81       	ldd	r24, Y+1	; 0x01
    64c6:	9a 81       	ldd	r25, Y+2	; 0x02
    64c8:	41 96       	adiw	r24, 0x11	; 17
    64ca:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    64ce:	88 23       	and	r24, r24
    64d0:	41 f0       	breq	.+16     	; 0x64e2 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    64d2:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
    64d6:	05 c0       	rjmp	.+10     	; 0x64e2 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    64d8:	8b 81       	ldd	r24, Y+3	; 0x03
    64da:	88 23       	and	r24, r24
    64dc:	11 f0       	breq	.+4      	; 0x64e2 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    64de:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    64e2:	0f 90       	pop	r0
    64e4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    64e6:	81 e0       	ldi	r24, 0x01	; 1
    64e8:	8f 87       	std	Y+15, r24	; 0x0f
    64ea:	5c c0       	rjmp	.+184    	; 0x65a4 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    64ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    64ee:	9d 85       	ldd	r25, Y+13	; 0x0d
    64f0:	00 97       	sbiw	r24, 0x00	; 0
    64f2:	21 f4       	brne	.+8      	; 0x64fc <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    64f4:	0f 90       	pop	r0
    64f6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    64f8:	1f 86       	std	Y+15, r1	; 0x0f
    64fa:	54 c0       	rjmp	.+168    	; 0x65a4 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    64fc:	8c 81       	ldd	r24, Y+4	; 0x04
    64fe:	88 23       	and	r24, r24
    6500:	31 f4       	brne	.+12     	; 0x650e <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    6502:	ce 01       	movw	r24, r28
    6504:	05 96       	adiw	r24, 0x05	; 5
    6506:	0e 94 9b 3f 	call	0x7f36	; 0x7f36 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    650a:	81 e0       	ldi	r24, 0x01	; 1
    650c:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    650e:	0f 90       	pop	r0
    6510:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    6512:	0e 94 44 3c 	call	0x7888	; 0x7888 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    6516:	0f b6       	in	r0, 0x3f	; 63
    6518:	f8 94       	cli
    651a:	0f 92       	push	r0
    651c:	e9 81       	ldd	r30, Y+1	; 0x01
    651e:	fa 81       	ldd	r31, Y+2	; 0x02
    6520:	85 8d       	ldd	r24, Z+29	; 0x1d
    6522:	8f 3f       	cpi	r24, 0xFF	; 255
    6524:	19 f4       	brne	.+6      	; 0x652c <xQueueGenericSend+0xcc>
    6526:	e9 81       	ldd	r30, Y+1	; 0x01
    6528:	fa 81       	ldd	r31, Y+2	; 0x02
    652a:	15 8e       	std	Z+29, r1	; 0x1d
    652c:	e9 81       	ldd	r30, Y+1	; 0x01
    652e:	fa 81       	ldd	r31, Y+2	; 0x02
    6530:	86 8d       	ldd	r24, Z+30	; 0x1e
    6532:	8f 3f       	cpi	r24, 0xFF	; 255
    6534:	19 f4       	brne	.+6      	; 0x653c <xQueueGenericSend+0xdc>
    6536:	e9 81       	ldd	r30, Y+1	; 0x01
    6538:	fa 81       	ldd	r31, Y+2	; 0x02
    653a:	16 8e       	std	Z+30, r1	; 0x1e
    653c:	0f 90       	pop	r0
    653e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    6540:	ce 01       	movw	r24, r28
    6542:	05 96       	adiw	r24, 0x05	; 5
    6544:	9e 01       	movw	r18, r28
    6546:	24 5f       	subi	r18, 0xF4	; 244
    6548:	3f 4f       	sbci	r19, 0xFF	; 255
    654a:	b9 01       	movw	r22, r18
    654c:	0e 94 b4 3f 	call	0x7f68	; 0x7f68 <xTaskCheckForTimeOut>
    6550:	88 23       	and	r24, r24
    6552:	09 f5       	brne	.+66     	; 0x6596 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    6554:	89 81       	ldd	r24, Y+1	; 0x01
    6556:	9a 81       	ldd	r25, Y+2	; 0x02
    6558:	0e 94 eb 36 	call	0x6dd6	; 0x6dd6 <prvIsQueueFull>
    655c:	88 23       	and	r24, r24
    655e:	a1 f0       	breq	.+40     	; 0x6588 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    6560:	89 81       	ldd	r24, Y+1	; 0x01
    6562:	9a 81       	ldd	r25, Y+2	; 0x02
    6564:	08 96       	adiw	r24, 0x08	; 8
    6566:	2c 85       	ldd	r18, Y+12	; 0x0c
    6568:	3d 85       	ldd	r19, Y+13	; 0x0d
    656a:	b9 01       	movw	r22, r18
    656c:	0e 94 79 3e 	call	0x7cf2	; 0x7cf2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    6570:	89 81       	ldd	r24, Y+1	; 0x01
    6572:	9a 81       	ldd	r25, Y+2	; 0x02
    6574:	0e 94 63 36 	call	0x6cc6	; 0x6cc6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    6578:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>
    657c:	88 23       	and	r24, r24
    657e:	09 f0       	breq	.+2      	; 0x6582 <xQueueGenericSend+0x122>
    6580:	85 cf       	rjmp	.-246    	; 0x648c <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    6582:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
    6586:	82 cf       	rjmp	.-252    	; 0x648c <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    6588:	89 81       	ldd	r24, Y+1	; 0x01
    658a:	9a 81       	ldd	r25, Y+2	; 0x02
    658c:	0e 94 63 36 	call	0x6cc6	; 0x6cc6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    6590:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>
    6594:	7b cf       	rjmp	.-266    	; 0x648c <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    6596:	89 81       	ldd	r24, Y+1	; 0x01
    6598:	9a 81       	ldd	r25, Y+2	; 0x02
    659a:	0e 94 63 36 	call	0x6cc6	; 0x6cc6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    659e:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    65a2:	1f 86       	std	Y+15, r1	; 0x0f
    65a4:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    65a6:	2f 96       	adiw	r28, 0x0f	; 15
    65a8:	0f b6       	in	r0, 0x3f	; 63
    65aa:	f8 94       	cli
    65ac:	de bf       	out	0x3e, r29	; 62
    65ae:	0f be       	out	0x3f, r0	; 63
    65b0:	cd bf       	out	0x3d, r28	; 61
    65b2:	cf 91       	pop	r28
    65b4:	df 91       	pop	r29
    65b6:	08 95       	ret

000065b8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    65b8:	df 93       	push	r29
    65ba:	cf 93       	push	r28
    65bc:	cd b7       	in	r28, 0x3d	; 61
    65be:	de b7       	in	r29, 0x3e	; 62
    65c0:	2c 97       	sbiw	r28, 0x0c	; 12
    65c2:	0f b6       	in	r0, 0x3f	; 63
    65c4:	f8 94       	cli
    65c6:	de bf       	out	0x3e, r29	; 62
    65c8:	0f be       	out	0x3f, r0	; 63
    65ca:	cd bf       	out	0x3d, r28	; 61
    65cc:	9f 83       	std	Y+7, r25	; 0x07
    65ce:	8e 83       	std	Y+6, r24	; 0x06
    65d0:	79 87       	std	Y+9, r23	; 0x09
    65d2:	68 87       	std	Y+8, r22	; 0x08
    65d4:	5b 87       	std	Y+11, r21	; 0x0b
    65d6:	4a 87       	std	Y+10, r20	; 0x0a
    65d8:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    65da:	8e 81       	ldd	r24, Y+6	; 0x06
    65dc:	9f 81       	ldd	r25, Y+7	; 0x07
    65de:	9b 83       	std	Y+3, r25	; 0x03
    65e0:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    65e2:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    65e4:	ea 81       	ldd	r30, Y+2	; 0x02
    65e6:	fb 81       	ldd	r31, Y+3	; 0x03
    65e8:	92 8d       	ldd	r25, Z+26	; 0x1a
    65ea:	ea 81       	ldd	r30, Y+2	; 0x02
    65ec:	fb 81       	ldd	r31, Y+3	; 0x03
    65ee:	83 8d       	ldd	r24, Z+27	; 0x1b
    65f0:	98 17       	cp	r25, r24
    65f2:	18 f0       	brcs	.+6      	; 0x65fa <xQueueGenericSendFromISR+0x42>
    65f4:	8c 85       	ldd	r24, Y+12	; 0x0c
    65f6:	82 30       	cpi	r24, 0x02	; 2
    65f8:	61 f5       	brne	.+88     	; 0x6652 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    65fa:	ea 81       	ldd	r30, Y+2	; 0x02
    65fc:	fb 81       	ldd	r31, Y+3	; 0x03
    65fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    6600:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    6602:	8a 81       	ldd	r24, Y+2	; 0x02
    6604:	9b 81       	ldd	r25, Y+3	; 0x03
    6606:	28 85       	ldd	r18, Y+8	; 0x08
    6608:	39 85       	ldd	r19, Y+9	; 0x09
    660a:	b9 01       	movw	r22, r18
    660c:	4c 85       	ldd	r20, Y+12	; 0x0c
    660e:	0e 94 64 35 	call	0x6ac8	; 0x6ac8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    6612:	89 81       	ldd	r24, Y+1	; 0x01
    6614:	8f 3f       	cpi	r24, 0xFF	; 255
    6616:	a9 f4       	brne	.+42     	; 0x6642 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    6618:	ea 81       	ldd	r30, Y+2	; 0x02
    661a:	fb 81       	ldd	r31, Y+3	; 0x03
    661c:	81 89       	ldd	r24, Z+17	; 0x11
    661e:	88 23       	and	r24, r24
    6620:	a9 f0       	breq	.+42     	; 0x664c <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    6622:	8a 81       	ldd	r24, Y+2	; 0x02
    6624:	9b 81       	ldd	r25, Y+3	; 0x03
    6626:	41 96       	adiw	r24, 0x11	; 17
    6628:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    662c:	88 23       	and	r24, r24
    662e:	71 f0       	breq	.+28     	; 0x664c <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    6630:	8a 85       	ldd	r24, Y+10	; 0x0a
    6632:	9b 85       	ldd	r25, Y+11	; 0x0b
    6634:	00 97       	sbiw	r24, 0x00	; 0
    6636:	51 f0       	breq	.+20     	; 0x664c <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    6638:	ea 85       	ldd	r30, Y+10	; 0x0a
    663a:	fb 85       	ldd	r31, Y+11	; 0x0b
    663c:	81 e0       	ldi	r24, 0x01	; 1
    663e:	80 83       	st	Z, r24
    6640:	05 c0       	rjmp	.+10     	; 0x664c <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    6642:	89 81       	ldd	r24, Y+1	; 0x01
    6644:	8f 5f       	subi	r24, 0xFF	; 255
    6646:	ea 81       	ldd	r30, Y+2	; 0x02
    6648:	fb 81       	ldd	r31, Y+3	; 0x03
    664a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    664c:	81 e0       	ldi	r24, 0x01	; 1
    664e:	8d 83       	std	Y+5, r24	; 0x05
    6650:	01 c0       	rjmp	.+2      	; 0x6654 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    6652:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6654:	8d 81       	ldd	r24, Y+5	; 0x05
}
    6656:	2c 96       	adiw	r28, 0x0c	; 12
    6658:	0f b6       	in	r0, 0x3f	; 63
    665a:	f8 94       	cli
    665c:	de bf       	out	0x3e, r29	; 62
    665e:	0f be       	out	0x3f, r0	; 63
    6660:	cd bf       	out	0x3d, r28	; 61
    6662:	cf 91       	pop	r28
    6664:	df 91       	pop	r29
    6666:	08 95       	ret

00006668 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    6668:	df 93       	push	r29
    666a:	cf 93       	push	r28
    666c:	cd b7       	in	r28, 0x3d	; 61
    666e:	de b7       	in	r29, 0x3e	; 62
    6670:	2a 97       	sbiw	r28, 0x0a	; 10
    6672:	0f b6       	in	r0, 0x3f	; 63
    6674:	f8 94       	cli
    6676:	de bf       	out	0x3e, r29	; 62
    6678:	0f be       	out	0x3f, r0	; 63
    667a:	cd bf       	out	0x3d, r28	; 61
    667c:	98 87       	std	Y+8, r25	; 0x08
    667e:	8f 83       	std	Y+7, r24	; 0x07
    6680:	7a 87       	std	Y+10, r23	; 0x0a
    6682:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    6684:	8f 81       	ldd	r24, Y+7	; 0x07
    6686:	98 85       	ldd	r25, Y+8	; 0x08
    6688:	9c 83       	std	Y+4, r25	; 0x04
    668a:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    668c:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    668e:	eb 81       	ldd	r30, Y+3	; 0x03
    6690:	fc 81       	ldd	r31, Y+4	; 0x04
    6692:	82 8d       	ldd	r24, Z+26	; 0x1a
    6694:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    6696:	eb 81       	ldd	r30, Y+3	; 0x03
    6698:	fc 81       	ldd	r31, Y+4	; 0x04
    669a:	93 8d       	ldd	r25, Z+27	; 0x1b
    669c:	8a 81       	ldd	r24, Y+2	; 0x02
    669e:	89 17       	cp	r24, r25
    66a0:	48 f5       	brcc	.+82     	; 0x66f4 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    66a2:	eb 81       	ldd	r30, Y+3	; 0x03
    66a4:	fc 81       	ldd	r31, Y+4	; 0x04
    66a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    66a8:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    66aa:	8a 81       	ldd	r24, Y+2	; 0x02
    66ac:	8f 5f       	subi	r24, 0xFF	; 255
    66ae:	eb 81       	ldd	r30, Y+3	; 0x03
    66b0:	fc 81       	ldd	r31, Y+4	; 0x04
    66b2:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    66b4:	89 81       	ldd	r24, Y+1	; 0x01
    66b6:	8f 3f       	cpi	r24, 0xFF	; 255
    66b8:	a9 f4       	brne	.+42     	; 0x66e4 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    66ba:	eb 81       	ldd	r30, Y+3	; 0x03
    66bc:	fc 81       	ldd	r31, Y+4	; 0x04
    66be:	81 89       	ldd	r24, Z+17	; 0x11
    66c0:	88 23       	and	r24, r24
    66c2:	a9 f0       	breq	.+42     	; 0x66ee <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    66c4:	8b 81       	ldd	r24, Y+3	; 0x03
    66c6:	9c 81       	ldd	r25, Y+4	; 0x04
    66c8:	41 96       	adiw	r24, 0x11	; 17
    66ca:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    66ce:	88 23       	and	r24, r24
    66d0:	71 f0       	breq	.+28     	; 0x66ee <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    66d2:	89 85       	ldd	r24, Y+9	; 0x09
    66d4:	9a 85       	ldd	r25, Y+10	; 0x0a
    66d6:	00 97       	sbiw	r24, 0x00	; 0
    66d8:	51 f0       	breq	.+20     	; 0x66ee <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    66da:	e9 85       	ldd	r30, Y+9	; 0x09
    66dc:	fa 85       	ldd	r31, Y+10	; 0x0a
    66de:	81 e0       	ldi	r24, 0x01	; 1
    66e0:	80 83       	st	Z, r24
    66e2:	05 c0       	rjmp	.+10     	; 0x66ee <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    66e4:	89 81       	ldd	r24, Y+1	; 0x01
    66e6:	8f 5f       	subi	r24, 0xFF	; 255
    66e8:	eb 81       	ldd	r30, Y+3	; 0x03
    66ea:	fc 81       	ldd	r31, Y+4	; 0x04
    66ec:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    66ee:	81 e0       	ldi	r24, 0x01	; 1
    66f0:	8e 83       	std	Y+6, r24	; 0x06
    66f2:	01 c0       	rjmp	.+2      	; 0x66f6 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    66f4:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    66f6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    66f8:	2a 96       	adiw	r28, 0x0a	; 10
    66fa:	0f b6       	in	r0, 0x3f	; 63
    66fc:	f8 94       	cli
    66fe:	de bf       	out	0x3e, r29	; 62
    6700:	0f be       	out	0x3f, r0	; 63
    6702:	cd bf       	out	0x3d, r28	; 61
    6704:	cf 91       	pop	r28
    6706:	df 91       	pop	r29
    6708:	08 95       	ret

0000670a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    670a:	df 93       	push	r29
    670c:	cf 93       	push	r28
    670e:	cd b7       	in	r28, 0x3d	; 61
    6710:	de b7       	in	r29, 0x3e	; 62
    6712:	61 97       	sbiw	r28, 0x11	; 17
    6714:	0f b6       	in	r0, 0x3f	; 63
    6716:	f8 94       	cli
    6718:	de bf       	out	0x3e, r29	; 62
    671a:	0f be       	out	0x3f, r0	; 63
    671c:	cd bf       	out	0x3d, r28	; 61
    671e:	9b 87       	std	Y+11, r25	; 0x0b
    6720:	8a 87       	std	Y+10, r24	; 0x0a
    6722:	7d 87       	std	Y+13, r23	; 0x0d
    6724:	6c 87       	std	Y+12, r22	; 0x0c
    6726:	5f 87       	std	Y+15, r21	; 0x0f
    6728:	4e 87       	std	Y+14, r20	; 0x0e
    672a:	28 8b       	std	Y+16, r18	; 0x10
BaseType_t xEntryTimeSet = pdFALSE;
    672c:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    672e:	8a 85       	ldd	r24, Y+10	; 0x0a
    6730:	9b 85       	ldd	r25, Y+11	; 0x0b
    6732:	9b 83       	std	Y+3, r25	; 0x03
    6734:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    6736:	0f b6       	in	r0, 0x3f	; 63
    6738:	f8 94       	cli
    673a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    673c:	ea 81       	ldd	r30, Y+2	; 0x02
    673e:	fb 81       	ldd	r31, Y+3	; 0x03
    6740:	82 8d       	ldd	r24, Z+26	; 0x1a
    6742:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    6744:	89 81       	ldd	r24, Y+1	; 0x01
    6746:	88 23       	and	r24, r24
    6748:	09 f4       	brne	.+2      	; 0x674c <xQueueGenericReceive+0x42>
    674a:	49 c0       	rjmp	.+146    	; 0x67de <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    674c:	ea 81       	ldd	r30, Y+2	; 0x02
    674e:	fb 81       	ldd	r31, Y+3	; 0x03
    6750:	86 81       	ldd	r24, Z+6	; 0x06
    6752:	97 81       	ldd	r25, Z+7	; 0x07
    6754:	9d 83       	std	Y+5, r25	; 0x05
    6756:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    6758:	8a 81       	ldd	r24, Y+2	; 0x02
    675a:	9b 81       	ldd	r25, Y+3	; 0x03
    675c:	2c 85       	ldd	r18, Y+12	; 0x0c
    675e:	3d 85       	ldd	r19, Y+13	; 0x0d
    6760:	b9 01       	movw	r22, r18
    6762:	0e 94 1c 36 	call	0x6c38	; 0x6c38 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    6766:	88 89       	ldd	r24, Y+16	; 0x10
    6768:	88 23       	and	r24, r24
    676a:	01 f5       	brne	.+64     	; 0x67ac <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    676c:	89 81       	ldd	r24, Y+1	; 0x01
    676e:	81 50       	subi	r24, 0x01	; 1
    6770:	ea 81       	ldd	r30, Y+2	; 0x02
    6772:	fb 81       	ldd	r31, Y+3	; 0x03
    6774:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    6776:	ea 81       	ldd	r30, Y+2	; 0x02
    6778:	fb 81       	ldd	r31, Y+3	; 0x03
    677a:	80 81       	ld	r24, Z
    677c:	91 81       	ldd	r25, Z+1	; 0x01
    677e:	00 97       	sbiw	r24, 0x00	; 0
    6780:	31 f4       	brne	.+12     	; 0x678e <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    6782:	0e 94 2c 42 	call	0x8458	; 0x8458 <pvTaskIncrementMutexHeldCount>
    6786:	ea 81       	ldd	r30, Y+2	; 0x02
    6788:	fb 81       	ldd	r31, Y+3	; 0x03
    678a:	93 83       	std	Z+3, r25	; 0x03
    678c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    678e:	ea 81       	ldd	r30, Y+2	; 0x02
    6790:	fb 81       	ldd	r31, Y+3	; 0x03
    6792:	80 85       	ldd	r24, Z+8	; 0x08
    6794:	88 23       	and	r24, r24
    6796:	f1 f0       	breq	.+60     	; 0x67d4 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6798:	8a 81       	ldd	r24, Y+2	; 0x02
    679a:	9b 81       	ldd	r25, Y+3	; 0x03
    679c:	08 96       	adiw	r24, 0x08	; 8
    679e:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    67a2:	88 23       	and	r24, r24
    67a4:	b9 f0       	breq	.+46     	; 0x67d4 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    67a6:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
    67aa:	14 c0       	rjmp	.+40     	; 0x67d4 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    67ac:	ea 81       	ldd	r30, Y+2	; 0x02
    67ae:	fb 81       	ldd	r31, Y+3	; 0x03
    67b0:	8c 81       	ldd	r24, Y+4	; 0x04
    67b2:	9d 81       	ldd	r25, Y+5	; 0x05
    67b4:	97 83       	std	Z+7, r25	; 0x07
    67b6:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    67b8:	ea 81       	ldd	r30, Y+2	; 0x02
    67ba:	fb 81       	ldd	r31, Y+3	; 0x03
    67bc:	81 89       	ldd	r24, Z+17	; 0x11
    67be:	88 23       	and	r24, r24
    67c0:	49 f0       	breq	.+18     	; 0x67d4 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    67c2:	8a 81       	ldd	r24, Y+2	; 0x02
    67c4:	9b 81       	ldd	r25, Y+3	; 0x03
    67c6:	41 96       	adiw	r24, 0x11	; 17
    67c8:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    67cc:	88 23       	and	r24, r24
    67ce:	11 f0       	breq	.+4      	; 0x67d4 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    67d0:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    67d4:	0f 90       	pop	r0
    67d6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    67d8:	81 e0       	ldi	r24, 0x01	; 1
    67da:	89 8b       	std	Y+17, r24	; 0x11
    67dc:	74 c0       	rjmp	.+232    	; 0x68c6 <xQueueGenericReceive+0x1bc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    67de:	8e 85       	ldd	r24, Y+14	; 0x0e
    67e0:	9f 85       	ldd	r25, Y+15	; 0x0f
    67e2:	00 97       	sbiw	r24, 0x00	; 0
    67e4:	21 f4       	brne	.+8      	; 0x67ee <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    67e6:	0f 90       	pop	r0
    67e8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    67ea:	19 8a       	std	Y+17, r1	; 0x11
    67ec:	6c c0       	rjmp	.+216    	; 0x68c6 <xQueueGenericReceive+0x1bc>
				}
				else if( xEntryTimeSet == pdFALSE )
    67ee:	8e 81       	ldd	r24, Y+6	; 0x06
    67f0:	88 23       	and	r24, r24
    67f2:	31 f4       	brne	.+12     	; 0x6800 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    67f4:	ce 01       	movw	r24, r28
    67f6:	07 96       	adiw	r24, 0x07	; 7
    67f8:	0e 94 9b 3f 	call	0x7f36	; 0x7f36 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    67fc:	81 e0       	ldi	r24, 0x01	; 1
    67fe:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    6800:	0f 90       	pop	r0
    6802:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    6804:	0e 94 44 3c 	call	0x7888	; 0x7888 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    6808:	0f b6       	in	r0, 0x3f	; 63
    680a:	f8 94       	cli
    680c:	0f 92       	push	r0
    680e:	ea 81       	ldd	r30, Y+2	; 0x02
    6810:	fb 81       	ldd	r31, Y+3	; 0x03
    6812:	85 8d       	ldd	r24, Z+29	; 0x1d
    6814:	8f 3f       	cpi	r24, 0xFF	; 255
    6816:	19 f4       	brne	.+6      	; 0x681e <xQueueGenericReceive+0x114>
    6818:	ea 81       	ldd	r30, Y+2	; 0x02
    681a:	fb 81       	ldd	r31, Y+3	; 0x03
    681c:	15 8e       	std	Z+29, r1	; 0x1d
    681e:	ea 81       	ldd	r30, Y+2	; 0x02
    6820:	fb 81       	ldd	r31, Y+3	; 0x03
    6822:	86 8d       	ldd	r24, Z+30	; 0x1e
    6824:	8f 3f       	cpi	r24, 0xFF	; 255
    6826:	19 f4       	brne	.+6      	; 0x682e <xQueueGenericReceive+0x124>
    6828:	ea 81       	ldd	r30, Y+2	; 0x02
    682a:	fb 81       	ldd	r31, Y+3	; 0x03
    682c:	16 8e       	std	Z+30, r1	; 0x1e
    682e:	0f 90       	pop	r0
    6830:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    6832:	ce 01       	movw	r24, r28
    6834:	07 96       	adiw	r24, 0x07	; 7
    6836:	9e 01       	movw	r18, r28
    6838:	22 5f       	subi	r18, 0xF2	; 242
    683a:	3f 4f       	sbci	r19, 0xFF	; 255
    683c:	b9 01       	movw	r22, r18
    683e:	0e 94 b4 3f 	call	0x7f68	; 0x7f68 <xTaskCheckForTimeOut>
    6842:	88 23       	and	r24, r24
    6844:	91 f5       	brne	.+100    	; 0x68aa <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    6846:	8a 81       	ldd	r24, Y+2	; 0x02
    6848:	9b 81       	ldd	r25, Y+3	; 0x03
    684a:	0e 94 b6 36 	call	0x6d6c	; 0x6d6c <prvIsQueueEmpty>
    684e:	88 23       	and	r24, r24
    6850:	29 f1       	breq	.+74     	; 0x689c <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    6852:	ea 81       	ldd	r30, Y+2	; 0x02
    6854:	fb 81       	ldd	r31, Y+3	; 0x03
    6856:	80 81       	ld	r24, Z
    6858:	91 81       	ldd	r25, Z+1	; 0x01
    685a:	00 97       	sbiw	r24, 0x00	; 0
    685c:	59 f4       	brne	.+22     	; 0x6874 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    685e:	0f b6       	in	r0, 0x3f	; 63
    6860:	f8 94       	cli
    6862:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    6864:	ea 81       	ldd	r30, Y+2	; 0x02
    6866:	fb 81       	ldd	r31, Y+3	; 0x03
    6868:	82 81       	ldd	r24, Z+2	; 0x02
    686a:	93 81       	ldd	r25, Z+3	; 0x03
    686c:	0e 94 08 41 	call	0x8210	; 0x8210 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    6870:	0f 90       	pop	r0
    6872:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    6874:	8a 81       	ldd	r24, Y+2	; 0x02
    6876:	9b 81       	ldd	r25, Y+3	; 0x03
    6878:	41 96       	adiw	r24, 0x11	; 17
    687a:	2e 85       	ldd	r18, Y+14	; 0x0e
    687c:	3f 85       	ldd	r19, Y+15	; 0x0f
    687e:	b9 01       	movw	r22, r18
    6880:	0e 94 79 3e 	call	0x7cf2	; 0x7cf2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    6884:	8a 81       	ldd	r24, Y+2	; 0x02
    6886:	9b 81       	ldd	r25, Y+3	; 0x03
    6888:	0e 94 63 36 	call	0x6cc6	; 0x6cc6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    688c:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>
    6890:	88 23       	and	r24, r24
    6892:	09 f0       	breq	.+2      	; 0x6896 <xQueueGenericReceive+0x18c>
    6894:	50 cf       	rjmp	.-352    	; 0x6736 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    6896:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
    689a:	4d cf       	rjmp	.-358    	; 0x6736 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    689c:	8a 81       	ldd	r24, Y+2	; 0x02
    689e:	9b 81       	ldd	r25, Y+3	; 0x03
    68a0:	0e 94 63 36 	call	0x6cc6	; 0x6cc6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    68a4:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>
    68a8:	46 cf       	rjmp	.-372    	; 0x6736 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    68aa:	8a 81       	ldd	r24, Y+2	; 0x02
    68ac:	9b 81       	ldd	r25, Y+3	; 0x03
    68ae:	0e 94 63 36 	call	0x6cc6	; 0x6cc6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    68b2:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    68b6:	8a 81       	ldd	r24, Y+2	; 0x02
    68b8:	9b 81       	ldd	r25, Y+3	; 0x03
    68ba:	0e 94 b6 36 	call	0x6d6c	; 0x6d6c <prvIsQueueEmpty>
    68be:	88 23       	and	r24, r24
    68c0:	09 f4       	brne	.+2      	; 0x68c4 <xQueueGenericReceive+0x1ba>
    68c2:	39 cf       	rjmp	.-398    	; 0x6736 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    68c4:	19 8a       	std	Y+17, r1	; 0x11
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    68c6:	89 89       	ldd	r24, Y+17	; 0x11
}
    68c8:	61 96       	adiw	r28, 0x11	; 17
    68ca:	0f b6       	in	r0, 0x3f	; 63
    68cc:	f8 94       	cli
    68ce:	de bf       	out	0x3e, r29	; 62
    68d0:	0f be       	out	0x3f, r0	; 63
    68d2:	cd bf       	out	0x3d, r28	; 61
    68d4:	cf 91       	pop	r28
    68d6:	df 91       	pop	r29
    68d8:	08 95       	ret

000068da <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    68da:	df 93       	push	r29
    68dc:	cf 93       	push	r28
    68de:	cd b7       	in	r28, 0x3d	; 61
    68e0:	de b7       	in	r29, 0x3e	; 62
    68e2:	2c 97       	sbiw	r28, 0x0c	; 12
    68e4:	0f b6       	in	r0, 0x3f	; 63
    68e6:	f8 94       	cli
    68e8:	de bf       	out	0x3e, r29	; 62
    68ea:	0f be       	out	0x3f, r0	; 63
    68ec:	cd bf       	out	0x3d, r28	; 61
    68ee:	98 87       	std	Y+8, r25	; 0x08
    68f0:	8f 83       	std	Y+7, r24	; 0x07
    68f2:	7a 87       	std	Y+10, r23	; 0x0a
    68f4:	69 87       	std	Y+9, r22	; 0x09
    68f6:	5c 87       	std	Y+12, r21	; 0x0c
    68f8:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    68fa:	8f 81       	ldd	r24, Y+7	; 0x07
    68fc:	98 85       	ldd	r25, Y+8	; 0x08
    68fe:	9c 83       	std	Y+4, r25	; 0x04
    6900:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6902:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    6904:	eb 81       	ldd	r30, Y+3	; 0x03
    6906:	fc 81       	ldd	r31, Y+4	; 0x04
    6908:	82 8d       	ldd	r24, Z+26	; 0x1a
    690a:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    690c:	8a 81       	ldd	r24, Y+2	; 0x02
    690e:	88 23       	and	r24, r24
    6910:	81 f1       	breq	.+96     	; 0x6972 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    6912:	eb 81       	ldd	r30, Y+3	; 0x03
    6914:	fc 81       	ldd	r31, Y+4	; 0x04
    6916:	85 8d       	ldd	r24, Z+29	; 0x1d
    6918:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    691a:	8b 81       	ldd	r24, Y+3	; 0x03
    691c:	9c 81       	ldd	r25, Y+4	; 0x04
    691e:	29 85       	ldd	r18, Y+9	; 0x09
    6920:	3a 85       	ldd	r19, Y+10	; 0x0a
    6922:	b9 01       	movw	r22, r18
    6924:	0e 94 1c 36 	call	0x6c38	; 0x6c38 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    6928:	8a 81       	ldd	r24, Y+2	; 0x02
    692a:	81 50       	subi	r24, 0x01	; 1
    692c:	eb 81       	ldd	r30, Y+3	; 0x03
    692e:	fc 81       	ldd	r31, Y+4	; 0x04
    6930:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    6932:	89 81       	ldd	r24, Y+1	; 0x01
    6934:	8f 3f       	cpi	r24, 0xFF	; 255
    6936:	a9 f4       	brne	.+42     	; 0x6962 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    6938:	eb 81       	ldd	r30, Y+3	; 0x03
    693a:	fc 81       	ldd	r31, Y+4	; 0x04
    693c:	80 85       	ldd	r24, Z+8	; 0x08
    693e:	88 23       	and	r24, r24
    6940:	a9 f0       	breq	.+42     	; 0x696c <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6942:	8b 81       	ldd	r24, Y+3	; 0x03
    6944:	9c 81       	ldd	r25, Y+4	; 0x04
    6946:	08 96       	adiw	r24, 0x08	; 8
    6948:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    694c:	88 23       	and	r24, r24
    694e:	71 f0       	breq	.+28     	; 0x696c <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    6950:	8b 85       	ldd	r24, Y+11	; 0x0b
    6952:	9c 85       	ldd	r25, Y+12	; 0x0c
    6954:	00 97       	sbiw	r24, 0x00	; 0
    6956:	51 f0       	breq	.+20     	; 0x696c <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    6958:	eb 85       	ldd	r30, Y+11	; 0x0b
    695a:	fc 85       	ldd	r31, Y+12	; 0x0c
    695c:	81 e0       	ldi	r24, 0x01	; 1
    695e:	80 83       	st	Z, r24
    6960:	05 c0       	rjmp	.+10     	; 0x696c <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    6962:	89 81       	ldd	r24, Y+1	; 0x01
    6964:	8f 5f       	subi	r24, 0xFF	; 255
    6966:	eb 81       	ldd	r30, Y+3	; 0x03
    6968:	fc 81       	ldd	r31, Y+4	; 0x04
    696a:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    696c:	81 e0       	ldi	r24, 0x01	; 1
    696e:	8e 83       	std	Y+6, r24	; 0x06
    6970:	01 c0       	rjmp	.+2      	; 0x6974 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    6972:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6974:	8e 81       	ldd	r24, Y+6	; 0x06
}
    6976:	2c 96       	adiw	r28, 0x0c	; 12
    6978:	0f b6       	in	r0, 0x3f	; 63
    697a:	f8 94       	cli
    697c:	de bf       	out	0x3e, r29	; 62
    697e:	0f be       	out	0x3f, r0	; 63
    6980:	cd bf       	out	0x3d, r28	; 61
    6982:	cf 91       	pop	r28
    6984:	df 91       	pop	r29
    6986:	08 95       	ret

00006988 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    6988:	df 93       	push	r29
    698a:	cf 93       	push	r28
    698c:	cd b7       	in	r28, 0x3d	; 61
    698e:	de b7       	in	r29, 0x3e	; 62
    6990:	2a 97       	sbiw	r28, 0x0a	; 10
    6992:	0f b6       	in	r0, 0x3f	; 63
    6994:	f8 94       	cli
    6996:	de bf       	out	0x3e, r29	; 62
    6998:	0f be       	out	0x3f, r0	; 63
    699a:	cd bf       	out	0x3d, r28	; 61
    699c:	98 87       	std	Y+8, r25	; 0x08
    699e:	8f 83       	std	Y+7, r24	; 0x07
    69a0:	7a 87       	std	Y+10, r23	; 0x0a
    69a2:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    69a4:	8f 81       	ldd	r24, Y+7	; 0x07
    69a6:	98 85       	ldd	r25, Y+8	; 0x08
    69a8:	9a 83       	std	Y+2, r25	; 0x02
    69aa:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    69ac:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    69ae:	e9 81       	ldd	r30, Y+1	; 0x01
    69b0:	fa 81       	ldd	r31, Y+2	; 0x02
    69b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    69b4:	88 23       	and	r24, r24
    69b6:	b1 f0       	breq	.+44     	; 0x69e4 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    69b8:	e9 81       	ldd	r30, Y+1	; 0x01
    69ba:	fa 81       	ldd	r31, Y+2	; 0x02
    69bc:	86 81       	ldd	r24, Z+6	; 0x06
    69be:	97 81       	ldd	r25, Z+7	; 0x07
    69c0:	9c 83       	std	Y+4, r25	; 0x04
    69c2:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    69c4:	89 81       	ldd	r24, Y+1	; 0x01
    69c6:	9a 81       	ldd	r25, Y+2	; 0x02
    69c8:	29 85       	ldd	r18, Y+9	; 0x09
    69ca:	3a 85       	ldd	r19, Y+10	; 0x0a
    69cc:	b9 01       	movw	r22, r18
    69ce:	0e 94 1c 36 	call	0x6c38	; 0x6c38 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    69d2:	e9 81       	ldd	r30, Y+1	; 0x01
    69d4:	fa 81       	ldd	r31, Y+2	; 0x02
    69d6:	8b 81       	ldd	r24, Y+3	; 0x03
    69d8:	9c 81       	ldd	r25, Y+4	; 0x04
    69da:	97 83       	std	Z+7, r25	; 0x07
    69dc:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    69de:	81 e0       	ldi	r24, 0x01	; 1
    69e0:	8e 83       	std	Y+6, r24	; 0x06
    69e2:	01 c0       	rjmp	.+2      	; 0x69e6 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    69e4:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    69e6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    69e8:	2a 96       	adiw	r28, 0x0a	; 10
    69ea:	0f b6       	in	r0, 0x3f	; 63
    69ec:	f8 94       	cli
    69ee:	de bf       	out	0x3e, r29	; 62
    69f0:	0f be       	out	0x3f, r0	; 63
    69f2:	cd bf       	out	0x3d, r28	; 61
    69f4:	cf 91       	pop	r28
    69f6:	df 91       	pop	r29
    69f8:	08 95       	ret

000069fa <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    69fa:	df 93       	push	r29
    69fc:	cf 93       	push	r28
    69fe:	00 d0       	rcall	.+0      	; 0x6a00 <uxQueueMessagesWaiting+0x6>
    6a00:	0f 92       	push	r0
    6a02:	cd b7       	in	r28, 0x3d	; 61
    6a04:	de b7       	in	r29, 0x3e	; 62
    6a06:	9b 83       	std	Y+3, r25	; 0x03
    6a08:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    6a0a:	0f b6       	in	r0, 0x3f	; 63
    6a0c:	f8 94       	cli
    6a0e:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    6a10:	ea 81       	ldd	r30, Y+2	; 0x02
    6a12:	fb 81       	ldd	r31, Y+3	; 0x03
    6a14:	82 8d       	ldd	r24, Z+26	; 0x1a
    6a16:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    6a18:	0f 90       	pop	r0
    6a1a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    6a1c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    6a1e:	0f 90       	pop	r0
    6a20:	0f 90       	pop	r0
    6a22:	0f 90       	pop	r0
    6a24:	cf 91       	pop	r28
    6a26:	df 91       	pop	r29
    6a28:	08 95       	ret

00006a2a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    6a2a:	df 93       	push	r29
    6a2c:	cf 93       	push	r28
    6a2e:	00 d0       	rcall	.+0      	; 0x6a30 <uxQueueSpacesAvailable+0x6>
    6a30:	00 d0       	rcall	.+0      	; 0x6a32 <uxQueueSpacesAvailable+0x8>
    6a32:	0f 92       	push	r0
    6a34:	cd b7       	in	r28, 0x3d	; 61
    6a36:	de b7       	in	r29, 0x3e	; 62
    6a38:	9d 83       	std	Y+5, r25	; 0x05
    6a3a:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    6a3c:	8c 81       	ldd	r24, Y+4	; 0x04
    6a3e:	9d 81       	ldd	r25, Y+5	; 0x05
    6a40:	9a 83       	std	Y+2, r25	; 0x02
    6a42:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    6a44:	0f b6       	in	r0, 0x3f	; 63
    6a46:	f8 94       	cli
    6a48:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    6a4a:	e9 81       	ldd	r30, Y+1	; 0x01
    6a4c:	fa 81       	ldd	r31, Y+2	; 0x02
    6a4e:	93 8d       	ldd	r25, Z+27	; 0x1b
    6a50:	e9 81       	ldd	r30, Y+1	; 0x01
    6a52:	fa 81       	ldd	r31, Y+2	; 0x02
    6a54:	82 8d       	ldd	r24, Z+26	; 0x1a
    6a56:	29 2f       	mov	r18, r25
    6a58:	28 1b       	sub	r18, r24
    6a5a:	82 2f       	mov	r24, r18
    6a5c:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    6a5e:	0f 90       	pop	r0
    6a60:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    6a62:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    6a64:	0f 90       	pop	r0
    6a66:	0f 90       	pop	r0
    6a68:	0f 90       	pop	r0
    6a6a:	0f 90       	pop	r0
    6a6c:	0f 90       	pop	r0
    6a6e:	cf 91       	pop	r28
    6a70:	df 91       	pop	r29
    6a72:	08 95       	ret

00006a74 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    6a74:	df 93       	push	r29
    6a76:	cf 93       	push	r28
    6a78:	00 d0       	rcall	.+0      	; 0x6a7a <uxQueueMessagesWaitingFromISR+0x6>
    6a7a:	0f 92       	push	r0
    6a7c:	cd b7       	in	r28, 0x3d	; 61
    6a7e:	de b7       	in	r29, 0x3e	; 62
    6a80:	9b 83       	std	Y+3, r25	; 0x03
    6a82:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    6a84:	ea 81       	ldd	r30, Y+2	; 0x02
    6a86:	fb 81       	ldd	r31, Y+3	; 0x03
    6a88:	82 8d       	ldd	r24, Z+26	; 0x1a
    6a8a:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    6a8c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    6a8e:	0f 90       	pop	r0
    6a90:	0f 90       	pop	r0
    6a92:	0f 90       	pop	r0
    6a94:	cf 91       	pop	r28
    6a96:	df 91       	pop	r29
    6a98:	08 95       	ret

00006a9a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    6a9a:	df 93       	push	r29
    6a9c:	cf 93       	push	r28
    6a9e:	00 d0       	rcall	.+0      	; 0x6aa0 <vQueueDelete+0x6>
    6aa0:	00 d0       	rcall	.+0      	; 0x6aa2 <vQueueDelete+0x8>
    6aa2:	cd b7       	in	r28, 0x3d	; 61
    6aa4:	de b7       	in	r29, 0x3e	; 62
    6aa6:	9c 83       	std	Y+4, r25	; 0x04
    6aa8:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    6aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    6aac:	9c 81       	ldd	r25, Y+4	; 0x04
    6aae:	9a 83       	std	Y+2, r25	; 0x02
    6ab0:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    6ab2:	89 81       	ldd	r24, Y+1	; 0x01
    6ab4:	9a 81       	ldd	r25, Y+2	; 0x02
    6ab6:	0e 94 20 2c 	call	0x5840	; 0x5840 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    6aba:	0f 90       	pop	r0
    6abc:	0f 90       	pop	r0
    6abe:	0f 90       	pop	r0
    6ac0:	0f 90       	pop	r0
    6ac2:	cf 91       	pop	r28
    6ac4:	df 91       	pop	r29
    6ac6:	08 95       	ret

00006ac8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    6ac8:	df 93       	push	r29
    6aca:	cf 93       	push	r28
    6acc:	cd b7       	in	r28, 0x3d	; 61
    6ace:	de b7       	in	r29, 0x3e	; 62
    6ad0:	27 97       	sbiw	r28, 0x07	; 7
    6ad2:	0f b6       	in	r0, 0x3f	; 63
    6ad4:	f8 94       	cli
    6ad6:	de bf       	out	0x3e, r29	; 62
    6ad8:	0f be       	out	0x3f, r0	; 63
    6ada:	cd bf       	out	0x3d, r28	; 61
    6adc:	9c 83       	std	Y+4, r25	; 0x04
    6ade:	8b 83       	std	Y+3, r24	; 0x03
    6ae0:	7e 83       	std	Y+6, r23	; 0x06
    6ae2:	6d 83       	std	Y+5, r22	; 0x05
    6ae4:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    6ae6:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    6ae8:	eb 81       	ldd	r30, Y+3	; 0x03
    6aea:	fc 81       	ldd	r31, Y+4	; 0x04
    6aec:	82 8d       	ldd	r24, Z+26	; 0x1a
    6aee:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    6af0:	eb 81       	ldd	r30, Y+3	; 0x03
    6af2:	fc 81       	ldd	r31, Y+4	; 0x04
    6af4:	84 8d       	ldd	r24, Z+28	; 0x1c
    6af6:	88 23       	and	r24, r24
    6af8:	99 f4       	brne	.+38     	; 0x6b20 <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    6afa:	eb 81       	ldd	r30, Y+3	; 0x03
    6afc:	fc 81       	ldd	r31, Y+4	; 0x04
    6afe:	80 81       	ld	r24, Z
    6b00:	91 81       	ldd	r25, Z+1	; 0x01
    6b02:	00 97       	sbiw	r24, 0x00	; 0
    6b04:	09 f0       	breq	.+2      	; 0x6b08 <prvCopyDataToQueue+0x40>
    6b06:	89 c0       	rjmp	.+274    	; 0x6c1a <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    6b08:	eb 81       	ldd	r30, Y+3	; 0x03
    6b0a:	fc 81       	ldd	r31, Y+4	; 0x04
    6b0c:	82 81       	ldd	r24, Z+2	; 0x02
    6b0e:	93 81       	ldd	r25, Z+3	; 0x03
    6b10:	0e 94 93 41 	call	0x8326	; 0x8326 <xTaskPriorityDisinherit>
    6b14:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->pxMutexHolder = NULL;
    6b16:	eb 81       	ldd	r30, Y+3	; 0x03
    6b18:	fc 81       	ldd	r31, Y+4	; 0x04
    6b1a:	13 82       	std	Z+3, r1	; 0x03
    6b1c:	12 82       	std	Z+2, r1	; 0x02
    6b1e:	7d c0       	rjmp	.+250    	; 0x6c1a <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    6b20:	8f 81       	ldd	r24, Y+7	; 0x07
    6b22:	88 23       	and	r24, r24
    6b24:	99 f5       	brne	.+102    	; 0x6b8c <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    6b26:	eb 81       	ldd	r30, Y+3	; 0x03
    6b28:	fc 81       	ldd	r31, Y+4	; 0x04
    6b2a:	64 81       	ldd	r22, Z+4	; 0x04
    6b2c:	75 81       	ldd	r23, Z+5	; 0x05
    6b2e:	eb 81       	ldd	r30, Y+3	; 0x03
    6b30:	fc 81       	ldd	r31, Y+4	; 0x04
    6b32:	84 8d       	ldd	r24, Z+28	; 0x1c
    6b34:	48 2f       	mov	r20, r24
    6b36:	50 e0       	ldi	r21, 0x00	; 0
    6b38:	2d 81       	ldd	r18, Y+5	; 0x05
    6b3a:	3e 81       	ldd	r19, Y+6	; 0x06
    6b3c:	cb 01       	movw	r24, r22
    6b3e:	b9 01       	movw	r22, r18
    6b40:	0e 94 15 47 	call	0x8e2a	; 0x8e2a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    6b44:	eb 81       	ldd	r30, Y+3	; 0x03
    6b46:	fc 81       	ldd	r31, Y+4	; 0x04
    6b48:	24 81       	ldd	r18, Z+4	; 0x04
    6b4a:	35 81       	ldd	r19, Z+5	; 0x05
    6b4c:	eb 81       	ldd	r30, Y+3	; 0x03
    6b4e:	fc 81       	ldd	r31, Y+4	; 0x04
    6b50:	84 8d       	ldd	r24, Z+28	; 0x1c
    6b52:	88 2f       	mov	r24, r24
    6b54:	90 e0       	ldi	r25, 0x00	; 0
    6b56:	82 0f       	add	r24, r18
    6b58:	93 1f       	adc	r25, r19
    6b5a:	eb 81       	ldd	r30, Y+3	; 0x03
    6b5c:	fc 81       	ldd	r31, Y+4	; 0x04
    6b5e:	95 83       	std	Z+5, r25	; 0x05
    6b60:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    6b62:	eb 81       	ldd	r30, Y+3	; 0x03
    6b64:	fc 81       	ldd	r31, Y+4	; 0x04
    6b66:	24 81       	ldd	r18, Z+4	; 0x04
    6b68:	35 81       	ldd	r19, Z+5	; 0x05
    6b6a:	eb 81       	ldd	r30, Y+3	; 0x03
    6b6c:	fc 81       	ldd	r31, Y+4	; 0x04
    6b6e:	82 81       	ldd	r24, Z+2	; 0x02
    6b70:	93 81       	ldd	r25, Z+3	; 0x03
    6b72:	28 17       	cp	r18, r24
    6b74:	39 07       	cpc	r19, r25
    6b76:	08 f4       	brcc	.+2      	; 0x6b7a <prvCopyDataToQueue+0xb2>
    6b78:	50 c0       	rjmp	.+160    	; 0x6c1a <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    6b7a:	eb 81       	ldd	r30, Y+3	; 0x03
    6b7c:	fc 81       	ldd	r31, Y+4	; 0x04
    6b7e:	80 81       	ld	r24, Z
    6b80:	91 81       	ldd	r25, Z+1	; 0x01
    6b82:	eb 81       	ldd	r30, Y+3	; 0x03
    6b84:	fc 81       	ldd	r31, Y+4	; 0x04
    6b86:	95 83       	std	Z+5, r25	; 0x05
    6b88:	84 83       	std	Z+4, r24	; 0x04
    6b8a:	47 c0       	rjmp	.+142    	; 0x6c1a <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6b8c:	eb 81       	ldd	r30, Y+3	; 0x03
    6b8e:	fc 81       	ldd	r31, Y+4	; 0x04
    6b90:	66 81       	ldd	r22, Z+6	; 0x06
    6b92:	77 81       	ldd	r23, Z+7	; 0x07
    6b94:	eb 81       	ldd	r30, Y+3	; 0x03
    6b96:	fc 81       	ldd	r31, Y+4	; 0x04
    6b98:	84 8d       	ldd	r24, Z+28	; 0x1c
    6b9a:	48 2f       	mov	r20, r24
    6b9c:	50 e0       	ldi	r21, 0x00	; 0
    6b9e:	2d 81       	ldd	r18, Y+5	; 0x05
    6ba0:	3e 81       	ldd	r19, Y+6	; 0x06
    6ba2:	cb 01       	movw	r24, r22
    6ba4:	b9 01       	movw	r22, r18
    6ba6:	0e 94 15 47 	call	0x8e2a	; 0x8e2a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    6baa:	eb 81       	ldd	r30, Y+3	; 0x03
    6bac:	fc 81       	ldd	r31, Y+4	; 0x04
    6bae:	26 81       	ldd	r18, Z+6	; 0x06
    6bb0:	37 81       	ldd	r19, Z+7	; 0x07
    6bb2:	eb 81       	ldd	r30, Y+3	; 0x03
    6bb4:	fc 81       	ldd	r31, Y+4	; 0x04
    6bb6:	84 8d       	ldd	r24, Z+28	; 0x1c
    6bb8:	88 2f       	mov	r24, r24
    6bba:	90 e0       	ldi	r25, 0x00	; 0
    6bbc:	90 95       	com	r25
    6bbe:	81 95       	neg	r24
    6bc0:	9f 4f       	sbci	r25, 0xFF	; 255
    6bc2:	82 0f       	add	r24, r18
    6bc4:	93 1f       	adc	r25, r19
    6bc6:	eb 81       	ldd	r30, Y+3	; 0x03
    6bc8:	fc 81       	ldd	r31, Y+4	; 0x04
    6bca:	97 83       	std	Z+7, r25	; 0x07
    6bcc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    6bce:	eb 81       	ldd	r30, Y+3	; 0x03
    6bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    6bd2:	26 81       	ldd	r18, Z+6	; 0x06
    6bd4:	37 81       	ldd	r19, Z+7	; 0x07
    6bd6:	eb 81       	ldd	r30, Y+3	; 0x03
    6bd8:	fc 81       	ldd	r31, Y+4	; 0x04
    6bda:	80 81       	ld	r24, Z
    6bdc:	91 81       	ldd	r25, Z+1	; 0x01
    6bde:	28 17       	cp	r18, r24
    6be0:	39 07       	cpc	r19, r25
    6be2:	90 f4       	brcc	.+36     	; 0x6c08 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    6be4:	eb 81       	ldd	r30, Y+3	; 0x03
    6be6:	fc 81       	ldd	r31, Y+4	; 0x04
    6be8:	22 81       	ldd	r18, Z+2	; 0x02
    6bea:	33 81       	ldd	r19, Z+3	; 0x03
    6bec:	eb 81       	ldd	r30, Y+3	; 0x03
    6bee:	fc 81       	ldd	r31, Y+4	; 0x04
    6bf0:	84 8d       	ldd	r24, Z+28	; 0x1c
    6bf2:	88 2f       	mov	r24, r24
    6bf4:	90 e0       	ldi	r25, 0x00	; 0
    6bf6:	90 95       	com	r25
    6bf8:	81 95       	neg	r24
    6bfa:	9f 4f       	sbci	r25, 0xFF	; 255
    6bfc:	82 0f       	add	r24, r18
    6bfe:	93 1f       	adc	r25, r19
    6c00:	eb 81       	ldd	r30, Y+3	; 0x03
    6c02:	fc 81       	ldd	r31, Y+4	; 0x04
    6c04:	97 83       	std	Z+7, r25	; 0x07
    6c06:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    6c08:	8f 81       	ldd	r24, Y+7	; 0x07
    6c0a:	82 30       	cpi	r24, 0x02	; 2
    6c0c:	31 f4       	brne	.+12     	; 0x6c1a <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    6c0e:	89 81       	ldd	r24, Y+1	; 0x01
    6c10:	88 23       	and	r24, r24
    6c12:	19 f0       	breq	.+6      	; 0x6c1a <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    6c14:	89 81       	ldd	r24, Y+1	; 0x01
    6c16:	81 50       	subi	r24, 0x01	; 1
    6c18:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    6c1a:	89 81       	ldd	r24, Y+1	; 0x01
    6c1c:	8f 5f       	subi	r24, 0xFF	; 255
    6c1e:	eb 81       	ldd	r30, Y+3	; 0x03
    6c20:	fc 81       	ldd	r31, Y+4	; 0x04
    6c22:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    6c24:	8a 81       	ldd	r24, Y+2	; 0x02
}
    6c26:	27 96       	adiw	r28, 0x07	; 7
    6c28:	0f b6       	in	r0, 0x3f	; 63
    6c2a:	f8 94       	cli
    6c2c:	de bf       	out	0x3e, r29	; 62
    6c2e:	0f be       	out	0x3f, r0	; 63
    6c30:	cd bf       	out	0x3d, r28	; 61
    6c32:	cf 91       	pop	r28
    6c34:	df 91       	pop	r29
    6c36:	08 95       	ret

00006c38 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    6c38:	df 93       	push	r29
    6c3a:	cf 93       	push	r28
    6c3c:	00 d0       	rcall	.+0      	; 0x6c3e <prvCopyDataFromQueue+0x6>
    6c3e:	00 d0       	rcall	.+0      	; 0x6c40 <prvCopyDataFromQueue+0x8>
    6c40:	cd b7       	in	r28, 0x3d	; 61
    6c42:	de b7       	in	r29, 0x3e	; 62
    6c44:	9a 83       	std	Y+2, r25	; 0x02
    6c46:	89 83       	std	Y+1, r24	; 0x01
    6c48:	7c 83       	std	Y+4, r23	; 0x04
    6c4a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    6c4c:	e9 81       	ldd	r30, Y+1	; 0x01
    6c4e:	fa 81       	ldd	r31, Y+2	; 0x02
    6c50:	84 8d       	ldd	r24, Z+28	; 0x1c
    6c52:	88 23       	and	r24, r24
    6c54:	89 f1       	breq	.+98     	; 0x6cb8 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    6c56:	e9 81       	ldd	r30, Y+1	; 0x01
    6c58:	fa 81       	ldd	r31, Y+2	; 0x02
    6c5a:	26 81       	ldd	r18, Z+6	; 0x06
    6c5c:	37 81       	ldd	r19, Z+7	; 0x07
    6c5e:	e9 81       	ldd	r30, Y+1	; 0x01
    6c60:	fa 81       	ldd	r31, Y+2	; 0x02
    6c62:	84 8d       	ldd	r24, Z+28	; 0x1c
    6c64:	88 2f       	mov	r24, r24
    6c66:	90 e0       	ldi	r25, 0x00	; 0
    6c68:	82 0f       	add	r24, r18
    6c6a:	93 1f       	adc	r25, r19
    6c6c:	e9 81       	ldd	r30, Y+1	; 0x01
    6c6e:	fa 81       	ldd	r31, Y+2	; 0x02
    6c70:	97 83       	std	Z+7, r25	; 0x07
    6c72:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    6c74:	e9 81       	ldd	r30, Y+1	; 0x01
    6c76:	fa 81       	ldd	r31, Y+2	; 0x02
    6c78:	26 81       	ldd	r18, Z+6	; 0x06
    6c7a:	37 81       	ldd	r19, Z+7	; 0x07
    6c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    6c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    6c80:	82 81       	ldd	r24, Z+2	; 0x02
    6c82:	93 81       	ldd	r25, Z+3	; 0x03
    6c84:	28 17       	cp	r18, r24
    6c86:	39 07       	cpc	r19, r25
    6c88:	40 f0       	brcs	.+16     	; 0x6c9a <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    6c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    6c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    6c8e:	80 81       	ld	r24, Z
    6c90:	91 81       	ldd	r25, Z+1	; 0x01
    6c92:	e9 81       	ldd	r30, Y+1	; 0x01
    6c94:	fa 81       	ldd	r31, Y+2	; 0x02
    6c96:	97 83       	std	Z+7, r25	; 0x07
    6c98:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    6c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    6c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    6c9e:	46 81       	ldd	r20, Z+6	; 0x06
    6ca0:	57 81       	ldd	r21, Z+7	; 0x07
    6ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    6ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    6ca6:	84 8d       	ldd	r24, Z+28	; 0x1c
    6ca8:	28 2f       	mov	r18, r24
    6caa:	30 e0       	ldi	r19, 0x00	; 0
    6cac:	8b 81       	ldd	r24, Y+3	; 0x03
    6cae:	9c 81       	ldd	r25, Y+4	; 0x04
    6cb0:	ba 01       	movw	r22, r20
    6cb2:	a9 01       	movw	r20, r18
    6cb4:	0e 94 15 47 	call	0x8e2a	; 0x8e2a <memcpy>
	}
}
    6cb8:	0f 90       	pop	r0
    6cba:	0f 90       	pop	r0
    6cbc:	0f 90       	pop	r0
    6cbe:	0f 90       	pop	r0
    6cc0:	cf 91       	pop	r28
    6cc2:	df 91       	pop	r29
    6cc4:	08 95       	ret

00006cc6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    6cc6:	df 93       	push	r29
    6cc8:	cf 93       	push	r28
    6cca:	00 d0       	rcall	.+0      	; 0x6ccc <prvUnlockQueue+0x6>
    6ccc:	00 d0       	rcall	.+0      	; 0x6cce <prvUnlockQueue+0x8>
    6cce:	cd b7       	in	r28, 0x3d	; 61
    6cd0:	de b7       	in	r29, 0x3e	; 62
    6cd2:	9c 83       	std	Y+4, r25	; 0x04
    6cd4:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    6cd6:	0f b6       	in	r0, 0x3f	; 63
    6cd8:	f8 94       	cli
    6cda:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    6cdc:	eb 81       	ldd	r30, Y+3	; 0x03
    6cde:	fc 81       	ldd	r31, Y+4	; 0x04
    6ce0:	86 8d       	ldd	r24, Z+30	; 0x1e
    6ce2:	8a 83       	std	Y+2, r24	; 0x02
    6ce4:	11 c0       	rjmp	.+34     	; 0x6d08 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    6ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    6ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    6cea:	81 89       	ldd	r24, Z+17	; 0x11
    6cec:	88 23       	and	r24, r24
    6cee:	79 f0       	breq	.+30     	; 0x6d0e <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    6cf0:	8b 81       	ldd	r24, Y+3	; 0x03
    6cf2:	9c 81       	ldd	r25, Y+4	; 0x04
    6cf4:	41 96       	adiw	r24, 0x11	; 17
    6cf6:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    6cfa:	88 23       	and	r24, r24
    6cfc:	11 f0       	breq	.+4      	; 0x6d02 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    6cfe:	0e 94 21 40 	call	0x8042	; 0x8042 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    6d02:	8a 81       	ldd	r24, Y+2	; 0x02
    6d04:	81 50       	subi	r24, 0x01	; 1
    6d06:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    6d08:	8a 81       	ldd	r24, Y+2	; 0x02
    6d0a:	18 16       	cp	r1, r24
    6d0c:	64 f3       	brlt	.-40     	; 0x6ce6 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    6d0e:	eb 81       	ldd	r30, Y+3	; 0x03
    6d10:	fc 81       	ldd	r31, Y+4	; 0x04
    6d12:	8f ef       	ldi	r24, 0xFF	; 255
    6d14:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    6d16:	0f 90       	pop	r0
    6d18:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    6d1a:	0f b6       	in	r0, 0x3f	; 63
    6d1c:	f8 94       	cli
    6d1e:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    6d20:	eb 81       	ldd	r30, Y+3	; 0x03
    6d22:	fc 81       	ldd	r31, Y+4	; 0x04
    6d24:	85 8d       	ldd	r24, Z+29	; 0x1d
    6d26:	89 83       	std	Y+1, r24	; 0x01
    6d28:	11 c0       	rjmp	.+34     	; 0x6d4c <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    6d2a:	eb 81       	ldd	r30, Y+3	; 0x03
    6d2c:	fc 81       	ldd	r31, Y+4	; 0x04
    6d2e:	80 85       	ldd	r24, Z+8	; 0x08
    6d30:	88 23       	and	r24, r24
    6d32:	79 f0       	breq	.+30     	; 0x6d52 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6d34:	8b 81       	ldd	r24, Y+3	; 0x03
    6d36:	9c 81       	ldd	r25, Y+4	; 0x04
    6d38:	08 96       	adiw	r24, 0x08	; 8
    6d3a:	0e 94 cb 3e 	call	0x7d96	; 0x7d96 <xTaskRemoveFromEventList>
    6d3e:	88 23       	and	r24, r24
    6d40:	11 f0       	breq	.+4      	; 0x6d46 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    6d42:	0e 94 21 40 	call	0x8042	; 0x8042 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    6d46:	89 81       	ldd	r24, Y+1	; 0x01
    6d48:	81 50       	subi	r24, 0x01	; 1
    6d4a:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    6d4c:	89 81       	ldd	r24, Y+1	; 0x01
    6d4e:	18 16       	cp	r1, r24
    6d50:	64 f3       	brlt	.-40     	; 0x6d2a <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    6d52:	eb 81       	ldd	r30, Y+3	; 0x03
    6d54:	fc 81       	ldd	r31, Y+4	; 0x04
    6d56:	8f ef       	ldi	r24, 0xFF	; 255
    6d58:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    6d5a:	0f 90       	pop	r0
    6d5c:	0f be       	out	0x3f, r0	; 63
}
    6d5e:	0f 90       	pop	r0
    6d60:	0f 90       	pop	r0
    6d62:	0f 90       	pop	r0
    6d64:	0f 90       	pop	r0
    6d66:	cf 91       	pop	r28
    6d68:	df 91       	pop	r29
    6d6a:	08 95       	ret

00006d6c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    6d6c:	df 93       	push	r29
    6d6e:	cf 93       	push	r28
    6d70:	00 d0       	rcall	.+0      	; 0x6d72 <prvIsQueueEmpty+0x6>
    6d72:	0f 92       	push	r0
    6d74:	cd b7       	in	r28, 0x3d	; 61
    6d76:	de b7       	in	r29, 0x3e	; 62
    6d78:	9b 83       	std	Y+3, r25	; 0x03
    6d7a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    6d7c:	0f b6       	in	r0, 0x3f	; 63
    6d7e:	f8 94       	cli
    6d80:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    6d82:	ea 81       	ldd	r30, Y+2	; 0x02
    6d84:	fb 81       	ldd	r31, Y+3	; 0x03
    6d86:	82 8d       	ldd	r24, Z+26	; 0x1a
    6d88:	88 23       	and	r24, r24
    6d8a:	19 f4       	brne	.+6      	; 0x6d92 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    6d8c:	81 e0       	ldi	r24, 0x01	; 1
    6d8e:	89 83       	std	Y+1, r24	; 0x01
    6d90:	01 c0       	rjmp	.+2      	; 0x6d94 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    6d92:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    6d94:	0f 90       	pop	r0
    6d96:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6d98:	89 81       	ldd	r24, Y+1	; 0x01
}
    6d9a:	0f 90       	pop	r0
    6d9c:	0f 90       	pop	r0
    6d9e:	0f 90       	pop	r0
    6da0:	cf 91       	pop	r28
    6da2:	df 91       	pop	r29
    6da4:	08 95       	ret

00006da6 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    6da6:	df 93       	push	r29
    6da8:	cf 93       	push	r28
    6daa:	00 d0       	rcall	.+0      	; 0x6dac <xQueueIsQueueEmptyFromISR+0x6>
    6dac:	0f 92       	push	r0
    6dae:	cd b7       	in	r28, 0x3d	; 61
    6db0:	de b7       	in	r29, 0x3e	; 62
    6db2:	9b 83       	std	Y+3, r25	; 0x03
    6db4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    6db6:	ea 81       	ldd	r30, Y+2	; 0x02
    6db8:	fb 81       	ldd	r31, Y+3	; 0x03
    6dba:	82 8d       	ldd	r24, Z+26	; 0x1a
    6dbc:	88 23       	and	r24, r24
    6dbe:	19 f4       	brne	.+6      	; 0x6dc6 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    6dc0:	81 e0       	ldi	r24, 0x01	; 1
    6dc2:	89 83       	std	Y+1, r24	; 0x01
    6dc4:	01 c0       	rjmp	.+2      	; 0x6dc8 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    6dc6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    6dc8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    6dca:	0f 90       	pop	r0
    6dcc:	0f 90       	pop	r0
    6dce:	0f 90       	pop	r0
    6dd0:	cf 91       	pop	r28
    6dd2:	df 91       	pop	r29
    6dd4:	08 95       	ret

00006dd6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    6dd6:	df 93       	push	r29
    6dd8:	cf 93       	push	r28
    6dda:	00 d0       	rcall	.+0      	; 0x6ddc <prvIsQueueFull+0x6>
    6ddc:	0f 92       	push	r0
    6dde:	cd b7       	in	r28, 0x3d	; 61
    6de0:	de b7       	in	r29, 0x3e	; 62
    6de2:	9b 83       	std	Y+3, r25	; 0x03
    6de4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    6de6:	0f b6       	in	r0, 0x3f	; 63
    6de8:	f8 94       	cli
    6dea:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    6dec:	ea 81       	ldd	r30, Y+2	; 0x02
    6dee:	fb 81       	ldd	r31, Y+3	; 0x03
    6df0:	92 8d       	ldd	r25, Z+26	; 0x1a
    6df2:	ea 81       	ldd	r30, Y+2	; 0x02
    6df4:	fb 81       	ldd	r31, Y+3	; 0x03
    6df6:	83 8d       	ldd	r24, Z+27	; 0x1b
    6df8:	98 17       	cp	r25, r24
    6dfa:	19 f4       	brne	.+6      	; 0x6e02 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    6dfc:	81 e0       	ldi	r24, 0x01	; 1
    6dfe:	89 83       	std	Y+1, r24	; 0x01
    6e00:	01 c0       	rjmp	.+2      	; 0x6e04 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    6e02:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    6e04:	0f 90       	pop	r0
    6e06:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6e08:	89 81       	ldd	r24, Y+1	; 0x01
}
    6e0a:	0f 90       	pop	r0
    6e0c:	0f 90       	pop	r0
    6e0e:	0f 90       	pop	r0
    6e10:	cf 91       	pop	r28
    6e12:	df 91       	pop	r29
    6e14:	08 95       	ret

00006e16 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    6e16:	df 93       	push	r29
    6e18:	cf 93       	push	r28
    6e1a:	00 d0       	rcall	.+0      	; 0x6e1c <xQueueIsQueueFullFromISR+0x6>
    6e1c:	0f 92       	push	r0
    6e1e:	cd b7       	in	r28, 0x3d	; 61
    6e20:	de b7       	in	r29, 0x3e	; 62
    6e22:	9b 83       	std	Y+3, r25	; 0x03
    6e24:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    6e26:	ea 81       	ldd	r30, Y+2	; 0x02
    6e28:	fb 81       	ldd	r31, Y+3	; 0x03
    6e2a:	92 8d       	ldd	r25, Z+26	; 0x1a
    6e2c:	ea 81       	ldd	r30, Y+2	; 0x02
    6e2e:	fb 81       	ldd	r31, Y+3	; 0x03
    6e30:	83 8d       	ldd	r24, Z+27	; 0x1b
    6e32:	98 17       	cp	r25, r24
    6e34:	19 f4       	brne	.+6      	; 0x6e3c <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    6e36:	81 e0       	ldi	r24, 0x01	; 1
    6e38:	89 83       	std	Y+1, r24	; 0x01
    6e3a:	01 c0       	rjmp	.+2      	; 0x6e3e <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    6e3c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    6e3e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    6e40:	0f 90       	pop	r0
    6e42:	0f 90       	pop	r0
    6e44:	0f 90       	pop	r0
    6e46:	cf 91       	pop	r28
    6e48:	df 91       	pop	r29
    6e4a:	08 95       	ret

00006e4c <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    6e4c:	8f 92       	push	r8
    6e4e:	9f 92       	push	r9
    6e50:	af 92       	push	r10
    6e52:	bf 92       	push	r11
    6e54:	cf 92       	push	r12
    6e56:	df 92       	push	r13
    6e58:	ef 92       	push	r14
    6e5a:	ff 92       	push	r15
    6e5c:	0f 93       	push	r16
    6e5e:	1f 93       	push	r17
    6e60:	df 93       	push	r29
    6e62:	cf 93       	push	r28
    6e64:	cd b7       	in	r28, 0x3d	; 61
    6e66:	de b7       	in	r29, 0x3e	; 62
    6e68:	60 97       	sbiw	r28, 0x10	; 16
    6e6a:	0f b6       	in	r0, 0x3f	; 63
    6e6c:	f8 94       	cli
    6e6e:	de bf       	out	0x3e, r29	; 62
    6e70:	0f be       	out	0x3f, r0	; 63
    6e72:	cd bf       	out	0x3d, r28	; 61
    6e74:	9f 83       	std	Y+7, r25	; 0x07
    6e76:	8e 83       	std	Y+6, r24	; 0x06
    6e78:	79 87       	std	Y+9, r23	; 0x09
    6e7a:	68 87       	std	Y+8, r22	; 0x08
    6e7c:	5b 87       	std	Y+11, r21	; 0x0b
    6e7e:	4a 87       	std	Y+10, r20	; 0x0a
    6e80:	3d 87       	std	Y+13, r19	; 0x0d
    6e82:	2c 87       	std	Y+12, r18	; 0x0c
    6e84:	0e 87       	std	Y+14, r16	; 0x0e
    6e86:	f8 8a       	std	Y+16, r15	; 0x10
    6e88:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6e8a:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e8c:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e8e:	0e 94 38 2b 	call	0x5670	; 0x5670 <pvPortMalloc>
    6e92:	9a 83       	std	Y+2, r25	; 0x02
    6e94:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    6e96:	89 81       	ldd	r24, Y+1	; 0x01
    6e98:	9a 81       	ldd	r25, Y+2	; 0x02
    6e9a:	00 97       	sbiw	r24, 0x00	; 0
    6e9c:	b1 f0       	breq	.+44     	; 0x6eca <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    6e9e:	88 e2       	ldi	r24, 0x28	; 40
    6ea0:	90 e0       	ldi	r25, 0x00	; 0
    6ea2:	0e 94 38 2b 	call	0x5670	; 0x5670 <pvPortMalloc>
    6ea6:	9d 83       	std	Y+5, r25	; 0x05
    6ea8:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    6eaa:	8c 81       	ldd	r24, Y+4	; 0x04
    6eac:	9d 81       	ldd	r25, Y+5	; 0x05
    6eae:	00 97       	sbiw	r24, 0x00	; 0
    6eb0:	39 f0       	breq	.+14     	; 0x6ec0 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    6eb2:	ec 81       	ldd	r30, Y+4	; 0x04
    6eb4:	fd 81       	ldd	r31, Y+5	; 0x05
    6eb6:	89 81       	ldd	r24, Y+1	; 0x01
    6eb8:	9a 81       	ldd	r25, Y+2	; 0x02
    6eba:	90 8f       	std	Z+24, r25	; 0x18
    6ebc:	87 8b       	std	Z+23, r24	; 0x17
    6ebe:	07 c0       	rjmp	.+14     	; 0x6ece <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    6ec0:	89 81       	ldd	r24, Y+1	; 0x01
    6ec2:	9a 81       	ldd	r25, Y+2	; 0x02
    6ec4:	0e 94 20 2c 	call	0x5840	; 0x5840 <vPortFree>
    6ec8:	02 c0       	rjmp	.+4      	; 0x6ece <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    6eca:	1d 82       	std	Y+5, r1	; 0x05
    6ecc:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    6ece:	8c 81       	ldd	r24, Y+4	; 0x04
    6ed0:	9d 81       	ldd	r25, Y+5	; 0x05
    6ed2:	00 97       	sbiw	r24, 0x00	; 0
    6ed4:	e9 f0       	breq	.+58     	; 0x6f10 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    6ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
    6ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
    6eda:	9c 01       	movw	r18, r24
    6edc:	40 e0       	ldi	r20, 0x00	; 0
    6ede:	50 e0       	ldi	r21, 0x00	; 0
    6ee0:	8e 81       	ldd	r24, Y+6	; 0x06
    6ee2:	9f 81       	ldd	r25, Y+7	; 0x07
    6ee4:	68 85       	ldd	r22, Y+8	; 0x08
    6ee6:	79 85       	ldd	r23, Y+9	; 0x09
    6ee8:	ec 85       	ldd	r30, Y+12	; 0x0c
    6eea:	fd 85       	ldd	r31, Y+13	; 0x0d
    6eec:	af 85       	ldd	r26, Y+15	; 0x0f
    6eee:	b8 89       	ldd	r27, Y+16	; 0x10
    6ef0:	ac 80       	ldd	r10, Y+4	; 0x04
    6ef2:	bd 80       	ldd	r11, Y+5	; 0x05
    6ef4:	8f 01       	movw	r16, r30
    6ef6:	ee 84       	ldd	r14, Y+14	; 0x0e
    6ef8:	6d 01       	movw	r12, r26
    6efa:	88 24       	eor	r8, r8
    6efc:	99 24       	eor	r9, r9
    6efe:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    6f02:	8c 81       	ldd	r24, Y+4	; 0x04
    6f04:	9d 81       	ldd	r25, Y+5	; 0x05
    6f06:	0e 94 59 38 	call	0x70b2	; 0x70b2 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    6f0a:	81 e0       	ldi	r24, 0x01	; 1
    6f0c:	8b 83       	std	Y+3, r24	; 0x03
    6f0e:	02 c0       	rjmp	.+4      	; 0x6f14 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    6f10:	8f ef       	ldi	r24, 0xFF	; 255
    6f12:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    6f14:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    6f16:	60 96       	adiw	r28, 0x10	; 16
    6f18:	0f b6       	in	r0, 0x3f	; 63
    6f1a:	f8 94       	cli
    6f1c:	de bf       	out	0x3e, r29	; 62
    6f1e:	0f be       	out	0x3f, r0	; 63
    6f20:	cd bf       	out	0x3d, r28	; 61
    6f22:	cf 91       	pop	r28
    6f24:	df 91       	pop	r29
    6f26:	1f 91       	pop	r17
    6f28:	0f 91       	pop	r16
    6f2a:	ff 90       	pop	r15
    6f2c:	ef 90       	pop	r14
    6f2e:	df 90       	pop	r13
    6f30:	cf 90       	pop	r12
    6f32:	bf 90       	pop	r11
    6f34:	af 90       	pop	r10
    6f36:	9f 90       	pop	r9
    6f38:	8f 90       	pop	r8
    6f3a:	08 95       	ret

00006f3c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    6f3c:	8f 92       	push	r8
    6f3e:	9f 92       	push	r9
    6f40:	af 92       	push	r10
    6f42:	bf 92       	push	r11
    6f44:	cf 92       	push	r12
    6f46:	df 92       	push	r13
    6f48:	ef 92       	push	r14
    6f4a:	0f 93       	push	r16
    6f4c:	1f 93       	push	r17
    6f4e:	df 93       	push	r29
    6f50:	cf 93       	push	r28
    6f52:	cd b7       	in	r28, 0x3d	; 61
    6f54:	de b7       	in	r29, 0x3e	; 62
    6f56:	64 97       	sbiw	r28, 0x14	; 20
    6f58:	0f b6       	in	r0, 0x3f	; 63
    6f5a:	f8 94       	cli
    6f5c:	de bf       	out	0x3e, r29	; 62
    6f5e:	0f be       	out	0x3f, r0	; 63
    6f60:	cd bf       	out	0x3d, r28	; 61
    6f62:	9d 83       	std	Y+5, r25	; 0x05
    6f64:	8c 83       	std	Y+4, r24	; 0x04
    6f66:	7f 83       	std	Y+7, r23	; 0x07
    6f68:	6e 83       	std	Y+6, r22	; 0x06
    6f6a:	28 87       	std	Y+8, r18	; 0x08
    6f6c:	39 87       	std	Y+9, r19	; 0x09
    6f6e:	4a 87       	std	Y+10, r20	; 0x0a
    6f70:	5b 87       	std	Y+11, r21	; 0x0b
    6f72:	1d 87       	std	Y+13, r17	; 0x0d
    6f74:	0c 87       	std	Y+12, r16	; 0x0c
    6f76:	ee 86       	std	Y+14, r14	; 0x0e
    6f78:	d8 8a       	std	Y+16, r13	; 0x10
    6f7a:	cf 86       	std	Y+15, r12	; 0x0f
    6f7c:	ba 8a       	std	Y+18, r11	; 0x12
    6f7e:	a9 8a       	std	Y+17, r10	; 0x11
    6f80:	9c 8a       	std	Y+20, r9	; 0x14
    6f82:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    6f84:	e9 89       	ldd	r30, Y+17	; 0x11
    6f86:	fa 89       	ldd	r31, Y+18	; 0x12
    6f88:	27 89       	ldd	r18, Z+23	; 0x17
    6f8a:	30 8d       	ldd	r19, Z+24	; 0x18
    6f8c:	88 85       	ldd	r24, Y+8	; 0x08
    6f8e:	99 85       	ldd	r25, Y+9	; 0x09
    6f90:	01 97       	sbiw	r24, 0x01	; 1
    6f92:	82 0f       	add	r24, r18
    6f94:	93 1f       	adc	r25, r19
    6f96:	9b 83       	std	Y+3, r25	; 0x03
    6f98:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    6f9a:	19 82       	std	Y+1, r1	; 0x01
    6f9c:	21 c0       	rjmp	.+66     	; 0x6fe0 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    6f9e:	89 81       	ldd	r24, Y+1	; 0x01
    6fa0:	48 2f       	mov	r20, r24
    6fa2:	50 e0       	ldi	r21, 0x00	; 0
    6fa4:	89 81       	ldd	r24, Y+1	; 0x01
    6fa6:	28 2f       	mov	r18, r24
    6fa8:	30 e0       	ldi	r19, 0x00	; 0
    6faa:	8e 81       	ldd	r24, Y+6	; 0x06
    6fac:	9f 81       	ldd	r25, Y+7	; 0x07
    6fae:	fc 01       	movw	r30, r24
    6fb0:	e2 0f       	add	r30, r18
    6fb2:	f3 1f       	adc	r31, r19
    6fb4:	20 81       	ld	r18, Z
    6fb6:	89 89       	ldd	r24, Y+17	; 0x11
    6fb8:	9a 89       	ldd	r25, Y+18	; 0x12
    6fba:	84 0f       	add	r24, r20
    6fbc:	95 1f       	adc	r25, r21
    6fbe:	fc 01       	movw	r30, r24
    6fc0:	79 96       	adiw	r30, 0x19	; 25
    6fc2:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    6fc4:	89 81       	ldd	r24, Y+1	; 0x01
    6fc6:	28 2f       	mov	r18, r24
    6fc8:	30 e0       	ldi	r19, 0x00	; 0
    6fca:	8e 81       	ldd	r24, Y+6	; 0x06
    6fcc:	9f 81       	ldd	r25, Y+7	; 0x07
    6fce:	fc 01       	movw	r30, r24
    6fd0:	e2 0f       	add	r30, r18
    6fd2:	f3 1f       	adc	r31, r19
    6fd4:	80 81       	ld	r24, Z
    6fd6:	88 23       	and	r24, r24
    6fd8:	31 f0       	breq	.+12     	; 0x6fe6 <prvInitialiseNewTask+0xaa>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    6fda:	89 81       	ldd	r24, Y+1	; 0x01
    6fdc:	8f 5f       	subi	r24, 0xFF	; 255
    6fde:	89 83       	std	Y+1, r24	; 0x01
    6fe0:	89 81       	ldd	r24, Y+1	; 0x01
    6fe2:	88 30       	cpi	r24, 0x08	; 8
    6fe4:	e0 f2       	brcs	.-72     	; 0x6f9e <prvInitialiseNewTask+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    6fe6:	e9 89       	ldd	r30, Y+17	; 0x11
    6fe8:	fa 89       	ldd	r31, Y+18	; 0x12
    6fea:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    6fec:	8e 85       	ldd	r24, Y+14	; 0x0e
    6fee:	89 30       	cpi	r24, 0x09	; 9
    6ff0:	10 f0       	brcs	.+4      	; 0x6ff6 <prvInitialiseNewTask+0xba>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    6ff2:	88 e0       	ldi	r24, 0x08	; 8
    6ff4:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    6ff6:	e9 89       	ldd	r30, Y+17	; 0x11
    6ff8:	fa 89       	ldd	r31, Y+18	; 0x12
    6ffa:	8e 85       	ldd	r24, Y+14	; 0x0e
    6ffc:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    6ffe:	e9 89       	ldd	r30, Y+17	; 0x11
    7000:	fa 89       	ldd	r31, Y+18	; 0x12
    7002:	8e 85       	ldd	r24, Y+14	; 0x0e
    7004:	81 a3       	std	Z+33, r24	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    7006:	e9 89       	ldd	r30, Y+17	; 0x11
    7008:	fa 89       	ldd	r31, Y+18	; 0x12
    700a:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    700c:	89 89       	ldd	r24, Y+17	; 0x11
    700e:	9a 89       	ldd	r25, Y+18	; 0x12
    7010:	02 96       	adiw	r24, 0x02	; 2
    7012:	0e 94 fe 2c 	call	0x59fc	; 0x59fc <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    7016:	89 89       	ldd	r24, Y+17	; 0x11
    7018:	9a 89       	ldd	r25, Y+18	; 0x12
    701a:	0c 96       	adiw	r24, 0x0c	; 12
    701c:	0e 94 fe 2c 	call	0x59fc	; 0x59fc <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    7020:	e9 89       	ldd	r30, Y+17	; 0x11
    7022:	fa 89       	ldd	r31, Y+18	; 0x12
    7024:	89 89       	ldd	r24, Y+17	; 0x11
    7026:	9a 89       	ldd	r25, Y+18	; 0x12
    7028:	91 87       	std	Z+9, r25	; 0x09
    702a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    702c:	8e 85       	ldd	r24, Y+14	; 0x0e
    702e:	28 2f       	mov	r18, r24
    7030:	30 e0       	ldi	r19, 0x00	; 0
    7032:	89 e0       	ldi	r24, 0x09	; 9
    7034:	90 e0       	ldi	r25, 0x00	; 0
    7036:	82 1b       	sub	r24, r18
    7038:	93 0b       	sbc	r25, r19
    703a:	e9 89       	ldd	r30, Y+17	; 0x11
    703c:	fa 89       	ldd	r31, Y+18	; 0x12
    703e:	95 87       	std	Z+13, r25	; 0x0d
    7040:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    7042:	e9 89       	ldd	r30, Y+17	; 0x11
    7044:	fa 89       	ldd	r31, Y+18	; 0x12
    7046:	89 89       	ldd	r24, Y+17	; 0x11
    7048:	9a 89       	ldd	r25, Y+18	; 0x12
    704a:	93 8b       	std	Z+19, r25	; 0x13
    704c:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    704e:	e9 89       	ldd	r30, Y+17	; 0x11
    7050:	fa 89       	ldd	r31, Y+18	; 0x12
    7052:	13 a2       	std	Z+35, r1	; 0x23
    7054:	14 a2       	std	Z+36, r1	; 0x24
    7056:	15 a2       	std	Z+37, r1	; 0x25
    7058:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    705a:	e9 89       	ldd	r30, Y+17	; 0x11
    705c:	fa 89       	ldd	r31, Y+18	; 0x12
    705e:	17 a2       	std	Z+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    7060:	8a 81       	ldd	r24, Y+2	; 0x02
    7062:	9b 81       	ldd	r25, Y+3	; 0x03
    7064:	2c 81       	ldd	r18, Y+4	; 0x04
    7066:	3d 81       	ldd	r19, Y+5	; 0x05
    7068:	4c 85       	ldd	r20, Y+12	; 0x0c
    706a:	5d 85       	ldd	r21, Y+13	; 0x0d
    706c:	b9 01       	movw	r22, r18
    706e:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <pxPortInitialiseStack>
    7072:	e9 89       	ldd	r30, Y+17	; 0x11
    7074:	fa 89       	ldd	r31, Y+18	; 0x12
    7076:	91 83       	std	Z+1, r25	; 0x01
    7078:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    707a:	8f 85       	ldd	r24, Y+15	; 0x0f
    707c:	98 89       	ldd	r25, Y+16	; 0x10
    707e:	00 97       	sbiw	r24, 0x00	; 0
    7080:	31 f0       	breq	.+12     	; 0x708e <prvInitialiseNewTask+0x152>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    7082:	ef 85       	ldd	r30, Y+15	; 0x0f
    7084:	f8 89       	ldd	r31, Y+16	; 0x10
    7086:	89 89       	ldd	r24, Y+17	; 0x11
    7088:	9a 89       	ldd	r25, Y+18	; 0x12
    708a:	91 83       	std	Z+1, r25	; 0x01
    708c:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    708e:	64 96       	adiw	r28, 0x14	; 20
    7090:	0f b6       	in	r0, 0x3f	; 63
    7092:	f8 94       	cli
    7094:	de bf       	out	0x3e, r29	; 62
    7096:	0f be       	out	0x3f, r0	; 63
    7098:	cd bf       	out	0x3d, r28	; 61
    709a:	cf 91       	pop	r28
    709c:	df 91       	pop	r29
    709e:	1f 91       	pop	r17
    70a0:	0f 91       	pop	r16
    70a2:	ef 90       	pop	r14
    70a4:	df 90       	pop	r13
    70a6:	cf 90       	pop	r12
    70a8:	bf 90       	pop	r11
    70aa:	af 90       	pop	r10
    70ac:	9f 90       	pop	r9
    70ae:	8f 90       	pop	r8
    70b0:	08 95       	ret

000070b2 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    70b2:	df 93       	push	r29
    70b4:	cf 93       	push	r28
    70b6:	00 d0       	rcall	.+0      	; 0x70b8 <prvAddNewTaskToReadyList+0x6>
    70b8:	cd b7       	in	r28, 0x3d	; 61
    70ba:	de b7       	in	r29, 0x3e	; 62
    70bc:	9a 83       	std	Y+2, r25	; 0x02
    70be:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    70c0:	0f b6       	in	r0, 0x3f	; 63
    70c2:	f8 94       	cli
    70c4:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    70c6:	80 91 8f 05 	lds	r24, 0x058F
    70ca:	8f 5f       	subi	r24, 0xFF	; 255
    70cc:	80 93 8f 05 	sts	0x058F, r24
		if( pxCurrentTCB == NULL )
    70d0:	80 91 8c 05 	lds	r24, 0x058C
    70d4:	90 91 8d 05 	lds	r25, 0x058D
    70d8:	00 97       	sbiw	r24, 0x00	; 0
    70da:	69 f4       	brne	.+26     	; 0x70f6 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    70dc:	89 81       	ldd	r24, Y+1	; 0x01
    70de:	9a 81       	ldd	r25, Y+2	; 0x02
    70e0:	90 93 8d 05 	sts	0x058D, r25
    70e4:	80 93 8c 05 	sts	0x058C, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    70e8:	80 91 8f 05 	lds	r24, 0x058F
    70ec:	81 30       	cpi	r24, 0x01	; 1
    70ee:	b9 f4       	brne	.+46     	; 0x711e <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    70f0:	0e 94 35 40 	call	0x806a	; 0x806a <prvInitialiseTaskLists>
    70f4:	14 c0       	rjmp	.+40     	; 0x711e <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    70f6:	80 91 93 05 	lds	r24, 0x0593
    70fa:	88 23       	and	r24, r24
    70fc:	81 f4       	brne	.+32     	; 0x711e <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    70fe:	e0 91 8c 05 	lds	r30, 0x058C
    7102:	f0 91 8d 05 	lds	r31, 0x058D
    7106:	96 89       	ldd	r25, Z+22	; 0x16
    7108:	e9 81       	ldd	r30, Y+1	; 0x01
    710a:	fa 81       	ldd	r31, Y+2	; 0x02
    710c:	86 89       	ldd	r24, Z+22	; 0x16
    710e:	89 17       	cp	r24, r25
    7110:	30 f0       	brcs	.+12     	; 0x711e <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    7112:	89 81       	ldd	r24, Y+1	; 0x01
    7114:	9a 81       	ldd	r25, Y+2	; 0x02
    7116:	90 93 8d 05 	sts	0x058D, r25
    711a:	80 93 8c 05 	sts	0x058C, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    711e:	80 91 97 05 	lds	r24, 0x0597
    7122:	8f 5f       	subi	r24, 0xFF	; 255
    7124:	80 93 97 05 	sts	0x0597, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    7128:	e9 81       	ldd	r30, Y+1	; 0x01
    712a:	fa 81       	ldd	r31, Y+2	; 0x02
    712c:	96 89       	ldd	r25, Z+22	; 0x16
    712e:	80 91 92 05 	lds	r24, 0x0592
    7132:	89 17       	cp	r24, r25
    7134:	28 f4       	brcc	.+10     	; 0x7140 <prvAddNewTaskToReadyList+0x8e>
    7136:	e9 81       	ldd	r30, Y+1	; 0x01
    7138:	fa 81       	ldd	r31, Y+2	; 0x02
    713a:	86 89       	ldd	r24, Z+22	; 0x16
    713c:	80 93 92 05 	sts	0x0592, r24
    7140:	e9 81       	ldd	r30, Y+1	; 0x01
    7142:	fa 81       	ldd	r31, Y+2	; 0x02
    7144:	86 89       	ldd	r24, Z+22	; 0x16
    7146:	28 2f       	mov	r18, r24
    7148:	30 e0       	ldi	r19, 0x00	; 0
    714a:	c9 01       	movw	r24, r18
    714c:	88 0f       	add	r24, r24
    714e:	99 1f       	adc	r25, r25
    7150:	88 0f       	add	r24, r24
    7152:	99 1f       	adc	r25, r25
    7154:	88 0f       	add	r24, r24
    7156:	99 1f       	adc	r25, r25
    7158:	82 0f       	add	r24, r18
    715a:	93 1f       	adc	r25, r19
    715c:	ac 01       	movw	r20, r24
    715e:	43 56       	subi	r20, 0x63	; 99
    7160:	5a 4f       	sbci	r21, 0xFA	; 250
    7162:	89 81       	ldd	r24, Y+1	; 0x01
    7164:	9a 81       	ldd	r25, Y+2	; 0x02
    7166:	9c 01       	movw	r18, r24
    7168:	2e 5f       	subi	r18, 0xFE	; 254
    716a:	3f 4f       	sbci	r19, 0xFF	; 255
    716c:	ca 01       	movw	r24, r20
    716e:	b9 01       	movw	r22, r18
    7170:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    7174:	0f 90       	pop	r0
    7176:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    7178:	80 91 93 05 	lds	r24, 0x0593
    717c:	88 23       	and	r24, r24
    717e:	61 f0       	breq	.+24     	; 0x7198 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    7180:	e0 91 8c 05 	lds	r30, 0x058C
    7184:	f0 91 8d 05 	lds	r31, 0x058D
    7188:	96 89       	ldd	r25, Z+22	; 0x16
    718a:	e9 81       	ldd	r30, Y+1	; 0x01
    718c:	fa 81       	ldd	r31, Y+2	; 0x02
    718e:	86 89       	ldd	r24, Z+22	; 0x16
    7190:	98 17       	cp	r25, r24
    7192:	10 f4       	brcc	.+4      	; 0x7198 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    7194:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    7198:	0f 90       	pop	r0
    719a:	0f 90       	pop	r0
    719c:	cf 91       	pop	r28
    719e:	df 91       	pop	r29
    71a0:	08 95       	ret

000071a2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    71a2:	df 93       	push	r29
    71a4:	cf 93       	push	r28
    71a6:	00 d0       	rcall	.+0      	; 0x71a8 <vTaskDelete+0x6>
    71a8:	00 d0       	rcall	.+0      	; 0x71aa <vTaskDelete+0x8>
    71aa:	00 d0       	rcall	.+0      	; 0x71ac <vTaskDelete+0xa>
    71ac:	cd b7       	in	r28, 0x3d	; 61
    71ae:	de b7       	in	r29, 0x3e	; 62
    71b0:	9c 83       	std	Y+4, r25	; 0x04
    71b2:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    71b4:	0f b6       	in	r0, 0x3f	; 63
    71b6:	f8 94       	cli
    71b8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    71ba:	8b 81       	ldd	r24, Y+3	; 0x03
    71bc:	9c 81       	ldd	r25, Y+4	; 0x04
    71be:	00 97       	sbiw	r24, 0x00	; 0
    71c0:	39 f4       	brne	.+14     	; 0x71d0 <vTaskDelete+0x2e>
    71c2:	80 91 8c 05 	lds	r24, 0x058C
    71c6:	90 91 8d 05 	lds	r25, 0x058D
    71ca:	9e 83       	std	Y+6, r25	; 0x06
    71cc:	8d 83       	std	Y+5, r24	; 0x05
    71ce:	04 c0       	rjmp	.+8      	; 0x71d8 <vTaskDelete+0x36>
    71d0:	8b 81       	ldd	r24, Y+3	; 0x03
    71d2:	9c 81       	ldd	r25, Y+4	; 0x04
    71d4:	9e 83       	std	Y+6, r25	; 0x06
    71d6:	8d 83       	std	Y+5, r24	; 0x05
    71d8:	8d 81       	ldd	r24, Y+5	; 0x05
    71da:	9e 81       	ldd	r25, Y+6	; 0x06
    71dc:	9a 83       	std	Y+2, r25	; 0x02
    71de:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    71e0:	89 81       	ldd	r24, Y+1	; 0x01
    71e2:	9a 81       	ldd	r25, Y+2	; 0x02
    71e4:	02 96       	adiw	r24, 0x02	; 2
    71e6:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    71ea:	e9 81       	ldd	r30, Y+1	; 0x01
    71ec:	fa 81       	ldd	r31, Y+2	; 0x02
    71ee:	84 89       	ldd	r24, Z+20	; 0x14
    71f0:	95 89       	ldd	r25, Z+21	; 0x15
    71f2:	00 97       	sbiw	r24, 0x00	; 0
    71f4:	29 f0       	breq	.+10     	; 0x7200 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    71f6:	89 81       	ldd	r24, Y+1	; 0x01
    71f8:	9a 81       	ldd	r25, Y+2	; 0x02
    71fa:	0c 96       	adiw	r24, 0x0c	; 12
    71fc:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    7200:	80 91 97 05 	lds	r24, 0x0597
    7204:	8f 5f       	subi	r24, 0xFF	; 255
    7206:	80 93 97 05 	sts	0x0597, r24

			if( pxTCB == pxCurrentTCB )
    720a:	20 91 8c 05 	lds	r18, 0x058C
    720e:	30 91 8d 05 	lds	r19, 0x058D
    7212:	89 81       	ldd	r24, Y+1	; 0x01
    7214:	9a 81       	ldd	r25, Y+2	; 0x02
    7216:	82 17       	cp	r24, r18
    7218:	93 07       	cpc	r25, r19
    721a:	81 f4       	brne	.+32     	; 0x723c <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    721c:	89 81       	ldd	r24, Y+1	; 0x01
    721e:	9a 81       	ldd	r25, Y+2	; 0x02
    7220:	9c 01       	movw	r18, r24
    7222:	2e 5f       	subi	r18, 0xFE	; 254
    7224:	3f 4f       	sbci	r19, 0xFF	; 255
    7226:	8d e0       	ldi	r24, 0x0D	; 13
    7228:	96 e0       	ldi	r25, 0x06	; 6
    722a:	b9 01       	movw	r22, r18
    722c:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    7230:	80 91 8e 05 	lds	r24, 0x058E
    7234:	8f 5f       	subi	r24, 0xFF	; 255
    7236:	80 93 8e 05 	sts	0x058E, r24
    723a:	0b c0       	rjmp	.+22     	; 0x7252 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    723c:	80 91 8f 05 	lds	r24, 0x058F
    7240:	81 50       	subi	r24, 0x01	; 1
    7242:	80 93 8f 05 	sts	0x058F, r24
				prvDeleteTCB( pxTCB );
    7246:	89 81       	ldd	r24, Y+1	; 0x01
    7248:	9a 81       	ldd	r25, Y+2	; 0x02
    724a:	0e 94 b5 40 	call	0x816a	; 0x816a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    724e:	0e 94 cb 40 	call	0x8196	; 0x8196 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    7252:	0f 90       	pop	r0
    7254:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    7256:	80 91 93 05 	lds	r24, 0x0593
    725a:	88 23       	and	r24, r24
    725c:	59 f0       	breq	.+22     	; 0x7274 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    725e:	20 91 8c 05 	lds	r18, 0x058C
    7262:	30 91 8d 05 	lds	r19, 0x058D
    7266:	89 81       	ldd	r24, Y+1	; 0x01
    7268:	9a 81       	ldd	r25, Y+2	; 0x02
    726a:	82 17       	cp	r24, r18
    726c:	93 07       	cpc	r25, r19
    726e:	11 f4       	brne	.+4      	; 0x7274 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    7270:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    7274:	26 96       	adiw	r28, 0x06	; 6
    7276:	0f b6       	in	r0, 0x3f	; 63
    7278:	f8 94       	cli
    727a:	de bf       	out	0x3e, r29	; 62
    727c:	0f be       	out	0x3f, r0	; 63
    727e:	cd bf       	out	0x3d, r28	; 61
    7280:	cf 91       	pop	r28
    7282:	df 91       	pop	r29
    7284:	08 95       	ret

00007286 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    7286:	df 93       	push	r29
    7288:	cf 93       	push	r28
    728a:	cd b7       	in	r28, 0x3d	; 61
    728c:	de b7       	in	r29, 0x3e	; 62
    728e:	2a 97       	sbiw	r28, 0x0a	; 10
    7290:	0f b6       	in	r0, 0x3f	; 63
    7292:	f8 94       	cli
    7294:	de bf       	out	0x3e, r29	; 62
    7296:	0f be       	out	0x3f, r0	; 63
    7298:	cd bf       	out	0x3d, r28	; 61
    729a:	98 87       	std	Y+8, r25	; 0x08
    729c:	8f 83       	std	Y+7, r24	; 0x07
    729e:	7a 87       	std	Y+10, r23	; 0x0a
    72a0:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    72a2:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    72a4:	0e 94 44 3c 	call	0x7888	; 0x7888 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    72a8:	80 91 90 05 	lds	r24, 0x0590
    72ac:	90 91 91 05 	lds	r25, 0x0591
    72b0:	9a 83       	std	Y+2, r25	; 0x02
    72b2:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    72b4:	ef 81       	ldd	r30, Y+7	; 0x07
    72b6:	f8 85       	ldd	r31, Y+8	; 0x08
    72b8:	20 81       	ld	r18, Z
    72ba:	31 81       	ldd	r19, Z+1	; 0x01
    72bc:	89 85       	ldd	r24, Y+9	; 0x09
    72be:	9a 85       	ldd	r25, Y+10	; 0x0a
    72c0:	82 0f       	add	r24, r18
    72c2:	93 1f       	adc	r25, r19
    72c4:	9e 83       	std	Y+6, r25	; 0x06
    72c6:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    72c8:	ef 81       	ldd	r30, Y+7	; 0x07
    72ca:	f8 85       	ldd	r31, Y+8	; 0x08
    72cc:	20 81       	ld	r18, Z
    72ce:	31 81       	ldd	r19, Z+1	; 0x01
    72d0:	89 81       	ldd	r24, Y+1	; 0x01
    72d2:	9a 81       	ldd	r25, Y+2	; 0x02
    72d4:	82 17       	cp	r24, r18
    72d6:	93 07       	cpc	r25, r19
    72d8:	98 f4       	brcc	.+38     	; 0x7300 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    72da:	ef 81       	ldd	r30, Y+7	; 0x07
    72dc:	f8 85       	ldd	r31, Y+8	; 0x08
    72de:	20 81       	ld	r18, Z
    72e0:	31 81       	ldd	r19, Z+1	; 0x01
    72e2:	8d 81       	ldd	r24, Y+5	; 0x05
    72e4:	9e 81       	ldd	r25, Y+6	; 0x06
    72e6:	82 17       	cp	r24, r18
    72e8:	93 07       	cpc	r25, r19
    72ea:	e0 f4       	brcc	.+56     	; 0x7324 <vTaskDelayUntil+0x9e>
    72ec:	2d 81       	ldd	r18, Y+5	; 0x05
    72ee:	3e 81       	ldd	r19, Y+6	; 0x06
    72f0:	89 81       	ldd	r24, Y+1	; 0x01
    72f2:	9a 81       	ldd	r25, Y+2	; 0x02
    72f4:	82 17       	cp	r24, r18
    72f6:	93 07       	cpc	r25, r19
    72f8:	a8 f4       	brcc	.+42     	; 0x7324 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    72fa:	81 e0       	ldi	r24, 0x01	; 1
    72fc:	8b 83       	std	Y+3, r24	; 0x03
    72fe:	12 c0       	rjmp	.+36     	; 0x7324 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    7300:	ef 81       	ldd	r30, Y+7	; 0x07
    7302:	f8 85       	ldd	r31, Y+8	; 0x08
    7304:	20 81       	ld	r18, Z
    7306:	31 81       	ldd	r19, Z+1	; 0x01
    7308:	8d 81       	ldd	r24, Y+5	; 0x05
    730a:	9e 81       	ldd	r25, Y+6	; 0x06
    730c:	82 17       	cp	r24, r18
    730e:	93 07       	cpc	r25, r19
    7310:	38 f0       	brcs	.+14     	; 0x7320 <vTaskDelayUntil+0x9a>
    7312:	2d 81       	ldd	r18, Y+5	; 0x05
    7314:	3e 81       	ldd	r19, Y+6	; 0x06
    7316:	89 81       	ldd	r24, Y+1	; 0x01
    7318:	9a 81       	ldd	r25, Y+2	; 0x02
    731a:	82 17       	cp	r24, r18
    731c:	93 07       	cpc	r25, r19
    731e:	10 f4       	brcc	.+4      	; 0x7324 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    7320:	81 e0       	ldi	r24, 0x01	; 1
    7322:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    7324:	ef 81       	ldd	r30, Y+7	; 0x07
    7326:	f8 85       	ldd	r31, Y+8	; 0x08
    7328:	8d 81       	ldd	r24, Y+5	; 0x05
    732a:	9e 81       	ldd	r25, Y+6	; 0x06
    732c:	91 83       	std	Z+1, r25	; 0x01
    732e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    7330:	8b 81       	ldd	r24, Y+3	; 0x03
    7332:	88 23       	and	r24, r24
    7334:	49 f0       	breq	.+18     	; 0x7348 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    7336:	8d 81       	ldd	r24, Y+5	; 0x05
    7338:	9e 81       	ldd	r25, Y+6	; 0x06
    733a:	29 81       	ldd	r18, Y+1	; 0x01
    733c:	3a 81       	ldd	r19, Y+2	; 0x02
    733e:	82 1b       	sub	r24, r18
    7340:	93 0b       	sbc	r25, r19
    7342:	60 e0       	ldi	r22, 0x00	; 0
    7344:	0e 94 ee 45 	call	0x8bdc	; 0x8bdc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    7348:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>
    734c:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    734e:	8c 81       	ldd	r24, Y+4	; 0x04
    7350:	88 23       	and	r24, r24
    7352:	11 f4       	brne	.+4      	; 0x7358 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    7354:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    7358:	2a 96       	adiw	r28, 0x0a	; 10
    735a:	0f b6       	in	r0, 0x3f	; 63
    735c:	f8 94       	cli
    735e:	de bf       	out	0x3e, r29	; 62
    7360:	0f be       	out	0x3f, r0	; 63
    7362:	cd bf       	out	0x3d, r28	; 61
    7364:	cf 91       	pop	r28
    7366:	df 91       	pop	r29
    7368:	08 95       	ret

0000736a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    736a:	df 93       	push	r29
    736c:	cf 93       	push	r28
    736e:	00 d0       	rcall	.+0      	; 0x7370 <vTaskDelay+0x6>
    7370:	0f 92       	push	r0
    7372:	cd b7       	in	r28, 0x3d	; 61
    7374:	de b7       	in	r29, 0x3e	; 62
    7376:	9b 83       	std	Y+3, r25	; 0x03
    7378:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    737a:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    737c:	8a 81       	ldd	r24, Y+2	; 0x02
    737e:	9b 81       	ldd	r25, Y+3	; 0x03
    7380:	00 97       	sbiw	r24, 0x00	; 0
    7382:	51 f0       	breq	.+20     	; 0x7398 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    7384:	0e 94 44 3c 	call	0x7888	; 0x7888 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    7388:	8a 81       	ldd	r24, Y+2	; 0x02
    738a:	9b 81       	ldd	r25, Y+3	; 0x03
    738c:	60 e0       	ldi	r22, 0x00	; 0
    738e:	0e 94 ee 45 	call	0x8bdc	; 0x8bdc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    7392:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>
    7396:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    7398:	89 81       	ldd	r24, Y+1	; 0x01
    739a:	88 23       	and	r24, r24
    739c:	11 f4       	brne	.+4      	; 0x73a2 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    739e:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    73a2:	0f 90       	pop	r0
    73a4:	0f 90       	pop	r0
    73a6:	0f 90       	pop	r0
    73a8:	cf 91       	pop	r28
    73aa:	df 91       	pop	r29
    73ac:	08 95       	ret

000073ae <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    73ae:	df 93       	push	r29
    73b0:	cf 93       	push	r28
    73b2:	cd b7       	in	r28, 0x3d	; 61
    73b4:	de b7       	in	r29, 0x3e	; 62
    73b6:	2a 97       	sbiw	r28, 0x0a	; 10
    73b8:	0f b6       	in	r0, 0x3f	; 63
    73ba:	f8 94       	cli
    73bc:	de bf       	out	0x3e, r29	; 62
    73be:	0f be       	out	0x3f, r0	; 63
    73c0:	cd bf       	out	0x3d, r28	; 61
    73c2:	9f 83       	std	Y+7, r25	; 0x07
    73c4:	8e 83       	std	Y+6, r24	; 0x06
    73c6:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    73c8:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    73ca:	88 85       	ldd	r24, Y+8	; 0x08
    73cc:	89 30       	cpi	r24, 0x09	; 9
    73ce:	10 f0       	brcs	.+4      	; 0x73d4 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    73d0:	88 e0       	ldi	r24, 0x08	; 8
    73d2:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    73d4:	0f b6       	in	r0, 0x3f	; 63
    73d6:	f8 94       	cli
    73d8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    73da:	8e 81       	ldd	r24, Y+6	; 0x06
    73dc:	9f 81       	ldd	r25, Y+7	; 0x07
    73de:	00 97       	sbiw	r24, 0x00	; 0
    73e0:	39 f4       	brne	.+14     	; 0x73f0 <vTaskPrioritySet+0x42>
    73e2:	80 91 8c 05 	lds	r24, 0x058C
    73e6:	90 91 8d 05 	lds	r25, 0x058D
    73ea:	9a 87       	std	Y+10, r25	; 0x0a
    73ec:	89 87       	std	Y+9, r24	; 0x09
    73ee:	04 c0       	rjmp	.+8      	; 0x73f8 <vTaskPrioritySet+0x4a>
    73f0:	8e 81       	ldd	r24, Y+6	; 0x06
    73f2:	9f 81       	ldd	r25, Y+7	; 0x07
    73f4:	9a 87       	std	Y+10, r25	; 0x0a
    73f6:	89 87       	std	Y+9, r24	; 0x09
    73f8:	89 85       	ldd	r24, Y+9	; 0x09
    73fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    73fc:	9d 83       	std	Y+5, r25	; 0x05
    73fe:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    7400:	ec 81       	ldd	r30, Y+4	; 0x04
    7402:	fd 81       	ldd	r31, Y+5	; 0x05
    7404:	81 a1       	ldd	r24, Z+33	; 0x21
    7406:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    7408:	9b 81       	ldd	r25, Y+3	; 0x03
    740a:	88 85       	ldd	r24, Y+8	; 0x08
    740c:	98 17       	cp	r25, r24
    740e:	09 f4       	brne	.+2      	; 0x7412 <vTaskPrioritySet+0x64>
    7410:	8d c0       	rjmp	.+282    	; 0x752c <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    7412:	98 85       	ldd	r25, Y+8	; 0x08
    7414:	8b 81       	ldd	r24, Y+3	; 0x03
    7416:	89 17       	cp	r24, r25
    7418:	a0 f4       	brcc	.+40     	; 0x7442 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    741a:	20 91 8c 05 	lds	r18, 0x058C
    741e:	30 91 8d 05 	lds	r19, 0x058D
    7422:	8c 81       	ldd	r24, Y+4	; 0x04
    7424:	9d 81       	ldd	r25, Y+5	; 0x05
    7426:	82 17       	cp	r24, r18
    7428:	93 07       	cpc	r25, r19
    742a:	b1 f0       	breq	.+44     	; 0x7458 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    742c:	e0 91 8c 05 	lds	r30, 0x058C
    7430:	f0 91 8d 05 	lds	r31, 0x058D
    7434:	96 89       	ldd	r25, Z+22	; 0x16
    7436:	88 85       	ldd	r24, Y+8	; 0x08
    7438:	89 17       	cp	r24, r25
    743a:	70 f0       	brcs	.+28     	; 0x7458 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    743c:	81 e0       	ldi	r24, 0x01	; 1
    743e:	89 83       	std	Y+1, r24	; 0x01
    7440:	0b c0       	rjmp	.+22     	; 0x7458 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    7442:	20 91 8c 05 	lds	r18, 0x058C
    7446:	30 91 8d 05 	lds	r19, 0x058D
    744a:	8c 81       	ldd	r24, Y+4	; 0x04
    744c:	9d 81       	ldd	r25, Y+5	; 0x05
    744e:	82 17       	cp	r24, r18
    7450:	93 07       	cpc	r25, r19
    7452:	11 f4       	brne	.+4      	; 0x7458 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    7454:	81 e0       	ldi	r24, 0x01	; 1
    7456:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    7458:	ec 81       	ldd	r30, Y+4	; 0x04
    745a:	fd 81       	ldd	r31, Y+5	; 0x05
    745c:	86 89       	ldd	r24, Z+22	; 0x16
    745e:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    7460:	ec 81       	ldd	r30, Y+4	; 0x04
    7462:	fd 81       	ldd	r31, Y+5	; 0x05
    7464:	91 a1       	ldd	r25, Z+33	; 0x21
    7466:	ec 81       	ldd	r30, Y+4	; 0x04
    7468:	fd 81       	ldd	r31, Y+5	; 0x05
    746a:	86 89       	ldd	r24, Z+22	; 0x16
    746c:	98 17       	cp	r25, r24
    746e:	21 f4       	brne	.+8      	; 0x7478 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    7470:	ec 81       	ldd	r30, Y+4	; 0x04
    7472:	fd 81       	ldd	r31, Y+5	; 0x05
    7474:	88 85       	ldd	r24, Y+8	; 0x08
    7476:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    7478:	ec 81       	ldd	r30, Y+4	; 0x04
    747a:	fd 81       	ldd	r31, Y+5	; 0x05
    747c:	88 85       	ldd	r24, Y+8	; 0x08
    747e:	81 a3       	std	Z+33, r24	; 0x21
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    7480:	ec 81       	ldd	r30, Y+4	; 0x04
    7482:	fd 81       	ldd	r31, Y+5	; 0x05
    7484:	84 85       	ldd	r24, Z+12	; 0x0c
    7486:	95 85       	ldd	r25, Z+13	; 0x0d
    7488:	99 23       	and	r25, r25
    748a:	5c f0       	brlt	.+22     	; 0x74a2 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    748c:	88 85       	ldd	r24, Y+8	; 0x08
    748e:	28 2f       	mov	r18, r24
    7490:	30 e0       	ldi	r19, 0x00	; 0
    7492:	89 e0       	ldi	r24, 0x09	; 9
    7494:	90 e0       	ldi	r25, 0x00	; 0
    7496:	82 1b       	sub	r24, r18
    7498:	93 0b       	sbc	r25, r19
    749a:	ec 81       	ldd	r30, Y+4	; 0x04
    749c:	fd 81       	ldd	r31, Y+5	; 0x05
    749e:	95 87       	std	Z+13, r25	; 0x0d
    74a0:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    74a2:	ec 81       	ldd	r30, Y+4	; 0x04
    74a4:	fd 81       	ldd	r31, Y+5	; 0x05
    74a6:	42 85       	ldd	r20, Z+10	; 0x0a
    74a8:	53 85       	ldd	r21, Z+11	; 0x0b
    74aa:	8a 81       	ldd	r24, Y+2	; 0x02
    74ac:	28 2f       	mov	r18, r24
    74ae:	30 e0       	ldi	r19, 0x00	; 0
    74b0:	c9 01       	movw	r24, r18
    74b2:	88 0f       	add	r24, r24
    74b4:	99 1f       	adc	r25, r25
    74b6:	88 0f       	add	r24, r24
    74b8:	99 1f       	adc	r25, r25
    74ba:	88 0f       	add	r24, r24
    74bc:	99 1f       	adc	r25, r25
    74be:	82 0f       	add	r24, r18
    74c0:	93 1f       	adc	r25, r19
    74c2:	83 56       	subi	r24, 0x63	; 99
    74c4:	9a 4f       	sbci	r25, 0xFA	; 250
    74c6:	48 17       	cp	r20, r24
    74c8:	59 07       	cpc	r21, r25
    74ca:	59 f5       	brne	.+86     	; 0x7522 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    74cc:	8c 81       	ldd	r24, Y+4	; 0x04
    74ce:	9d 81       	ldd	r25, Y+5	; 0x05
    74d0:	02 96       	adiw	r24, 0x02	; 2
    74d2:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    74d6:	ec 81       	ldd	r30, Y+4	; 0x04
    74d8:	fd 81       	ldd	r31, Y+5	; 0x05
    74da:	96 89       	ldd	r25, Z+22	; 0x16
    74dc:	80 91 92 05 	lds	r24, 0x0592
    74e0:	89 17       	cp	r24, r25
    74e2:	28 f4       	brcc	.+10     	; 0x74ee <vTaskPrioritySet+0x140>
    74e4:	ec 81       	ldd	r30, Y+4	; 0x04
    74e6:	fd 81       	ldd	r31, Y+5	; 0x05
    74e8:	86 89       	ldd	r24, Z+22	; 0x16
    74ea:	80 93 92 05 	sts	0x0592, r24
    74ee:	ec 81       	ldd	r30, Y+4	; 0x04
    74f0:	fd 81       	ldd	r31, Y+5	; 0x05
    74f2:	86 89       	ldd	r24, Z+22	; 0x16
    74f4:	28 2f       	mov	r18, r24
    74f6:	30 e0       	ldi	r19, 0x00	; 0
    74f8:	c9 01       	movw	r24, r18
    74fa:	88 0f       	add	r24, r24
    74fc:	99 1f       	adc	r25, r25
    74fe:	88 0f       	add	r24, r24
    7500:	99 1f       	adc	r25, r25
    7502:	88 0f       	add	r24, r24
    7504:	99 1f       	adc	r25, r25
    7506:	82 0f       	add	r24, r18
    7508:	93 1f       	adc	r25, r19
    750a:	ac 01       	movw	r20, r24
    750c:	43 56       	subi	r20, 0x63	; 99
    750e:	5a 4f       	sbci	r21, 0xFA	; 250
    7510:	8c 81       	ldd	r24, Y+4	; 0x04
    7512:	9d 81       	ldd	r25, Y+5	; 0x05
    7514:	9c 01       	movw	r18, r24
    7516:	2e 5f       	subi	r18, 0xFE	; 254
    7518:	3f 4f       	sbci	r19, 0xFF	; 255
    751a:	ca 01       	movw	r24, r20
    751c:	b9 01       	movw	r22, r18
    751e:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    7522:	89 81       	ldd	r24, Y+1	; 0x01
    7524:	88 23       	and	r24, r24
    7526:	11 f0       	breq	.+4      	; 0x752c <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    7528:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    752c:	0f 90       	pop	r0
    752e:	0f be       	out	0x3f, r0	; 63
	}
    7530:	2a 96       	adiw	r28, 0x0a	; 10
    7532:	0f b6       	in	r0, 0x3f	; 63
    7534:	f8 94       	cli
    7536:	de bf       	out	0x3e, r29	; 62
    7538:	0f be       	out	0x3f, r0	; 63
    753a:	cd bf       	out	0x3d, r28	; 61
    753c:	cf 91       	pop	r28
    753e:	df 91       	pop	r29
    7540:	08 95       	ret

00007542 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    7542:	df 93       	push	r29
    7544:	cf 93       	push	r28
    7546:	00 d0       	rcall	.+0      	; 0x7548 <vTaskSuspend+0x6>
    7548:	00 d0       	rcall	.+0      	; 0x754a <vTaskSuspend+0x8>
    754a:	00 d0       	rcall	.+0      	; 0x754c <vTaskSuspend+0xa>
    754c:	cd b7       	in	r28, 0x3d	; 61
    754e:	de b7       	in	r29, 0x3e	; 62
    7550:	9c 83       	std	Y+4, r25	; 0x04
    7552:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    7554:	0f b6       	in	r0, 0x3f	; 63
    7556:	f8 94       	cli
    7558:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    755a:	8b 81       	ldd	r24, Y+3	; 0x03
    755c:	9c 81       	ldd	r25, Y+4	; 0x04
    755e:	00 97       	sbiw	r24, 0x00	; 0
    7560:	39 f4       	brne	.+14     	; 0x7570 <vTaskSuspend+0x2e>
    7562:	80 91 8c 05 	lds	r24, 0x058C
    7566:	90 91 8d 05 	lds	r25, 0x058D
    756a:	9e 83       	std	Y+6, r25	; 0x06
    756c:	8d 83       	std	Y+5, r24	; 0x05
    756e:	04 c0       	rjmp	.+8      	; 0x7578 <vTaskSuspend+0x36>
    7570:	8b 81       	ldd	r24, Y+3	; 0x03
    7572:	9c 81       	ldd	r25, Y+4	; 0x04
    7574:	9e 83       	std	Y+6, r25	; 0x06
    7576:	8d 83       	std	Y+5, r24	; 0x05
    7578:	8d 81       	ldd	r24, Y+5	; 0x05
    757a:	9e 81       	ldd	r25, Y+6	; 0x06
    757c:	9a 83       	std	Y+2, r25	; 0x02
    757e:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7580:	89 81       	ldd	r24, Y+1	; 0x01
    7582:	9a 81       	ldd	r25, Y+2	; 0x02
    7584:	02 96       	adiw	r24, 0x02	; 2
    7586:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    758a:	e9 81       	ldd	r30, Y+1	; 0x01
    758c:	fa 81       	ldd	r31, Y+2	; 0x02
    758e:	84 89       	ldd	r24, Z+20	; 0x14
    7590:	95 89       	ldd	r25, Z+21	; 0x15
    7592:	00 97       	sbiw	r24, 0x00	; 0
    7594:	29 f0       	breq	.+10     	; 0x75a0 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    7596:	89 81       	ldd	r24, Y+1	; 0x01
    7598:	9a 81       	ldd	r25, Y+2	; 0x02
    759a:	0c 96       	adiw	r24, 0x0c	; 12
    759c:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    75a0:	89 81       	ldd	r24, Y+1	; 0x01
    75a2:	9a 81       	ldd	r25, Y+2	; 0x02
    75a4:	9c 01       	movw	r18, r24
    75a6:	2e 5f       	subi	r18, 0xFE	; 254
    75a8:	3f 4f       	sbci	r19, 0xFF	; 255
    75aa:	86 e1       	ldi	r24, 0x16	; 22
    75ac:	96 e0       	ldi	r25, 0x06	; 6
    75ae:	b9 01       	movw	r22, r18
    75b0:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    75b4:	0f 90       	pop	r0
    75b6:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    75b8:	80 91 93 05 	lds	r24, 0x0593
    75bc:	88 23       	and	r24, r24
    75be:	39 f0       	breq	.+14     	; 0x75ce <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    75c0:	0f b6       	in	r0, 0x3f	; 63
    75c2:	f8 94       	cli
    75c4:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    75c6:	0e 94 cb 40 	call	0x8196	; 0x8196 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    75ca:	0f 90       	pop	r0
    75cc:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    75ce:	20 91 8c 05 	lds	r18, 0x058C
    75d2:	30 91 8d 05 	lds	r19, 0x058D
    75d6:	89 81       	ldd	r24, Y+1	; 0x01
    75d8:	9a 81       	ldd	r25, Y+2	; 0x02
    75da:	82 17       	cp	r24, r18
    75dc:	93 07       	cpc	r25, r19
    75de:	a1 f4       	brne	.+40     	; 0x7608 <vTaskSuspend+0xc6>
		{
			if( xSchedulerRunning != pdFALSE )
    75e0:	80 91 93 05 	lds	r24, 0x0593
    75e4:	88 23       	and	r24, r24
    75e6:	19 f0       	breq	.+6      	; 0x75ee <vTaskSuspend+0xac>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    75e8:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
    75ec:	0d c0       	rjmp	.+26     	; 0x7608 <vTaskSuspend+0xc6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    75ee:	90 91 16 06 	lds	r25, 0x0616
    75f2:	80 91 8f 05 	lds	r24, 0x058F
    75f6:	98 17       	cp	r25, r24
    75f8:	29 f4       	brne	.+10     	; 0x7604 <vTaskSuspend+0xc2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    75fa:	10 92 8d 05 	sts	0x058D, r1
    75fe:	10 92 8c 05 	sts	0x058C, r1
    7602:	02 c0       	rjmp	.+4      	; 0x7608 <vTaskSuspend+0xc6>
				}
				else
				{
					vTaskSwitchContext();
    7604:	0e 94 0c 3e 	call	0x7c18	; 0x7c18 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    7608:	26 96       	adiw	r28, 0x06	; 6
    760a:	0f b6       	in	r0, 0x3f	; 63
    760c:	f8 94       	cli
    760e:	de bf       	out	0x3e, r29	; 62
    7610:	0f be       	out	0x3f, r0	; 63
    7612:	cd bf       	out	0x3d, r28	; 61
    7614:	cf 91       	pop	r28
    7616:	df 91       	pop	r29
    7618:	08 95       	ret

0000761a <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    761a:	df 93       	push	r29
    761c:	cf 93       	push	r28
    761e:	00 d0       	rcall	.+0      	; 0x7620 <prvTaskIsTaskSuspended+0x6>
    7620:	00 d0       	rcall	.+0      	; 0x7622 <prvTaskIsTaskSuspended+0x8>
    7622:	0f 92       	push	r0
    7624:	cd b7       	in	r28, 0x3d	; 61
    7626:	de b7       	in	r29, 0x3e	; 62
    7628:	9d 83       	std	Y+5, r25	; 0x05
    762a:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    762c:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    762e:	8c 81       	ldd	r24, Y+4	; 0x04
    7630:	9d 81       	ldd	r25, Y+5	; 0x05
    7632:	9a 83       	std	Y+2, r25	; 0x02
    7634:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    7636:	e9 81       	ldd	r30, Y+1	; 0x01
    7638:	fa 81       	ldd	r31, Y+2	; 0x02
    763a:	82 85       	ldd	r24, Z+10	; 0x0a
    763c:	93 85       	ldd	r25, Z+11	; 0x0b
    763e:	26 e0       	ldi	r18, 0x06	; 6
    7640:	86 31       	cpi	r24, 0x16	; 22
    7642:	92 07       	cpc	r25, r18
    7644:	81 f4       	brne	.+32     	; 0x7666 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    7646:	e9 81       	ldd	r30, Y+1	; 0x01
    7648:	fa 81       	ldd	r31, Y+2	; 0x02
    764a:	84 89       	ldd	r24, Z+20	; 0x14
    764c:	95 89       	ldd	r25, Z+21	; 0x15
    764e:	26 e0       	ldi	r18, 0x06	; 6
    7650:	84 30       	cpi	r24, 0x04	; 4
    7652:	92 07       	cpc	r25, r18
    7654:	41 f0       	breq	.+16     	; 0x7666 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    7656:	e9 81       	ldd	r30, Y+1	; 0x01
    7658:	fa 81       	ldd	r31, Y+2	; 0x02
    765a:	84 89       	ldd	r24, Z+20	; 0x14
    765c:	95 89       	ldd	r25, Z+21	; 0x15
    765e:	00 97       	sbiw	r24, 0x00	; 0
    7660:	11 f4       	brne	.+4      	; 0x7666 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    7662:	81 e0       	ldi	r24, 0x01	; 1
    7664:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    7666:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    7668:	0f 90       	pop	r0
    766a:	0f 90       	pop	r0
    766c:	0f 90       	pop	r0
    766e:	0f 90       	pop	r0
    7670:	0f 90       	pop	r0
    7672:	cf 91       	pop	r28
    7674:	df 91       	pop	r29
    7676:	08 95       	ret

00007678 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    7678:	df 93       	push	r29
    767a:	cf 93       	push	r28
    767c:	00 d0       	rcall	.+0      	; 0x767e <vTaskResume+0x6>
    767e:	00 d0       	rcall	.+0      	; 0x7680 <vTaskResume+0x8>
    7680:	cd b7       	in	r28, 0x3d	; 61
    7682:	de b7       	in	r29, 0x3e	; 62
    7684:	9c 83       	std	Y+4, r25	; 0x04
    7686:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    7688:	8b 81       	ldd	r24, Y+3	; 0x03
    768a:	9c 81       	ldd	r25, Y+4	; 0x04
    768c:	9a 83       	std	Y+2, r25	; 0x02
    768e:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    7690:	89 81       	ldd	r24, Y+1	; 0x01
    7692:	9a 81       	ldd	r25, Y+2	; 0x02
    7694:	00 97       	sbiw	r24, 0x00	; 0
    7696:	09 f4       	brne	.+2      	; 0x769a <vTaskResume+0x22>
    7698:	4c c0       	rjmp	.+152    	; 0x7732 <vTaskResume+0xba>
    769a:	20 91 8c 05 	lds	r18, 0x058C
    769e:	30 91 8d 05 	lds	r19, 0x058D
    76a2:	89 81       	ldd	r24, Y+1	; 0x01
    76a4:	9a 81       	ldd	r25, Y+2	; 0x02
    76a6:	82 17       	cp	r24, r18
    76a8:	93 07       	cpc	r25, r19
    76aa:	09 f4       	brne	.+2      	; 0x76ae <vTaskResume+0x36>
    76ac:	42 c0       	rjmp	.+132    	; 0x7732 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    76ae:	0f b6       	in	r0, 0x3f	; 63
    76b0:	f8 94       	cli
    76b2:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    76b4:	89 81       	ldd	r24, Y+1	; 0x01
    76b6:	9a 81       	ldd	r25, Y+2	; 0x02
    76b8:	0e 94 0d 3b 	call	0x761a	; 0x761a <prvTaskIsTaskSuspended>
    76bc:	88 23       	and	r24, r24
    76be:	b9 f1       	breq	.+110    	; 0x772e <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    76c0:	89 81       	ldd	r24, Y+1	; 0x01
    76c2:	9a 81       	ldd	r25, Y+2	; 0x02
    76c4:	02 96       	adiw	r24, 0x02	; 2
    76c6:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    76ca:	e9 81       	ldd	r30, Y+1	; 0x01
    76cc:	fa 81       	ldd	r31, Y+2	; 0x02
    76ce:	96 89       	ldd	r25, Z+22	; 0x16
    76d0:	80 91 92 05 	lds	r24, 0x0592
    76d4:	89 17       	cp	r24, r25
    76d6:	28 f4       	brcc	.+10     	; 0x76e2 <vTaskResume+0x6a>
    76d8:	e9 81       	ldd	r30, Y+1	; 0x01
    76da:	fa 81       	ldd	r31, Y+2	; 0x02
    76dc:	86 89       	ldd	r24, Z+22	; 0x16
    76de:	80 93 92 05 	sts	0x0592, r24
    76e2:	e9 81       	ldd	r30, Y+1	; 0x01
    76e4:	fa 81       	ldd	r31, Y+2	; 0x02
    76e6:	86 89       	ldd	r24, Z+22	; 0x16
    76e8:	28 2f       	mov	r18, r24
    76ea:	30 e0       	ldi	r19, 0x00	; 0
    76ec:	c9 01       	movw	r24, r18
    76ee:	88 0f       	add	r24, r24
    76f0:	99 1f       	adc	r25, r25
    76f2:	88 0f       	add	r24, r24
    76f4:	99 1f       	adc	r25, r25
    76f6:	88 0f       	add	r24, r24
    76f8:	99 1f       	adc	r25, r25
    76fa:	82 0f       	add	r24, r18
    76fc:	93 1f       	adc	r25, r19
    76fe:	ac 01       	movw	r20, r24
    7700:	43 56       	subi	r20, 0x63	; 99
    7702:	5a 4f       	sbci	r21, 0xFA	; 250
    7704:	89 81       	ldd	r24, Y+1	; 0x01
    7706:	9a 81       	ldd	r25, Y+2	; 0x02
    7708:	9c 01       	movw	r18, r24
    770a:	2e 5f       	subi	r18, 0xFE	; 254
    770c:	3f 4f       	sbci	r19, 0xFF	; 255
    770e:	ca 01       	movw	r24, r20
    7710:	b9 01       	movw	r22, r18
    7712:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    7716:	e9 81       	ldd	r30, Y+1	; 0x01
    7718:	fa 81       	ldd	r31, Y+2	; 0x02
    771a:	96 89       	ldd	r25, Z+22	; 0x16
    771c:	e0 91 8c 05 	lds	r30, 0x058C
    7720:	f0 91 8d 05 	lds	r31, 0x058D
    7724:	86 89       	ldd	r24, Z+22	; 0x16
    7726:	98 17       	cp	r25, r24
    7728:	10 f0       	brcs	.+4      	; 0x772e <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    772a:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    772e:	0f 90       	pop	r0
    7730:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    7732:	0f 90       	pop	r0
    7734:	0f 90       	pop	r0
    7736:	0f 90       	pop	r0
    7738:	0f 90       	pop	r0
    773a:	cf 91       	pop	r28
    773c:	df 91       	pop	r29
    773e:	08 95       	ret

00007740 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    7740:	df 93       	push	r29
    7742:	cf 93       	push	r28
    7744:	00 d0       	rcall	.+0      	; 0x7746 <xTaskResumeFromISR+0x6>
    7746:	00 d0       	rcall	.+0      	; 0x7748 <xTaskResumeFromISR+0x8>
    7748:	00 d0       	rcall	.+0      	; 0x774a <xTaskResumeFromISR+0xa>
    774a:	cd b7       	in	r28, 0x3d	; 61
    774c:	de b7       	in	r29, 0x3e	; 62
    774e:	9e 83       	std	Y+6, r25	; 0x06
    7750:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    7752:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    7754:	8d 81       	ldd	r24, Y+5	; 0x05
    7756:	9e 81       	ldd	r25, Y+6	; 0x06
    7758:	9b 83       	std	Y+3, r25	; 0x03
    775a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    775c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    775e:	8a 81       	ldd	r24, Y+2	; 0x02
    7760:	9b 81       	ldd	r25, Y+3	; 0x03
    7762:	0e 94 0d 3b 	call	0x761a	; 0x761a <prvTaskIsTaskSuspended>
    7766:	88 23       	and	r24, r24
    7768:	09 f4       	brne	.+2      	; 0x776c <xTaskResumeFromISR+0x2c>
    776a:	46 c0       	rjmp	.+140    	; 0x77f8 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    776c:	80 91 9c 05 	lds	r24, 0x059C
    7770:	88 23       	and	r24, r24
    7772:	c1 f5       	brne	.+112    	; 0x77e4 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    7774:	ea 81       	ldd	r30, Y+2	; 0x02
    7776:	fb 81       	ldd	r31, Y+3	; 0x03
    7778:	96 89       	ldd	r25, Z+22	; 0x16
    777a:	e0 91 8c 05 	lds	r30, 0x058C
    777e:	f0 91 8d 05 	lds	r31, 0x058D
    7782:	86 89       	ldd	r24, Z+22	; 0x16
    7784:	98 17       	cp	r25, r24
    7786:	10 f0       	brcs	.+4      	; 0x778c <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    7788:	81 e0       	ldi	r24, 0x01	; 1
    778a:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    778c:	8a 81       	ldd	r24, Y+2	; 0x02
    778e:	9b 81       	ldd	r25, Y+3	; 0x03
    7790:	02 96       	adiw	r24, 0x02	; 2
    7792:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    7796:	ea 81       	ldd	r30, Y+2	; 0x02
    7798:	fb 81       	ldd	r31, Y+3	; 0x03
    779a:	96 89       	ldd	r25, Z+22	; 0x16
    779c:	80 91 92 05 	lds	r24, 0x0592
    77a0:	89 17       	cp	r24, r25
    77a2:	28 f4       	brcc	.+10     	; 0x77ae <xTaskResumeFromISR+0x6e>
    77a4:	ea 81       	ldd	r30, Y+2	; 0x02
    77a6:	fb 81       	ldd	r31, Y+3	; 0x03
    77a8:	86 89       	ldd	r24, Z+22	; 0x16
    77aa:	80 93 92 05 	sts	0x0592, r24
    77ae:	ea 81       	ldd	r30, Y+2	; 0x02
    77b0:	fb 81       	ldd	r31, Y+3	; 0x03
    77b2:	86 89       	ldd	r24, Z+22	; 0x16
    77b4:	28 2f       	mov	r18, r24
    77b6:	30 e0       	ldi	r19, 0x00	; 0
    77b8:	c9 01       	movw	r24, r18
    77ba:	88 0f       	add	r24, r24
    77bc:	99 1f       	adc	r25, r25
    77be:	88 0f       	add	r24, r24
    77c0:	99 1f       	adc	r25, r25
    77c2:	88 0f       	add	r24, r24
    77c4:	99 1f       	adc	r25, r25
    77c6:	82 0f       	add	r24, r18
    77c8:	93 1f       	adc	r25, r19
    77ca:	ac 01       	movw	r20, r24
    77cc:	43 56       	subi	r20, 0x63	; 99
    77ce:	5a 4f       	sbci	r21, 0xFA	; 250
    77d0:	8a 81       	ldd	r24, Y+2	; 0x02
    77d2:	9b 81       	ldd	r25, Y+3	; 0x03
    77d4:	9c 01       	movw	r18, r24
    77d6:	2e 5f       	subi	r18, 0xFE	; 254
    77d8:	3f 4f       	sbci	r19, 0xFF	; 255
    77da:	ca 01       	movw	r24, r20
    77dc:	b9 01       	movw	r22, r18
    77de:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
    77e2:	0a c0       	rjmp	.+20     	; 0x77f8 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    77e4:	8a 81       	ldd	r24, Y+2	; 0x02
    77e6:	9b 81       	ldd	r25, Y+3	; 0x03
    77e8:	9c 01       	movw	r18, r24
    77ea:	24 5f       	subi	r18, 0xF4	; 244
    77ec:	3f 4f       	sbci	r19, 0xFF	; 255
    77ee:	84 e0       	ldi	r24, 0x04	; 4
    77f0:	96 e0       	ldi	r25, 0x06	; 6
    77f2:	b9 01       	movw	r22, r18
    77f4:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    77f8:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    77fa:	26 96       	adiw	r28, 0x06	; 6
    77fc:	0f b6       	in	r0, 0x3f	; 63
    77fe:	f8 94       	cli
    7800:	de bf       	out	0x3e, r29	; 62
    7802:	0f be       	out	0x3f, r0	; 63
    7804:	cd bf       	out	0x3d, r28	; 61
    7806:	cf 91       	pop	r28
    7808:	df 91       	pop	r29
    780a:	08 95       	ret

0000780c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    780c:	ef 92       	push	r14
    780e:	ff 92       	push	r15
    7810:	0f 93       	push	r16
    7812:	df 93       	push	r29
    7814:	cf 93       	push	r28
    7816:	0f 92       	push	r0
    7818:	cd b7       	in	r28, 0x3d	; 61
    781a:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    781c:	8b e2       	ldi	r24, 0x2B	; 43
    781e:	90 e4       	ldi	r25, 0x40	; 64
    7820:	20 e6       	ldi	r18, 0x60	; 96
    7822:	30 e0       	ldi	r19, 0x00	; 0
    7824:	ea e9       	ldi	r30, 0x9A	; 154
    7826:	f5 e0       	ldi	r31, 0x05	; 5
    7828:	b9 01       	movw	r22, r18
    782a:	40 e5       	ldi	r20, 0x50	; 80
    782c:	50 e0       	ldi	r21, 0x00	; 0
    782e:	20 e0       	ldi	r18, 0x00	; 0
    7830:	30 e0       	ldi	r19, 0x00	; 0
    7832:	00 e0       	ldi	r16, 0x00	; 0
    7834:	7f 01       	movw	r14, r30
    7836:	0e 94 26 37 	call	0x6e4c	; 0x6e4c <xTaskCreate>
    783a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    783c:	89 81       	ldd	r24, Y+1	; 0x01
    783e:	81 30       	cpi	r24, 0x01	; 1
    7840:	81 f4       	brne	.+32     	; 0x7862 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    7842:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    7844:	8f ef       	ldi	r24, 0xFF	; 255
    7846:	9f ef       	ldi	r25, 0xFF	; 255
    7848:	90 93 99 05 	sts	0x0599, r25
    784c:	80 93 98 05 	sts	0x0598, r24
		xSchedulerRunning = pdTRUE;
    7850:	81 e0       	ldi	r24, 0x01	; 1
    7852:	80 93 93 05 	sts	0x0593, r24
		xTickCount = ( TickType_t ) 0U;
    7856:	10 92 91 05 	sts	0x0591, r1
    785a:	10 92 90 05 	sts	0x0590, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    785e:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    7862:	0f 90       	pop	r0
    7864:	cf 91       	pop	r28
    7866:	df 91       	pop	r29
    7868:	0f 91       	pop	r16
    786a:	ff 90       	pop	r15
    786c:	ef 90       	pop	r14
    786e:	08 95       	ret

00007870 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    7870:	df 93       	push	r29
    7872:	cf 93       	push	r28
    7874:	cd b7       	in	r28, 0x3d	; 61
    7876:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    7878:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    787a:	10 92 93 05 	sts	0x0593, r1
	vPortEndScheduler();
    787e:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <vPortEndScheduler>
}
    7882:	cf 91       	pop	r28
    7884:	df 91       	pop	r29
    7886:	08 95       	ret

00007888 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    7888:	df 93       	push	r29
    788a:	cf 93       	push	r28
    788c:	cd b7       	in	r28, 0x3d	; 61
    788e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    7890:	80 91 9c 05 	lds	r24, 0x059C
    7894:	8f 5f       	subi	r24, 0xFF	; 255
    7896:	80 93 9c 05 	sts	0x059C, r24
}
    789a:	cf 91       	pop	r28
    789c:	df 91       	pop	r29
    789e:	08 95       	ret

000078a0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    78a0:	df 93       	push	r29
    78a2:	cf 93       	push	r28
    78a4:	00 d0       	rcall	.+0      	; 0x78a6 <xTaskResumeAll+0x6>
    78a6:	00 d0       	rcall	.+0      	; 0x78a8 <xTaskResumeAll+0x8>
    78a8:	cd b7       	in	r28, 0x3d	; 61
    78aa:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    78ac:	1c 82       	std	Y+4, r1	; 0x04
    78ae:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    78b0:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    78b2:	0f b6       	in	r0, 0x3f	; 63
    78b4:	f8 94       	cli
    78b6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    78b8:	80 91 9c 05 	lds	r24, 0x059C
    78bc:	81 50       	subi	r24, 0x01	; 1
    78be:	80 93 9c 05 	sts	0x059C, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    78c2:	80 91 9c 05 	lds	r24, 0x059C
    78c6:	88 23       	and	r24, r24
    78c8:	09 f0       	breq	.+2      	; 0x78cc <xTaskResumeAll+0x2c>
    78ca:	73 c0       	rjmp	.+230    	; 0x79b2 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    78cc:	80 91 8f 05 	lds	r24, 0x058F
    78d0:	88 23       	and	r24, r24
    78d2:	09 f4       	brne	.+2      	; 0x78d6 <xTaskResumeAll+0x36>
    78d4:	6e c0       	rjmp	.+220    	; 0x79b2 <xTaskResumeAll+0x112>
    78d6:	45 c0       	rjmp	.+138    	; 0x7962 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    78d8:	e0 91 09 06 	lds	r30, 0x0609
    78dc:	f0 91 0a 06 	lds	r31, 0x060A
    78e0:	86 81       	ldd	r24, Z+6	; 0x06
    78e2:	97 81       	ldd	r25, Z+7	; 0x07
    78e4:	9c 83       	std	Y+4, r25	; 0x04
    78e6:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    78e8:	8b 81       	ldd	r24, Y+3	; 0x03
    78ea:	9c 81       	ldd	r25, Y+4	; 0x04
    78ec:	0c 96       	adiw	r24, 0x0c	; 12
    78ee:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    78f2:	8b 81       	ldd	r24, Y+3	; 0x03
    78f4:	9c 81       	ldd	r25, Y+4	; 0x04
    78f6:	02 96       	adiw	r24, 0x02	; 2
    78f8:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    78fc:	eb 81       	ldd	r30, Y+3	; 0x03
    78fe:	fc 81       	ldd	r31, Y+4	; 0x04
    7900:	96 89       	ldd	r25, Z+22	; 0x16
    7902:	80 91 92 05 	lds	r24, 0x0592
    7906:	89 17       	cp	r24, r25
    7908:	28 f4       	brcc	.+10     	; 0x7914 <xTaskResumeAll+0x74>
    790a:	eb 81       	ldd	r30, Y+3	; 0x03
    790c:	fc 81       	ldd	r31, Y+4	; 0x04
    790e:	86 89       	ldd	r24, Z+22	; 0x16
    7910:	80 93 92 05 	sts	0x0592, r24
    7914:	eb 81       	ldd	r30, Y+3	; 0x03
    7916:	fc 81       	ldd	r31, Y+4	; 0x04
    7918:	86 89       	ldd	r24, Z+22	; 0x16
    791a:	28 2f       	mov	r18, r24
    791c:	30 e0       	ldi	r19, 0x00	; 0
    791e:	c9 01       	movw	r24, r18
    7920:	88 0f       	add	r24, r24
    7922:	99 1f       	adc	r25, r25
    7924:	88 0f       	add	r24, r24
    7926:	99 1f       	adc	r25, r25
    7928:	88 0f       	add	r24, r24
    792a:	99 1f       	adc	r25, r25
    792c:	82 0f       	add	r24, r18
    792e:	93 1f       	adc	r25, r19
    7930:	ac 01       	movw	r20, r24
    7932:	43 56       	subi	r20, 0x63	; 99
    7934:	5a 4f       	sbci	r21, 0xFA	; 250
    7936:	8b 81       	ldd	r24, Y+3	; 0x03
    7938:	9c 81       	ldd	r25, Y+4	; 0x04
    793a:	9c 01       	movw	r18, r24
    793c:	2e 5f       	subi	r18, 0xFE	; 254
    793e:	3f 4f       	sbci	r19, 0xFF	; 255
    7940:	ca 01       	movw	r24, r20
    7942:	b9 01       	movw	r22, r18
    7944:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    7948:	eb 81       	ldd	r30, Y+3	; 0x03
    794a:	fc 81       	ldd	r31, Y+4	; 0x04
    794c:	96 89       	ldd	r25, Z+22	; 0x16
    794e:	e0 91 8c 05 	lds	r30, 0x058C
    7952:	f0 91 8d 05 	lds	r31, 0x058D
    7956:	86 89       	ldd	r24, Z+22	; 0x16
    7958:	98 17       	cp	r25, r24
    795a:	18 f0       	brcs	.+6      	; 0x7962 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    795c:	81 e0       	ldi	r24, 0x01	; 1
    795e:	80 93 95 05 	sts	0x0595, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    7962:	80 91 04 06 	lds	r24, 0x0604
    7966:	88 23       	and	r24, r24
    7968:	09 f0       	breq	.+2      	; 0x796c <xTaskResumeAll+0xcc>
    796a:	b6 cf       	rjmp	.-148    	; 0x78d8 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    796c:	8b 81       	ldd	r24, Y+3	; 0x03
    796e:	9c 81       	ldd	r25, Y+4	; 0x04
    7970:	00 97       	sbiw	r24, 0x00	; 0
    7972:	11 f0       	breq	.+4      	; 0x7978 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    7974:	0e 94 cb 40 	call	0x8196	; 0x8196 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    7978:	80 91 94 05 	lds	r24, 0x0594
    797c:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    797e:	89 81       	ldd	r24, Y+1	; 0x01
    7980:	88 23       	and	r24, r24
    7982:	79 f0       	breq	.+30     	; 0x79a2 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    7984:	0e 94 40 3d 	call	0x7a80	; 0x7a80 <xTaskIncrementTick>
    7988:	88 23       	and	r24, r24
    798a:	19 f0       	breq	.+6      	; 0x7992 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    798c:	81 e0       	ldi	r24, 0x01	; 1
    798e:	80 93 95 05 	sts	0x0595, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    7992:	89 81       	ldd	r24, Y+1	; 0x01
    7994:	81 50       	subi	r24, 0x01	; 1
    7996:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    7998:	89 81       	ldd	r24, Y+1	; 0x01
    799a:	88 23       	and	r24, r24
    799c:	99 f7       	brne	.-26     	; 0x7984 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    799e:	10 92 94 05 	sts	0x0594, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    79a2:	80 91 95 05 	lds	r24, 0x0595
    79a6:	88 23       	and	r24, r24
    79a8:	21 f0       	breq	.+8      	; 0x79b2 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    79aa:	81 e0       	ldi	r24, 0x01	; 1
    79ac:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    79ae:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    79b2:	0f 90       	pop	r0
    79b4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    79b6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    79b8:	0f 90       	pop	r0
    79ba:	0f 90       	pop	r0
    79bc:	0f 90       	pop	r0
    79be:	0f 90       	pop	r0
    79c0:	cf 91       	pop	r28
    79c2:	df 91       	pop	r29
    79c4:	08 95       	ret

000079c6 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    79c6:	df 93       	push	r29
    79c8:	cf 93       	push	r28
    79ca:	00 d0       	rcall	.+0      	; 0x79cc <xTaskGetTickCount+0x6>
    79cc:	cd b7       	in	r28, 0x3d	; 61
    79ce:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    79d0:	0f b6       	in	r0, 0x3f	; 63
    79d2:	f8 94       	cli
    79d4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    79d6:	80 91 90 05 	lds	r24, 0x0590
    79da:	90 91 91 05 	lds	r25, 0x0591
    79de:	9a 83       	std	Y+2, r25	; 0x02
    79e0:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    79e2:	0f 90       	pop	r0
    79e4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    79e6:	89 81       	ldd	r24, Y+1	; 0x01
    79e8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    79ea:	0f 90       	pop	r0
    79ec:	0f 90       	pop	r0
    79ee:	cf 91       	pop	r28
    79f0:	df 91       	pop	r29
    79f2:	08 95       	ret

000079f4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    79f4:	df 93       	push	r29
    79f6:	cf 93       	push	r28
    79f8:	00 d0       	rcall	.+0      	; 0x79fa <xTaskGetTickCountFromISR+0x6>
    79fa:	0f 92       	push	r0
    79fc:	cd b7       	in	r28, 0x3d	; 61
    79fe:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    7a00:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    7a02:	80 91 90 05 	lds	r24, 0x0590
    7a06:	90 91 91 05 	lds	r25, 0x0591
    7a0a:	9b 83       	std	Y+3, r25	; 0x03
    7a0c:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    7a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    7a10:	9b 81       	ldd	r25, Y+3	; 0x03
}
    7a12:	0f 90       	pop	r0
    7a14:	0f 90       	pop	r0
    7a16:	0f 90       	pop	r0
    7a18:	cf 91       	pop	r28
    7a1a:	df 91       	pop	r29
    7a1c:	08 95       	ret

00007a1e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    7a1e:	df 93       	push	r29
    7a20:	cf 93       	push	r28
    7a22:	cd b7       	in	r28, 0x3d	; 61
    7a24:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    7a26:	80 91 8f 05 	lds	r24, 0x058F
}
    7a2a:	cf 91       	pop	r28
    7a2c:	df 91       	pop	r29
    7a2e:	08 95       	ret

00007a30 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    7a30:	df 93       	push	r29
    7a32:	cf 93       	push	r28
    7a34:	00 d0       	rcall	.+0      	; 0x7a36 <pcTaskGetName+0x6>
    7a36:	00 d0       	rcall	.+0      	; 0x7a38 <pcTaskGetName+0x8>
    7a38:	00 d0       	rcall	.+0      	; 0x7a3a <pcTaskGetName+0xa>
    7a3a:	cd b7       	in	r28, 0x3d	; 61
    7a3c:	de b7       	in	r29, 0x3e	; 62
    7a3e:	9c 83       	std	Y+4, r25	; 0x04
    7a40:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    7a42:	8b 81       	ldd	r24, Y+3	; 0x03
    7a44:	9c 81       	ldd	r25, Y+4	; 0x04
    7a46:	00 97       	sbiw	r24, 0x00	; 0
    7a48:	39 f4       	brne	.+14     	; 0x7a58 <pcTaskGetName+0x28>
    7a4a:	80 91 8c 05 	lds	r24, 0x058C
    7a4e:	90 91 8d 05 	lds	r25, 0x058D
    7a52:	9e 83       	std	Y+6, r25	; 0x06
    7a54:	8d 83       	std	Y+5, r24	; 0x05
    7a56:	04 c0       	rjmp	.+8      	; 0x7a60 <pcTaskGetName+0x30>
    7a58:	8b 81       	ldd	r24, Y+3	; 0x03
    7a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    7a5c:	9e 83       	std	Y+6, r25	; 0x06
    7a5e:	8d 83       	std	Y+5, r24	; 0x05
    7a60:	8d 81       	ldd	r24, Y+5	; 0x05
    7a62:	9e 81       	ldd	r25, Y+6	; 0x06
    7a64:	9a 83       	std	Y+2, r25	; 0x02
    7a66:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    7a68:	89 81       	ldd	r24, Y+1	; 0x01
    7a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    7a6c:	49 96       	adiw	r24, 0x19	; 25
}
    7a6e:	26 96       	adiw	r28, 0x06	; 6
    7a70:	0f b6       	in	r0, 0x3f	; 63
    7a72:	f8 94       	cli
    7a74:	de bf       	out	0x3e, r29	; 62
    7a76:	0f be       	out	0x3f, r0	; 63
    7a78:	cd bf       	out	0x3d, r28	; 61
    7a7a:	cf 91       	pop	r28
    7a7c:	df 91       	pop	r29
    7a7e:	08 95       	ret

00007a80 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    7a80:	df 93       	push	r29
    7a82:	cf 93       	push	r28
    7a84:	cd b7       	in	r28, 0x3d	; 61
    7a86:	de b7       	in	r29, 0x3e	; 62
    7a88:	29 97       	sbiw	r28, 0x09	; 9
    7a8a:	0f b6       	in	r0, 0x3f	; 63
    7a8c:	f8 94       	cli
    7a8e:	de bf       	out	0x3e, r29	; 62
    7a90:	0f be       	out	0x3f, r0	; 63
    7a92:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    7a94:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    7a96:	80 91 9c 05 	lds	r24, 0x059C
    7a9a:	88 23       	and	r24, r24
    7a9c:	09 f0       	breq	.+2      	; 0x7aa0 <xTaskIncrementTick+0x20>
    7a9e:	a7 c0       	rjmp	.+334    	; 0x7bee <xTaskIncrementTick+0x16e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    7aa0:	80 91 90 05 	lds	r24, 0x0590
    7aa4:	90 91 91 05 	lds	r25, 0x0591
    7aa8:	01 96       	adiw	r24, 0x01	; 1
    7aaa:	9c 83       	std	Y+4, r25	; 0x04
    7aac:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    7aae:	8b 81       	ldd	r24, Y+3	; 0x03
    7ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    7ab2:	90 93 91 05 	sts	0x0591, r25
    7ab6:	80 93 90 05 	sts	0x0590, r24

		if( xConstTickCount == ( TickType_t ) 0U )
    7aba:	8b 81       	ldd	r24, Y+3	; 0x03
    7abc:	9c 81       	ldd	r25, Y+4	; 0x04
    7abe:	00 97       	sbiw	r24, 0x00	; 0
    7ac0:	d9 f4       	brne	.+54     	; 0x7af8 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    7ac2:	80 91 00 06 	lds	r24, 0x0600
    7ac6:	90 91 01 06 	lds	r25, 0x0601
    7aca:	9a 83       	std	Y+2, r25	; 0x02
    7acc:	89 83       	std	Y+1, r24	; 0x01
    7ace:	80 91 02 06 	lds	r24, 0x0602
    7ad2:	90 91 03 06 	lds	r25, 0x0603
    7ad6:	90 93 01 06 	sts	0x0601, r25
    7ada:	80 93 00 06 	sts	0x0600, r24
    7ade:	89 81       	ldd	r24, Y+1	; 0x01
    7ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    7ae2:	90 93 03 06 	sts	0x0603, r25
    7ae6:	80 93 02 06 	sts	0x0602, r24
    7aea:	80 91 96 05 	lds	r24, 0x0596
    7aee:	8f 5f       	subi	r24, 0xFF	; 255
    7af0:	80 93 96 05 	sts	0x0596, r24
    7af4:	0e 94 cb 40 	call	0x8196	; 0x8196 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    7af8:	20 91 98 05 	lds	r18, 0x0598
    7afc:	30 91 99 05 	lds	r19, 0x0599
    7b00:	8b 81       	ldd	r24, Y+3	; 0x03
    7b02:	9c 81       	ldd	r25, Y+4	; 0x04
    7b04:	82 17       	cp	r24, r18
    7b06:	93 07       	cpc	r25, r19
    7b08:	08 f4       	brcc	.+2      	; 0x7b0c <xTaskIncrementTick+0x8c>
    7b0a:	76 c0       	rjmp	.+236    	; 0x7bf8 <xTaskIncrementTick+0x178>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    7b0c:	e0 91 00 06 	lds	r30, 0x0600
    7b10:	f0 91 01 06 	lds	r31, 0x0601
    7b14:	80 81       	ld	r24, Z
    7b16:	88 23       	and	r24, r24
    7b18:	39 f4       	brne	.+14     	; 0x7b28 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7b1a:	8f ef       	ldi	r24, 0xFF	; 255
    7b1c:	9f ef       	ldi	r25, 0xFF	; 255
    7b1e:	90 93 99 05 	sts	0x0599, r25
    7b22:	80 93 98 05 	sts	0x0598, r24
    7b26:	68 c0       	rjmp	.+208    	; 0x7bf8 <xTaskIncrementTick+0x178>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    7b28:	e0 91 00 06 	lds	r30, 0x0600
    7b2c:	f0 91 01 06 	lds	r31, 0x0601
    7b30:	05 80       	ldd	r0, Z+5	; 0x05
    7b32:	f6 81       	ldd	r31, Z+6	; 0x06
    7b34:	e0 2d       	mov	r30, r0
    7b36:	86 81       	ldd	r24, Z+6	; 0x06
    7b38:	97 81       	ldd	r25, Z+7	; 0x07
    7b3a:	99 87       	std	Y+9, r25	; 0x09
    7b3c:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    7b3e:	e8 85       	ldd	r30, Y+8	; 0x08
    7b40:	f9 85       	ldd	r31, Y+9	; 0x09
    7b42:	82 81       	ldd	r24, Z+2	; 0x02
    7b44:	93 81       	ldd	r25, Z+3	; 0x03
    7b46:	9f 83       	std	Y+7, r25	; 0x07
    7b48:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    7b4a:	2b 81       	ldd	r18, Y+3	; 0x03
    7b4c:	3c 81       	ldd	r19, Y+4	; 0x04
    7b4e:	8e 81       	ldd	r24, Y+6	; 0x06
    7b50:	9f 81       	ldd	r25, Y+7	; 0x07
    7b52:	28 17       	cp	r18, r24
    7b54:	39 07       	cpc	r19, r25
    7b56:	38 f4       	brcc	.+14     	; 0x7b66 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    7b58:	8e 81       	ldd	r24, Y+6	; 0x06
    7b5a:	9f 81       	ldd	r25, Y+7	; 0x07
    7b5c:	90 93 99 05 	sts	0x0599, r25
    7b60:	80 93 98 05 	sts	0x0598, r24
    7b64:	49 c0       	rjmp	.+146    	; 0x7bf8 <xTaskIncrementTick+0x178>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7b66:	88 85       	ldd	r24, Y+8	; 0x08
    7b68:	99 85       	ldd	r25, Y+9	; 0x09
    7b6a:	02 96       	adiw	r24, 0x02	; 2
    7b6c:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    7b70:	e8 85       	ldd	r30, Y+8	; 0x08
    7b72:	f9 85       	ldd	r31, Y+9	; 0x09
    7b74:	84 89       	ldd	r24, Z+20	; 0x14
    7b76:	95 89       	ldd	r25, Z+21	; 0x15
    7b78:	00 97       	sbiw	r24, 0x00	; 0
    7b7a:	29 f0       	breq	.+10     	; 0x7b86 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    7b7c:	88 85       	ldd	r24, Y+8	; 0x08
    7b7e:	99 85       	ldd	r25, Y+9	; 0x09
    7b80:	0c 96       	adiw	r24, 0x0c	; 12
    7b82:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    7b86:	e8 85       	ldd	r30, Y+8	; 0x08
    7b88:	f9 85       	ldd	r31, Y+9	; 0x09
    7b8a:	96 89       	ldd	r25, Z+22	; 0x16
    7b8c:	80 91 92 05 	lds	r24, 0x0592
    7b90:	89 17       	cp	r24, r25
    7b92:	28 f4       	brcc	.+10     	; 0x7b9e <xTaskIncrementTick+0x11e>
    7b94:	e8 85       	ldd	r30, Y+8	; 0x08
    7b96:	f9 85       	ldd	r31, Y+9	; 0x09
    7b98:	86 89       	ldd	r24, Z+22	; 0x16
    7b9a:	80 93 92 05 	sts	0x0592, r24
    7b9e:	e8 85       	ldd	r30, Y+8	; 0x08
    7ba0:	f9 85       	ldd	r31, Y+9	; 0x09
    7ba2:	86 89       	ldd	r24, Z+22	; 0x16
    7ba4:	28 2f       	mov	r18, r24
    7ba6:	30 e0       	ldi	r19, 0x00	; 0
    7ba8:	c9 01       	movw	r24, r18
    7baa:	88 0f       	add	r24, r24
    7bac:	99 1f       	adc	r25, r25
    7bae:	88 0f       	add	r24, r24
    7bb0:	99 1f       	adc	r25, r25
    7bb2:	88 0f       	add	r24, r24
    7bb4:	99 1f       	adc	r25, r25
    7bb6:	82 0f       	add	r24, r18
    7bb8:	93 1f       	adc	r25, r19
    7bba:	ac 01       	movw	r20, r24
    7bbc:	43 56       	subi	r20, 0x63	; 99
    7bbe:	5a 4f       	sbci	r21, 0xFA	; 250
    7bc0:	88 85       	ldd	r24, Y+8	; 0x08
    7bc2:	99 85       	ldd	r25, Y+9	; 0x09
    7bc4:	9c 01       	movw	r18, r24
    7bc6:	2e 5f       	subi	r18, 0xFE	; 254
    7bc8:	3f 4f       	sbci	r19, 0xFF	; 255
    7bca:	ca 01       	movw	r24, r20
    7bcc:	b9 01       	movw	r22, r18
    7bce:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    7bd2:	e8 85       	ldd	r30, Y+8	; 0x08
    7bd4:	f9 85       	ldd	r31, Y+9	; 0x09
    7bd6:	96 89       	ldd	r25, Z+22	; 0x16
    7bd8:	e0 91 8c 05 	lds	r30, 0x058C
    7bdc:	f0 91 8d 05 	lds	r31, 0x058D
    7be0:	86 89       	ldd	r24, Z+22	; 0x16
    7be2:	98 17       	cp	r25, r24
    7be4:	08 f4       	brcc	.+2      	; 0x7be8 <xTaskIncrementTick+0x168>
    7be6:	92 cf       	rjmp	.-220    	; 0x7b0c <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    7be8:	81 e0       	ldi	r24, 0x01	; 1
    7bea:	8d 83       	std	Y+5, r24	; 0x05
    7bec:	8f cf       	rjmp	.-226    	; 0x7b0c <xTaskIncrementTick+0x8c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    7bee:	80 91 94 05 	lds	r24, 0x0594
    7bf2:	8f 5f       	subi	r24, 0xFF	; 255
    7bf4:	80 93 94 05 	sts	0x0594, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    7bf8:	80 91 95 05 	lds	r24, 0x0595
    7bfc:	88 23       	and	r24, r24
    7bfe:	11 f0       	breq	.+4      	; 0x7c04 <xTaskIncrementTick+0x184>
		{
			xSwitchRequired = pdTRUE;
    7c00:	81 e0       	ldi	r24, 0x01	; 1
    7c02:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    7c04:	8d 81       	ldd	r24, Y+5	; 0x05
}
    7c06:	29 96       	adiw	r28, 0x09	; 9
    7c08:	0f b6       	in	r0, 0x3f	; 63
    7c0a:	f8 94       	cli
    7c0c:	de bf       	out	0x3e, r29	; 62
    7c0e:	0f be       	out	0x3f, r0	; 63
    7c10:	cd bf       	out	0x3d, r28	; 61
    7c12:	cf 91       	pop	r28
    7c14:	df 91       	pop	r29
    7c16:	08 95       	ret

00007c18 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    7c18:	df 93       	push	r29
    7c1a:	cf 93       	push	r28
    7c1c:	00 d0       	rcall	.+0      	; 0x7c1e <vTaskSwitchContext+0x6>
    7c1e:	0f 92       	push	r0
    7c20:	cd b7       	in	r28, 0x3d	; 61
    7c22:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    7c24:	80 91 9c 05 	lds	r24, 0x059C
    7c28:	88 23       	and	r24, r24
    7c2a:	21 f0       	breq	.+8      	; 0x7c34 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    7c2c:	81 e0       	ldi	r24, 0x01	; 1
    7c2e:	80 93 95 05 	sts	0x0595, r24
    7c32:	59 c0       	rjmp	.+178    	; 0x7ce6 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    7c34:	10 92 95 05 	sts	0x0595, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    7c38:	80 91 92 05 	lds	r24, 0x0592
    7c3c:	8b 83       	std	Y+3, r24	; 0x03
    7c3e:	03 c0       	rjmp	.+6      	; 0x7c46 <vTaskSwitchContext+0x2e>
    7c40:	8b 81       	ldd	r24, Y+3	; 0x03
    7c42:	81 50       	subi	r24, 0x01	; 1
    7c44:	8b 83       	std	Y+3, r24	; 0x03
    7c46:	8b 81       	ldd	r24, Y+3	; 0x03
    7c48:	28 2f       	mov	r18, r24
    7c4a:	30 e0       	ldi	r19, 0x00	; 0
    7c4c:	c9 01       	movw	r24, r18
    7c4e:	88 0f       	add	r24, r24
    7c50:	99 1f       	adc	r25, r25
    7c52:	88 0f       	add	r24, r24
    7c54:	99 1f       	adc	r25, r25
    7c56:	88 0f       	add	r24, r24
    7c58:	99 1f       	adc	r25, r25
    7c5a:	82 0f       	add	r24, r18
    7c5c:	93 1f       	adc	r25, r19
    7c5e:	fc 01       	movw	r30, r24
    7c60:	e3 56       	subi	r30, 0x63	; 99
    7c62:	fa 4f       	sbci	r31, 0xFA	; 250
    7c64:	80 81       	ld	r24, Z
    7c66:	88 23       	and	r24, r24
    7c68:	59 f3       	breq	.-42     	; 0x7c40 <vTaskSwitchContext+0x28>
    7c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    7c6c:	28 2f       	mov	r18, r24
    7c6e:	30 e0       	ldi	r19, 0x00	; 0
    7c70:	c9 01       	movw	r24, r18
    7c72:	88 0f       	add	r24, r24
    7c74:	99 1f       	adc	r25, r25
    7c76:	88 0f       	add	r24, r24
    7c78:	99 1f       	adc	r25, r25
    7c7a:	88 0f       	add	r24, r24
    7c7c:	99 1f       	adc	r25, r25
    7c7e:	82 0f       	add	r24, r18
    7c80:	93 1f       	adc	r25, r19
    7c82:	83 56       	subi	r24, 0x63	; 99
    7c84:	9a 4f       	sbci	r25, 0xFA	; 250
    7c86:	9a 83       	std	Y+2, r25	; 0x02
    7c88:	89 83       	std	Y+1, r24	; 0x01
    7c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    7c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    7c8e:	01 80       	ldd	r0, Z+1	; 0x01
    7c90:	f2 81       	ldd	r31, Z+2	; 0x02
    7c92:	e0 2d       	mov	r30, r0
    7c94:	82 81       	ldd	r24, Z+2	; 0x02
    7c96:	93 81       	ldd	r25, Z+3	; 0x03
    7c98:	e9 81       	ldd	r30, Y+1	; 0x01
    7c9a:	fa 81       	ldd	r31, Y+2	; 0x02
    7c9c:	92 83       	std	Z+2, r25	; 0x02
    7c9e:	81 83       	std	Z+1, r24	; 0x01
    7ca0:	e9 81       	ldd	r30, Y+1	; 0x01
    7ca2:	fa 81       	ldd	r31, Y+2	; 0x02
    7ca4:	21 81       	ldd	r18, Z+1	; 0x01
    7ca6:	32 81       	ldd	r19, Z+2	; 0x02
    7ca8:	89 81       	ldd	r24, Y+1	; 0x01
    7caa:	9a 81       	ldd	r25, Y+2	; 0x02
    7cac:	03 96       	adiw	r24, 0x03	; 3
    7cae:	28 17       	cp	r18, r24
    7cb0:	39 07       	cpc	r19, r25
    7cb2:	59 f4       	brne	.+22     	; 0x7cca <vTaskSwitchContext+0xb2>
    7cb4:	e9 81       	ldd	r30, Y+1	; 0x01
    7cb6:	fa 81       	ldd	r31, Y+2	; 0x02
    7cb8:	01 80       	ldd	r0, Z+1	; 0x01
    7cba:	f2 81       	ldd	r31, Z+2	; 0x02
    7cbc:	e0 2d       	mov	r30, r0
    7cbe:	82 81       	ldd	r24, Z+2	; 0x02
    7cc0:	93 81       	ldd	r25, Z+3	; 0x03
    7cc2:	e9 81       	ldd	r30, Y+1	; 0x01
    7cc4:	fa 81       	ldd	r31, Y+2	; 0x02
    7cc6:	92 83       	std	Z+2, r25	; 0x02
    7cc8:	81 83       	std	Z+1, r24	; 0x01
    7cca:	e9 81       	ldd	r30, Y+1	; 0x01
    7ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    7cce:	01 80       	ldd	r0, Z+1	; 0x01
    7cd0:	f2 81       	ldd	r31, Z+2	; 0x02
    7cd2:	e0 2d       	mov	r30, r0
    7cd4:	86 81       	ldd	r24, Z+6	; 0x06
    7cd6:	97 81       	ldd	r25, Z+7	; 0x07
    7cd8:	90 93 8d 05 	sts	0x058D, r25
    7cdc:	80 93 8c 05 	sts	0x058C, r24
    7ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    7ce2:	80 93 92 05 	sts	0x0592, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    7ce6:	0f 90       	pop	r0
    7ce8:	0f 90       	pop	r0
    7cea:	0f 90       	pop	r0
    7cec:	cf 91       	pop	r28
    7cee:	df 91       	pop	r29
    7cf0:	08 95       	ret

00007cf2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    7cf2:	df 93       	push	r29
    7cf4:	cf 93       	push	r28
    7cf6:	00 d0       	rcall	.+0      	; 0x7cf8 <vTaskPlaceOnEventList+0x6>
    7cf8:	00 d0       	rcall	.+0      	; 0x7cfa <vTaskPlaceOnEventList+0x8>
    7cfa:	cd b7       	in	r28, 0x3d	; 61
    7cfc:	de b7       	in	r29, 0x3e	; 62
    7cfe:	9a 83       	std	Y+2, r25	; 0x02
    7d00:	89 83       	std	Y+1, r24	; 0x01
    7d02:	7c 83       	std	Y+4, r23	; 0x04
    7d04:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    7d06:	80 91 8c 05 	lds	r24, 0x058C
    7d0a:	90 91 8d 05 	lds	r25, 0x058D
    7d0e:	9c 01       	movw	r18, r24
    7d10:	24 5f       	subi	r18, 0xF4	; 244
    7d12:	3f 4f       	sbci	r19, 0xFF	; 255
    7d14:	89 81       	ldd	r24, Y+1	; 0x01
    7d16:	9a 81       	ldd	r25, Y+2	; 0x02
    7d18:	b9 01       	movw	r22, r18
    7d1a:	0e 94 52 2d 	call	0x5aa4	; 0x5aa4 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7d1e:	8b 81       	ldd	r24, Y+3	; 0x03
    7d20:	9c 81       	ldd	r25, Y+4	; 0x04
    7d22:	61 e0       	ldi	r22, 0x01	; 1
    7d24:	0e 94 ee 45 	call	0x8bdc	; 0x8bdc <prvAddCurrentTaskToDelayedList>
}
    7d28:	0f 90       	pop	r0
    7d2a:	0f 90       	pop	r0
    7d2c:	0f 90       	pop	r0
    7d2e:	0f 90       	pop	r0
    7d30:	cf 91       	pop	r28
    7d32:	df 91       	pop	r29
    7d34:	08 95       	ret

00007d36 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    7d36:	df 93       	push	r29
    7d38:	cf 93       	push	r28
    7d3a:	00 d0       	rcall	.+0      	; 0x7d3c <vTaskPlaceOnUnorderedEventList+0x6>
    7d3c:	00 d0       	rcall	.+0      	; 0x7d3e <vTaskPlaceOnUnorderedEventList+0x8>
    7d3e:	00 d0       	rcall	.+0      	; 0x7d40 <vTaskPlaceOnUnorderedEventList+0xa>
    7d40:	cd b7       	in	r28, 0x3d	; 61
    7d42:	de b7       	in	r29, 0x3e	; 62
    7d44:	9a 83       	std	Y+2, r25	; 0x02
    7d46:	89 83       	std	Y+1, r24	; 0x01
    7d48:	7c 83       	std	Y+4, r23	; 0x04
    7d4a:	6b 83       	std	Y+3, r22	; 0x03
    7d4c:	5e 83       	std	Y+6, r21	; 0x06
    7d4e:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    7d50:	e0 91 8c 05 	lds	r30, 0x058C
    7d54:	f0 91 8d 05 	lds	r31, 0x058D
    7d58:	8b 81       	ldd	r24, Y+3	; 0x03
    7d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    7d5c:	90 68       	ori	r25, 0x80	; 128
    7d5e:	95 87       	std	Z+13, r25	; 0x0d
    7d60:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    7d62:	80 91 8c 05 	lds	r24, 0x058C
    7d66:	90 91 8d 05 	lds	r25, 0x058D
    7d6a:	9c 01       	movw	r18, r24
    7d6c:	24 5f       	subi	r18, 0xF4	; 244
    7d6e:	3f 4f       	sbci	r19, 0xFF	; 255
    7d70:	89 81       	ldd	r24, Y+1	; 0x01
    7d72:	9a 81       	ldd	r25, Y+2	; 0x02
    7d74:	b9 01       	movw	r22, r18
    7d76:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7d7a:	8d 81       	ldd	r24, Y+5	; 0x05
    7d7c:	9e 81       	ldd	r25, Y+6	; 0x06
    7d7e:	61 e0       	ldi	r22, 0x01	; 1
    7d80:	0e 94 ee 45 	call	0x8bdc	; 0x8bdc <prvAddCurrentTaskToDelayedList>
}
    7d84:	26 96       	adiw	r28, 0x06	; 6
    7d86:	0f b6       	in	r0, 0x3f	; 63
    7d88:	f8 94       	cli
    7d8a:	de bf       	out	0x3e, r29	; 62
    7d8c:	0f be       	out	0x3f, r0	; 63
    7d8e:	cd bf       	out	0x3d, r28	; 61
    7d90:	cf 91       	pop	r28
    7d92:	df 91       	pop	r29
    7d94:	08 95       	ret

00007d96 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    7d96:	df 93       	push	r29
    7d98:	cf 93       	push	r28
    7d9a:	00 d0       	rcall	.+0      	; 0x7d9c <xTaskRemoveFromEventList+0x6>
    7d9c:	00 d0       	rcall	.+0      	; 0x7d9e <xTaskRemoveFromEventList+0x8>
    7d9e:	0f 92       	push	r0
    7da0:	cd b7       	in	r28, 0x3d	; 61
    7da2:	de b7       	in	r29, 0x3e	; 62
    7da4:	9d 83       	std	Y+5, r25	; 0x05
    7da6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    7da8:	ec 81       	ldd	r30, Y+4	; 0x04
    7daa:	fd 81       	ldd	r31, Y+5	; 0x05
    7dac:	05 80       	ldd	r0, Z+5	; 0x05
    7dae:	f6 81       	ldd	r31, Z+6	; 0x06
    7db0:	e0 2d       	mov	r30, r0
    7db2:	86 81       	ldd	r24, Z+6	; 0x06
    7db4:	97 81       	ldd	r25, Z+7	; 0x07
    7db6:	9b 83       	std	Y+3, r25	; 0x03
    7db8:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    7dba:	8a 81       	ldd	r24, Y+2	; 0x02
    7dbc:	9b 81       	ldd	r25, Y+3	; 0x03
    7dbe:	0c 96       	adiw	r24, 0x0c	; 12
    7dc0:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    7dc4:	80 91 9c 05 	lds	r24, 0x059C
    7dc8:	88 23       	and	r24, r24
    7dca:	61 f5       	brne	.+88     	; 0x7e24 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    7dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    7dce:	9b 81       	ldd	r25, Y+3	; 0x03
    7dd0:	02 96       	adiw	r24, 0x02	; 2
    7dd2:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    7dd6:	ea 81       	ldd	r30, Y+2	; 0x02
    7dd8:	fb 81       	ldd	r31, Y+3	; 0x03
    7dda:	96 89       	ldd	r25, Z+22	; 0x16
    7ddc:	80 91 92 05 	lds	r24, 0x0592
    7de0:	89 17       	cp	r24, r25
    7de2:	28 f4       	brcc	.+10     	; 0x7dee <xTaskRemoveFromEventList+0x58>
    7de4:	ea 81       	ldd	r30, Y+2	; 0x02
    7de6:	fb 81       	ldd	r31, Y+3	; 0x03
    7de8:	86 89       	ldd	r24, Z+22	; 0x16
    7dea:	80 93 92 05 	sts	0x0592, r24
    7dee:	ea 81       	ldd	r30, Y+2	; 0x02
    7df0:	fb 81       	ldd	r31, Y+3	; 0x03
    7df2:	86 89       	ldd	r24, Z+22	; 0x16
    7df4:	28 2f       	mov	r18, r24
    7df6:	30 e0       	ldi	r19, 0x00	; 0
    7df8:	c9 01       	movw	r24, r18
    7dfa:	88 0f       	add	r24, r24
    7dfc:	99 1f       	adc	r25, r25
    7dfe:	88 0f       	add	r24, r24
    7e00:	99 1f       	adc	r25, r25
    7e02:	88 0f       	add	r24, r24
    7e04:	99 1f       	adc	r25, r25
    7e06:	82 0f       	add	r24, r18
    7e08:	93 1f       	adc	r25, r19
    7e0a:	ac 01       	movw	r20, r24
    7e0c:	43 56       	subi	r20, 0x63	; 99
    7e0e:	5a 4f       	sbci	r21, 0xFA	; 250
    7e10:	8a 81       	ldd	r24, Y+2	; 0x02
    7e12:	9b 81       	ldd	r25, Y+3	; 0x03
    7e14:	9c 01       	movw	r18, r24
    7e16:	2e 5f       	subi	r18, 0xFE	; 254
    7e18:	3f 4f       	sbci	r19, 0xFF	; 255
    7e1a:	ca 01       	movw	r24, r20
    7e1c:	b9 01       	movw	r22, r18
    7e1e:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
    7e22:	0a c0       	rjmp	.+20     	; 0x7e38 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    7e24:	8a 81       	ldd	r24, Y+2	; 0x02
    7e26:	9b 81       	ldd	r25, Y+3	; 0x03
    7e28:	9c 01       	movw	r18, r24
    7e2a:	24 5f       	subi	r18, 0xF4	; 244
    7e2c:	3f 4f       	sbci	r19, 0xFF	; 255
    7e2e:	84 e0       	ldi	r24, 0x04	; 4
    7e30:	96 e0       	ldi	r25, 0x06	; 6
    7e32:	b9 01       	movw	r22, r18
    7e34:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    7e38:	ea 81       	ldd	r30, Y+2	; 0x02
    7e3a:	fb 81       	ldd	r31, Y+3	; 0x03
    7e3c:	96 89       	ldd	r25, Z+22	; 0x16
    7e3e:	e0 91 8c 05 	lds	r30, 0x058C
    7e42:	f0 91 8d 05 	lds	r31, 0x058D
    7e46:	86 89       	ldd	r24, Z+22	; 0x16
    7e48:	89 17       	cp	r24, r25
    7e4a:	30 f4       	brcc	.+12     	; 0x7e58 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    7e4c:	81 e0       	ldi	r24, 0x01	; 1
    7e4e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    7e50:	81 e0       	ldi	r24, 0x01	; 1
    7e52:	80 93 95 05 	sts	0x0595, r24
    7e56:	01 c0       	rjmp	.+2      	; 0x7e5a <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    7e58:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    7e5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    7e5c:	0f 90       	pop	r0
    7e5e:	0f 90       	pop	r0
    7e60:	0f 90       	pop	r0
    7e62:	0f 90       	pop	r0
    7e64:	0f 90       	pop	r0
    7e66:	cf 91       	pop	r28
    7e68:	df 91       	pop	r29
    7e6a:	08 95       	ret

00007e6c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    7e6c:	df 93       	push	r29
    7e6e:	cf 93       	push	r28
    7e70:	cd b7       	in	r28, 0x3d	; 61
    7e72:	de b7       	in	r29, 0x3e	; 62
    7e74:	27 97       	sbiw	r28, 0x07	; 7
    7e76:	0f b6       	in	r0, 0x3f	; 63
    7e78:	f8 94       	cli
    7e7a:	de bf       	out	0x3e, r29	; 62
    7e7c:	0f be       	out	0x3f, r0	; 63
    7e7e:	cd bf       	out	0x3d, r28	; 61
    7e80:	9d 83       	std	Y+5, r25	; 0x05
    7e82:	8c 83       	std	Y+4, r24	; 0x04
    7e84:	7f 83       	std	Y+7, r23	; 0x07
    7e86:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    7e88:	8e 81       	ldd	r24, Y+6	; 0x06
    7e8a:	9f 81       	ldd	r25, Y+7	; 0x07
    7e8c:	90 68       	ori	r25, 0x80	; 128
    7e8e:	ec 81       	ldd	r30, Y+4	; 0x04
    7e90:	fd 81       	ldd	r31, Y+5	; 0x05
    7e92:	91 83       	std	Z+1, r25	; 0x01
    7e94:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    7e96:	ec 81       	ldd	r30, Y+4	; 0x04
    7e98:	fd 81       	ldd	r31, Y+5	; 0x05
    7e9a:	86 81       	ldd	r24, Z+6	; 0x06
    7e9c:	97 81       	ldd	r25, Z+7	; 0x07
    7e9e:	9b 83       	std	Y+3, r25	; 0x03
    7ea0:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    7ea2:	8c 81       	ldd	r24, Y+4	; 0x04
    7ea4:	9d 81       	ldd	r25, Y+5	; 0x05
    7ea6:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    7eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    7eac:	9b 81       	ldd	r25, Y+3	; 0x03
    7eae:	02 96       	adiw	r24, 0x02	; 2
    7eb0:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    7eb4:	ea 81       	ldd	r30, Y+2	; 0x02
    7eb6:	fb 81       	ldd	r31, Y+3	; 0x03
    7eb8:	96 89       	ldd	r25, Z+22	; 0x16
    7eba:	80 91 92 05 	lds	r24, 0x0592
    7ebe:	89 17       	cp	r24, r25
    7ec0:	28 f4       	brcc	.+10     	; 0x7ecc <xTaskRemoveFromUnorderedEventList+0x60>
    7ec2:	ea 81       	ldd	r30, Y+2	; 0x02
    7ec4:	fb 81       	ldd	r31, Y+3	; 0x03
    7ec6:	86 89       	ldd	r24, Z+22	; 0x16
    7ec8:	80 93 92 05 	sts	0x0592, r24
    7ecc:	ea 81       	ldd	r30, Y+2	; 0x02
    7ece:	fb 81       	ldd	r31, Y+3	; 0x03
    7ed0:	86 89       	ldd	r24, Z+22	; 0x16
    7ed2:	28 2f       	mov	r18, r24
    7ed4:	30 e0       	ldi	r19, 0x00	; 0
    7ed6:	c9 01       	movw	r24, r18
    7ed8:	88 0f       	add	r24, r24
    7eda:	99 1f       	adc	r25, r25
    7edc:	88 0f       	add	r24, r24
    7ede:	99 1f       	adc	r25, r25
    7ee0:	88 0f       	add	r24, r24
    7ee2:	99 1f       	adc	r25, r25
    7ee4:	82 0f       	add	r24, r18
    7ee6:	93 1f       	adc	r25, r19
    7ee8:	ac 01       	movw	r20, r24
    7eea:	43 56       	subi	r20, 0x63	; 99
    7eec:	5a 4f       	sbci	r21, 0xFA	; 250
    7eee:	8a 81       	ldd	r24, Y+2	; 0x02
    7ef0:	9b 81       	ldd	r25, Y+3	; 0x03
    7ef2:	9c 01       	movw	r18, r24
    7ef4:	2e 5f       	subi	r18, 0xFE	; 254
    7ef6:	3f 4f       	sbci	r19, 0xFF	; 255
    7ef8:	ca 01       	movw	r24, r20
    7efa:	b9 01       	movw	r22, r18
    7efc:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    7f00:	ea 81       	ldd	r30, Y+2	; 0x02
    7f02:	fb 81       	ldd	r31, Y+3	; 0x03
    7f04:	96 89       	ldd	r25, Z+22	; 0x16
    7f06:	e0 91 8c 05 	lds	r30, 0x058C
    7f0a:	f0 91 8d 05 	lds	r31, 0x058D
    7f0e:	86 89       	ldd	r24, Z+22	; 0x16
    7f10:	89 17       	cp	r24, r25
    7f12:	30 f4       	brcc	.+12     	; 0x7f20 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    7f14:	81 e0       	ldi	r24, 0x01	; 1
    7f16:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    7f18:	81 e0       	ldi	r24, 0x01	; 1
    7f1a:	80 93 95 05 	sts	0x0595, r24
    7f1e:	01 c0       	rjmp	.+2      	; 0x7f22 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    7f20:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    7f22:	89 81       	ldd	r24, Y+1	; 0x01
}
    7f24:	27 96       	adiw	r28, 0x07	; 7
    7f26:	0f b6       	in	r0, 0x3f	; 63
    7f28:	f8 94       	cli
    7f2a:	de bf       	out	0x3e, r29	; 62
    7f2c:	0f be       	out	0x3f, r0	; 63
    7f2e:	cd bf       	out	0x3d, r28	; 61
    7f30:	cf 91       	pop	r28
    7f32:	df 91       	pop	r29
    7f34:	08 95       	ret

00007f36 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    7f36:	df 93       	push	r29
    7f38:	cf 93       	push	r28
    7f3a:	00 d0       	rcall	.+0      	; 0x7f3c <vTaskSetTimeOutState+0x6>
    7f3c:	cd b7       	in	r28, 0x3d	; 61
    7f3e:	de b7       	in	r29, 0x3e	; 62
    7f40:	9a 83       	std	Y+2, r25	; 0x02
    7f42:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    7f44:	80 91 96 05 	lds	r24, 0x0596
    7f48:	e9 81       	ldd	r30, Y+1	; 0x01
    7f4a:	fa 81       	ldd	r31, Y+2	; 0x02
    7f4c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    7f4e:	80 91 90 05 	lds	r24, 0x0590
    7f52:	90 91 91 05 	lds	r25, 0x0591
    7f56:	e9 81       	ldd	r30, Y+1	; 0x01
    7f58:	fa 81       	ldd	r31, Y+2	; 0x02
    7f5a:	92 83       	std	Z+2, r25	; 0x02
    7f5c:	81 83       	std	Z+1, r24	; 0x01
}
    7f5e:	0f 90       	pop	r0
    7f60:	0f 90       	pop	r0
    7f62:	cf 91       	pop	r28
    7f64:	df 91       	pop	r29
    7f66:	08 95       	ret

00007f68 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    7f68:	df 93       	push	r29
    7f6a:	cf 93       	push	r28
    7f6c:	cd b7       	in	r28, 0x3d	; 61
    7f6e:	de b7       	in	r29, 0x3e	; 62
    7f70:	27 97       	sbiw	r28, 0x07	; 7
    7f72:	0f b6       	in	r0, 0x3f	; 63
    7f74:	f8 94       	cli
    7f76:	de bf       	out	0x3e, r29	; 62
    7f78:	0f be       	out	0x3f, r0	; 63
    7f7a:	cd bf       	out	0x3d, r28	; 61
    7f7c:	9d 83       	std	Y+5, r25	; 0x05
    7f7e:	8c 83       	std	Y+4, r24	; 0x04
    7f80:	7f 83       	std	Y+7, r23	; 0x07
    7f82:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    7f84:	0f b6       	in	r0, 0x3f	; 63
    7f86:	f8 94       	cli
    7f88:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    7f8a:	80 91 90 05 	lds	r24, 0x0590
    7f8e:	90 91 91 05 	lds	r25, 0x0591
    7f92:	9a 83       	std	Y+2, r25	; 0x02
    7f94:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    7f96:	ee 81       	ldd	r30, Y+6	; 0x06
    7f98:	ff 81       	ldd	r31, Y+7	; 0x07
    7f9a:	80 81       	ld	r24, Z
    7f9c:	91 81       	ldd	r25, Z+1	; 0x01
    7f9e:	2f ef       	ldi	r18, 0xFF	; 255
    7fa0:	8f 3f       	cpi	r24, 0xFF	; 255
    7fa2:	92 07       	cpc	r25, r18
    7fa4:	11 f4       	brne	.+4      	; 0x7faa <xTaskCheckForTimeOut+0x42>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    7fa6:	1b 82       	std	Y+3, r1	; 0x03
    7fa8:	40 c0       	rjmp	.+128    	; 0x802a <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    7faa:	ec 81       	ldd	r30, Y+4	; 0x04
    7fac:	fd 81       	ldd	r31, Y+5	; 0x05
    7fae:	90 81       	ld	r25, Z
    7fb0:	80 91 96 05 	lds	r24, 0x0596
    7fb4:	98 17       	cp	r25, r24
    7fb6:	61 f0       	breq	.+24     	; 0x7fd0 <xTaskCheckForTimeOut+0x68>
    7fb8:	ec 81       	ldd	r30, Y+4	; 0x04
    7fba:	fd 81       	ldd	r31, Y+5	; 0x05
    7fbc:	21 81       	ldd	r18, Z+1	; 0x01
    7fbe:	32 81       	ldd	r19, Z+2	; 0x02
    7fc0:	89 81       	ldd	r24, Y+1	; 0x01
    7fc2:	9a 81       	ldd	r25, Y+2	; 0x02
    7fc4:	82 17       	cp	r24, r18
    7fc6:	93 07       	cpc	r25, r19
    7fc8:	18 f0       	brcs	.+6      	; 0x7fd0 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    7fca:	81 e0       	ldi	r24, 0x01	; 1
    7fcc:	8b 83       	std	Y+3, r24	; 0x03
    7fce:	2d c0       	rjmp	.+90     	; 0x802a <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    7fd0:	ec 81       	ldd	r30, Y+4	; 0x04
    7fd2:	fd 81       	ldd	r31, Y+5	; 0x05
    7fd4:	21 81       	ldd	r18, Z+1	; 0x01
    7fd6:	32 81       	ldd	r19, Z+2	; 0x02
    7fd8:	89 81       	ldd	r24, Y+1	; 0x01
    7fda:	9a 81       	ldd	r25, Y+2	; 0x02
    7fdc:	ac 01       	movw	r20, r24
    7fde:	42 1b       	sub	r20, r18
    7fe0:	53 0b       	sbc	r21, r19
    7fe2:	9a 01       	movw	r18, r20
    7fe4:	ee 81       	ldd	r30, Y+6	; 0x06
    7fe6:	ff 81       	ldd	r31, Y+7	; 0x07
    7fe8:	80 81       	ld	r24, Z
    7fea:	91 81       	ldd	r25, Z+1	; 0x01
    7fec:	28 17       	cp	r18, r24
    7fee:	39 07       	cpc	r19, r25
    7ff0:	d0 f4       	brcc	.+52     	; 0x8026 <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    7ff2:	ee 81       	ldd	r30, Y+6	; 0x06
    7ff4:	ff 81       	ldd	r31, Y+7	; 0x07
    7ff6:	40 81       	ld	r20, Z
    7ff8:	51 81       	ldd	r21, Z+1	; 0x01
    7ffa:	ec 81       	ldd	r30, Y+4	; 0x04
    7ffc:	fd 81       	ldd	r31, Y+5	; 0x05
    7ffe:	21 81       	ldd	r18, Z+1	; 0x01
    8000:	32 81       	ldd	r19, Z+2	; 0x02
    8002:	89 81       	ldd	r24, Y+1	; 0x01
    8004:	9a 81       	ldd	r25, Y+2	; 0x02
    8006:	b9 01       	movw	r22, r18
    8008:	68 1b       	sub	r22, r24
    800a:	79 0b       	sbc	r23, r25
    800c:	cb 01       	movw	r24, r22
    800e:	84 0f       	add	r24, r20
    8010:	95 1f       	adc	r25, r21
    8012:	ee 81       	ldd	r30, Y+6	; 0x06
    8014:	ff 81       	ldd	r31, Y+7	; 0x07
    8016:	91 83       	std	Z+1, r25	; 0x01
    8018:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    801a:	8c 81       	ldd	r24, Y+4	; 0x04
    801c:	9d 81       	ldd	r25, Y+5	; 0x05
    801e:	0e 94 9b 3f 	call	0x7f36	; 0x7f36 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    8022:	1b 82       	std	Y+3, r1	; 0x03
    8024:	02 c0       	rjmp	.+4      	; 0x802a <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    8026:	81 e0       	ldi	r24, 0x01	; 1
    8028:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    802a:	0f 90       	pop	r0
    802c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    802e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    8030:	27 96       	adiw	r28, 0x07	; 7
    8032:	0f b6       	in	r0, 0x3f	; 63
    8034:	f8 94       	cli
    8036:	de bf       	out	0x3e, r29	; 62
    8038:	0f be       	out	0x3f, r0	; 63
    803a:	cd bf       	out	0x3d, r28	; 61
    803c:	cf 91       	pop	r28
    803e:	df 91       	pop	r29
    8040:	08 95       	ret

00008042 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    8042:	df 93       	push	r29
    8044:	cf 93       	push	r28
    8046:	cd b7       	in	r28, 0x3d	; 61
    8048:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    804a:	81 e0       	ldi	r24, 0x01	; 1
    804c:	80 93 95 05 	sts	0x0595, r24
}
    8050:	cf 91       	pop	r28
    8052:	df 91       	pop	r29
    8054:	08 95       	ret

00008056 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    8056:	df 93       	push	r29
    8058:	cf 93       	push	r28
    805a:	00 d0       	rcall	.+0      	; 0x805c <prvIdleTask+0x6>
    805c:	cd b7       	in	r28, 0x3d	; 61
    805e:	de b7       	in	r29, 0x3e	; 62
    8060:	9a 83       	std	Y+2, r25	; 0x02
    8062:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    8064:	0e 94 76 40 	call	0x80ec	; 0x80ec <prvCheckTasksWaitingTermination>
    8068:	fd cf       	rjmp	.-6      	; 0x8064 <prvIdleTask+0xe>

0000806a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    806a:	df 93       	push	r29
    806c:	cf 93       	push	r28
    806e:	0f 92       	push	r0
    8070:	cd b7       	in	r28, 0x3d	; 61
    8072:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    8074:	19 82       	std	Y+1, r1	; 0x01
    8076:	13 c0       	rjmp	.+38     	; 0x809e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    8078:	89 81       	ldd	r24, Y+1	; 0x01
    807a:	28 2f       	mov	r18, r24
    807c:	30 e0       	ldi	r19, 0x00	; 0
    807e:	c9 01       	movw	r24, r18
    8080:	88 0f       	add	r24, r24
    8082:	99 1f       	adc	r25, r25
    8084:	88 0f       	add	r24, r24
    8086:	99 1f       	adc	r25, r25
    8088:	88 0f       	add	r24, r24
    808a:	99 1f       	adc	r25, r25
    808c:	82 0f       	add	r24, r18
    808e:	93 1f       	adc	r25, r19
    8090:	83 56       	subi	r24, 0x63	; 99
    8092:	9a 4f       	sbci	r25, 0xFA	; 250
    8094:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    8098:	89 81       	ldd	r24, Y+1	; 0x01
    809a:	8f 5f       	subi	r24, 0xFF	; 255
    809c:	89 83       	std	Y+1, r24	; 0x01
    809e:	89 81       	ldd	r24, Y+1	; 0x01
    80a0:	89 30       	cpi	r24, 0x09	; 9
    80a2:	50 f3       	brcs	.-44     	; 0x8078 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    80a4:	8e ee       	ldi	r24, 0xEE	; 238
    80a6:	95 e0       	ldi	r25, 0x05	; 5
    80a8:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    80ac:	87 ef       	ldi	r24, 0xF7	; 247
    80ae:	95 e0       	ldi	r25, 0x05	; 5
    80b0:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    80b4:	84 e0       	ldi	r24, 0x04	; 4
    80b6:	96 e0       	ldi	r25, 0x06	; 6
    80b8:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    80bc:	8d e0       	ldi	r24, 0x0D	; 13
    80be:	96 e0       	ldi	r25, 0x06	; 6
    80c0:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    80c4:	86 e1       	ldi	r24, 0x16	; 22
    80c6:	96 e0       	ldi	r25, 0x06	; 6
    80c8:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    80cc:	8e ee       	ldi	r24, 0xEE	; 238
    80ce:	95 e0       	ldi	r25, 0x05	; 5
    80d0:	90 93 01 06 	sts	0x0601, r25
    80d4:	80 93 00 06 	sts	0x0600, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    80d8:	87 ef       	ldi	r24, 0xF7	; 247
    80da:	95 e0       	ldi	r25, 0x05	; 5
    80dc:	90 93 03 06 	sts	0x0603, r25
    80e0:	80 93 02 06 	sts	0x0602, r24
}
    80e4:	0f 90       	pop	r0
    80e6:	cf 91       	pop	r28
    80e8:	df 91       	pop	r29
    80ea:	08 95       	ret

000080ec <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    80ec:	df 93       	push	r29
    80ee:	cf 93       	push	r28
    80f0:	00 d0       	rcall	.+0      	; 0x80f2 <prvCheckTasksWaitingTermination+0x6>
    80f2:	0f 92       	push	r0
    80f4:	cd b7       	in	r28, 0x3d	; 61
    80f6:	de b7       	in	r29, 0x3e	; 62
    80f8:	2e c0       	rjmp	.+92     	; 0x8156 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    80fa:	0e 94 44 3c 	call	0x7888	; 0x7888 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    80fe:	80 91 0d 06 	lds	r24, 0x060D
    8102:	1b 82       	std	Y+3, r1	; 0x03
    8104:	88 23       	and	r24, r24
    8106:	11 f4       	brne	.+4      	; 0x810c <prvCheckTasksWaitingTermination+0x20>
    8108:	81 e0       	ldi	r24, 0x01	; 1
    810a:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    810c:	0e 94 50 3c 	call	0x78a0	; 0x78a0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    8110:	8b 81       	ldd	r24, Y+3	; 0x03
    8112:	88 23       	and	r24, r24
    8114:	01 f5       	brne	.+64     	; 0x8156 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    8116:	0f b6       	in	r0, 0x3f	; 63
    8118:	f8 94       	cli
    811a:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    811c:	e0 91 12 06 	lds	r30, 0x0612
    8120:	f0 91 13 06 	lds	r31, 0x0613
    8124:	86 81       	ldd	r24, Z+6	; 0x06
    8126:	97 81       	ldd	r25, Z+7	; 0x07
    8128:	9a 83       	std	Y+2, r25	; 0x02
    812a:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    812c:	89 81       	ldd	r24, Y+1	; 0x01
    812e:	9a 81       	ldd	r25, Y+2	; 0x02
    8130:	02 96       	adiw	r24, 0x02	; 2
    8132:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					--uxCurrentNumberOfTasks;
    8136:	80 91 8f 05 	lds	r24, 0x058F
    813a:	81 50       	subi	r24, 0x01	; 1
    813c:	80 93 8f 05 	sts	0x058F, r24
					--uxDeletedTasksWaitingCleanUp;
    8140:	80 91 8e 05 	lds	r24, 0x058E
    8144:	81 50       	subi	r24, 0x01	; 1
    8146:	80 93 8e 05 	sts	0x058E, r24
				}
				taskEXIT_CRITICAL();
    814a:	0f 90       	pop	r0
    814c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    814e:	89 81       	ldd	r24, Y+1	; 0x01
    8150:	9a 81       	ldd	r25, Y+2	; 0x02
    8152:	0e 94 b5 40 	call	0x816a	; 0x816a <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    8156:	80 91 8e 05 	lds	r24, 0x058E
    815a:	88 23       	and	r24, r24
    815c:	71 f6       	brne	.-100    	; 0x80fa <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    815e:	0f 90       	pop	r0
    8160:	0f 90       	pop	r0
    8162:	0f 90       	pop	r0
    8164:	cf 91       	pop	r28
    8166:	df 91       	pop	r29
    8168:	08 95       	ret

0000816a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    816a:	df 93       	push	r29
    816c:	cf 93       	push	r28
    816e:	00 d0       	rcall	.+0      	; 0x8170 <prvDeleteTCB+0x6>
    8170:	cd b7       	in	r28, 0x3d	; 61
    8172:	de b7       	in	r29, 0x3e	; 62
    8174:	9a 83       	std	Y+2, r25	; 0x02
    8176:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    8178:	e9 81       	ldd	r30, Y+1	; 0x01
    817a:	fa 81       	ldd	r31, Y+2	; 0x02
    817c:	87 89       	ldd	r24, Z+23	; 0x17
    817e:	90 8d       	ldd	r25, Z+24	; 0x18
    8180:	0e 94 20 2c 	call	0x5840	; 0x5840 <vPortFree>
			vPortFree( pxTCB );
    8184:	89 81       	ldd	r24, Y+1	; 0x01
    8186:	9a 81       	ldd	r25, Y+2	; 0x02
    8188:	0e 94 20 2c 	call	0x5840	; 0x5840 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    818c:	0f 90       	pop	r0
    818e:	0f 90       	pop	r0
    8190:	cf 91       	pop	r28
    8192:	df 91       	pop	r29
    8194:	08 95       	ret

00008196 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    8196:	df 93       	push	r29
    8198:	cf 93       	push	r28
    819a:	00 d0       	rcall	.+0      	; 0x819c <prvResetNextTaskUnblockTime+0x6>
    819c:	cd b7       	in	r28, 0x3d	; 61
    819e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    81a0:	e0 91 00 06 	lds	r30, 0x0600
    81a4:	f0 91 01 06 	lds	r31, 0x0601
    81a8:	80 81       	ld	r24, Z
    81aa:	88 23       	and	r24, r24
    81ac:	39 f4       	brne	.+14     	; 0x81bc <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    81ae:	8f ef       	ldi	r24, 0xFF	; 255
    81b0:	9f ef       	ldi	r25, 0xFF	; 255
    81b2:	90 93 99 05 	sts	0x0599, r25
    81b6:	80 93 98 05 	sts	0x0598, r24
    81ba:	13 c0       	rjmp	.+38     	; 0x81e2 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    81bc:	e0 91 00 06 	lds	r30, 0x0600
    81c0:	f0 91 01 06 	lds	r31, 0x0601
    81c4:	05 80       	ldd	r0, Z+5	; 0x05
    81c6:	f6 81       	ldd	r31, Z+6	; 0x06
    81c8:	e0 2d       	mov	r30, r0
    81ca:	86 81       	ldd	r24, Z+6	; 0x06
    81cc:	97 81       	ldd	r25, Z+7	; 0x07
    81ce:	9a 83       	std	Y+2, r25	; 0x02
    81d0:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    81d2:	e9 81       	ldd	r30, Y+1	; 0x01
    81d4:	fa 81       	ldd	r31, Y+2	; 0x02
    81d6:	82 81       	ldd	r24, Z+2	; 0x02
    81d8:	93 81       	ldd	r25, Z+3	; 0x03
    81da:	90 93 99 05 	sts	0x0599, r25
    81de:	80 93 98 05 	sts	0x0598, r24
	}
}
    81e2:	0f 90       	pop	r0
    81e4:	0f 90       	pop	r0
    81e6:	cf 91       	pop	r28
    81e8:	df 91       	pop	r29
    81ea:	08 95       	ret

000081ec <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    81ec:	df 93       	push	r29
    81ee:	cf 93       	push	r28
    81f0:	00 d0       	rcall	.+0      	; 0x81f2 <xTaskGetCurrentTaskHandle+0x6>
    81f2:	cd b7       	in	r28, 0x3d	; 61
    81f4:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    81f6:	80 91 8c 05 	lds	r24, 0x058C
    81fa:	90 91 8d 05 	lds	r25, 0x058D
    81fe:	9a 83       	std	Y+2, r25	; 0x02
    8200:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    8202:	89 81       	ldd	r24, Y+1	; 0x01
    8204:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    8206:	0f 90       	pop	r0
    8208:	0f 90       	pop	r0
    820a:	cf 91       	pop	r28
    820c:	df 91       	pop	r29
    820e:	08 95       	ret

00008210 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    8210:	df 93       	push	r29
    8212:	cf 93       	push	r28
    8214:	00 d0       	rcall	.+0      	; 0x8216 <vTaskPriorityInherit+0x6>
    8216:	00 d0       	rcall	.+0      	; 0x8218 <vTaskPriorityInherit+0x8>
    8218:	cd b7       	in	r28, 0x3d	; 61
    821a:	de b7       	in	r29, 0x3e	; 62
    821c:	9c 83       	std	Y+4, r25	; 0x04
    821e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    8220:	8b 81       	ldd	r24, Y+3	; 0x03
    8222:	9c 81       	ldd	r25, Y+4	; 0x04
    8224:	9a 83       	std	Y+2, r25	; 0x02
    8226:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    8228:	8b 81       	ldd	r24, Y+3	; 0x03
    822a:	9c 81       	ldd	r25, Y+4	; 0x04
    822c:	00 97       	sbiw	r24, 0x00	; 0
    822e:	09 f4       	brne	.+2      	; 0x8232 <vTaskPriorityInherit+0x22>
    8230:	73 c0       	rjmp	.+230    	; 0x8318 <vTaskPriorityInherit+0x108>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    8232:	e9 81       	ldd	r30, Y+1	; 0x01
    8234:	fa 81       	ldd	r31, Y+2	; 0x02
    8236:	96 89       	ldd	r25, Z+22	; 0x16
    8238:	e0 91 8c 05 	lds	r30, 0x058C
    823c:	f0 91 8d 05 	lds	r31, 0x058D
    8240:	86 89       	ldd	r24, Z+22	; 0x16
    8242:	98 17       	cp	r25, r24
    8244:	08 f0       	brcs	.+2      	; 0x8248 <vTaskPriorityInherit+0x38>
    8246:	68 c0       	rjmp	.+208    	; 0x8318 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    8248:	e9 81       	ldd	r30, Y+1	; 0x01
    824a:	fa 81       	ldd	r31, Y+2	; 0x02
    824c:	84 85       	ldd	r24, Z+12	; 0x0c
    824e:	95 85       	ldd	r25, Z+13	; 0x0d
    8250:	99 23       	and	r25, r25
    8252:	7c f0       	brlt	.+30     	; 0x8272 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    8254:	e0 91 8c 05 	lds	r30, 0x058C
    8258:	f0 91 8d 05 	lds	r31, 0x058D
    825c:	86 89       	ldd	r24, Z+22	; 0x16
    825e:	28 2f       	mov	r18, r24
    8260:	30 e0       	ldi	r19, 0x00	; 0
    8262:	89 e0       	ldi	r24, 0x09	; 9
    8264:	90 e0       	ldi	r25, 0x00	; 0
    8266:	82 1b       	sub	r24, r18
    8268:	93 0b       	sbc	r25, r19
    826a:	e9 81       	ldd	r30, Y+1	; 0x01
    826c:	fa 81       	ldd	r31, Y+2	; 0x02
    826e:	95 87       	std	Z+13, r25	; 0x0d
    8270:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    8272:	e9 81       	ldd	r30, Y+1	; 0x01
    8274:	fa 81       	ldd	r31, Y+2	; 0x02
    8276:	42 85       	ldd	r20, Z+10	; 0x0a
    8278:	53 85       	ldd	r21, Z+11	; 0x0b
    827a:	e9 81       	ldd	r30, Y+1	; 0x01
    827c:	fa 81       	ldd	r31, Y+2	; 0x02
    827e:	86 89       	ldd	r24, Z+22	; 0x16
    8280:	28 2f       	mov	r18, r24
    8282:	30 e0       	ldi	r19, 0x00	; 0
    8284:	c9 01       	movw	r24, r18
    8286:	88 0f       	add	r24, r24
    8288:	99 1f       	adc	r25, r25
    828a:	88 0f       	add	r24, r24
    828c:	99 1f       	adc	r25, r25
    828e:	88 0f       	add	r24, r24
    8290:	99 1f       	adc	r25, r25
    8292:	82 0f       	add	r24, r18
    8294:	93 1f       	adc	r25, r19
    8296:	83 56       	subi	r24, 0x63	; 99
    8298:	9a 4f       	sbci	r25, 0xFA	; 250
    829a:	48 17       	cp	r20, r24
    829c:	59 07       	cpc	r21, r25
    829e:	a1 f5       	brne	.+104    	; 0x8308 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    82a0:	89 81       	ldd	r24, Y+1	; 0x01
    82a2:	9a 81       	ldd	r25, Y+2	; 0x02
    82a4:	02 96       	adiw	r24, 0x02	; 2
    82a6:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    82aa:	e0 91 8c 05 	lds	r30, 0x058C
    82ae:	f0 91 8d 05 	lds	r31, 0x058D
    82b2:	86 89       	ldd	r24, Z+22	; 0x16
    82b4:	e9 81       	ldd	r30, Y+1	; 0x01
    82b6:	fa 81       	ldd	r31, Y+2	; 0x02
    82b8:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    82ba:	e9 81       	ldd	r30, Y+1	; 0x01
    82bc:	fa 81       	ldd	r31, Y+2	; 0x02
    82be:	96 89       	ldd	r25, Z+22	; 0x16
    82c0:	80 91 92 05 	lds	r24, 0x0592
    82c4:	89 17       	cp	r24, r25
    82c6:	28 f4       	brcc	.+10     	; 0x82d2 <vTaskPriorityInherit+0xc2>
    82c8:	e9 81       	ldd	r30, Y+1	; 0x01
    82ca:	fa 81       	ldd	r31, Y+2	; 0x02
    82cc:	86 89       	ldd	r24, Z+22	; 0x16
    82ce:	80 93 92 05 	sts	0x0592, r24
    82d2:	e9 81       	ldd	r30, Y+1	; 0x01
    82d4:	fa 81       	ldd	r31, Y+2	; 0x02
    82d6:	86 89       	ldd	r24, Z+22	; 0x16
    82d8:	28 2f       	mov	r18, r24
    82da:	30 e0       	ldi	r19, 0x00	; 0
    82dc:	c9 01       	movw	r24, r18
    82de:	88 0f       	add	r24, r24
    82e0:	99 1f       	adc	r25, r25
    82e2:	88 0f       	add	r24, r24
    82e4:	99 1f       	adc	r25, r25
    82e6:	88 0f       	add	r24, r24
    82e8:	99 1f       	adc	r25, r25
    82ea:	82 0f       	add	r24, r18
    82ec:	93 1f       	adc	r25, r19
    82ee:	ac 01       	movw	r20, r24
    82f0:	43 56       	subi	r20, 0x63	; 99
    82f2:	5a 4f       	sbci	r21, 0xFA	; 250
    82f4:	89 81       	ldd	r24, Y+1	; 0x01
    82f6:	9a 81       	ldd	r25, Y+2	; 0x02
    82f8:	9c 01       	movw	r18, r24
    82fa:	2e 5f       	subi	r18, 0xFE	; 254
    82fc:	3f 4f       	sbci	r19, 0xFF	; 255
    82fe:	ca 01       	movw	r24, r20
    8300:	b9 01       	movw	r22, r18
    8302:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
    8306:	08 c0       	rjmp	.+16     	; 0x8318 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    8308:	e0 91 8c 05 	lds	r30, 0x058C
    830c:	f0 91 8d 05 	lds	r31, 0x058D
    8310:	86 89       	ldd	r24, Z+22	; 0x16
    8312:	e9 81       	ldd	r30, Y+1	; 0x01
    8314:	fa 81       	ldd	r31, Y+2	; 0x02
    8316:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    8318:	0f 90       	pop	r0
    831a:	0f 90       	pop	r0
    831c:	0f 90       	pop	r0
    831e:	0f 90       	pop	r0
    8320:	cf 91       	pop	r28
    8322:	df 91       	pop	r29
    8324:	08 95       	ret

00008326 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    8326:	df 93       	push	r29
    8328:	cf 93       	push	r28
    832a:	00 d0       	rcall	.+0      	; 0x832c <xTaskPriorityDisinherit+0x6>
    832c:	00 d0       	rcall	.+0      	; 0x832e <xTaskPriorityDisinherit+0x8>
    832e:	0f 92       	push	r0
    8330:	cd b7       	in	r28, 0x3d	; 61
    8332:	de b7       	in	r29, 0x3e	; 62
    8334:	9d 83       	std	Y+5, r25	; 0x05
    8336:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    8338:	8c 81       	ldd	r24, Y+4	; 0x04
    833a:	9d 81       	ldd	r25, Y+5	; 0x05
    833c:	9b 83       	std	Y+3, r25	; 0x03
    833e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    8340:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    8342:	8c 81       	ldd	r24, Y+4	; 0x04
    8344:	9d 81       	ldd	r25, Y+5	; 0x05
    8346:	00 97       	sbiw	r24, 0x00	; 0
    8348:	09 f4       	brne	.+2      	; 0x834c <xTaskPriorityDisinherit+0x26>
    834a:	56 c0       	rjmp	.+172    	; 0x83f8 <xTaskPriorityDisinherit+0xd2>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    834c:	ea 81       	ldd	r30, Y+2	; 0x02
    834e:	fb 81       	ldd	r31, Y+3	; 0x03
    8350:	82 a1       	ldd	r24, Z+34	; 0x22
    8352:	81 50       	subi	r24, 0x01	; 1
    8354:	ea 81       	ldd	r30, Y+2	; 0x02
    8356:	fb 81       	ldd	r31, Y+3	; 0x03
    8358:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    835a:	ea 81       	ldd	r30, Y+2	; 0x02
    835c:	fb 81       	ldd	r31, Y+3	; 0x03
    835e:	96 89       	ldd	r25, Z+22	; 0x16
    8360:	ea 81       	ldd	r30, Y+2	; 0x02
    8362:	fb 81       	ldd	r31, Y+3	; 0x03
    8364:	81 a1       	ldd	r24, Z+33	; 0x21
    8366:	98 17       	cp	r25, r24
    8368:	09 f4       	brne	.+2      	; 0x836c <xTaskPriorityDisinherit+0x46>
    836a:	46 c0       	rjmp	.+140    	; 0x83f8 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    836c:	ea 81       	ldd	r30, Y+2	; 0x02
    836e:	fb 81       	ldd	r31, Y+3	; 0x03
    8370:	82 a1       	ldd	r24, Z+34	; 0x22
    8372:	88 23       	and	r24, r24
    8374:	09 f0       	breq	.+2      	; 0x8378 <xTaskPriorityDisinherit+0x52>
    8376:	40 c0       	rjmp	.+128    	; 0x83f8 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    8378:	8a 81       	ldd	r24, Y+2	; 0x02
    837a:	9b 81       	ldd	r25, Y+3	; 0x03
    837c:	02 96       	adiw	r24, 0x02	; 2
    837e:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    8382:	ea 81       	ldd	r30, Y+2	; 0x02
    8384:	fb 81       	ldd	r31, Y+3	; 0x03
    8386:	81 a1       	ldd	r24, Z+33	; 0x21
    8388:	ea 81       	ldd	r30, Y+2	; 0x02
    838a:	fb 81       	ldd	r31, Y+3	; 0x03
    838c:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    838e:	ea 81       	ldd	r30, Y+2	; 0x02
    8390:	fb 81       	ldd	r31, Y+3	; 0x03
    8392:	86 89       	ldd	r24, Z+22	; 0x16
    8394:	28 2f       	mov	r18, r24
    8396:	30 e0       	ldi	r19, 0x00	; 0
    8398:	89 e0       	ldi	r24, 0x09	; 9
    839a:	90 e0       	ldi	r25, 0x00	; 0
    839c:	82 1b       	sub	r24, r18
    839e:	93 0b       	sbc	r25, r19
    83a0:	ea 81       	ldd	r30, Y+2	; 0x02
    83a2:	fb 81       	ldd	r31, Y+3	; 0x03
    83a4:	95 87       	std	Z+13, r25	; 0x0d
    83a6:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    83a8:	ea 81       	ldd	r30, Y+2	; 0x02
    83aa:	fb 81       	ldd	r31, Y+3	; 0x03
    83ac:	96 89       	ldd	r25, Z+22	; 0x16
    83ae:	80 91 92 05 	lds	r24, 0x0592
    83b2:	89 17       	cp	r24, r25
    83b4:	28 f4       	brcc	.+10     	; 0x83c0 <xTaskPriorityDisinherit+0x9a>
    83b6:	ea 81       	ldd	r30, Y+2	; 0x02
    83b8:	fb 81       	ldd	r31, Y+3	; 0x03
    83ba:	86 89       	ldd	r24, Z+22	; 0x16
    83bc:	80 93 92 05 	sts	0x0592, r24
    83c0:	ea 81       	ldd	r30, Y+2	; 0x02
    83c2:	fb 81       	ldd	r31, Y+3	; 0x03
    83c4:	86 89       	ldd	r24, Z+22	; 0x16
    83c6:	28 2f       	mov	r18, r24
    83c8:	30 e0       	ldi	r19, 0x00	; 0
    83ca:	c9 01       	movw	r24, r18
    83cc:	88 0f       	add	r24, r24
    83ce:	99 1f       	adc	r25, r25
    83d0:	88 0f       	add	r24, r24
    83d2:	99 1f       	adc	r25, r25
    83d4:	88 0f       	add	r24, r24
    83d6:	99 1f       	adc	r25, r25
    83d8:	82 0f       	add	r24, r18
    83da:	93 1f       	adc	r25, r19
    83dc:	ac 01       	movw	r20, r24
    83de:	43 56       	subi	r20, 0x63	; 99
    83e0:	5a 4f       	sbci	r21, 0xFA	; 250
    83e2:	8a 81       	ldd	r24, Y+2	; 0x02
    83e4:	9b 81       	ldd	r25, Y+3	; 0x03
    83e6:	9c 01       	movw	r18, r24
    83e8:	2e 5f       	subi	r18, 0xFE	; 254
    83ea:	3f 4f       	sbci	r19, 0xFF	; 255
    83ec:	ca 01       	movw	r24, r20
    83ee:	b9 01       	movw	r22, r18
    83f0:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    83f4:	81 e0       	ldi	r24, 0x01	; 1
    83f6:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    83f8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    83fa:	0f 90       	pop	r0
    83fc:	0f 90       	pop	r0
    83fe:	0f 90       	pop	r0
    8400:	0f 90       	pop	r0
    8402:	0f 90       	pop	r0
    8404:	cf 91       	pop	r28
    8406:	df 91       	pop	r29
    8408:	08 95       	ret

0000840a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    840a:	df 93       	push	r29
    840c:	cf 93       	push	r28
    840e:	00 d0       	rcall	.+0      	; 0x8410 <uxTaskResetEventItemValue+0x6>
    8410:	cd b7       	in	r28, 0x3d	; 61
    8412:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    8414:	e0 91 8c 05 	lds	r30, 0x058C
    8418:	f0 91 8d 05 	lds	r31, 0x058D
    841c:	84 85       	ldd	r24, Z+12	; 0x0c
    841e:	95 85       	ldd	r25, Z+13	; 0x0d
    8420:	9a 83       	std	Y+2, r25	; 0x02
    8422:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    8424:	a0 91 8c 05 	lds	r26, 0x058C
    8428:	b0 91 8d 05 	lds	r27, 0x058D
    842c:	e0 91 8c 05 	lds	r30, 0x058C
    8430:	f0 91 8d 05 	lds	r31, 0x058D
    8434:	86 89       	ldd	r24, Z+22	; 0x16
    8436:	28 2f       	mov	r18, r24
    8438:	30 e0       	ldi	r19, 0x00	; 0
    843a:	89 e0       	ldi	r24, 0x09	; 9
    843c:	90 e0       	ldi	r25, 0x00	; 0
    843e:	82 1b       	sub	r24, r18
    8440:	93 0b       	sbc	r25, r19
    8442:	1d 96       	adiw	r26, 0x0d	; 13
    8444:	9c 93       	st	X, r25
    8446:	8e 93       	st	-X, r24
    8448:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    844a:	89 81       	ldd	r24, Y+1	; 0x01
    844c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    844e:	0f 90       	pop	r0
    8450:	0f 90       	pop	r0
    8452:	cf 91       	pop	r28
    8454:	df 91       	pop	r29
    8456:	08 95       	ret

00008458 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    8458:	df 93       	push	r29
    845a:	cf 93       	push	r28
    845c:	cd b7       	in	r28, 0x3d	; 61
    845e:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    8460:	80 91 8c 05 	lds	r24, 0x058C
    8464:	90 91 8d 05 	lds	r25, 0x058D
    8468:	00 97       	sbiw	r24, 0x00	; 0
    846a:	39 f0       	breq	.+14     	; 0x847a <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    846c:	e0 91 8c 05 	lds	r30, 0x058C
    8470:	f0 91 8d 05 	lds	r31, 0x058D
    8474:	82 a1       	ldd	r24, Z+34	; 0x22
    8476:	8f 5f       	subi	r24, 0xFF	; 255
    8478:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    847a:	80 91 8c 05 	lds	r24, 0x058C
    847e:	90 91 8d 05 	lds	r25, 0x058D
	}
    8482:	cf 91       	pop	r28
    8484:	df 91       	pop	r29
    8486:	08 95       	ret

00008488 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    8488:	df 93       	push	r29
    848a:	cf 93       	push	r28
    848c:	cd b7       	in	r28, 0x3d	; 61
    848e:	de b7       	in	r29, 0x3e	; 62
    8490:	27 97       	sbiw	r28, 0x07	; 7
    8492:	0f b6       	in	r0, 0x3f	; 63
    8494:	f8 94       	cli
    8496:	de bf       	out	0x3e, r29	; 62
    8498:	0f be       	out	0x3f, r0	; 63
    849a:	cd bf       	out	0x3d, r28	; 61
    849c:	8d 83       	std	Y+5, r24	; 0x05
    849e:	7f 83       	std	Y+7, r23	; 0x07
    84a0:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    84a2:	0f b6       	in	r0, 0x3f	; 63
    84a4:	f8 94       	cli
    84a6:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    84a8:	e0 91 8c 05 	lds	r30, 0x058C
    84ac:	f0 91 8d 05 	lds	r31, 0x058D
    84b0:	83 a1       	ldd	r24, Z+35	; 0x23
    84b2:	94 a1       	ldd	r25, Z+36	; 0x24
    84b4:	a5 a1       	ldd	r26, Z+37	; 0x25
    84b6:	b6 a1       	ldd	r27, Z+38	; 0x26
    84b8:	00 97       	sbiw	r24, 0x00	; 0
    84ba:	a1 05       	cpc	r26, r1
    84bc:	b1 05       	cpc	r27, r1
    84be:	89 f4       	brne	.+34     	; 0x84e2 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    84c0:	e0 91 8c 05 	lds	r30, 0x058C
    84c4:	f0 91 8d 05 	lds	r31, 0x058D
    84c8:	81 e0       	ldi	r24, 0x01	; 1
    84ca:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    84cc:	8e 81       	ldd	r24, Y+6	; 0x06
    84ce:	9f 81       	ldd	r25, Y+7	; 0x07
    84d0:	00 97       	sbiw	r24, 0x00	; 0
    84d2:	39 f0       	breq	.+14     	; 0x84e2 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    84d4:	8e 81       	ldd	r24, Y+6	; 0x06
    84d6:	9f 81       	ldd	r25, Y+7	; 0x07
    84d8:	61 e0       	ldi	r22, 0x01	; 1
    84da:	0e 94 ee 45 	call	0x8bdc	; 0x8bdc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    84de:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    84e2:	0f 90       	pop	r0
    84e4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    84e6:	0f b6       	in	r0, 0x3f	; 63
    84e8:	f8 94       	cli
    84ea:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    84ec:	e0 91 8c 05 	lds	r30, 0x058C
    84f0:	f0 91 8d 05 	lds	r31, 0x058D
    84f4:	83 a1       	ldd	r24, Z+35	; 0x23
    84f6:	94 a1       	ldd	r25, Z+36	; 0x24
    84f8:	a5 a1       	ldd	r26, Z+37	; 0x25
    84fa:	b6 a1       	ldd	r27, Z+38	; 0x26
    84fc:	89 83       	std	Y+1, r24	; 0x01
    84fe:	9a 83       	std	Y+2, r25	; 0x02
    8500:	ab 83       	std	Y+3, r26	; 0x03
    8502:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    8504:	89 81       	ldd	r24, Y+1	; 0x01
    8506:	9a 81       	ldd	r25, Y+2	; 0x02
    8508:	ab 81       	ldd	r26, Y+3	; 0x03
    850a:	bc 81       	ldd	r27, Y+4	; 0x04
    850c:	00 97       	sbiw	r24, 0x00	; 0
    850e:	a1 05       	cpc	r26, r1
    8510:	b1 05       	cpc	r27, r1
    8512:	d9 f0       	breq	.+54     	; 0x854a <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    8514:	8d 81       	ldd	r24, Y+5	; 0x05
    8516:	88 23       	and	r24, r24
    8518:	49 f0       	breq	.+18     	; 0x852c <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    851a:	e0 91 8c 05 	lds	r30, 0x058C
    851e:	f0 91 8d 05 	lds	r31, 0x058D
    8522:	13 a2       	std	Z+35, r1	; 0x23
    8524:	14 a2       	std	Z+36, r1	; 0x24
    8526:	15 a2       	std	Z+37, r1	; 0x25
    8528:	16 a2       	std	Z+38, r1	; 0x26
    852a:	0f c0       	rjmp	.+30     	; 0x854a <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    852c:	e0 91 8c 05 	lds	r30, 0x058C
    8530:	f0 91 8d 05 	lds	r31, 0x058D
    8534:	89 81       	ldd	r24, Y+1	; 0x01
    8536:	9a 81       	ldd	r25, Y+2	; 0x02
    8538:	ab 81       	ldd	r26, Y+3	; 0x03
    853a:	bc 81       	ldd	r27, Y+4	; 0x04
    853c:	01 97       	sbiw	r24, 0x01	; 1
    853e:	a1 09       	sbc	r26, r1
    8540:	b1 09       	sbc	r27, r1
    8542:	83 a3       	std	Z+35, r24	; 0x23
    8544:	94 a3       	std	Z+36, r25	; 0x24
    8546:	a5 a3       	std	Z+37, r26	; 0x25
    8548:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    854a:	e0 91 8c 05 	lds	r30, 0x058C
    854e:	f0 91 8d 05 	lds	r31, 0x058D
    8552:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    8554:	0f 90       	pop	r0
    8556:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    8558:	89 81       	ldd	r24, Y+1	; 0x01
    855a:	9a 81       	ldd	r25, Y+2	; 0x02
    855c:	ab 81       	ldd	r26, Y+3	; 0x03
    855e:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    8560:	bc 01       	movw	r22, r24
    8562:	cd 01       	movw	r24, r26
    8564:	27 96       	adiw	r28, 0x07	; 7
    8566:	0f b6       	in	r0, 0x3f	; 63
    8568:	f8 94       	cli
    856a:	de bf       	out	0x3e, r29	; 62
    856c:	0f be       	out	0x3f, r0	; 63
    856e:	cd bf       	out	0x3d, r28	; 61
    8570:	cf 91       	pop	r28
    8572:	df 91       	pop	r29
    8574:	08 95       	ret

00008576 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    8576:	ef 92       	push	r14
    8578:	ff 92       	push	r15
    857a:	0f 93       	push	r16
    857c:	1f 93       	push	r17
    857e:	df 93       	push	r29
    8580:	cf 93       	push	r28
    8582:	cd b7       	in	r28, 0x3d	; 61
    8584:	de b7       	in	r29, 0x3e	; 62
    8586:	2d 97       	sbiw	r28, 0x0d	; 13
    8588:	0f b6       	in	r0, 0x3f	; 63
    858a:	f8 94       	cli
    858c:	de bf       	out	0x3e, r29	; 62
    858e:	0f be       	out	0x3f, r0	; 63
    8590:	cd bf       	out	0x3d, r28	; 61
    8592:	6a 83       	std	Y+2, r22	; 0x02
    8594:	7b 83       	std	Y+3, r23	; 0x03
    8596:	8c 83       	std	Y+4, r24	; 0x04
    8598:	9d 83       	std	Y+5, r25	; 0x05
    859a:	2e 83       	std	Y+6, r18	; 0x06
    859c:	3f 83       	std	Y+7, r19	; 0x07
    859e:	48 87       	std	Y+8, r20	; 0x08
    85a0:	59 87       	std	Y+9, r21	; 0x09
    85a2:	1b 87       	std	Y+11, r17	; 0x0b
    85a4:	0a 87       	std	Y+10, r16	; 0x0a
    85a6:	fd 86       	std	Y+13, r15	; 0x0d
    85a8:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    85aa:	0f b6       	in	r0, 0x3f	; 63
    85ac:	f8 94       	cli
    85ae:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    85b0:	e0 91 8c 05 	lds	r30, 0x058C
    85b4:	f0 91 8d 05 	lds	r31, 0x058D
    85b8:	87 a1       	ldd	r24, Z+39	; 0x27
    85ba:	82 30       	cpi	r24, 0x02	; 2
    85bc:	49 f1       	breq	.+82     	; 0x8610 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    85be:	e0 91 8c 05 	lds	r30, 0x058C
    85c2:	f0 91 8d 05 	lds	r31, 0x058D
    85c6:	23 a1       	ldd	r18, Z+35	; 0x23
    85c8:	34 a1       	ldd	r19, Z+36	; 0x24
    85ca:	45 a1       	ldd	r20, Z+37	; 0x25
    85cc:	56 a1       	ldd	r21, Z+38	; 0x26
    85ce:	8a 81       	ldd	r24, Y+2	; 0x02
    85d0:	9b 81       	ldd	r25, Y+3	; 0x03
    85d2:	ac 81       	ldd	r26, Y+4	; 0x04
    85d4:	bd 81       	ldd	r27, Y+5	; 0x05
    85d6:	80 95       	com	r24
    85d8:	90 95       	com	r25
    85da:	a0 95       	com	r26
    85dc:	b0 95       	com	r27
    85de:	82 23       	and	r24, r18
    85e0:	93 23       	and	r25, r19
    85e2:	a4 23       	and	r26, r20
    85e4:	b5 23       	and	r27, r21
    85e6:	83 a3       	std	Z+35, r24	; 0x23
    85e8:	94 a3       	std	Z+36, r25	; 0x24
    85ea:	a5 a3       	std	Z+37, r26	; 0x25
    85ec:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    85ee:	e0 91 8c 05 	lds	r30, 0x058C
    85f2:	f0 91 8d 05 	lds	r31, 0x058D
    85f6:	81 e0       	ldi	r24, 0x01	; 1
    85f8:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    85fa:	8c 85       	ldd	r24, Y+12	; 0x0c
    85fc:	9d 85       	ldd	r25, Y+13	; 0x0d
    85fe:	00 97       	sbiw	r24, 0x00	; 0
    8600:	39 f0       	breq	.+14     	; 0x8610 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    8602:	8c 85       	ldd	r24, Y+12	; 0x0c
    8604:	9d 85       	ldd	r25, Y+13	; 0x0d
    8606:	61 e0       	ldi	r22, 0x01	; 1
    8608:	0e 94 ee 45 	call	0x8bdc	; 0x8bdc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    860c:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    8610:	0f 90       	pop	r0
    8612:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    8614:	0f b6       	in	r0, 0x3f	; 63
    8616:	f8 94       	cli
    8618:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    861a:	8a 85       	ldd	r24, Y+10	; 0x0a
    861c:	9b 85       	ldd	r25, Y+11	; 0x0b
    861e:	00 97       	sbiw	r24, 0x00	; 0
    8620:	71 f0       	breq	.+28     	; 0x863e <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    8622:	e0 91 8c 05 	lds	r30, 0x058C
    8626:	f0 91 8d 05 	lds	r31, 0x058D
    862a:	83 a1       	ldd	r24, Z+35	; 0x23
    862c:	94 a1       	ldd	r25, Z+36	; 0x24
    862e:	a5 a1       	ldd	r26, Z+37	; 0x25
    8630:	b6 a1       	ldd	r27, Z+38	; 0x26
    8632:	ea 85       	ldd	r30, Y+10	; 0x0a
    8634:	fb 85       	ldd	r31, Y+11	; 0x0b
    8636:	80 83       	st	Z, r24
    8638:	91 83       	std	Z+1, r25	; 0x01
    863a:	a2 83       	std	Z+2, r26	; 0x02
    863c:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    863e:	e0 91 8c 05 	lds	r30, 0x058C
    8642:	f0 91 8d 05 	lds	r31, 0x058D
    8646:	87 a1       	ldd	r24, Z+39	; 0x27
    8648:	81 30       	cpi	r24, 0x01	; 1
    864a:	11 f4       	brne	.+4      	; 0x8650 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    864c:	19 82       	std	Y+1, r1	; 0x01
    864e:	1a c0       	rjmp	.+52     	; 0x8684 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    8650:	e0 91 8c 05 	lds	r30, 0x058C
    8654:	f0 91 8d 05 	lds	r31, 0x058D
    8658:	23 a1       	ldd	r18, Z+35	; 0x23
    865a:	34 a1       	ldd	r19, Z+36	; 0x24
    865c:	45 a1       	ldd	r20, Z+37	; 0x25
    865e:	56 a1       	ldd	r21, Z+38	; 0x26
    8660:	8e 81       	ldd	r24, Y+6	; 0x06
    8662:	9f 81       	ldd	r25, Y+7	; 0x07
    8664:	a8 85       	ldd	r26, Y+8	; 0x08
    8666:	b9 85       	ldd	r27, Y+9	; 0x09
    8668:	80 95       	com	r24
    866a:	90 95       	com	r25
    866c:	a0 95       	com	r26
    866e:	b0 95       	com	r27
    8670:	82 23       	and	r24, r18
    8672:	93 23       	and	r25, r19
    8674:	a4 23       	and	r26, r20
    8676:	b5 23       	and	r27, r21
    8678:	83 a3       	std	Z+35, r24	; 0x23
    867a:	94 a3       	std	Z+36, r25	; 0x24
    867c:	a5 a3       	std	Z+37, r26	; 0x25
    867e:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    8680:	81 e0       	ldi	r24, 0x01	; 1
    8682:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    8684:	e0 91 8c 05 	lds	r30, 0x058C
    8688:	f0 91 8d 05 	lds	r31, 0x058D
    868c:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    868e:	0f 90       	pop	r0
    8690:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    8692:	89 81       	ldd	r24, Y+1	; 0x01
	}
    8694:	2d 96       	adiw	r28, 0x0d	; 13
    8696:	0f b6       	in	r0, 0x3f	; 63
    8698:	f8 94       	cli
    869a:	de bf       	out	0x3e, r29	; 62
    869c:	0f be       	out	0x3f, r0	; 63
    869e:	cd bf       	out	0x3d, r28	; 61
    86a0:	cf 91       	pop	r28
    86a2:	df 91       	pop	r29
    86a4:	1f 91       	pop	r17
    86a6:	0f 91       	pop	r16
    86a8:	ff 90       	pop	r15
    86aa:	ef 90       	pop	r14
    86ac:	08 95       	ret

000086ae <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    86ae:	0f 93       	push	r16
    86b0:	1f 93       	push	r17
    86b2:	df 93       	push	r29
    86b4:	cf 93       	push	r28
    86b6:	cd b7       	in	r28, 0x3d	; 61
    86b8:	de b7       	in	r29, 0x3e	; 62
    86ba:	2f 97       	sbiw	r28, 0x0f	; 15
    86bc:	0f b6       	in	r0, 0x3f	; 63
    86be:	f8 94       	cli
    86c0:	de bf       	out	0x3e, r29	; 62
    86c2:	0f be       	out	0x3f, r0	; 63
    86c4:	cd bf       	out	0x3d, r28	; 61
    86c6:	9e 83       	std	Y+6, r25	; 0x06
    86c8:	8d 83       	std	Y+5, r24	; 0x05
    86ca:	4f 83       	std	Y+7, r20	; 0x07
    86cc:	58 87       	std	Y+8, r21	; 0x08
    86ce:	69 87       	std	Y+9, r22	; 0x09
    86d0:	7a 87       	std	Y+10, r23	; 0x0a
    86d2:	2b 87       	std	Y+11, r18	; 0x0b
    86d4:	1d 87       	std	Y+13, r17	; 0x0d
    86d6:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    86d8:	81 e0       	ldi	r24, 0x01	; 1
    86da:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    86dc:	8d 81       	ldd	r24, Y+5	; 0x05
    86de:	9e 81       	ldd	r25, Y+6	; 0x06
    86e0:	9c 83       	std	Y+4, r25	; 0x04
    86e2:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    86e4:	0f b6       	in	r0, 0x3f	; 63
    86e6:	f8 94       	cli
    86e8:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    86ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    86ec:	9d 85       	ldd	r25, Y+13	; 0x0d
    86ee:	00 97       	sbiw	r24, 0x00	; 0
    86f0:	61 f0       	breq	.+24     	; 0x870a <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    86f2:	eb 81       	ldd	r30, Y+3	; 0x03
    86f4:	fc 81       	ldd	r31, Y+4	; 0x04
    86f6:	83 a1       	ldd	r24, Z+35	; 0x23
    86f8:	94 a1       	ldd	r25, Z+36	; 0x24
    86fa:	a5 a1       	ldd	r26, Z+37	; 0x25
    86fc:	b6 a1       	ldd	r27, Z+38	; 0x26
    86fe:	ec 85       	ldd	r30, Y+12	; 0x0c
    8700:	fd 85       	ldd	r31, Y+13	; 0x0d
    8702:	80 83       	st	Z, r24
    8704:	91 83       	std	Z+1, r25	; 0x01
    8706:	a2 83       	std	Z+2, r26	; 0x02
    8708:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    870a:	eb 81       	ldd	r30, Y+3	; 0x03
    870c:	fc 81       	ldd	r31, Y+4	; 0x04
    870e:	87 a1       	ldd	r24, Z+39	; 0x27
    8710:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    8712:	eb 81       	ldd	r30, Y+3	; 0x03
    8714:	fc 81       	ldd	r31, Y+4	; 0x04
    8716:	82 e0       	ldi	r24, 0x02	; 2
    8718:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    871a:	8b 85       	ldd	r24, Y+11	; 0x0b
    871c:	28 2f       	mov	r18, r24
    871e:	30 e0       	ldi	r19, 0x00	; 0
    8720:	3f 87       	std	Y+15, r19	; 0x0f
    8722:	2e 87       	std	Y+14, r18	; 0x0e
    8724:	8e 85       	ldd	r24, Y+14	; 0x0e
    8726:	9f 85       	ldd	r25, Y+15	; 0x0f
    8728:	82 30       	cpi	r24, 0x02	; 2
    872a:	91 05       	cpc	r25, r1
    872c:	59 f1       	breq	.+86     	; 0x8784 <xTaskGenericNotify+0xd6>
    872e:	2e 85       	ldd	r18, Y+14	; 0x0e
    8730:	3f 85       	ldd	r19, Y+15	; 0x0f
    8732:	23 30       	cpi	r18, 0x03	; 3
    8734:	31 05       	cpc	r19, r1
    8736:	34 f4       	brge	.+12     	; 0x8744 <xTaskGenericNotify+0x96>
    8738:	8e 85       	ldd	r24, Y+14	; 0x0e
    873a:	9f 85       	ldd	r25, Y+15	; 0x0f
    873c:	81 30       	cpi	r24, 0x01	; 1
    873e:	91 05       	cpc	r25, r1
    8740:	61 f0       	breq	.+24     	; 0x875a <xTaskGenericNotify+0xac>
    8742:	4a c0       	rjmp	.+148    	; 0x87d8 <xTaskGenericNotify+0x12a>
    8744:	2e 85       	ldd	r18, Y+14	; 0x0e
    8746:	3f 85       	ldd	r19, Y+15	; 0x0f
    8748:	23 30       	cpi	r18, 0x03	; 3
    874a:	31 05       	cpc	r19, r1
    874c:	59 f1       	breq	.+86     	; 0x87a4 <xTaskGenericNotify+0xf6>
    874e:	8e 85       	ldd	r24, Y+14	; 0x0e
    8750:	9f 85       	ldd	r25, Y+15	; 0x0f
    8752:	84 30       	cpi	r24, 0x04	; 4
    8754:	91 05       	cpc	r25, r1
    8756:	89 f1       	breq	.+98     	; 0x87ba <xTaskGenericNotify+0x10c>
    8758:	3f c0       	rjmp	.+126    	; 0x87d8 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    875a:	eb 81       	ldd	r30, Y+3	; 0x03
    875c:	fc 81       	ldd	r31, Y+4	; 0x04
    875e:	23 a1       	ldd	r18, Z+35	; 0x23
    8760:	34 a1       	ldd	r19, Z+36	; 0x24
    8762:	45 a1       	ldd	r20, Z+37	; 0x25
    8764:	56 a1       	ldd	r21, Z+38	; 0x26
    8766:	8f 81       	ldd	r24, Y+7	; 0x07
    8768:	98 85       	ldd	r25, Y+8	; 0x08
    876a:	a9 85       	ldd	r26, Y+9	; 0x09
    876c:	ba 85       	ldd	r27, Y+10	; 0x0a
    876e:	82 2b       	or	r24, r18
    8770:	93 2b       	or	r25, r19
    8772:	a4 2b       	or	r26, r20
    8774:	b5 2b       	or	r27, r21
    8776:	eb 81       	ldd	r30, Y+3	; 0x03
    8778:	fc 81       	ldd	r31, Y+4	; 0x04
    877a:	83 a3       	std	Z+35, r24	; 0x23
    877c:	94 a3       	std	Z+36, r25	; 0x24
    877e:	a5 a3       	std	Z+37, r26	; 0x25
    8780:	b6 a3       	std	Z+38, r27	; 0x26
    8782:	2a c0       	rjmp	.+84     	; 0x87d8 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    8784:	eb 81       	ldd	r30, Y+3	; 0x03
    8786:	fc 81       	ldd	r31, Y+4	; 0x04
    8788:	83 a1       	ldd	r24, Z+35	; 0x23
    878a:	94 a1       	ldd	r25, Z+36	; 0x24
    878c:	a5 a1       	ldd	r26, Z+37	; 0x25
    878e:	b6 a1       	ldd	r27, Z+38	; 0x26
    8790:	01 96       	adiw	r24, 0x01	; 1
    8792:	a1 1d       	adc	r26, r1
    8794:	b1 1d       	adc	r27, r1
    8796:	eb 81       	ldd	r30, Y+3	; 0x03
    8798:	fc 81       	ldd	r31, Y+4	; 0x04
    879a:	83 a3       	std	Z+35, r24	; 0x23
    879c:	94 a3       	std	Z+36, r25	; 0x24
    879e:	a5 a3       	std	Z+37, r26	; 0x25
    87a0:	b6 a3       	std	Z+38, r27	; 0x26
    87a2:	1a c0       	rjmp	.+52     	; 0x87d8 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    87a4:	eb 81       	ldd	r30, Y+3	; 0x03
    87a6:	fc 81       	ldd	r31, Y+4	; 0x04
    87a8:	8f 81       	ldd	r24, Y+7	; 0x07
    87aa:	98 85       	ldd	r25, Y+8	; 0x08
    87ac:	a9 85       	ldd	r26, Y+9	; 0x09
    87ae:	ba 85       	ldd	r27, Y+10	; 0x0a
    87b0:	83 a3       	std	Z+35, r24	; 0x23
    87b2:	94 a3       	std	Z+36, r25	; 0x24
    87b4:	a5 a3       	std	Z+37, r26	; 0x25
    87b6:	b6 a3       	std	Z+38, r27	; 0x26
    87b8:	0f c0       	rjmp	.+30     	; 0x87d8 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    87ba:	89 81       	ldd	r24, Y+1	; 0x01
    87bc:	82 30       	cpi	r24, 0x02	; 2
    87be:	59 f0       	breq	.+22     	; 0x87d6 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    87c0:	eb 81       	ldd	r30, Y+3	; 0x03
    87c2:	fc 81       	ldd	r31, Y+4	; 0x04
    87c4:	8f 81       	ldd	r24, Y+7	; 0x07
    87c6:	98 85       	ldd	r25, Y+8	; 0x08
    87c8:	a9 85       	ldd	r26, Y+9	; 0x09
    87ca:	ba 85       	ldd	r27, Y+10	; 0x0a
    87cc:	83 a3       	std	Z+35, r24	; 0x23
    87ce:	94 a3       	std	Z+36, r25	; 0x24
    87d0:	a5 a3       	std	Z+37, r26	; 0x25
    87d2:	b6 a3       	std	Z+38, r27	; 0x26
    87d4:	01 c0       	rjmp	.+2      	; 0x87d8 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    87d6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    87d8:	89 81       	ldd	r24, Y+1	; 0x01
    87da:	81 30       	cpi	r24, 0x01	; 1
    87dc:	b9 f5       	brne	.+110    	; 0x884c <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    87de:	8b 81       	ldd	r24, Y+3	; 0x03
    87e0:	9c 81       	ldd	r25, Y+4	; 0x04
    87e2:	02 96       	adiw	r24, 0x02	; 2
    87e4:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    87e8:	eb 81       	ldd	r30, Y+3	; 0x03
    87ea:	fc 81       	ldd	r31, Y+4	; 0x04
    87ec:	96 89       	ldd	r25, Z+22	; 0x16
    87ee:	80 91 92 05 	lds	r24, 0x0592
    87f2:	89 17       	cp	r24, r25
    87f4:	28 f4       	brcc	.+10     	; 0x8800 <xTaskGenericNotify+0x152>
    87f6:	eb 81       	ldd	r30, Y+3	; 0x03
    87f8:	fc 81       	ldd	r31, Y+4	; 0x04
    87fa:	86 89       	ldd	r24, Z+22	; 0x16
    87fc:	80 93 92 05 	sts	0x0592, r24
    8800:	eb 81       	ldd	r30, Y+3	; 0x03
    8802:	fc 81       	ldd	r31, Y+4	; 0x04
    8804:	86 89       	ldd	r24, Z+22	; 0x16
    8806:	28 2f       	mov	r18, r24
    8808:	30 e0       	ldi	r19, 0x00	; 0
    880a:	c9 01       	movw	r24, r18
    880c:	88 0f       	add	r24, r24
    880e:	99 1f       	adc	r25, r25
    8810:	88 0f       	add	r24, r24
    8812:	99 1f       	adc	r25, r25
    8814:	88 0f       	add	r24, r24
    8816:	99 1f       	adc	r25, r25
    8818:	82 0f       	add	r24, r18
    881a:	93 1f       	adc	r25, r19
    881c:	ac 01       	movw	r20, r24
    881e:	43 56       	subi	r20, 0x63	; 99
    8820:	5a 4f       	sbci	r21, 0xFA	; 250
    8822:	8b 81       	ldd	r24, Y+3	; 0x03
    8824:	9c 81       	ldd	r25, Y+4	; 0x04
    8826:	9c 01       	movw	r18, r24
    8828:	2e 5f       	subi	r18, 0xFE	; 254
    882a:	3f 4f       	sbci	r19, 0xFF	; 255
    882c:	ca 01       	movw	r24, r20
    882e:	b9 01       	movw	r22, r18
    8830:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    8834:	eb 81       	ldd	r30, Y+3	; 0x03
    8836:	fc 81       	ldd	r31, Y+4	; 0x04
    8838:	96 89       	ldd	r25, Z+22	; 0x16
    883a:	e0 91 8c 05 	lds	r30, 0x058C
    883e:	f0 91 8d 05 	lds	r31, 0x058D
    8842:	86 89       	ldd	r24, Z+22	; 0x16
    8844:	89 17       	cp	r24, r25
    8846:	10 f4       	brcc	.+4      	; 0x884c <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    8848:	0e 94 c9 2f 	call	0x5f92	; 0x5f92 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    884c:	0f 90       	pop	r0
    884e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    8850:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    8852:	2f 96       	adiw	r28, 0x0f	; 15
    8854:	0f b6       	in	r0, 0x3f	; 63
    8856:	f8 94       	cli
    8858:	de bf       	out	0x3e, r29	; 62
    885a:	0f be       	out	0x3f, r0	; 63
    885c:	cd bf       	out	0x3d, r28	; 61
    885e:	cf 91       	pop	r28
    8860:	df 91       	pop	r29
    8862:	1f 91       	pop	r17
    8864:	0f 91       	pop	r16
    8866:	08 95       	ret

00008868 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    8868:	ef 92       	push	r14
    886a:	ff 92       	push	r15
    886c:	0f 93       	push	r16
    886e:	1f 93       	push	r17
    8870:	df 93       	push	r29
    8872:	cf 93       	push	r28
    8874:	cd b7       	in	r28, 0x3d	; 61
    8876:	de b7       	in	r29, 0x3e	; 62
    8878:	62 97       	sbiw	r28, 0x12	; 18
    887a:	0f b6       	in	r0, 0x3f	; 63
    887c:	f8 94       	cli
    887e:	de bf       	out	0x3e, r29	; 62
    8880:	0f be       	out	0x3f, r0	; 63
    8882:	cd bf       	out	0x3d, r28	; 61
    8884:	9f 83       	std	Y+7, r25	; 0x07
    8886:	8e 83       	std	Y+6, r24	; 0x06
    8888:	48 87       	std	Y+8, r20	; 0x08
    888a:	59 87       	std	Y+9, r21	; 0x09
    888c:	6a 87       	std	Y+10, r22	; 0x0a
    888e:	7b 87       	std	Y+11, r23	; 0x0b
    8890:	2c 87       	std	Y+12, r18	; 0x0c
    8892:	1e 87       	std	Y+14, r17	; 0x0e
    8894:	0d 87       	std	Y+13, r16	; 0x0d
    8896:	f8 8a       	std	Y+16, r15	; 0x10
    8898:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    889a:	81 e0       	ldi	r24, 0x01	; 1
    889c:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    889e:	8e 81       	ldd	r24, Y+6	; 0x06
    88a0:	9f 81       	ldd	r25, Y+7	; 0x07
    88a2:	9d 83       	std	Y+5, r25	; 0x05
    88a4:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    88a6:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    88a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    88aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    88ac:	00 97       	sbiw	r24, 0x00	; 0
    88ae:	61 f0       	breq	.+24     	; 0x88c8 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    88b0:	ec 81       	ldd	r30, Y+4	; 0x04
    88b2:	fd 81       	ldd	r31, Y+5	; 0x05
    88b4:	83 a1       	ldd	r24, Z+35	; 0x23
    88b6:	94 a1       	ldd	r25, Z+36	; 0x24
    88b8:	a5 a1       	ldd	r26, Z+37	; 0x25
    88ba:	b6 a1       	ldd	r27, Z+38	; 0x26
    88bc:	ed 85       	ldd	r30, Y+13	; 0x0d
    88be:	fe 85       	ldd	r31, Y+14	; 0x0e
    88c0:	80 83       	st	Z, r24
    88c2:	91 83       	std	Z+1, r25	; 0x01
    88c4:	a2 83       	std	Z+2, r26	; 0x02
    88c6:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    88c8:	ec 81       	ldd	r30, Y+4	; 0x04
    88ca:	fd 81       	ldd	r31, Y+5	; 0x05
    88cc:	87 a1       	ldd	r24, Z+39	; 0x27
    88ce:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    88d0:	ec 81       	ldd	r30, Y+4	; 0x04
    88d2:	fd 81       	ldd	r31, Y+5	; 0x05
    88d4:	82 e0       	ldi	r24, 0x02	; 2
    88d6:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    88d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    88da:	28 2f       	mov	r18, r24
    88dc:	30 e0       	ldi	r19, 0x00	; 0
    88de:	3a 8b       	std	Y+18, r19	; 0x12
    88e0:	29 8b       	std	Y+17, r18	; 0x11
    88e2:	89 89       	ldd	r24, Y+17	; 0x11
    88e4:	9a 89       	ldd	r25, Y+18	; 0x12
    88e6:	82 30       	cpi	r24, 0x02	; 2
    88e8:	91 05       	cpc	r25, r1
    88ea:	59 f1       	breq	.+86     	; 0x8942 <xTaskGenericNotifyFromISR+0xda>
    88ec:	29 89       	ldd	r18, Y+17	; 0x11
    88ee:	3a 89       	ldd	r19, Y+18	; 0x12
    88f0:	23 30       	cpi	r18, 0x03	; 3
    88f2:	31 05       	cpc	r19, r1
    88f4:	34 f4       	brge	.+12     	; 0x8902 <xTaskGenericNotifyFromISR+0x9a>
    88f6:	89 89       	ldd	r24, Y+17	; 0x11
    88f8:	9a 89       	ldd	r25, Y+18	; 0x12
    88fa:	81 30       	cpi	r24, 0x01	; 1
    88fc:	91 05       	cpc	r25, r1
    88fe:	61 f0       	breq	.+24     	; 0x8918 <xTaskGenericNotifyFromISR+0xb0>
    8900:	4a c0       	rjmp	.+148    	; 0x8996 <xTaskGenericNotifyFromISR+0x12e>
    8902:	29 89       	ldd	r18, Y+17	; 0x11
    8904:	3a 89       	ldd	r19, Y+18	; 0x12
    8906:	23 30       	cpi	r18, 0x03	; 3
    8908:	31 05       	cpc	r19, r1
    890a:	59 f1       	breq	.+86     	; 0x8962 <xTaskGenericNotifyFromISR+0xfa>
    890c:	89 89       	ldd	r24, Y+17	; 0x11
    890e:	9a 89       	ldd	r25, Y+18	; 0x12
    8910:	84 30       	cpi	r24, 0x04	; 4
    8912:	91 05       	cpc	r25, r1
    8914:	89 f1       	breq	.+98     	; 0x8978 <xTaskGenericNotifyFromISR+0x110>
    8916:	3f c0       	rjmp	.+126    	; 0x8996 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    8918:	ec 81       	ldd	r30, Y+4	; 0x04
    891a:	fd 81       	ldd	r31, Y+5	; 0x05
    891c:	23 a1       	ldd	r18, Z+35	; 0x23
    891e:	34 a1       	ldd	r19, Z+36	; 0x24
    8920:	45 a1       	ldd	r20, Z+37	; 0x25
    8922:	56 a1       	ldd	r21, Z+38	; 0x26
    8924:	88 85       	ldd	r24, Y+8	; 0x08
    8926:	99 85       	ldd	r25, Y+9	; 0x09
    8928:	aa 85       	ldd	r26, Y+10	; 0x0a
    892a:	bb 85       	ldd	r27, Y+11	; 0x0b
    892c:	82 2b       	or	r24, r18
    892e:	93 2b       	or	r25, r19
    8930:	a4 2b       	or	r26, r20
    8932:	b5 2b       	or	r27, r21
    8934:	ec 81       	ldd	r30, Y+4	; 0x04
    8936:	fd 81       	ldd	r31, Y+5	; 0x05
    8938:	83 a3       	std	Z+35, r24	; 0x23
    893a:	94 a3       	std	Z+36, r25	; 0x24
    893c:	a5 a3       	std	Z+37, r26	; 0x25
    893e:	b6 a3       	std	Z+38, r27	; 0x26
    8940:	2a c0       	rjmp	.+84     	; 0x8996 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    8942:	ec 81       	ldd	r30, Y+4	; 0x04
    8944:	fd 81       	ldd	r31, Y+5	; 0x05
    8946:	83 a1       	ldd	r24, Z+35	; 0x23
    8948:	94 a1       	ldd	r25, Z+36	; 0x24
    894a:	a5 a1       	ldd	r26, Z+37	; 0x25
    894c:	b6 a1       	ldd	r27, Z+38	; 0x26
    894e:	01 96       	adiw	r24, 0x01	; 1
    8950:	a1 1d       	adc	r26, r1
    8952:	b1 1d       	adc	r27, r1
    8954:	ec 81       	ldd	r30, Y+4	; 0x04
    8956:	fd 81       	ldd	r31, Y+5	; 0x05
    8958:	83 a3       	std	Z+35, r24	; 0x23
    895a:	94 a3       	std	Z+36, r25	; 0x24
    895c:	a5 a3       	std	Z+37, r26	; 0x25
    895e:	b6 a3       	std	Z+38, r27	; 0x26
    8960:	1a c0       	rjmp	.+52     	; 0x8996 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    8962:	ec 81       	ldd	r30, Y+4	; 0x04
    8964:	fd 81       	ldd	r31, Y+5	; 0x05
    8966:	88 85       	ldd	r24, Y+8	; 0x08
    8968:	99 85       	ldd	r25, Y+9	; 0x09
    896a:	aa 85       	ldd	r26, Y+10	; 0x0a
    896c:	bb 85       	ldd	r27, Y+11	; 0x0b
    896e:	83 a3       	std	Z+35, r24	; 0x23
    8970:	94 a3       	std	Z+36, r25	; 0x24
    8972:	a5 a3       	std	Z+37, r26	; 0x25
    8974:	b6 a3       	std	Z+38, r27	; 0x26
    8976:	0f c0       	rjmp	.+30     	; 0x8996 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    8978:	8b 81       	ldd	r24, Y+3	; 0x03
    897a:	82 30       	cpi	r24, 0x02	; 2
    897c:	59 f0       	breq	.+22     	; 0x8994 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    897e:	ec 81       	ldd	r30, Y+4	; 0x04
    8980:	fd 81       	ldd	r31, Y+5	; 0x05
    8982:	88 85       	ldd	r24, Y+8	; 0x08
    8984:	99 85       	ldd	r25, Y+9	; 0x09
    8986:	aa 85       	ldd	r26, Y+10	; 0x0a
    8988:	bb 85       	ldd	r27, Y+11	; 0x0b
    898a:	83 a3       	std	Z+35, r24	; 0x23
    898c:	94 a3       	std	Z+36, r25	; 0x24
    898e:	a5 a3       	std	Z+37, r26	; 0x25
    8990:	b6 a3       	std	Z+38, r27	; 0x26
    8992:	01 c0       	rjmp	.+2      	; 0x8996 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    8994:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    8996:	8b 81       	ldd	r24, Y+3	; 0x03
    8998:	81 30       	cpi	r24, 0x01	; 1
    899a:	09 f0       	breq	.+2      	; 0x899e <xTaskGenericNotifyFromISR+0x136>
    899c:	50 c0       	rjmp	.+160    	; 0x8a3e <xTaskGenericNotifyFromISR+0x1d6>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    899e:	80 91 9c 05 	lds	r24, 0x059C
    89a2:	88 23       	and	r24, r24
    89a4:	61 f5       	brne	.+88     	; 0x89fe <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    89a6:	8c 81       	ldd	r24, Y+4	; 0x04
    89a8:	9d 81       	ldd	r25, Y+5	; 0x05
    89aa:	02 96       	adiw	r24, 0x02	; 2
    89ac:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    89b0:	ec 81       	ldd	r30, Y+4	; 0x04
    89b2:	fd 81       	ldd	r31, Y+5	; 0x05
    89b4:	96 89       	ldd	r25, Z+22	; 0x16
    89b6:	80 91 92 05 	lds	r24, 0x0592
    89ba:	89 17       	cp	r24, r25
    89bc:	28 f4       	brcc	.+10     	; 0x89c8 <xTaskGenericNotifyFromISR+0x160>
    89be:	ec 81       	ldd	r30, Y+4	; 0x04
    89c0:	fd 81       	ldd	r31, Y+5	; 0x05
    89c2:	86 89       	ldd	r24, Z+22	; 0x16
    89c4:	80 93 92 05 	sts	0x0592, r24
    89c8:	ec 81       	ldd	r30, Y+4	; 0x04
    89ca:	fd 81       	ldd	r31, Y+5	; 0x05
    89cc:	86 89       	ldd	r24, Z+22	; 0x16
    89ce:	28 2f       	mov	r18, r24
    89d0:	30 e0       	ldi	r19, 0x00	; 0
    89d2:	c9 01       	movw	r24, r18
    89d4:	88 0f       	add	r24, r24
    89d6:	99 1f       	adc	r25, r25
    89d8:	88 0f       	add	r24, r24
    89da:	99 1f       	adc	r25, r25
    89dc:	88 0f       	add	r24, r24
    89de:	99 1f       	adc	r25, r25
    89e0:	82 0f       	add	r24, r18
    89e2:	93 1f       	adc	r25, r19
    89e4:	ac 01       	movw	r20, r24
    89e6:	43 56       	subi	r20, 0x63	; 99
    89e8:	5a 4f       	sbci	r21, 0xFA	; 250
    89ea:	8c 81       	ldd	r24, Y+4	; 0x04
    89ec:	9d 81       	ldd	r25, Y+5	; 0x05
    89ee:	9c 01       	movw	r18, r24
    89f0:	2e 5f       	subi	r18, 0xFE	; 254
    89f2:	3f 4f       	sbci	r19, 0xFF	; 255
    89f4:	ca 01       	movw	r24, r20
    89f6:	b9 01       	movw	r22, r18
    89f8:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
    89fc:	0a c0       	rjmp	.+20     	; 0x8a12 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    89fe:	8c 81       	ldd	r24, Y+4	; 0x04
    8a00:	9d 81       	ldd	r25, Y+5	; 0x05
    8a02:	9c 01       	movw	r18, r24
    8a04:	24 5f       	subi	r18, 0xF4	; 244
    8a06:	3f 4f       	sbci	r19, 0xFF	; 255
    8a08:	84 e0       	ldi	r24, 0x04	; 4
    8a0a:	96 e0       	ldi	r25, 0x06	; 6
    8a0c:	b9 01       	movw	r22, r18
    8a0e:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    8a12:	ec 81       	ldd	r30, Y+4	; 0x04
    8a14:	fd 81       	ldd	r31, Y+5	; 0x05
    8a16:	96 89       	ldd	r25, Z+22	; 0x16
    8a18:	e0 91 8c 05 	lds	r30, 0x058C
    8a1c:	f0 91 8d 05 	lds	r31, 0x058D
    8a20:	86 89       	ldd	r24, Z+22	; 0x16
    8a22:	89 17       	cp	r24, r25
    8a24:	60 f4       	brcc	.+24     	; 0x8a3e <xTaskGenericNotifyFromISR+0x1d6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    8a26:	8f 85       	ldd	r24, Y+15	; 0x0f
    8a28:	98 89       	ldd	r25, Y+16	; 0x10
    8a2a:	00 97       	sbiw	r24, 0x00	; 0
    8a2c:	29 f0       	breq	.+10     	; 0x8a38 <xTaskGenericNotifyFromISR+0x1d0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    8a2e:	ef 85       	ldd	r30, Y+15	; 0x0f
    8a30:	f8 89       	ldd	r31, Y+16	; 0x10
    8a32:	81 e0       	ldi	r24, 0x01	; 1
    8a34:	80 83       	st	Z, r24
    8a36:	03 c0       	rjmp	.+6      	; 0x8a3e <xTaskGenericNotifyFromISR+0x1d6>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    8a38:	81 e0       	ldi	r24, 0x01	; 1
    8a3a:	80 93 95 05 	sts	0x0595, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    8a3e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    8a40:	62 96       	adiw	r28, 0x12	; 18
    8a42:	0f b6       	in	r0, 0x3f	; 63
    8a44:	f8 94       	cli
    8a46:	de bf       	out	0x3e, r29	; 62
    8a48:	0f be       	out	0x3f, r0	; 63
    8a4a:	cd bf       	out	0x3d, r28	; 61
    8a4c:	cf 91       	pop	r28
    8a4e:	df 91       	pop	r29
    8a50:	1f 91       	pop	r17
    8a52:	0f 91       	pop	r16
    8a54:	ff 90       	pop	r15
    8a56:	ef 90       	pop	r14
    8a58:	08 95       	ret

00008a5a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    8a5a:	df 93       	push	r29
    8a5c:	cf 93       	push	r28
    8a5e:	cd b7       	in	r28, 0x3d	; 61
    8a60:	de b7       	in	r29, 0x3e	; 62
    8a62:	28 97       	sbiw	r28, 0x08	; 8
    8a64:	0f b6       	in	r0, 0x3f	; 63
    8a66:	f8 94       	cli
    8a68:	de bf       	out	0x3e, r29	; 62
    8a6a:	0f be       	out	0x3f, r0	; 63
    8a6c:	cd bf       	out	0x3d, r28	; 61
    8a6e:	9e 83       	std	Y+6, r25	; 0x06
    8a70:	8d 83       	std	Y+5, r24	; 0x05
    8a72:	78 87       	std	Y+8, r23	; 0x08
    8a74:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    8a76:	8d 81       	ldd	r24, Y+5	; 0x05
    8a78:	9e 81       	ldd	r25, Y+6	; 0x06
    8a7a:	9c 83       	std	Y+4, r25	; 0x04
    8a7c:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    8a7e:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    8a80:	eb 81       	ldd	r30, Y+3	; 0x03
    8a82:	fc 81       	ldd	r31, Y+4	; 0x04
    8a84:	87 a1       	ldd	r24, Z+39	; 0x27
    8a86:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    8a88:	eb 81       	ldd	r30, Y+3	; 0x03
    8a8a:	fc 81       	ldd	r31, Y+4	; 0x04
    8a8c:	82 e0       	ldi	r24, 0x02	; 2
    8a8e:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    8a90:	eb 81       	ldd	r30, Y+3	; 0x03
    8a92:	fc 81       	ldd	r31, Y+4	; 0x04
    8a94:	83 a1       	ldd	r24, Z+35	; 0x23
    8a96:	94 a1       	ldd	r25, Z+36	; 0x24
    8a98:	a5 a1       	ldd	r26, Z+37	; 0x25
    8a9a:	b6 a1       	ldd	r27, Z+38	; 0x26
    8a9c:	01 96       	adiw	r24, 0x01	; 1
    8a9e:	a1 1d       	adc	r26, r1
    8aa0:	b1 1d       	adc	r27, r1
    8aa2:	eb 81       	ldd	r30, Y+3	; 0x03
    8aa4:	fc 81       	ldd	r31, Y+4	; 0x04
    8aa6:	83 a3       	std	Z+35, r24	; 0x23
    8aa8:	94 a3       	std	Z+36, r25	; 0x24
    8aaa:	a5 a3       	std	Z+37, r26	; 0x25
    8aac:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    8aae:	8a 81       	ldd	r24, Y+2	; 0x02
    8ab0:	81 30       	cpi	r24, 0x01	; 1
    8ab2:	09 f0       	breq	.+2      	; 0x8ab6 <vTaskNotifyGiveFromISR+0x5c>
    8ab4:	50 c0       	rjmp	.+160    	; 0x8b56 <vTaskNotifyGiveFromISR+0xfc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    8ab6:	80 91 9c 05 	lds	r24, 0x059C
    8aba:	88 23       	and	r24, r24
    8abc:	61 f5       	brne	.+88     	; 0x8b16 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    8abe:	8b 81       	ldd	r24, Y+3	; 0x03
    8ac0:	9c 81       	ldd	r25, Y+4	; 0x04
    8ac2:	02 96       	adiw	r24, 0x02	; 2
    8ac4:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    8ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    8aca:	fc 81       	ldd	r31, Y+4	; 0x04
    8acc:	96 89       	ldd	r25, Z+22	; 0x16
    8ace:	80 91 92 05 	lds	r24, 0x0592
    8ad2:	89 17       	cp	r24, r25
    8ad4:	28 f4       	brcc	.+10     	; 0x8ae0 <vTaskNotifyGiveFromISR+0x86>
    8ad6:	eb 81       	ldd	r30, Y+3	; 0x03
    8ad8:	fc 81       	ldd	r31, Y+4	; 0x04
    8ada:	86 89       	ldd	r24, Z+22	; 0x16
    8adc:	80 93 92 05 	sts	0x0592, r24
    8ae0:	eb 81       	ldd	r30, Y+3	; 0x03
    8ae2:	fc 81       	ldd	r31, Y+4	; 0x04
    8ae4:	86 89       	ldd	r24, Z+22	; 0x16
    8ae6:	28 2f       	mov	r18, r24
    8ae8:	30 e0       	ldi	r19, 0x00	; 0
    8aea:	c9 01       	movw	r24, r18
    8aec:	88 0f       	add	r24, r24
    8aee:	99 1f       	adc	r25, r25
    8af0:	88 0f       	add	r24, r24
    8af2:	99 1f       	adc	r25, r25
    8af4:	88 0f       	add	r24, r24
    8af6:	99 1f       	adc	r25, r25
    8af8:	82 0f       	add	r24, r18
    8afa:	93 1f       	adc	r25, r19
    8afc:	ac 01       	movw	r20, r24
    8afe:	43 56       	subi	r20, 0x63	; 99
    8b00:	5a 4f       	sbci	r21, 0xFA	; 250
    8b02:	8b 81       	ldd	r24, Y+3	; 0x03
    8b04:	9c 81       	ldd	r25, Y+4	; 0x04
    8b06:	9c 01       	movw	r18, r24
    8b08:	2e 5f       	subi	r18, 0xFE	; 254
    8b0a:	3f 4f       	sbci	r19, 0xFF	; 255
    8b0c:	ca 01       	movw	r24, r20
    8b0e:	b9 01       	movw	r22, r18
    8b10:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
    8b14:	0a c0       	rjmp	.+20     	; 0x8b2a <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    8b16:	8b 81       	ldd	r24, Y+3	; 0x03
    8b18:	9c 81       	ldd	r25, Y+4	; 0x04
    8b1a:	9c 01       	movw	r18, r24
    8b1c:	24 5f       	subi	r18, 0xF4	; 244
    8b1e:	3f 4f       	sbci	r19, 0xFF	; 255
    8b20:	84 e0       	ldi	r24, 0x04	; 4
    8b22:	96 e0       	ldi	r25, 0x06	; 6
    8b24:	b9 01       	movw	r22, r18
    8b26:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    8b2a:	eb 81       	ldd	r30, Y+3	; 0x03
    8b2c:	fc 81       	ldd	r31, Y+4	; 0x04
    8b2e:	96 89       	ldd	r25, Z+22	; 0x16
    8b30:	e0 91 8c 05 	lds	r30, 0x058C
    8b34:	f0 91 8d 05 	lds	r31, 0x058D
    8b38:	86 89       	ldd	r24, Z+22	; 0x16
    8b3a:	89 17       	cp	r24, r25
    8b3c:	60 f4       	brcc	.+24     	; 0x8b56 <vTaskNotifyGiveFromISR+0xfc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    8b3e:	8f 81       	ldd	r24, Y+7	; 0x07
    8b40:	98 85       	ldd	r25, Y+8	; 0x08
    8b42:	00 97       	sbiw	r24, 0x00	; 0
    8b44:	29 f0       	breq	.+10     	; 0x8b50 <vTaskNotifyGiveFromISR+0xf6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    8b46:	ef 81       	ldd	r30, Y+7	; 0x07
    8b48:	f8 85       	ldd	r31, Y+8	; 0x08
    8b4a:	81 e0       	ldi	r24, 0x01	; 1
    8b4c:	80 83       	st	Z, r24
    8b4e:	03 c0       	rjmp	.+6      	; 0x8b56 <vTaskNotifyGiveFromISR+0xfc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    8b50:	81 e0       	ldi	r24, 0x01	; 1
    8b52:	80 93 95 05 	sts	0x0595, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    8b56:	28 96       	adiw	r28, 0x08	; 8
    8b58:	0f b6       	in	r0, 0x3f	; 63
    8b5a:	f8 94       	cli
    8b5c:	de bf       	out	0x3e, r29	; 62
    8b5e:	0f be       	out	0x3f, r0	; 63
    8b60:	cd bf       	out	0x3d, r28	; 61
    8b62:	cf 91       	pop	r28
    8b64:	df 91       	pop	r29
    8b66:	08 95       	ret

00008b68 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    8b68:	df 93       	push	r29
    8b6a:	cf 93       	push	r28
    8b6c:	cd b7       	in	r28, 0x3d	; 61
    8b6e:	de b7       	in	r29, 0x3e	; 62
    8b70:	27 97       	sbiw	r28, 0x07	; 7
    8b72:	0f b6       	in	r0, 0x3f	; 63
    8b74:	f8 94       	cli
    8b76:	de bf       	out	0x3e, r29	; 62
    8b78:	0f be       	out	0x3f, r0	; 63
    8b7a:	cd bf       	out	0x3d, r28	; 61
    8b7c:	9d 83       	std	Y+5, r25	; 0x05
    8b7e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    8b80:	8c 81       	ldd	r24, Y+4	; 0x04
    8b82:	9d 81       	ldd	r25, Y+5	; 0x05
    8b84:	00 97       	sbiw	r24, 0x00	; 0
    8b86:	39 f4       	brne	.+14     	; 0x8b96 <xTaskNotifyStateClear+0x2e>
    8b88:	80 91 8c 05 	lds	r24, 0x058C
    8b8c:	90 91 8d 05 	lds	r25, 0x058D
    8b90:	9f 83       	std	Y+7, r25	; 0x07
    8b92:	8e 83       	std	Y+6, r24	; 0x06
    8b94:	04 c0       	rjmp	.+8      	; 0x8b9e <xTaskNotifyStateClear+0x36>
    8b96:	8c 81       	ldd	r24, Y+4	; 0x04
    8b98:	9d 81       	ldd	r25, Y+5	; 0x05
    8b9a:	9f 83       	std	Y+7, r25	; 0x07
    8b9c:	8e 83       	std	Y+6, r24	; 0x06
    8b9e:	8e 81       	ldd	r24, Y+6	; 0x06
    8ba0:	9f 81       	ldd	r25, Y+7	; 0x07
    8ba2:	9b 83       	std	Y+3, r25	; 0x03
    8ba4:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    8ba6:	0f b6       	in	r0, 0x3f	; 63
    8ba8:	f8 94       	cli
    8baa:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    8bac:	ea 81       	ldd	r30, Y+2	; 0x02
    8bae:	fb 81       	ldd	r31, Y+3	; 0x03
    8bb0:	87 a1       	ldd	r24, Z+39	; 0x27
    8bb2:	82 30       	cpi	r24, 0x02	; 2
    8bb4:	31 f4       	brne	.+12     	; 0x8bc2 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    8bb6:	ea 81       	ldd	r30, Y+2	; 0x02
    8bb8:	fb 81       	ldd	r31, Y+3	; 0x03
    8bba:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    8bbc:	81 e0       	ldi	r24, 0x01	; 1
    8bbe:	89 83       	std	Y+1, r24	; 0x01
    8bc0:	01 c0       	rjmp	.+2      	; 0x8bc4 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    8bc2:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    8bc4:	0f 90       	pop	r0
    8bc6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    8bc8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    8bca:	27 96       	adiw	r28, 0x07	; 7
    8bcc:	0f b6       	in	r0, 0x3f	; 63
    8bce:	f8 94       	cli
    8bd0:	de bf       	out	0x3e, r29	; 62
    8bd2:	0f be       	out	0x3f, r0	; 63
    8bd4:	cd bf       	out	0x3d, r28	; 61
    8bd6:	cf 91       	pop	r28
    8bd8:	df 91       	pop	r29
    8bda:	08 95       	ret

00008bdc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    8bdc:	df 93       	push	r29
    8bde:	cf 93       	push	r28
    8be0:	cd b7       	in	r28, 0x3d	; 61
    8be2:	de b7       	in	r29, 0x3e	; 62
    8be4:	27 97       	sbiw	r28, 0x07	; 7
    8be6:	0f b6       	in	r0, 0x3f	; 63
    8be8:	f8 94       	cli
    8bea:	de bf       	out	0x3e, r29	; 62
    8bec:	0f be       	out	0x3f, r0	; 63
    8bee:	cd bf       	out	0x3d, r28	; 61
    8bf0:	9e 83       	std	Y+6, r25	; 0x06
    8bf2:	8d 83       	std	Y+5, r24	; 0x05
    8bf4:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    8bf6:	80 91 90 05 	lds	r24, 0x0590
    8bfa:	90 91 91 05 	lds	r25, 0x0591
    8bfe:	9a 83       	std	Y+2, r25	; 0x02
    8c00:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    8c02:	80 91 8c 05 	lds	r24, 0x058C
    8c06:	90 91 8d 05 	lds	r25, 0x058D
    8c0a:	02 96       	adiw	r24, 0x02	; 2
    8c0c:	0e 94 be 2d 	call	0x5b7c	; 0x5b7c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    8c10:	8d 81       	ldd	r24, Y+5	; 0x05
    8c12:	9e 81       	ldd	r25, Y+6	; 0x06
    8c14:	2f ef       	ldi	r18, 0xFF	; 255
    8c16:	8f 3f       	cpi	r24, 0xFF	; 255
    8c18:	92 07       	cpc	r25, r18
    8c1a:	81 f4       	brne	.+32     	; 0x8c3c <prvAddCurrentTaskToDelayedList+0x60>
    8c1c:	8f 81       	ldd	r24, Y+7	; 0x07
    8c1e:	88 23       	and	r24, r24
    8c20:	69 f0       	breq	.+26     	; 0x8c3c <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    8c22:	80 91 8c 05 	lds	r24, 0x058C
    8c26:	90 91 8d 05 	lds	r25, 0x058D
    8c2a:	9c 01       	movw	r18, r24
    8c2c:	2e 5f       	subi	r18, 0xFE	; 254
    8c2e:	3f 4f       	sbci	r19, 0xFF	; 255
    8c30:	86 e1       	ldi	r24, 0x16	; 22
    8c32:	96 e0       	ldi	r25, 0x06	; 6
    8c34:	b9 01       	movw	r22, r18
    8c36:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <vListInsertEnd>
    8c3a:	43 c0       	rjmp	.+134    	; 0x8cc2 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    8c3c:	29 81       	ldd	r18, Y+1	; 0x01
    8c3e:	3a 81       	ldd	r19, Y+2	; 0x02
    8c40:	8d 81       	ldd	r24, Y+5	; 0x05
    8c42:	9e 81       	ldd	r25, Y+6	; 0x06
    8c44:	82 0f       	add	r24, r18
    8c46:	93 1f       	adc	r25, r19
    8c48:	9c 83       	std	Y+4, r25	; 0x04
    8c4a:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    8c4c:	e0 91 8c 05 	lds	r30, 0x058C
    8c50:	f0 91 8d 05 	lds	r31, 0x058D
    8c54:	8b 81       	ldd	r24, Y+3	; 0x03
    8c56:	9c 81       	ldd	r25, Y+4	; 0x04
    8c58:	93 83       	std	Z+3, r25	; 0x03
    8c5a:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    8c5c:	2b 81       	ldd	r18, Y+3	; 0x03
    8c5e:	3c 81       	ldd	r19, Y+4	; 0x04
    8c60:	89 81       	ldd	r24, Y+1	; 0x01
    8c62:	9a 81       	ldd	r25, Y+2	; 0x02
    8c64:	28 17       	cp	r18, r24
    8c66:	39 07       	cpc	r19, r25
    8c68:	70 f4       	brcc	.+28     	; 0x8c86 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    8c6a:	80 91 02 06 	lds	r24, 0x0602
    8c6e:	90 91 03 06 	lds	r25, 0x0603
    8c72:	20 91 8c 05 	lds	r18, 0x058C
    8c76:	30 91 8d 05 	lds	r19, 0x058D
    8c7a:	2e 5f       	subi	r18, 0xFE	; 254
    8c7c:	3f 4f       	sbci	r19, 0xFF	; 255
    8c7e:	b9 01       	movw	r22, r18
    8c80:	0e 94 52 2d 	call	0x5aa4	; 0x5aa4 <vListInsert>
    8c84:	1e c0       	rjmp	.+60     	; 0x8cc2 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    8c86:	40 91 00 06 	lds	r20, 0x0600
    8c8a:	50 91 01 06 	lds	r21, 0x0601
    8c8e:	80 91 8c 05 	lds	r24, 0x058C
    8c92:	90 91 8d 05 	lds	r25, 0x058D
    8c96:	9c 01       	movw	r18, r24
    8c98:	2e 5f       	subi	r18, 0xFE	; 254
    8c9a:	3f 4f       	sbci	r19, 0xFF	; 255
    8c9c:	ca 01       	movw	r24, r20
    8c9e:	b9 01       	movw	r22, r18
    8ca0:	0e 94 52 2d 	call	0x5aa4	; 0x5aa4 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    8ca4:	20 91 98 05 	lds	r18, 0x0598
    8ca8:	30 91 99 05 	lds	r19, 0x0599
    8cac:	8b 81       	ldd	r24, Y+3	; 0x03
    8cae:	9c 81       	ldd	r25, Y+4	; 0x04
    8cb0:	82 17       	cp	r24, r18
    8cb2:	93 07       	cpc	r25, r19
    8cb4:	30 f4       	brcc	.+12     	; 0x8cc2 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    8cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    8cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    8cba:	90 93 99 05 	sts	0x0599, r25
    8cbe:	80 93 98 05 	sts	0x0598, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    8cc2:	27 96       	adiw	r28, 0x07	; 7
    8cc4:	0f b6       	in	r0, 0x3f	; 63
    8cc6:	f8 94       	cli
    8cc8:	de bf       	out	0x3e, r29	; 62
    8cca:	0f be       	out	0x3f, r0	; 63
    8ccc:	cd bf       	out	0x3d, r28	; 61
    8cce:	cf 91       	pop	r28
    8cd0:	df 91       	pop	r29
    8cd2:	08 95       	ret

00008cd4 <main>:
#include "main.h"
#include "../MCAL/DIO/DIO.h"
#include "../MCAL/Timer 0/Timer_0.h"
#include "../SERVICE/ICU_Interface.h"

int main(void) {
    8cd4:	df 93       	push	r29
    8cd6:	cf 93       	push	r28
    8cd8:	00 d0       	rcall	.+0      	; 0x8cda <main+0x6>
    8cda:	00 d0       	rcall	.+0      	; 0x8cdc <main+0x8>
    8cdc:	cd b7       	in	r28, 0x3d	; 61
    8cde:	de b7       	in	r29, 0x3e	; 62
//	HAL_SM_voidSMInit();
//			HAL_SM_voidSMSetAngle(i);
	u16 period_Ticks = 0;
    8ce0:	1a 82       	std	Y+2, r1	; 0x02
    8ce2:	19 82       	std	Y+1, r1	; 0x01
	  u16 on_Ticks = 0;
    8ce4:	1c 82       	std	Y+4, r1	; 0x04
    8ce6:	1b 82       	std	Y+3, r1	; 0x03
	  	SET_BIT(DDRD, Pin3);
    8ce8:	a1 e3       	ldi	r26, 0x31	; 49
    8cea:	b0 e0       	ldi	r27, 0x00	; 0
    8cec:	e1 e3       	ldi	r30, 0x31	; 49
    8cee:	f0 e0       	ldi	r31, 0x00	; 0
    8cf0:	80 81       	ld	r24, Z
    8cf2:	88 60       	ori	r24, 0x08	; 8
    8cf4:	8c 93       	st	X, r24
	  	MCAL_DIO_u8SetPinDirection(PortB, Pin3, Pin_High); //PWM
    8cf6:	81 e0       	ldi	r24, 0x01	; 1
    8cf8:	63 e0       	ldi	r22, 0x03	; 3
    8cfa:	41 e0       	ldi	r20, 0x01	; 1
    8cfc:	0e 94 47 19 	call	0x328e	; 0x328e <MCAL_DIO_u8SetPinDirection>
	  	//T0
	  	MCAL_Timer0_Init(FastPWM_Mode,Prescaller_8,NON_INVERTING_MODE);
    8d00:	83 e0       	ldi	r24, 0x03	; 3
    8d02:	62 e0       	ldi	r22, 0x02	; 2
    8d04:	40 e0       	ldi	r20, 0x00	; 0
    8d06:	0e 94 14 11 	call	0x2228	; 0x2228 <MCAL_Timer0_Init>
	  	MCAL_Timer0_SetCompareValue(64);
    8d0a:	80 e4       	ldi	r24, 0x40	; 64
    8d0c:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <MCAL_Timer0_SetCompareValue>

	  	while (1) {
	  	ICU_SW_init(&period_Ticks,&on_Ticks);
    8d10:	9e 01       	movw	r18, r28
    8d12:	2d 5f       	subi	r18, 0xFD	; 253
    8d14:	3f 4f       	sbci	r19, 0xFF	; 255
    8d16:	ce 01       	movw	r24, r28
    8d18:	01 96       	adiw	r24, 0x01	; 1
    8d1a:	b9 01       	movw	r22, r18
    8d1c:	0e 94 a5 07 	call	0xf4a	; 0xf4a <ICU_SW_init>
	  		if (on_Ticks == 64) {
    8d20:	8b 81       	ldd	r24, Y+3	; 0x03
    8d22:	9c 81       	ldd	r25, Y+4	; 0x04
    8d24:	80 34       	cpi	r24, 0x40	; 64
    8d26:	91 05       	cpc	r25, r1
    8d28:	99 f7       	brne	.-26     	; 0x8d10 <main+0x3c>
	  			SET_BIT(PORTD, Pin3);
    8d2a:	a2 e3       	ldi	r26, 0x32	; 50
    8d2c:	b0 e0       	ldi	r27, 0x00	; 0
    8d2e:	e2 e3       	ldi	r30, 0x32	; 50
    8d30:	f0 e0       	ldi	r31, 0x00	; 0
    8d32:	80 81       	ld	r24, Z
    8d34:	88 60       	ori	r24, 0x08	; 8
    8d36:	8c 93       	st	X, r24
    8d38:	eb cf       	rjmp	.-42     	; 0x8d10 <main+0x3c>

00008d3a <__mulsi3>:
    8d3a:	62 9f       	mul	r22, r18
    8d3c:	d0 01       	movw	r26, r0
    8d3e:	73 9f       	mul	r23, r19
    8d40:	f0 01       	movw	r30, r0
    8d42:	82 9f       	mul	r24, r18
    8d44:	e0 0d       	add	r30, r0
    8d46:	f1 1d       	adc	r31, r1
    8d48:	64 9f       	mul	r22, r20
    8d4a:	e0 0d       	add	r30, r0
    8d4c:	f1 1d       	adc	r31, r1
    8d4e:	92 9f       	mul	r25, r18
    8d50:	f0 0d       	add	r31, r0
    8d52:	83 9f       	mul	r24, r19
    8d54:	f0 0d       	add	r31, r0
    8d56:	74 9f       	mul	r23, r20
    8d58:	f0 0d       	add	r31, r0
    8d5a:	65 9f       	mul	r22, r21
    8d5c:	f0 0d       	add	r31, r0
    8d5e:	99 27       	eor	r25, r25
    8d60:	72 9f       	mul	r23, r18
    8d62:	b0 0d       	add	r27, r0
    8d64:	e1 1d       	adc	r30, r1
    8d66:	f9 1f       	adc	r31, r25
    8d68:	63 9f       	mul	r22, r19
    8d6a:	b0 0d       	add	r27, r0
    8d6c:	e1 1d       	adc	r30, r1
    8d6e:	f9 1f       	adc	r31, r25
    8d70:	bd 01       	movw	r22, r26
    8d72:	cf 01       	movw	r24, r30
    8d74:	11 24       	eor	r1, r1
    8d76:	08 95       	ret

00008d78 <__udivmodsi4>:
    8d78:	a1 e2       	ldi	r26, 0x21	; 33
    8d7a:	1a 2e       	mov	r1, r26
    8d7c:	aa 1b       	sub	r26, r26
    8d7e:	bb 1b       	sub	r27, r27
    8d80:	fd 01       	movw	r30, r26
    8d82:	0d c0       	rjmp	.+26     	; 0x8d9e <__udivmodsi4_ep>

00008d84 <__udivmodsi4_loop>:
    8d84:	aa 1f       	adc	r26, r26
    8d86:	bb 1f       	adc	r27, r27
    8d88:	ee 1f       	adc	r30, r30
    8d8a:	ff 1f       	adc	r31, r31
    8d8c:	a2 17       	cp	r26, r18
    8d8e:	b3 07       	cpc	r27, r19
    8d90:	e4 07       	cpc	r30, r20
    8d92:	f5 07       	cpc	r31, r21
    8d94:	20 f0       	brcs	.+8      	; 0x8d9e <__udivmodsi4_ep>
    8d96:	a2 1b       	sub	r26, r18
    8d98:	b3 0b       	sbc	r27, r19
    8d9a:	e4 0b       	sbc	r30, r20
    8d9c:	f5 0b       	sbc	r31, r21

00008d9e <__udivmodsi4_ep>:
    8d9e:	66 1f       	adc	r22, r22
    8da0:	77 1f       	adc	r23, r23
    8da2:	88 1f       	adc	r24, r24
    8da4:	99 1f       	adc	r25, r25
    8da6:	1a 94       	dec	r1
    8da8:	69 f7       	brne	.-38     	; 0x8d84 <__udivmodsi4_loop>
    8daa:	60 95       	com	r22
    8dac:	70 95       	com	r23
    8dae:	80 95       	com	r24
    8db0:	90 95       	com	r25
    8db2:	9b 01       	movw	r18, r22
    8db4:	ac 01       	movw	r20, r24
    8db6:	bd 01       	movw	r22, r26
    8db8:	cf 01       	movw	r24, r30
    8dba:	08 95       	ret

00008dbc <__prologue_saves__>:
    8dbc:	2f 92       	push	r2
    8dbe:	3f 92       	push	r3
    8dc0:	4f 92       	push	r4
    8dc2:	5f 92       	push	r5
    8dc4:	6f 92       	push	r6
    8dc6:	7f 92       	push	r7
    8dc8:	8f 92       	push	r8
    8dca:	9f 92       	push	r9
    8dcc:	af 92       	push	r10
    8dce:	bf 92       	push	r11
    8dd0:	cf 92       	push	r12
    8dd2:	df 92       	push	r13
    8dd4:	ef 92       	push	r14
    8dd6:	ff 92       	push	r15
    8dd8:	0f 93       	push	r16
    8dda:	1f 93       	push	r17
    8ddc:	cf 93       	push	r28
    8dde:	df 93       	push	r29
    8de0:	cd b7       	in	r28, 0x3d	; 61
    8de2:	de b7       	in	r29, 0x3e	; 62
    8de4:	ca 1b       	sub	r28, r26
    8de6:	db 0b       	sbc	r29, r27
    8de8:	0f b6       	in	r0, 0x3f	; 63
    8dea:	f8 94       	cli
    8dec:	de bf       	out	0x3e, r29	; 62
    8dee:	0f be       	out	0x3f, r0	; 63
    8df0:	cd bf       	out	0x3d, r28	; 61
    8df2:	09 94       	ijmp

00008df4 <__epilogue_restores__>:
    8df4:	2a 88       	ldd	r2, Y+18	; 0x12
    8df6:	39 88       	ldd	r3, Y+17	; 0x11
    8df8:	48 88       	ldd	r4, Y+16	; 0x10
    8dfa:	5f 84       	ldd	r5, Y+15	; 0x0f
    8dfc:	6e 84       	ldd	r6, Y+14	; 0x0e
    8dfe:	7d 84       	ldd	r7, Y+13	; 0x0d
    8e00:	8c 84       	ldd	r8, Y+12	; 0x0c
    8e02:	9b 84       	ldd	r9, Y+11	; 0x0b
    8e04:	aa 84       	ldd	r10, Y+10	; 0x0a
    8e06:	b9 84       	ldd	r11, Y+9	; 0x09
    8e08:	c8 84       	ldd	r12, Y+8	; 0x08
    8e0a:	df 80       	ldd	r13, Y+7	; 0x07
    8e0c:	ee 80       	ldd	r14, Y+6	; 0x06
    8e0e:	fd 80       	ldd	r15, Y+5	; 0x05
    8e10:	0c 81       	ldd	r16, Y+4	; 0x04
    8e12:	1b 81       	ldd	r17, Y+3	; 0x03
    8e14:	aa 81       	ldd	r26, Y+2	; 0x02
    8e16:	b9 81       	ldd	r27, Y+1	; 0x01
    8e18:	ce 0f       	add	r28, r30
    8e1a:	d1 1d       	adc	r29, r1
    8e1c:	0f b6       	in	r0, 0x3f	; 63
    8e1e:	f8 94       	cli
    8e20:	de bf       	out	0x3e, r29	; 62
    8e22:	0f be       	out	0x3f, r0	; 63
    8e24:	cd bf       	out	0x3d, r28	; 61
    8e26:	ed 01       	movw	r28, r26
    8e28:	08 95       	ret

00008e2a <memcpy>:
    8e2a:	fb 01       	movw	r30, r22
    8e2c:	dc 01       	movw	r26, r24
    8e2e:	02 c0       	rjmp	.+4      	; 0x8e34 <memcpy+0xa>
    8e30:	01 90       	ld	r0, Z+
    8e32:	0d 92       	st	X+, r0
    8e34:	41 50       	subi	r20, 0x01	; 1
    8e36:	50 40       	sbci	r21, 0x00	; 0
    8e38:	d8 f7       	brcc	.-10     	; 0x8e30 <memcpy+0x6>
    8e3a:	08 95       	ret

00008e3c <itoa>:
    8e3c:	fb 01       	movw	r30, r22
    8e3e:	9f 01       	movw	r18, r30
    8e40:	e8 94       	clt
    8e42:	42 30       	cpi	r20, 0x02	; 2
    8e44:	c4 f0       	brlt	.+48     	; 0x8e76 <itoa+0x3a>
    8e46:	45 32       	cpi	r20, 0x25	; 37
    8e48:	b4 f4       	brge	.+44     	; 0x8e76 <itoa+0x3a>
    8e4a:	4a 30       	cpi	r20, 0x0A	; 10
    8e4c:	29 f4       	brne	.+10     	; 0x8e58 <itoa+0x1c>
    8e4e:	97 fb       	bst	r25, 7
    8e50:	1e f4       	brtc	.+6      	; 0x8e58 <itoa+0x1c>
    8e52:	90 95       	com	r25
    8e54:	81 95       	neg	r24
    8e56:	9f 4f       	sbci	r25, 0xFF	; 255
    8e58:	64 2f       	mov	r22, r20
    8e5a:	77 27       	eor	r23, r23
    8e5c:	0e 94 4f 47 	call	0x8e9e	; 0x8e9e <__udivmodhi4>
    8e60:	80 5d       	subi	r24, 0xD0	; 208
    8e62:	8a 33       	cpi	r24, 0x3A	; 58
    8e64:	0c f0       	brlt	.+2      	; 0x8e68 <itoa+0x2c>
    8e66:	89 5d       	subi	r24, 0xD9	; 217
    8e68:	81 93       	st	Z+, r24
    8e6a:	cb 01       	movw	r24, r22
    8e6c:	00 97       	sbiw	r24, 0x00	; 0
    8e6e:	a1 f7       	brne	.-24     	; 0x8e58 <itoa+0x1c>
    8e70:	16 f4       	brtc	.+4      	; 0x8e76 <itoa+0x3a>
    8e72:	5d e2       	ldi	r21, 0x2D	; 45
    8e74:	51 93       	st	Z+, r21
    8e76:	10 82       	st	Z, r1
    8e78:	c9 01       	movw	r24, r18
    8e7a:	0c 94 3f 47 	jmp	0x8e7e	; 0x8e7e <strrev>

00008e7e <strrev>:
    8e7e:	dc 01       	movw	r26, r24
    8e80:	fc 01       	movw	r30, r24
    8e82:	67 2f       	mov	r22, r23
    8e84:	71 91       	ld	r23, Z+
    8e86:	77 23       	and	r23, r23
    8e88:	e1 f7       	brne	.-8      	; 0x8e82 <strrev+0x4>
    8e8a:	32 97       	sbiw	r30, 0x02	; 2
    8e8c:	04 c0       	rjmp	.+8      	; 0x8e96 <strrev+0x18>
    8e8e:	7c 91       	ld	r23, X
    8e90:	6d 93       	st	X+, r22
    8e92:	70 83       	st	Z, r23
    8e94:	62 91       	ld	r22, -Z
    8e96:	ae 17       	cp	r26, r30
    8e98:	bf 07       	cpc	r27, r31
    8e9a:	c8 f3       	brcs	.-14     	; 0x8e8e <strrev+0x10>
    8e9c:	08 95       	ret

00008e9e <__udivmodhi4>:
    8e9e:	aa 1b       	sub	r26, r26
    8ea0:	bb 1b       	sub	r27, r27
    8ea2:	51 e1       	ldi	r21, 0x11	; 17
    8ea4:	07 c0       	rjmp	.+14     	; 0x8eb4 <__udivmodhi4_ep>

00008ea6 <__udivmodhi4_loop>:
    8ea6:	aa 1f       	adc	r26, r26
    8ea8:	bb 1f       	adc	r27, r27
    8eaa:	a6 17       	cp	r26, r22
    8eac:	b7 07       	cpc	r27, r23
    8eae:	10 f0       	brcs	.+4      	; 0x8eb4 <__udivmodhi4_ep>
    8eb0:	a6 1b       	sub	r26, r22
    8eb2:	b7 0b       	sbc	r27, r23

00008eb4 <__udivmodhi4_ep>:
    8eb4:	88 1f       	adc	r24, r24
    8eb6:	99 1f       	adc	r25, r25
    8eb8:	5a 95       	dec	r21
    8eba:	a9 f7       	brne	.-22     	; 0x8ea6 <__udivmodhi4_loop>
    8ebc:	80 95       	com	r24
    8ebe:	90 95       	com	r25
    8ec0:	bc 01       	movw	r22, r24
    8ec2:	cd 01       	movw	r24, r26
    8ec4:	08 95       	ret

00008ec6 <_exit>:
    8ec6:	f8 94       	cli

00008ec8 <__stop_program>:
    8ec8:	ff cf       	rjmp	.-2      	; 0x8ec8 <__stop_program>
