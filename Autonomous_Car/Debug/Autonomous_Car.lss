
Autonomous_Car.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007ca0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000122  00800060  00007ca0  00007d34  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004a7  00800182  00800182  00007e56  2**0
                  ALLOC
  3 .stab         0000b1a8  00000000  00000000  00007e58  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000055e9  00000000  00000000  00013000  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  000185e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  00018789  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  0001897b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  0001ad86  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  0001c10c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  0001d2e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0001d4a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  0001d79a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001e108  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 d7 0e 	jmp	0x1dae	; 0x1dae <__vector_1>
       8:	0c 94 0a 0f 	jmp	0x1e14	; 0x1e14 <__vector_2>
       c:	0c 94 3d 0f 	jmp	0x1e7a	; 0x1e7a <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d3 27 	jmp	0x4fa6	; 0x4fa6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 bc 0b 	jmp	0x1778	; 0x1778 <__vector_10>
      2c:	0c 94 80 0b 	jmp	0x1700	; 0x1700 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 83 15 	jmp	0x2b06	; 0x2b06 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ea       	ldi	r30, 0xA0	; 160
      68:	fc e7       	ldi	r31, 0x7C	; 124
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 32       	cpi	r26, 0x29	; 41
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 62 3d 	call	0x7ac4	; 0x7ac4 <main>
      8a:	0c 94 4e 3e 	jmp	0x7c9c	; 0x7c9c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 c9 3d 	jmp	0x7b92	; 0x7b92 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e6       	ldi	r26, 0x65	; 101
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 e5 3d 	jmp	0x7bca	; 0x7bca <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 d5 3d 	jmp	0x7baa	; 0x7baa <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 f1 3d 	jmp	0x7be2	; 0x7be2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 d5 3d 	jmp	0x7baa	; 0x7baa <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 f1 3d 	jmp	0x7be2	; 0x7be2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 c9 3d 	jmp	0x7b92	; 0x7b92 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e6       	ldi	r24, 0x65	; 101
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 e5 3d 	jmp	0x7bca	; 0x7bca <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 d1 3d 	jmp	0x7ba2	; 0x7ba2 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	65 e6       	ldi	r22, 0x65	; 101
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 ed 3d 	jmp	0x7bda	; 0x7bda <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 d5 3d 	jmp	0x7baa	; 0x7baa <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 f1 3d 	jmp	0x7be2	; 0x7be2 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 d5 3d 	jmp	0x7baa	; 0x7baa <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 f1 3d 	jmp	0x7be2	; 0x7be2 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 d5 3d 	jmp	0x7baa	; 0x7baa <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 f1 3d 	jmp	0x7be2	; 0x7be2 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 d9 3d 	jmp	0x7bb2	; 0x7bb2 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 f5 3d 	jmp	0x7bea	; 0x7bea <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 d1 3d 	jmp	0x7ba2	; 0x7ba2 <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 ed 3d 	jmp	0x7bda	; 0x7bda <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	e3 59       	subi	r30, 0x93	; 147
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <MCAL_WDT_u8Enable>:
 *      Author: Mohamed
 */

#include "WDT.h"

void MCAL_WDT_u8Enable(void) {
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(WDTCR, WDTCR_Pin3);
     e36:	a1 e4       	ldi	r26, 0x41	; 65
     e38:	b0 e0       	ldi	r27, 0x00	; 0
     e3a:	e1 e4       	ldi	r30, 0x41	; 65
     e3c:	f0 e0       	ldi	r31, 0x00	; 0
     e3e:	80 81       	ld	r24, Z
     e40:	88 60       	ori	r24, 0x08	; 8
     e42:	8c 93       	st	X, r24
	SET_BIT(WDTCR, WDTCR_Pin4);
     e44:	a1 e4       	ldi	r26, 0x41	; 65
     e46:	b0 e0       	ldi	r27, 0x00	; 0
     e48:	e1 e4       	ldi	r30, 0x41	; 65
     e4a:	f0 e0       	ldi	r31, 0x00	; 0
     e4c:	80 81       	ld	r24, Z
     e4e:	80 61       	ori	r24, 0x10	; 16
     e50:	8c 93       	st	X, r24
}
     e52:	cf 91       	pop	r28
     e54:	df 91       	pop	r29
     e56:	08 95       	ret

00000e58 <MCAL_WDT_u8SetTime>:
void MCAL_WDT_u8SetTime(u8 Loc_u8Time) {
     e58:	df 93       	push	r29
     e5a:	cf 93       	push	r28
     e5c:	0f 92       	push	r0
     e5e:	cd b7       	in	r28, 0x3d	; 61
     e60:	de b7       	in	r29, 0x3e	; 62
     e62:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8Time == Time_16_3_ms) {
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	88 23       	and	r24, r24
     e68:	b1 f4       	brne	.+44     	; 0xe96 <MCAL_WDT_u8SetTime+0x3e>
		CLR_BIT(WDTCR, WDTCR_Pin0);
     e6a:	a1 e4       	ldi	r26, 0x41	; 65
     e6c:	b0 e0       	ldi	r27, 0x00	; 0
     e6e:	e1 e4       	ldi	r30, 0x41	; 65
     e70:	f0 e0       	ldi	r31, 0x00	; 0
     e72:	80 81       	ld	r24, Z
     e74:	8e 7f       	andi	r24, 0xFE	; 254
     e76:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin1);
     e78:	a1 e4       	ldi	r26, 0x41	; 65
     e7a:	b0 e0       	ldi	r27, 0x00	; 0
     e7c:	e1 e4       	ldi	r30, 0x41	; 65
     e7e:	f0 e0       	ldi	r31, 0x00	; 0
     e80:	80 81       	ld	r24, Z
     e82:	8d 7f       	andi	r24, 0xFD	; 253
     e84:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin2);
     e86:	a1 e4       	ldi	r26, 0x41	; 65
     e88:	b0 e0       	ldi	r27, 0x00	; 0
     e8a:	e1 e4       	ldi	r30, 0x41	; 65
     e8c:	f0 e0       	ldi	r31, 0x00	; 0
     e8e:	80 81       	ld	r24, Z
     e90:	8b 7f       	andi	r24, 0xFB	; 251
     e92:	8c 93       	st	X, r24
     e94:	ae c0       	rjmp	.+348    	; 0xff2 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_32_5_ms) {
     e96:	89 81       	ldd	r24, Y+1	; 0x01
     e98:	81 30       	cpi	r24, 0x01	; 1
     e9a:	b1 f4       	brne	.+44     	; 0xec8 <MCAL_WDT_u8SetTime+0x70>
		SET_BIT(WDTCR, WDTCR_Pin0);
     e9c:	a1 e4       	ldi	r26, 0x41	; 65
     e9e:	b0 e0       	ldi	r27, 0x00	; 0
     ea0:	e1 e4       	ldi	r30, 0x41	; 65
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	80 81       	ld	r24, Z
     ea6:	81 60       	ori	r24, 0x01	; 1
     ea8:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin1);
     eaa:	a1 e4       	ldi	r26, 0x41	; 65
     eac:	b0 e0       	ldi	r27, 0x00	; 0
     eae:	e1 e4       	ldi	r30, 0x41	; 65
     eb0:	f0 e0       	ldi	r31, 0x00	; 0
     eb2:	80 81       	ld	r24, Z
     eb4:	8d 7f       	andi	r24, 0xFD	; 253
     eb6:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin2);
     eb8:	a1 e4       	ldi	r26, 0x41	; 65
     eba:	b0 e0       	ldi	r27, 0x00	; 0
     ebc:	e1 e4       	ldi	r30, 0x41	; 65
     ebe:	f0 e0       	ldi	r31, 0x00	; 0
     ec0:	80 81       	ld	r24, Z
     ec2:	8b 7f       	andi	r24, 0xFB	; 251
     ec4:	8c 93       	st	X, r24
     ec6:	95 c0       	rjmp	.+298    	; 0xff2 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_65_0_ms) {
     ec8:	89 81       	ldd	r24, Y+1	; 0x01
     eca:	82 30       	cpi	r24, 0x02	; 2
     ecc:	b1 f4       	brne	.+44     	; 0xefa <MCAL_WDT_u8SetTime+0xa2>
		CLR_BIT(WDTCR, WDTCR_Pin0);
     ece:	a1 e4       	ldi	r26, 0x41	; 65
     ed0:	b0 e0       	ldi	r27, 0x00	; 0
     ed2:	e1 e4       	ldi	r30, 0x41	; 65
     ed4:	f0 e0       	ldi	r31, 0x00	; 0
     ed6:	80 81       	ld	r24, Z
     ed8:	8e 7f       	andi	r24, 0xFE	; 254
     eda:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin1);
     edc:	a1 e4       	ldi	r26, 0x41	; 65
     ede:	b0 e0       	ldi	r27, 0x00	; 0
     ee0:	e1 e4       	ldi	r30, 0x41	; 65
     ee2:	f0 e0       	ldi	r31, 0x00	; 0
     ee4:	80 81       	ld	r24, Z
     ee6:	82 60       	ori	r24, 0x02	; 2
     ee8:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin2);
     eea:	a1 e4       	ldi	r26, 0x41	; 65
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	e1 e4       	ldi	r30, 0x41	; 65
     ef0:	f0 e0       	ldi	r31, 0x00	; 0
     ef2:	80 81       	ld	r24, Z
     ef4:	8b 7f       	andi	r24, 0xFB	; 251
     ef6:	8c 93       	st	X, r24
     ef8:	7c c0       	rjmp	.+248    	; 0xff2 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_0_13_s) {
     efa:	89 81       	ldd	r24, Y+1	; 0x01
     efc:	83 30       	cpi	r24, 0x03	; 3
     efe:	b1 f4       	brne	.+44     	; 0xf2c <MCAL_WDT_u8SetTime+0xd4>
		SET_BIT(WDTCR, WDTCR_Pin0);
     f00:	a1 e4       	ldi	r26, 0x41	; 65
     f02:	b0 e0       	ldi	r27, 0x00	; 0
     f04:	e1 e4       	ldi	r30, 0x41	; 65
     f06:	f0 e0       	ldi	r31, 0x00	; 0
     f08:	80 81       	ld	r24, Z
     f0a:	81 60       	ori	r24, 0x01	; 1
     f0c:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin1);
     f0e:	a1 e4       	ldi	r26, 0x41	; 65
     f10:	b0 e0       	ldi	r27, 0x00	; 0
     f12:	e1 e4       	ldi	r30, 0x41	; 65
     f14:	f0 e0       	ldi	r31, 0x00	; 0
     f16:	80 81       	ld	r24, Z
     f18:	82 60       	ori	r24, 0x02	; 2
     f1a:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin2);
     f1c:	a1 e4       	ldi	r26, 0x41	; 65
     f1e:	b0 e0       	ldi	r27, 0x00	; 0
     f20:	e1 e4       	ldi	r30, 0x41	; 65
     f22:	f0 e0       	ldi	r31, 0x00	; 0
     f24:	80 81       	ld	r24, Z
     f26:	8b 7f       	andi	r24, 0xFB	; 251
     f28:	8c 93       	st	X, r24
     f2a:	63 c0       	rjmp	.+198    	; 0xff2 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_0_26_s) {
     f2c:	89 81       	ldd	r24, Y+1	; 0x01
     f2e:	84 30       	cpi	r24, 0x04	; 4
     f30:	b1 f4       	brne	.+44     	; 0xf5e <MCAL_WDT_u8SetTime+0x106>
		CLR_BIT(WDTCR, WDTCR_Pin0);
     f32:	a1 e4       	ldi	r26, 0x41	; 65
     f34:	b0 e0       	ldi	r27, 0x00	; 0
     f36:	e1 e4       	ldi	r30, 0x41	; 65
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
     f3c:	8e 7f       	andi	r24, 0xFE	; 254
     f3e:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin1);
     f40:	a1 e4       	ldi	r26, 0x41	; 65
     f42:	b0 e0       	ldi	r27, 0x00	; 0
     f44:	e1 e4       	ldi	r30, 0x41	; 65
     f46:	f0 e0       	ldi	r31, 0x00	; 0
     f48:	80 81       	ld	r24, Z
     f4a:	8d 7f       	andi	r24, 0xFD	; 253
     f4c:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin2);
     f4e:	a1 e4       	ldi	r26, 0x41	; 65
     f50:	b0 e0       	ldi	r27, 0x00	; 0
     f52:	e1 e4       	ldi	r30, 0x41	; 65
     f54:	f0 e0       	ldi	r31, 0x00	; 0
     f56:	80 81       	ld	r24, Z
     f58:	84 60       	ori	r24, 0x04	; 4
     f5a:	8c 93       	st	X, r24
     f5c:	4a c0       	rjmp	.+148    	; 0xff2 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_0_52_s) {
     f5e:	89 81       	ldd	r24, Y+1	; 0x01
     f60:	85 30       	cpi	r24, 0x05	; 5
     f62:	b1 f4       	brne	.+44     	; 0xf90 <MCAL_WDT_u8SetTime+0x138>
		SET_BIT(WDTCR, WDTCR_Pin0);
     f64:	a1 e4       	ldi	r26, 0x41	; 65
     f66:	b0 e0       	ldi	r27, 0x00	; 0
     f68:	e1 e4       	ldi	r30, 0x41	; 65
     f6a:	f0 e0       	ldi	r31, 0x00	; 0
     f6c:	80 81       	ld	r24, Z
     f6e:	81 60       	ori	r24, 0x01	; 1
     f70:	8c 93       	st	X, r24
		CLR_BIT(WDTCR, WDTCR_Pin1);
     f72:	a1 e4       	ldi	r26, 0x41	; 65
     f74:	b0 e0       	ldi	r27, 0x00	; 0
     f76:	e1 e4       	ldi	r30, 0x41	; 65
     f78:	f0 e0       	ldi	r31, 0x00	; 0
     f7a:	80 81       	ld	r24, Z
     f7c:	8d 7f       	andi	r24, 0xFD	; 253
     f7e:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin2);
     f80:	a1 e4       	ldi	r26, 0x41	; 65
     f82:	b0 e0       	ldi	r27, 0x00	; 0
     f84:	e1 e4       	ldi	r30, 0x41	; 65
     f86:	f0 e0       	ldi	r31, 0x00	; 0
     f88:	80 81       	ld	r24, Z
     f8a:	84 60       	ori	r24, 0x04	; 4
     f8c:	8c 93       	st	X, r24
     f8e:	31 c0       	rjmp	.+98     	; 0xff2 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_1_0_s) {
     f90:	89 81       	ldd	r24, Y+1	; 0x01
     f92:	86 30       	cpi	r24, 0x06	; 6
     f94:	b1 f4       	brne	.+44     	; 0xfc2 <MCAL_WDT_u8SetTime+0x16a>
		CLR_BIT(WDTCR, WDTCR_Pin0);
     f96:	a1 e4       	ldi	r26, 0x41	; 65
     f98:	b0 e0       	ldi	r27, 0x00	; 0
     f9a:	e1 e4       	ldi	r30, 0x41	; 65
     f9c:	f0 e0       	ldi	r31, 0x00	; 0
     f9e:	80 81       	ld	r24, Z
     fa0:	8e 7f       	andi	r24, 0xFE	; 254
     fa2:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin1);
     fa4:	a1 e4       	ldi	r26, 0x41	; 65
     fa6:	b0 e0       	ldi	r27, 0x00	; 0
     fa8:	e1 e4       	ldi	r30, 0x41	; 65
     faa:	f0 e0       	ldi	r31, 0x00	; 0
     fac:	80 81       	ld	r24, Z
     fae:	82 60       	ori	r24, 0x02	; 2
     fb0:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin2);
     fb2:	a1 e4       	ldi	r26, 0x41	; 65
     fb4:	b0 e0       	ldi	r27, 0x00	; 0
     fb6:	e1 e4       	ldi	r30, 0x41	; 65
     fb8:	f0 e0       	ldi	r31, 0x00	; 0
     fba:	80 81       	ld	r24, Z
     fbc:	84 60       	ori	r24, 0x04	; 4
     fbe:	8c 93       	st	X, r24
     fc0:	18 c0       	rjmp	.+48     	; 0xff2 <MCAL_WDT_u8SetTime+0x19a>
	} else if (Loc_u8Time == Time_2_1_s) {
     fc2:	89 81       	ldd	r24, Y+1	; 0x01
     fc4:	87 30       	cpi	r24, 0x07	; 7
     fc6:	a9 f4       	brne	.+42     	; 0xff2 <MCAL_WDT_u8SetTime+0x19a>
		SET_BIT(WDTCR, WDTCR_Pin0);
     fc8:	a1 e4       	ldi	r26, 0x41	; 65
     fca:	b0 e0       	ldi	r27, 0x00	; 0
     fcc:	e1 e4       	ldi	r30, 0x41	; 65
     fce:	f0 e0       	ldi	r31, 0x00	; 0
     fd0:	80 81       	ld	r24, Z
     fd2:	81 60       	ori	r24, 0x01	; 1
     fd4:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin1);
     fd6:	a1 e4       	ldi	r26, 0x41	; 65
     fd8:	b0 e0       	ldi	r27, 0x00	; 0
     fda:	e1 e4       	ldi	r30, 0x41	; 65
     fdc:	f0 e0       	ldi	r31, 0x00	; 0
     fde:	80 81       	ld	r24, Z
     fe0:	82 60       	ori	r24, 0x02	; 2
     fe2:	8c 93       	st	X, r24
		SET_BIT(WDTCR, WDTCR_Pin2);
     fe4:	a1 e4       	ldi	r26, 0x41	; 65
     fe6:	b0 e0       	ldi	r27, 0x00	; 0
     fe8:	e1 e4       	ldi	r30, 0x41	; 65
     fea:	f0 e0       	ldi	r31, 0x00	; 0
     fec:	80 81       	ld	r24, Z
     fee:	84 60       	ori	r24, 0x04	; 4
     ff0:	8c 93       	st	X, r24
	}
}
     ff2:	0f 90       	pop	r0
     ff4:	cf 91       	pop	r28
     ff6:	df 91       	pop	r29
     ff8:	08 95       	ret

00000ffa <MCAL_WDT_u8Disable>:
void MCAL_WDT_u8Disable(void) {
     ffa:	df 93       	push	r29
     ffc:	cf 93       	push	r28
     ffe:	cd b7       	in	r28, 0x3d	; 61
    1000:	de b7       	in	r29, 0x3e	; 62
	WDTCR = WDTCR_Disable;
    1002:	e1 e4       	ldi	r30, 0x41	; 65
    1004:	f0 e0       	ldi	r31, 0x00	; 0
    1006:	88 e1       	ldi	r24, 0x18	; 24
    1008:	80 83       	st	Z, r24
	WDTCR = WDTCR_Zero;
    100a:	e1 e4       	ldi	r30, 0x41	; 65
    100c:	f0 e0       	ldi	r31, 0x00	; 0
    100e:	10 82       	st	Z, r1
}
    1010:	cf 91       	pop	r28
    1012:	df 91       	pop	r29
    1014:	08 95       	ret

00001016 <MCAL_UART_UARTInit>:
 */

#include "UART.h"
//#include "avr/interrupt.h"

void MCAL_UART_UARTInit(void) {
    1016:	df 93       	push	r29
    1018:	cf 93       	push	r28
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
	/* Set baud rate */
	UBRRH = (u8) (Baud_Rate >> Shift_8_bit);
    101e:	e0 e4       	ldi	r30, 0x40	; 64
    1020:	f0 e0       	ldi	r31, 0x00	; 0
    1022:	10 82       	st	Z, r1
	UBRRL = (u8) Baud_Rate;
    1024:	e9 e2       	ldi	r30, 0x29	; 41
    1026:	f0 e0       	ldi	r31, 0x00	; 0
    1028:	87 e6       	ldi	r24, 0x67	; 103
    102a:	80 83       	st	Z, r24

	/* Enable RX and TX */
//	UCSRB = (1 << RXEN) | (1 << TXEN);
	SET_BIT(UCSRB,RXEN_PIN);
    102c:	aa e2       	ldi	r26, 0x2A	; 42
    102e:	b0 e0       	ldi	r27, 0x00	; 0
    1030:	ea e2       	ldi	r30, 0x2A	; 42
    1032:	f0 e0       	ldi	r31, 0x00	; 0
    1034:	80 81       	ld	r24, Z
    1036:	80 61       	ori	r24, 0x10	; 16
    1038:	8c 93       	st	X, r24
	SET_BIT(UCSRB,TXEN_PIN);
    103a:	aa e2       	ldi	r26, 0x2A	; 42
    103c:	b0 e0       	ldi	r27, 0x00	; 0
    103e:	ea e2       	ldi	r30, 0x2A	; 42
    1040:	f0 e0       	ldi	r31, 0x00	; 0
    1042:	80 81       	ld	r24, Z
    1044:	88 60       	ori	r24, 0x08	; 8
    1046:	8c 93       	st	X, r24

	/* Set frame format: 8data, 2stop bit */
//	UCSRC = (1 << URSEL) | (1 << USBS) | (3 << UCSZ0);
	UCSRC = UCSRC_Size;
    1048:	e0 e4       	ldi	r30, 0x40	; 64
    104a:	f0 e0       	ldi	r31, 0x00	; 0
    104c:	8e e8       	ldi	r24, 0x8E	; 142
    104e:	80 83       	st	Z, r24
	//Logical Error
//	SET_BIT(UCSRC,URSEL_PIN);
//	SET_BIT(UCSRC,USBS_PIN);
//	SET_BIT(UCSRC,UCSZ0_PIN);
//	SET_BIT(UCSRC,UCSZ1_PIN);
}
    1050:	cf 91       	pop	r28
    1052:	df 91       	pop	r29
    1054:	08 95       	ret

00001056 <MCAL_UART_UARTTransmit>:

void MCAL_UART_UARTTransmit(u8 Loc_u8data) {
    1056:	df 93       	push	r29
    1058:	cf 93       	push	r28
    105a:	0f 92       	push	r0
    105c:	cd b7       	in	r28, 0x3d	; 61
    105e:	de b7       	in	r29, 0x3e	; 62
    1060:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
//	while (!( UCSRA & (1 << UDRE_PIN)));
	while (GET_BIT(UCSRA,UDRE_PIN)==0);
    1062:	eb e2       	ldi	r30, 0x2B	; 43
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    1066:	80 81       	ld	r24, Z
    1068:	82 95       	swap	r24
    106a:	86 95       	lsr	r24
    106c:	87 70       	andi	r24, 0x07	; 7
    106e:	88 2f       	mov	r24, r24
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	81 70       	andi	r24, 0x01	; 1
    1074:	90 70       	andi	r25, 0x00	; 0
    1076:	00 97       	sbiw	r24, 0x00	; 0
    1078:	a1 f3       	breq	.-24     	; 0x1062 <MCAL_UART_UARTTransmit+0xc>

	/* Put data into buffer, sends the data */
	UDR = Loc_u8data;
    107a:	ec e2       	ldi	r30, 0x2C	; 44
    107c:	f0 e0       	ldi	r31, 0x00	; 0
    107e:	89 81       	ldd	r24, Y+1	; 0x01
    1080:	80 83       	st	Z, r24

	/* Wait for data to be transmitted */
	while (GET_BIT(UCSRA,TXC_PIN)==0);
    1082:	eb e2       	ldi	r30, 0x2B	; 43
    1084:	f0 e0       	ldi	r31, 0x00	; 0
    1086:	80 81       	ld	r24, Z
    1088:	82 95       	swap	r24
    108a:	86 95       	lsr	r24
    108c:	86 95       	lsr	r24
    108e:	83 70       	andi	r24, 0x03	; 3
    1090:	88 2f       	mov	r24, r24
    1092:	90 e0       	ldi	r25, 0x00	; 0
    1094:	81 70       	andi	r24, 0x01	; 1
    1096:	90 70       	andi	r25, 0x00	; 0
    1098:	00 97       	sbiw	r24, 0x00	; 0
    109a:	99 f3       	breq	.-26     	; 0x1082 <MCAL_UART_UARTTransmit+0x2c>
	SET_BIT(UCSRA,TXC_PIN);
    109c:	ab e2       	ldi	r26, 0x2B	; 43
    109e:	b0 e0       	ldi	r27, 0x00	; 0
    10a0:	eb e2       	ldi	r30, 0x2B	; 43
    10a2:	f0 e0       	ldi	r31, 0x00	; 0
    10a4:	80 81       	ld	r24, Z
    10a6:	80 64       	ori	r24, 0x40	; 64
    10a8:	8c 93       	st	X, r24

}
    10aa:	0f 90       	pop	r0
    10ac:	cf 91       	pop	r28
    10ae:	df 91       	pop	r29
    10b0:	08 95       	ret

000010b2 <MCAL_UART_UARTReceive>:
//		MCAL_UART_UARTTransmit(Loc_u8data[i]);
//	}
//
//}

void MCAL_UART_UARTReceive(u8* Loc_u8data) {
    10b2:	df 93       	push	r29
    10b4:	cf 93       	push	r28
    10b6:	00 d0       	rcall	.+0      	; 0x10b8 <MCAL_UART_UARTReceive+0x6>
    10b8:	cd b7       	in	r28, 0x3d	; 61
    10ba:	de b7       	in	r29, 0x3e	; 62
    10bc:	9a 83       	std	Y+2, r25	; 0x02
    10be:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for data to be received */
//	while (!(UCSRA & (1 << RXC_PIN)));
	while (GET_BIT(UCSRA,RXC_PIN)==0);
    10c0:	eb e2       	ldi	r30, 0x2B	; 43
    10c2:	f0 e0       	ldi	r31, 0x00	; 0
    10c4:	80 81       	ld	r24, Z
    10c6:	88 23       	and	r24, r24
    10c8:	dc f7       	brge	.-10     	; 0x10c0 <MCAL_UART_UARTReceive+0xe>

	/* 	Save Received Data in Var-Loc_u8data */
	*Loc_u8data=UDR;
    10ca:	ec e2       	ldi	r30, 0x2C	; 44
    10cc:	f0 e0       	ldi	r31, 0x00	; 0
    10ce:	80 81       	ld	r24, Z
    10d0:	e9 81       	ldd	r30, Y+1	; 0x01
    10d2:	fa 81       	ldd	r31, Y+2	; 0x02
    10d4:	80 83       	st	Z, r24
}
    10d6:	0f 90       	pop	r0
    10d8:	0f 90       	pop	r0
    10da:	cf 91       	pop	r28
    10dc:	df 91       	pop	r29
    10de:	08 95       	ret

000010e0 <MCAL_Timer0_Init>:
void (*Gptr3)(void)= '\0' ;
f32 Glob_TickTime;
u16 Start = 0;
u16 Counter = 0;

void MCAL_Timer0_Init(u8 Loc_u8Mode, u8 Loc_u8Prescaller,u8 Loc_u8OC0Mode) {
    10e0:	df 93       	push	r29
    10e2:	cf 93       	push	r28
    10e4:	00 d0       	rcall	.+0      	; 0x10e6 <MCAL_Timer0_Init+0x6>
    10e6:	00 d0       	rcall	.+0      	; 0x10e8 <MCAL_Timer0_Init+0x8>
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	8a 83       	std	Y+2, r24	; 0x02
    10ee:	6b 83       	std	Y+3, r22	; 0x03
    10f0:	4c 83       	std	Y+4, r20	; 0x04
	u8 LOC_u8ReturnValue = E_NOT_OK;
    10f2:	81 e0       	ldi	r24, 0x01	; 1
    10f4:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(SREG, 7);
    10f6:	af e5       	ldi	r26, 0x5F	; 95
    10f8:	b0 e0       	ldi	r27, 0x00	; 0
    10fa:	ef e5       	ldi	r30, 0x5F	; 95
    10fc:	f0 e0       	ldi	r31, 0x00	; 0
    10fe:	80 81       	ld	r24, Z
    1100:	80 68       	ori	r24, 0x80	; 128
    1102:	8c 93       	st	X, r24
	if (Loc_u8Mode == Normal_Mode) {
    1104:	8a 81       	ldd	r24, Y+2	; 0x02
    1106:	88 23       	and	r24, r24
    1108:	b1 f4       	brne	.+44     	; 0x1136 <MCAL_Timer0_Init+0x56>
		CLR_BIT(TCCR0, 3);
    110a:	a3 e5       	ldi	r26, 0x53	; 83
    110c:	b0 e0       	ldi	r27, 0x00	; 0
    110e:	e3 e5       	ldi	r30, 0x53	; 83
    1110:	f0 e0       	ldi	r31, 0x00	; 0
    1112:	80 81       	ld	r24, Z
    1114:	87 7f       	andi	r24, 0xF7	; 247
    1116:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 6);
    1118:	a3 e5       	ldi	r26, 0x53	; 83
    111a:	b0 e0       	ldi	r27, 0x00	; 0
    111c:	e3 e5       	ldi	r30, 0x53	; 83
    111e:	f0 e0       	ldi	r31, 0x00	; 0
    1120:	80 81       	ld	r24, Z
    1122:	8f 7b       	andi	r24, 0xBF	; 191
    1124:	8c 93       	st	X, r24
		SET_BIT(TIMSK, 0);
    1126:	a9 e5       	ldi	r26, 0x59	; 89
    1128:	b0 e0       	ldi	r27, 0x00	; 0
    112a:	e9 e5       	ldi	r30, 0x59	; 89
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
    1130:	81 60       	ori	r24, 0x01	; 1
    1132:	8c 93       	st	X, r24
    1134:	35 c0       	rjmp	.+106    	; 0x11a0 <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == CTC_Mode) {
    1136:	8a 81       	ldd	r24, Y+2	; 0x02
    1138:	81 30       	cpi	r24, 0x01	; 1
    113a:	b1 f4       	brne	.+44     	; 0x1168 <MCAL_Timer0_Init+0x88>
		SET_BIT(TCCR0, 3);
    113c:	a3 e5       	ldi	r26, 0x53	; 83
    113e:	b0 e0       	ldi	r27, 0x00	; 0
    1140:	e3 e5       	ldi	r30, 0x53	; 83
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	80 81       	ld	r24, Z
    1146:	88 60       	ori	r24, 0x08	; 8
    1148:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 6);
    114a:	a3 e5       	ldi	r26, 0x53	; 83
    114c:	b0 e0       	ldi	r27, 0x00	; 0
    114e:	e3 e5       	ldi	r30, 0x53	; 83
    1150:	f0 e0       	ldi	r31, 0x00	; 0
    1152:	80 81       	ld	r24, Z
    1154:	8f 7b       	andi	r24, 0xBF	; 191
    1156:	8c 93       	st	X, r24
		SET_BIT(TIMSK, 1);
    1158:	a9 e5       	ldi	r26, 0x59	; 89
    115a:	b0 e0       	ldi	r27, 0x00	; 0
    115c:	e9 e5       	ldi	r30, 0x59	; 89
    115e:	f0 e0       	ldi	r31, 0x00	; 0
    1160:	80 81       	ld	r24, Z
    1162:	82 60       	ori	r24, 0x02	; 2
    1164:	8c 93       	st	X, r24
    1166:	1c c0       	rjmp	.+56     	; 0x11a0 <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == PWM_Mode) {
    1168:	8a 81       	ldd	r24, Y+2	; 0x02
    116a:	82 30       	cpi	r24, 0x02	; 2
    116c:	79 f4       	brne	.+30     	; 0x118c <MCAL_Timer0_Init+0xac>
		CLR_BIT(TCCR0, 3);
    116e:	a3 e5       	ldi	r26, 0x53	; 83
    1170:	b0 e0       	ldi	r27, 0x00	; 0
    1172:	e3 e5       	ldi	r30, 0x53	; 83
    1174:	f0 e0       	ldi	r31, 0x00	; 0
    1176:	80 81       	ld	r24, Z
    1178:	87 7f       	andi	r24, 0xF7	; 247
    117a:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 6);
    117c:	a3 e5       	ldi	r26, 0x53	; 83
    117e:	b0 e0       	ldi	r27, 0x00	; 0
    1180:	e3 e5       	ldi	r30, 0x53	; 83
    1182:	f0 e0       	ldi	r31, 0x00	; 0
    1184:	80 81       	ld	r24, Z
    1186:	80 64       	ori	r24, 0x40	; 64
    1188:	8c 93       	st	X, r24
    118a:	0a c0       	rjmp	.+20     	; 0x11a0 <MCAL_Timer0_Init+0xc0>
	} else if (Loc_u8Mode == FastPWM_Mode) {
    118c:	8a 81       	ldd	r24, Y+2	; 0x02
    118e:	83 30       	cpi	r24, 0x03	; 3
    1190:	39 f4       	brne	.+14     	; 0x11a0 <MCAL_Timer0_Init+0xc0>
//		SET_BIT(TCCR0, 3);
//		SET_BIT(TCCR0, 6);
		SET_BIT(TIMSK, 1);
    1192:	a9 e5       	ldi	r26, 0x59	; 89
    1194:	b0 e0       	ldi	r27, 0x00	; 0
    1196:	e9 e5       	ldi	r30, 0x59	; 89
    1198:	f0 e0       	ldi	r31, 0x00	; 0
    119a:	80 81       	ld	r24, Z
    119c:	82 60       	ori	r24, 0x02	; 2
    119e:	8c 93       	st	X, r24
	}
	if (Loc_u8Prescaller == NoPrescaller) {
    11a0:	8b 81       	ldd	r24, Y+3	; 0x03
    11a2:	88 23       	and	r24, r24
    11a4:	b9 f4       	brne	.+46     	; 0x11d4 <MCAL_Timer0_Init+0xf4>
		CLR_BIT(TCCR0, 0);
    11a6:	a3 e5       	ldi	r26, 0x53	; 83
    11a8:	b0 e0       	ldi	r27, 0x00	; 0
    11aa:	e3 e5       	ldi	r30, 0x53	; 83
    11ac:	f0 e0       	ldi	r31, 0x00	; 0
    11ae:	80 81       	ld	r24, Z
    11b0:	8e 7f       	andi	r24, 0xFE	; 254
    11b2:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    11b4:	a3 e5       	ldi	r26, 0x53	; 83
    11b6:	b0 e0       	ldi	r27, 0x00	; 0
    11b8:	e3 e5       	ldi	r30, 0x53	; 83
    11ba:	f0 e0       	ldi	r31, 0x00	; 0
    11bc:	80 81       	ld	r24, Z
    11be:	8d 7f       	andi	r24, 0xFD	; 253
    11c0:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    11c2:	a3 e5       	ldi	r26, 0x53	; 83
    11c4:	b0 e0       	ldi	r27, 0x00	; 0
    11c6:	e3 e5       	ldi	r30, 0x53	; 83
    11c8:	f0 e0       	ldi	r31, 0x00	; 0
    11ca:	80 81       	ld	r24, Z
    11cc:	8b 7f       	andi	r24, 0xFB	; 251
    11ce:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    11d0:	19 82       	std	Y+1, r1	; 0x01
    11d2:	f1 c0       	rjmp	.+482    	; 0x13b6 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_1) {
    11d4:	8b 81       	ldd	r24, Y+3	; 0x03
    11d6:	81 30       	cpi	r24, 0x01	; 1
    11d8:	19 f5       	brne	.+70     	; 0x1220 <MCAL_Timer0_Init+0x140>
		SET_BIT(TCCR0, 0);
    11da:	a3 e5       	ldi	r26, 0x53	; 83
    11dc:	b0 e0       	ldi	r27, 0x00	; 0
    11de:	e3 e5       	ldi	r30, 0x53	; 83
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	80 81       	ld	r24, Z
    11e4:	81 60       	ori	r24, 0x01	; 1
    11e6:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    11e8:	a3 e5       	ldi	r26, 0x53	; 83
    11ea:	b0 e0       	ldi	r27, 0x00	; 0
    11ec:	e3 e5       	ldi	r30, 0x53	; 83
    11ee:	f0 e0       	ldi	r31, 0x00	; 0
    11f0:	80 81       	ld	r24, Z
    11f2:	8d 7f       	andi	r24, 0xFD	; 253
    11f4:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    11f6:	a3 e5       	ldi	r26, 0x53	; 83
    11f8:	b0 e0       	ldi	r27, 0x00	; 0
    11fa:	e3 e5       	ldi	r30, 0x53	; 83
    11fc:	f0 e0       	ldi	r31, 0x00	; 0
    11fe:	80 81       	ld	r24, Z
    1200:	8b 7f       	andi	r24, 0xFB	; 251
    1202:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller1_Value / (f32) CPU_Frequancy;
    1204:	8d eb       	ldi	r24, 0xBD	; 189
    1206:	97 e3       	ldi	r25, 0x37	; 55
    1208:	a6 e8       	ldi	r26, 0x86	; 134
    120a:	b3 e3       	ldi	r27, 0x33	; 51
    120c:	80 93 21 06 	sts	0x0621, r24
    1210:	90 93 22 06 	sts	0x0622, r25
    1214:	a0 93 23 06 	sts	0x0623, r26
    1218:	b0 93 24 06 	sts	0x0624, r27
		LOC_u8ReturnValue = E_OK;
    121c:	19 82       	std	Y+1, r1	; 0x01
    121e:	cb c0       	rjmp	.+406    	; 0x13b6 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_8) {
    1220:	8b 81       	ldd	r24, Y+3	; 0x03
    1222:	82 30       	cpi	r24, 0x02	; 2
    1224:	19 f5       	brne	.+70     	; 0x126c <MCAL_Timer0_Init+0x18c>
		CLR_BIT(TCCR0, 0);
    1226:	a3 e5       	ldi	r26, 0x53	; 83
    1228:	b0 e0       	ldi	r27, 0x00	; 0
    122a:	e3 e5       	ldi	r30, 0x53	; 83
    122c:	f0 e0       	ldi	r31, 0x00	; 0
    122e:	80 81       	ld	r24, Z
    1230:	8e 7f       	andi	r24, 0xFE	; 254
    1232:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    1234:	a3 e5       	ldi	r26, 0x53	; 83
    1236:	b0 e0       	ldi	r27, 0x00	; 0
    1238:	e3 e5       	ldi	r30, 0x53	; 83
    123a:	f0 e0       	ldi	r31, 0x00	; 0
    123c:	80 81       	ld	r24, Z
    123e:	82 60       	ori	r24, 0x02	; 2
    1240:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    1242:	a3 e5       	ldi	r26, 0x53	; 83
    1244:	b0 e0       	ldi	r27, 0x00	; 0
    1246:	e3 e5       	ldi	r30, 0x53	; 83
    1248:	f0 e0       	ldi	r31, 0x00	; 0
    124a:	80 81       	ld	r24, Z
    124c:	8b 7f       	andi	r24, 0xFB	; 251
    124e:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller8_Value / (f32) CPU_Frequancy;
    1250:	8d eb       	ldi	r24, 0xBD	; 189
    1252:	97 e3       	ldi	r25, 0x37	; 55
    1254:	a6 e0       	ldi	r26, 0x06	; 6
    1256:	b5 e3       	ldi	r27, 0x35	; 53
    1258:	80 93 21 06 	sts	0x0621, r24
    125c:	90 93 22 06 	sts	0x0622, r25
    1260:	a0 93 23 06 	sts	0x0623, r26
    1264:	b0 93 24 06 	sts	0x0624, r27
		LOC_u8ReturnValue = E_OK;
    1268:	19 82       	std	Y+1, r1	; 0x01
    126a:	a5 c0       	rjmp	.+330    	; 0x13b6 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_64) {
    126c:	8b 81       	ldd	r24, Y+3	; 0x03
    126e:	83 30       	cpi	r24, 0x03	; 3
    1270:	19 f5       	brne	.+70     	; 0x12b8 <MCAL_Timer0_Init+0x1d8>
		SET_BIT(TCCR0, 0);
    1272:	a3 e5       	ldi	r26, 0x53	; 83
    1274:	b0 e0       	ldi	r27, 0x00	; 0
    1276:	e3 e5       	ldi	r30, 0x53	; 83
    1278:	f0 e0       	ldi	r31, 0x00	; 0
    127a:	80 81       	ld	r24, Z
    127c:	81 60       	ori	r24, 0x01	; 1
    127e:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    1280:	a3 e5       	ldi	r26, 0x53	; 83
    1282:	b0 e0       	ldi	r27, 0x00	; 0
    1284:	e3 e5       	ldi	r30, 0x53	; 83
    1286:	f0 e0       	ldi	r31, 0x00	; 0
    1288:	80 81       	ld	r24, Z
    128a:	82 60       	ori	r24, 0x02	; 2
    128c:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 2);
    128e:	a3 e5       	ldi	r26, 0x53	; 83
    1290:	b0 e0       	ldi	r27, 0x00	; 0
    1292:	e3 e5       	ldi	r30, 0x53	; 83
    1294:	f0 e0       	ldi	r31, 0x00	; 0
    1296:	80 81       	ld	r24, Z
    1298:	8b 7f       	andi	r24, 0xFB	; 251
    129a:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller64_Value / (f32) CPU_Frequancy;
    129c:	8d eb       	ldi	r24, 0xBD	; 189
    129e:	97 e3       	ldi	r25, 0x37	; 55
    12a0:	a6 e8       	ldi	r26, 0x86	; 134
    12a2:	b6 e3       	ldi	r27, 0x36	; 54
    12a4:	80 93 21 06 	sts	0x0621, r24
    12a8:	90 93 22 06 	sts	0x0622, r25
    12ac:	a0 93 23 06 	sts	0x0623, r26
    12b0:	b0 93 24 06 	sts	0x0624, r27
		LOC_u8ReturnValue = E_OK;
    12b4:	19 82       	std	Y+1, r1	; 0x01
    12b6:	7f c0       	rjmp	.+254    	; 0x13b6 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_256) {
    12b8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ba:	84 30       	cpi	r24, 0x04	; 4
    12bc:	19 f5       	brne	.+70     	; 0x1304 <MCAL_Timer0_Init+0x224>
		CLR_BIT(TCCR0, 0);
    12be:	a3 e5       	ldi	r26, 0x53	; 83
    12c0:	b0 e0       	ldi	r27, 0x00	; 0
    12c2:	e3 e5       	ldi	r30, 0x53	; 83
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	80 81       	ld	r24, Z
    12c8:	8e 7f       	andi	r24, 0xFE	; 254
    12ca:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    12cc:	a3 e5       	ldi	r26, 0x53	; 83
    12ce:	b0 e0       	ldi	r27, 0x00	; 0
    12d0:	e3 e5       	ldi	r30, 0x53	; 83
    12d2:	f0 e0       	ldi	r31, 0x00	; 0
    12d4:	80 81       	ld	r24, Z
    12d6:	8d 7f       	andi	r24, 0xFD	; 253
    12d8:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    12da:	a3 e5       	ldi	r26, 0x53	; 83
    12dc:	b0 e0       	ldi	r27, 0x00	; 0
    12de:	e3 e5       	ldi	r30, 0x53	; 83
    12e0:	f0 e0       	ldi	r31, 0x00	; 0
    12e2:	80 81       	ld	r24, Z
    12e4:	84 60       	ori	r24, 0x04	; 4
    12e6:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller256_Value / (f32) CPU_Frequancy;
    12e8:	8d eb       	ldi	r24, 0xBD	; 189
    12ea:	97 e3       	ldi	r25, 0x37	; 55
    12ec:	a6 e8       	ldi	r26, 0x86	; 134
    12ee:	b7 e3       	ldi	r27, 0x37	; 55
    12f0:	80 93 21 06 	sts	0x0621, r24
    12f4:	90 93 22 06 	sts	0x0622, r25
    12f8:	a0 93 23 06 	sts	0x0623, r26
    12fc:	b0 93 24 06 	sts	0x0624, r27
		LOC_u8ReturnValue = E_OK;
    1300:	19 82       	std	Y+1, r1	; 0x01
    1302:	59 c0       	rjmp	.+178    	; 0x13b6 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Prescaller_1024) {
    1304:	8b 81       	ldd	r24, Y+3	; 0x03
    1306:	85 30       	cpi	r24, 0x05	; 5
    1308:	19 f5       	brne	.+70     	; 0x1350 <MCAL_Timer0_Init+0x270>
		SET_BIT(TCCR0, 0);
    130a:	a3 e5       	ldi	r26, 0x53	; 83
    130c:	b0 e0       	ldi	r27, 0x00	; 0
    130e:	e3 e5       	ldi	r30, 0x53	; 83
    1310:	f0 e0       	ldi	r31, 0x00	; 0
    1312:	80 81       	ld	r24, Z
    1314:	81 60       	ori	r24, 0x01	; 1
    1316:	8c 93       	st	X, r24
		CLR_BIT(TCCR0, 1);
    1318:	a3 e5       	ldi	r26, 0x53	; 83
    131a:	b0 e0       	ldi	r27, 0x00	; 0
    131c:	e3 e5       	ldi	r30, 0x53	; 83
    131e:	f0 e0       	ldi	r31, 0x00	; 0
    1320:	80 81       	ld	r24, Z
    1322:	8d 7f       	andi	r24, 0xFD	; 253
    1324:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    1326:	a3 e5       	ldi	r26, 0x53	; 83
    1328:	b0 e0       	ldi	r27, 0x00	; 0
    132a:	e3 e5       	ldi	r30, 0x53	; 83
    132c:	f0 e0       	ldi	r31, 0x00	; 0
    132e:	80 81       	ld	r24, Z
    1330:	84 60       	ori	r24, 0x04	; 4
    1332:	8c 93       	st	X, r24
		Glob_TickTime = Prescaller1024_Value / (f32) CPU_Frequancy;
    1334:	8d eb       	ldi	r24, 0xBD	; 189
    1336:	97 e3       	ldi	r25, 0x37	; 55
    1338:	a6 e8       	ldi	r26, 0x86	; 134
    133a:	b8 e3       	ldi	r27, 0x38	; 56
    133c:	80 93 21 06 	sts	0x0621, r24
    1340:	90 93 22 06 	sts	0x0622, r25
    1344:	a0 93 23 06 	sts	0x0623, r26
    1348:	b0 93 24 06 	sts	0x0624, r27
		LOC_u8ReturnValue = E_OK;
    134c:	19 82       	std	Y+1, r1	; 0x01
    134e:	33 c0       	rjmp	.+102    	; 0x13b6 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Clock_on_falling_edge) {
    1350:	8b 81       	ldd	r24, Y+3	; 0x03
    1352:	86 30       	cpi	r24, 0x06	; 6
    1354:	b9 f4       	brne	.+46     	; 0x1384 <MCAL_Timer0_Init+0x2a4>
		CLR_BIT(TCCR0, 0);
    1356:	a3 e5       	ldi	r26, 0x53	; 83
    1358:	b0 e0       	ldi	r27, 0x00	; 0
    135a:	e3 e5       	ldi	r30, 0x53	; 83
    135c:	f0 e0       	ldi	r31, 0x00	; 0
    135e:	80 81       	ld	r24, Z
    1360:	8e 7f       	andi	r24, 0xFE	; 254
    1362:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    1364:	a3 e5       	ldi	r26, 0x53	; 83
    1366:	b0 e0       	ldi	r27, 0x00	; 0
    1368:	e3 e5       	ldi	r30, 0x53	; 83
    136a:	f0 e0       	ldi	r31, 0x00	; 0
    136c:	80 81       	ld	r24, Z
    136e:	82 60       	ori	r24, 0x02	; 2
    1370:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    1372:	a3 e5       	ldi	r26, 0x53	; 83
    1374:	b0 e0       	ldi	r27, 0x00	; 0
    1376:	e3 e5       	ldi	r30, 0x53	; 83
    1378:	f0 e0       	ldi	r31, 0x00	; 0
    137a:	80 81       	ld	r24, Z
    137c:	84 60       	ori	r24, 0x04	; 4
    137e:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    1380:	19 82       	std	Y+1, r1	; 0x01
    1382:	19 c0       	rjmp	.+50     	; 0x13b6 <MCAL_Timer0_Init+0x2d6>
	} else if (Loc_u8Prescaller == Clock_on_rising_edge) {
    1384:	8b 81       	ldd	r24, Y+3	; 0x03
    1386:	87 30       	cpi	r24, 0x07	; 7
    1388:	b1 f4       	brne	.+44     	; 0x13b6 <MCAL_Timer0_Init+0x2d6>
		SET_BIT(TCCR0, 0);
    138a:	a3 e5       	ldi	r26, 0x53	; 83
    138c:	b0 e0       	ldi	r27, 0x00	; 0
    138e:	e3 e5       	ldi	r30, 0x53	; 83
    1390:	f0 e0       	ldi	r31, 0x00	; 0
    1392:	80 81       	ld	r24, Z
    1394:	81 60       	ori	r24, 0x01	; 1
    1396:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 1);
    1398:	a3 e5       	ldi	r26, 0x53	; 83
    139a:	b0 e0       	ldi	r27, 0x00	; 0
    139c:	e3 e5       	ldi	r30, 0x53	; 83
    139e:	f0 e0       	ldi	r31, 0x00	; 0
    13a0:	80 81       	ld	r24, Z
    13a2:	82 60       	ori	r24, 0x02	; 2
    13a4:	8c 93       	st	X, r24
		SET_BIT(TCCR0, 2);
    13a6:	a3 e5       	ldi	r26, 0x53	; 83
    13a8:	b0 e0       	ldi	r27, 0x00	; 0
    13aa:	e3 e5       	ldi	r30, 0x53	; 83
    13ac:	f0 e0       	ldi	r31, 0x00	; 0
    13ae:	80 81       	ld	r24, Z
    13b0:	84 60       	ori	r24, 0x04	; 4
    13b2:	8c 93       	st	X, r24
		LOC_u8ReturnValue = E_OK;
    13b4:	19 82       	std	Y+1, r1	; 0x01
	} else {
		//NOTHING
	}
	if (Loc_u8OC0Mode == Disconnected) {
    13b6:	8c 81       	ldd	r24, Y+4	; 0x04
    13b8:	88 23       	and	r24, r24
    13ba:	79 f4       	brne	.+30     	; 0x13da <MCAL_Timer0_Init+0x2fa>
			CLR_BIT(TCCR0, 4);
    13bc:	a3 e5       	ldi	r26, 0x53	; 83
    13be:	b0 e0       	ldi	r27, 0x00	; 0
    13c0:	e3 e5       	ldi	r30, 0x53	; 83
    13c2:	f0 e0       	ldi	r31, 0x00	; 0
    13c4:	80 81       	ld	r24, Z
    13c6:	8f 7e       	andi	r24, 0xEF	; 239
    13c8:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 5);
    13ca:	a3 e5       	ldi	r26, 0x53	; 83
    13cc:	b0 e0       	ldi	r27, 0x00	; 0
    13ce:	e3 e5       	ldi	r30, 0x53	; 83
    13d0:	f0 e0       	ldi	r31, 0x00	; 0
    13d2:	80 81       	ld	r24, Z
    13d4:	8f 7d       	andi	r24, 0xDF	; 223
    13d6:	8c 93       	st	X, r24
    13d8:	43 c0       	rjmp	.+134    	; 0x1460 <MCAL_Timer0_Init+0x380>
		} else if (Loc_u8OC0Mode == Reserved) {
    13da:	8c 81       	ldd	r24, Y+4	; 0x04
    13dc:	81 30       	cpi	r24, 0x01	; 1
    13de:	79 f4       	brne	.+30     	; 0x13fe <MCAL_Timer0_Init+0x31e>
			SET_BIT(TCCR0, 4);
    13e0:	a3 e5       	ldi	r26, 0x53	; 83
    13e2:	b0 e0       	ldi	r27, 0x00	; 0
    13e4:	e3 e5       	ldi	r30, 0x53	; 83
    13e6:	f0 e0       	ldi	r31, 0x00	; 0
    13e8:	80 81       	ld	r24, Z
    13ea:	80 61       	ori	r24, 0x10	; 16
    13ec:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 5);
    13ee:	a3 e5       	ldi	r26, 0x53	; 83
    13f0:	b0 e0       	ldi	r27, 0x00	; 0
    13f2:	e3 e5       	ldi	r30, 0x53	; 83
    13f4:	f0 e0       	ldi	r31, 0x00	; 0
    13f6:	80 81       	ld	r24, Z
    13f8:	8f 7d       	andi	r24, 0xDF	; 223
    13fa:	8c 93       	st	X, r24
    13fc:	31 c0       	rjmp	.+98     	; 0x1460 <MCAL_Timer0_Init+0x380>
			//PWM, Fast PWM
		} else if (Loc_u8OC0Mode == Non_Inverted) {
    13fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1400:	82 30       	cpi	r24, 0x02	; 2
    1402:	b1 f4       	brne	.+44     	; 0x1430 <MCAL_Timer0_Init+0x350>
			SET_BIT(TCCR0, 5);
    1404:	a3 e5       	ldi	r26, 0x53	; 83
    1406:	b0 e0       	ldi	r27, 0x00	; 0
    1408:	e3 e5       	ldi	r30, 0x53	; 83
    140a:	f0 e0       	ldi	r31, 0x00	; 0
    140c:	80 81       	ld	r24, Z
    140e:	80 62       	ori	r24, 0x20	; 32
    1410:	8c 93       	st	X, r24
			CLR_BIT(TCCR0, 4);
    1412:	a3 e5       	ldi	r26, 0x53	; 83
    1414:	b0 e0       	ldi	r27, 0x00	; 0
    1416:	e3 e5       	ldi	r30, 0x53	; 83
    1418:	f0 e0       	ldi	r31, 0x00	; 0
    141a:	80 81       	ld	r24, Z
    141c:	8f 7e       	andi	r24, 0xEF	; 239
    141e:	8c 93       	st	X, r24
			// OC0
			SET_BIT(DDRB, 3);
    1420:	a7 e3       	ldi	r26, 0x37	; 55
    1422:	b0 e0       	ldi	r27, 0x00	; 0
    1424:	e7 e3       	ldi	r30, 0x37	; 55
    1426:	f0 e0       	ldi	r31, 0x00	; 0
    1428:	80 81       	ld	r24, Z
    142a:	88 60       	ori	r24, 0x08	; 8
    142c:	8c 93       	st	X, r24
    142e:	18 c0       	rjmp	.+48     	; 0x1460 <MCAL_Timer0_Init+0x380>
			//PWM, Fast PWM
		} else if (Loc_u8OC0Mode == Inverted) {
    1430:	8c 81       	ldd	r24, Y+4	; 0x04
    1432:	83 30       	cpi	r24, 0x03	; 3
    1434:	a9 f4       	brne	.+42     	; 0x1460 <MCAL_Timer0_Init+0x380>
			SET_BIT(TCCR0, 4);
    1436:	a3 e5       	ldi	r26, 0x53	; 83
    1438:	b0 e0       	ldi	r27, 0x00	; 0
    143a:	e3 e5       	ldi	r30, 0x53	; 83
    143c:	f0 e0       	ldi	r31, 0x00	; 0
    143e:	80 81       	ld	r24, Z
    1440:	80 61       	ori	r24, 0x10	; 16
    1442:	8c 93       	st	X, r24
			SET_BIT(TCCR0, 5);
    1444:	a3 e5       	ldi	r26, 0x53	; 83
    1446:	b0 e0       	ldi	r27, 0x00	; 0
    1448:	e3 e5       	ldi	r30, 0x53	; 83
    144a:	f0 e0       	ldi	r31, 0x00	; 0
    144c:	80 81       	ld	r24, Z
    144e:	80 62       	ori	r24, 0x20	; 32
    1450:	8c 93       	st	X, r24
			// OC0
			SET_BIT(DDRB, 3);
    1452:	a7 e3       	ldi	r26, 0x37	; 55
    1454:	b0 e0       	ldi	r27, 0x00	; 0
    1456:	e7 e3       	ldi	r30, 0x37	; 55
    1458:	f0 e0       	ldi	r31, 0x00	; 0
    145a:	80 81       	ld	r24, Z
    145c:	88 60       	ori	r24, 0x08	; 8
    145e:	8c 93       	st	X, r24
		}
}
    1460:	0f 90       	pop	r0
    1462:	0f 90       	pop	r0
    1464:	0f 90       	pop	r0
    1466:	0f 90       	pop	r0
    1468:	cf 91       	pop	r28
    146a:	df 91       	pop	r29
    146c:	08 95       	ret

0000146e <MCAL_Timer0_SetPreloadValue>:
void MCAL_Timer0_SetPreloadValue(u8 Loc_u8Value) {
    146e:	df 93       	push	r29
    1470:	cf 93       	push	r28
    1472:	0f 92       	push	r0
    1474:	cd b7       	in	r28, 0x3d	; 61
    1476:	de b7       	in	r29, 0x3e	; 62
    1478:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = Loc_u8Value;
    147a:	e2 e5       	ldi	r30, 0x52	; 82
    147c:	f0 e0       	ldi	r31, 0x00	; 0
    147e:	89 81       	ldd	r24, Y+1	; 0x01
    1480:	80 83       	st	Z, r24
}
    1482:	0f 90       	pop	r0
    1484:	cf 91       	pop	r28
    1486:	df 91       	pop	r29
    1488:	08 95       	ret

0000148a <MCAL_Timer0_SetCompareValue>:
void MCAL_Timer0_SetCompareValue(u8 Loc_u8Value) {
    148a:	df 93       	push	r29
    148c:	cf 93       	push	r28
    148e:	0f 92       	push	r0
    1490:	cd b7       	in	r28, 0x3d	; 61
    1492:	de b7       	in	r29, 0x3e	; 62
    1494:	89 83       	std	Y+1, r24	; 0x01
	OCR0 = Loc_u8Value;
    1496:	ec e5       	ldi	r30, 0x5C	; 92
    1498:	f0 e0       	ldi	r31, 0x00	; 0
    149a:	89 81       	ldd	r24, Y+1	; 0x01
    149c:	80 83       	st	Z, r24
}
    149e:	0f 90       	pop	r0
    14a0:	cf 91       	pop	r28
    14a2:	df 91       	pop	r29
    14a4:	08 95       	ret

000014a6 <MCAL_Timer0_EnableNormalMode>:
void MCAL_Timer0_EnableNormalMode() {
    14a6:	df 93       	push	r29
    14a8:	cf 93       	push	r28
    14aa:	cd b7       	in	r28, 0x3d	; 61
    14ac:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK, 0);
    14ae:	a9 e5       	ldi	r26, 0x59	; 89
    14b0:	b0 e0       	ldi	r27, 0x00	; 0
    14b2:	e9 e5       	ldi	r30, 0x59	; 89
    14b4:	f0 e0       	ldi	r31, 0x00	; 0
    14b6:	80 81       	ld	r24, Z
    14b8:	81 60       	ori	r24, 0x01	; 1
    14ba:	8c 93       	st	X, r24
}
    14bc:	cf 91       	pop	r28
    14be:	df 91       	pop	r29
    14c0:	08 95       	ret

000014c2 <MCAL_Timer0_DisableNormalMode>:
void MCAL_Timer0_DisableNormalMode() {
    14c2:	df 93       	push	r29
    14c4:	cf 93       	push	r28
    14c6:	cd b7       	in	r28, 0x3d	; 61
    14c8:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, 0);
    14ca:	a9 e5       	ldi	r26, 0x59	; 89
    14cc:	b0 e0       	ldi	r27, 0x00	; 0
    14ce:	e9 e5       	ldi	r30, 0x59	; 89
    14d0:	f0 e0       	ldi	r31, 0x00	; 0
    14d2:	80 81       	ld	r24, Z
    14d4:	8e 7f       	andi	r24, 0xFE	; 254
    14d6:	8c 93       	st	X, r24
}
    14d8:	cf 91       	pop	r28
    14da:	df 91       	pop	r29
    14dc:	08 95       	ret

000014de <MCAL_Timer0_EnableCTCMode>:
void MCAL_Timer0_EnableCTCMode() {
    14de:	df 93       	push	r29
    14e0:	cf 93       	push	r28
    14e2:	cd b7       	in	r28, 0x3d	; 61
    14e4:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK, 1);
    14e6:	a9 e5       	ldi	r26, 0x59	; 89
    14e8:	b0 e0       	ldi	r27, 0x00	; 0
    14ea:	e9 e5       	ldi	r30, 0x59	; 89
    14ec:	f0 e0       	ldi	r31, 0x00	; 0
    14ee:	80 81       	ld	r24, Z
    14f0:	82 60       	ori	r24, 0x02	; 2
    14f2:	8c 93       	st	X, r24
}
    14f4:	cf 91       	pop	r28
    14f6:	df 91       	pop	r29
    14f8:	08 95       	ret

000014fa <MCAL_Timer0_DisableCTCMode>:
void MCAL_Timer0_DisableCTCMode() {
    14fa:	df 93       	push	r29
    14fc:	cf 93       	push	r28
    14fe:	cd b7       	in	r28, 0x3d	; 61
    1500:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK, 1);
    1502:	a9 e5       	ldi	r26, 0x59	; 89
    1504:	b0 e0       	ldi	r27, 0x00	; 0
    1506:	e9 e5       	ldi	r30, 0x59	; 89
    1508:	f0 e0       	ldi	r31, 0x00	; 0
    150a:	80 81       	ld	r24, Z
    150c:	8d 7f       	andi	r24, 0xFD	; 253
    150e:	8c 93       	st	X, r24
}
    1510:	cf 91       	pop	r28
    1512:	df 91       	pop	r29
    1514:	08 95       	ret

00001516 <MCAL_Timer0_Delayms_NormalMode>:

void MCAL_Timer0_Delayms_NormalMode(u32 Loc_u32MilliSeconds) {
    1516:	df 93       	push	r29
    1518:	cf 93       	push	r28
    151a:	cd b7       	in	r28, 0x3d	; 61
    151c:	de b7       	in	r29, 0x3e	; 62
    151e:	28 97       	sbiw	r28, 0x08	; 8
    1520:	0f b6       	in	r0, 0x3f	; 63
    1522:	f8 94       	cli
    1524:	de bf       	out	0x3e, r29	; 62
    1526:	0f be       	out	0x3f, r0	; 63
    1528:	cd bf       	out	0x3d, r28	; 61
    152a:	6d 83       	std	Y+5, r22	; 0x05
    152c:	7e 83       	std	Y+6, r23	; 0x06
    152e:	8f 83       	std	Y+7, r24	; 0x07
    1530:	98 87       	std	Y+8, r25	; 0x08
	u32 N = 0;
    1532:	19 82       	std	Y+1, r1	; 0x01
    1534:	1a 82       	std	Y+2, r1	; 0x02
    1536:	1b 82       	std	Y+3, r1	; 0x03
    1538:	1c 82       	std	Y+4, r1	; 0x04
	N = (Loc_u32MilliSeconds / 1000.0) / (f32) Glob_TickTime;
    153a:	6d 81       	ldd	r22, Y+5	; 0x05
    153c:	7e 81       	ldd	r23, Y+6	; 0x06
    153e:	8f 81       	ldd	r24, Y+7	; 0x07
    1540:	98 85       	ldd	r25, Y+8	; 0x08
    1542:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1546:	dc 01       	movw	r26, r24
    1548:	cb 01       	movw	r24, r22
    154a:	bc 01       	movw	r22, r24
    154c:	cd 01       	movw	r24, r26
    154e:	20 e0       	ldi	r18, 0x00	; 0
    1550:	30 e0       	ldi	r19, 0x00	; 0
    1552:	4a e7       	ldi	r20, 0x7A	; 122
    1554:	54 e4       	ldi	r21, 0x44	; 68
    1556:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    155a:	dc 01       	movw	r26, r24
    155c:	cb 01       	movw	r24, r22
    155e:	20 91 21 06 	lds	r18, 0x0621
    1562:	30 91 22 06 	lds	r19, 0x0622
    1566:	40 91 23 06 	lds	r20, 0x0623
    156a:	50 91 24 06 	lds	r21, 0x0624
    156e:	bc 01       	movw	r22, r24
    1570:	cd 01       	movw	r24, r26
    1572:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1576:	dc 01       	movw	r26, r24
    1578:	cb 01       	movw	r24, r22
    157a:	bc 01       	movw	r22, r24
    157c:	cd 01       	movw	r24, r26
    157e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1582:	dc 01       	movw	r26, r24
    1584:	cb 01       	movw	r24, r22
    1586:	89 83       	std	Y+1, r24	; 0x01
    1588:	9a 83       	std	Y+2, r25	; 0x02
    158a:	ab 83       	std	Y+3, r26	; 0x03
    158c:	bc 83       	std	Y+4, r27	; 0x04
	Start = N % 256;
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	9a 81       	ldd	r25, Y+2	; 0x02
    1592:	90 70       	andi	r25, 0x00	; 0
    1594:	90 93 87 01 	sts	0x0187, r25
    1598:	80 93 86 01 	sts	0x0186, r24
	if (Start == 0) {
    159c:	80 91 86 01 	lds	r24, 0x0186
    15a0:	90 91 87 01 	lds	r25, 0x0187
    15a4:	00 97       	sbiw	r24, 0x00	; 0
    15a6:	99 f4       	brne	.+38     	; 0x15ce <MCAL_Timer0_Delayms_NormalMode+0xb8>
		MCAL_Timer0_SetPreloadValue(Start);
    15a8:	80 91 86 01 	lds	r24, 0x0186
    15ac:	90 91 87 01 	lds	r25, 0x0187
    15b0:	0e 94 37 0a 	call	0x146e	; 0x146e <MCAL_Timer0_SetPreloadValue>
		Counter = N / 256;
    15b4:	89 81       	ldd	r24, Y+1	; 0x01
    15b6:	9a 81       	ldd	r25, Y+2	; 0x02
    15b8:	ab 81       	ldd	r26, Y+3	; 0x03
    15ba:	bc 81       	ldd	r27, Y+4	; 0x04
    15bc:	89 2f       	mov	r24, r25
    15be:	9a 2f       	mov	r25, r26
    15c0:	ab 2f       	mov	r26, r27
    15c2:	bb 27       	eor	r27, r27
    15c4:	90 93 89 01 	sts	0x0189, r25
    15c8:	80 93 88 01 	sts	0x0188, r24
    15cc:	19 c0       	rjmp	.+50     	; 0x1600 <MCAL_Timer0_Delayms_NormalMode+0xea>
	} else if (Start != 0) {
    15ce:	80 91 86 01 	lds	r24, 0x0186
    15d2:	90 91 87 01 	lds	r25, 0x0187
    15d6:	00 97       	sbiw	r24, 0x00	; 0
    15d8:	99 f0       	breq	.+38     	; 0x1600 <MCAL_Timer0_Delayms_NormalMode+0xea>
		MCAL_Timer0_SetPreloadValue(Start);
    15da:	80 91 86 01 	lds	r24, 0x0186
    15de:	90 91 87 01 	lds	r25, 0x0187
    15e2:	0e 94 37 0a 	call	0x146e	; 0x146e <MCAL_Timer0_SetPreloadValue>
		Counter = ((N / 256) + 1);
    15e6:	89 81       	ldd	r24, Y+1	; 0x01
    15e8:	9a 81       	ldd	r25, Y+2	; 0x02
    15ea:	ab 81       	ldd	r26, Y+3	; 0x03
    15ec:	bc 81       	ldd	r27, Y+4	; 0x04
    15ee:	89 2f       	mov	r24, r25
    15f0:	9a 2f       	mov	r25, r26
    15f2:	ab 2f       	mov	r26, r27
    15f4:	bb 27       	eor	r27, r27
    15f6:	01 96       	adiw	r24, 0x01	; 1
    15f8:	90 93 89 01 	sts	0x0189, r25
    15fc:	80 93 88 01 	sts	0x0188, r24
	} else {
		//NOTHING
	}
}
    1600:	28 96       	adiw	r28, 0x08	; 8
    1602:	0f b6       	in	r0, 0x3f	; 63
    1604:	f8 94       	cli
    1606:	de bf       	out	0x3e, r29	; 62
    1608:	0f be       	out	0x3f, r0	; 63
    160a:	cd bf       	out	0x3d, r28	; 61
    160c:	cf 91       	pop	r28
    160e:	df 91       	pop	r29
    1610:	08 95       	ret

00001612 <MCAL_Timer0_Delayms_CTCMode>:
void MCAL_Timer0_Delayms_CTCMode(u32 Loc_u32MilliSeconds) {
    1612:	df 93       	push	r29
    1614:	cf 93       	push	r28
    1616:	cd b7       	in	r28, 0x3d	; 61
    1618:	de b7       	in	r29, 0x3e	; 62
    161a:	29 97       	sbiw	r28, 0x09	; 9
    161c:	0f b6       	in	r0, 0x3f	; 63
    161e:	f8 94       	cli
    1620:	de bf       	out	0x3e, r29	; 62
    1622:	0f be       	out	0x3f, r0	; 63
    1624:	cd bf       	out	0x3d, r28	; 61
    1626:	6e 83       	std	Y+6, r22	; 0x06
    1628:	7f 83       	std	Y+7, r23	; 0x07
    162a:	88 87       	std	Y+8, r24	; 0x08
    162c:	99 87       	std	Y+9, r25	; 0x09
	u8 LOC_u8ReturnValue = E_NOT_OK;
    162e:	81 e0       	ldi	r24, 0x01	; 1
    1630:	8d 83       	std	Y+5, r24	; 0x05
	f32 N = 0;
    1632:	80 e0       	ldi	r24, 0x00	; 0
    1634:	90 e0       	ldi	r25, 0x00	; 0
    1636:	a0 e0       	ldi	r26, 0x00	; 0
    1638:	b0 e0       	ldi	r27, 0x00	; 0
    163a:	89 83       	std	Y+1, r24	; 0x01
    163c:	9a 83       	std	Y+2, r25	; 0x02
    163e:	ab 83       	std	Y+3, r26	; 0x03
    1640:	bc 83       	std	Y+4, r27	; 0x04
	MCAL_Timer0_SetCompareValue(CompareStartValue);
    1642:	87 ec       	ldi	r24, 0xC7	; 199
    1644:	0e 94 45 0a 	call	0x148a	; 0x148a <MCAL_Timer0_SetCompareValue>
	N = ((CompareStartValue + 1) * Glob_TickTime);
    1648:	80 91 21 06 	lds	r24, 0x0621
    164c:	90 91 22 06 	lds	r25, 0x0622
    1650:	a0 91 23 06 	lds	r26, 0x0623
    1654:	b0 91 24 06 	lds	r27, 0x0624
    1658:	bc 01       	movw	r22, r24
    165a:	cd 01       	movw	r24, r26
    165c:	20 e0       	ldi	r18, 0x00	; 0
    165e:	30 e0       	ldi	r19, 0x00	; 0
    1660:	48 e4       	ldi	r20, 0x48	; 72
    1662:	53 e4       	ldi	r21, 0x43	; 67
    1664:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1668:	dc 01       	movw	r26, r24
    166a:	cb 01       	movw	r24, r22
    166c:	89 83       	std	Y+1, r24	; 0x01
    166e:	9a 83       	std	Y+2, r25	; 0x02
    1670:	ab 83       	std	Y+3, r26	; 0x03
    1672:	bc 83       	std	Y+4, r27	; 0x04
	Counter = ((Loc_u32MilliSeconds/1000.0) / N);
    1674:	6e 81       	ldd	r22, Y+6	; 0x06
    1676:	7f 81       	ldd	r23, Y+7	; 0x07
    1678:	88 85       	ldd	r24, Y+8	; 0x08
    167a:	99 85       	ldd	r25, Y+9	; 0x09
    167c:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1680:	dc 01       	movw	r26, r24
    1682:	cb 01       	movw	r24, r22
    1684:	bc 01       	movw	r22, r24
    1686:	cd 01       	movw	r24, r26
    1688:	20 e0       	ldi	r18, 0x00	; 0
    168a:	30 e0       	ldi	r19, 0x00	; 0
    168c:	4a e7       	ldi	r20, 0x7A	; 122
    168e:	54 e4       	ldi	r21, 0x44	; 68
    1690:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1694:	dc 01       	movw	r26, r24
    1696:	cb 01       	movw	r24, r22
    1698:	bc 01       	movw	r22, r24
    169a:	cd 01       	movw	r24, r26
    169c:	29 81       	ldd	r18, Y+1	; 0x01
    169e:	3a 81       	ldd	r19, Y+2	; 0x02
    16a0:	4b 81       	ldd	r20, Y+3	; 0x03
    16a2:	5c 81       	ldd	r21, Y+4	; 0x04
    16a4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    16a8:	dc 01       	movw	r26, r24
    16aa:	cb 01       	movw	r24, r22
    16ac:	bc 01       	movw	r22, r24
    16ae:	cd 01       	movw	r24, r26
    16b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16b4:	dc 01       	movw	r26, r24
    16b6:	cb 01       	movw	r24, r22
    16b8:	90 93 89 01 	sts	0x0189, r25
    16bc:	80 93 88 01 	sts	0x0188, r24

	LOC_u8ReturnValue = E_OK;
    16c0:	1d 82       	std	Y+5, r1	; 0x05
}
    16c2:	29 96       	adiw	r28, 0x09	; 9
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	f8 94       	cli
    16c8:	de bf       	out	0x3e, r29	; 62
    16ca:	0f be       	out	0x3f, r0	; 63
    16cc:	cd bf       	out	0x3d, r28	; 61
    16ce:	cf 91       	pop	r28
    16d0:	df 91       	pop	r29
    16d2:	08 95       	ret

000016d4 <MCAL_Timer0_CallBack>:

void MCAL_Timer0_CallBack(void (*ptr)(void)) {
    16d4:	df 93       	push	r29
    16d6:	cf 93       	push	r28
    16d8:	00 d0       	rcall	.+0      	; 0x16da <MCAL_Timer0_CallBack+0x6>
    16da:	cd b7       	in	r28, 0x3d	; 61
    16dc:	de b7       	in	r29, 0x3e	; 62
    16de:	9a 83       	std	Y+2, r25	; 0x02
    16e0:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    16e2:	89 81       	ldd	r24, Y+1	; 0x01
    16e4:	9a 81       	ldd	r25, Y+2	; 0x02
    16e6:	00 97       	sbiw	r24, 0x00	; 0
    16e8:	31 f0       	breq	.+12     	; 0x16f6 <MCAL_Timer0_CallBack+0x22>
		Gptr3 = ptr;
    16ea:	89 81       	ldd	r24, Y+1	; 0x01
    16ec:	9a 81       	ldd	r25, Y+2	; 0x02
    16ee:	90 93 85 01 	sts	0x0185, r25
    16f2:	80 93 84 01 	sts	0x0184, r24
}
    16f6:	0f 90       	pop	r0
    16f8:	0f 90       	pop	r0
    16fa:	cf 91       	pop	r28
    16fc:	df 91       	pop	r29
    16fe:	08 95       	ret

00001700 <__vector_11>:

ISR(TIMER0_OVF_vect) {
    1700:	1f 92       	push	r1
    1702:	0f 92       	push	r0
    1704:	0f b6       	in	r0, 0x3f	; 63
    1706:	0f 92       	push	r0
    1708:	11 24       	eor	r1, r1
    170a:	2f 93       	push	r18
    170c:	3f 93       	push	r19
    170e:	4f 93       	push	r20
    1710:	5f 93       	push	r21
    1712:	6f 93       	push	r22
    1714:	7f 93       	push	r23
    1716:	8f 93       	push	r24
    1718:	9f 93       	push	r25
    171a:	af 93       	push	r26
    171c:	bf 93       	push	r27
    171e:	ef 93       	push	r30
    1720:	ff 93       	push	r31
    1722:	df 93       	push	r29
    1724:	cf 93       	push	r28
    1726:	cd b7       	in	r28, 0x3d	; 61
    1728:	de b7       	in	r29, 0x3e	; 62
	if (Gptr3 != '\0')
    172a:	80 91 84 01 	lds	r24, 0x0184
    172e:	90 91 85 01 	lds	r25, 0x0185
    1732:	00 97       	sbiw	r24, 0x00	; 0
    1734:	29 f0       	breq	.+10     	; 0x1740 <__vector_11+0x40>
		Gptr3();
    1736:	e0 91 84 01 	lds	r30, 0x0184
    173a:	f0 91 85 01 	lds	r31, 0x0185
    173e:	09 95       	icall
	OvfCounter++;
    1740:	80 91 82 01 	lds	r24, 0x0182
    1744:	90 91 83 01 	lds	r25, 0x0183
    1748:	01 96       	adiw	r24, 0x01	; 1
    174a:	90 93 83 01 	sts	0x0183, r25
    174e:	80 93 82 01 	sts	0x0182, r24
}
    1752:	cf 91       	pop	r28
    1754:	df 91       	pop	r29
    1756:	ff 91       	pop	r31
    1758:	ef 91       	pop	r30
    175a:	bf 91       	pop	r27
    175c:	af 91       	pop	r26
    175e:	9f 91       	pop	r25
    1760:	8f 91       	pop	r24
    1762:	7f 91       	pop	r23
    1764:	6f 91       	pop	r22
    1766:	5f 91       	pop	r21
    1768:	4f 91       	pop	r20
    176a:	3f 91       	pop	r19
    176c:	2f 91       	pop	r18
    176e:	0f 90       	pop	r0
    1770:	0f be       	out	0x3f, r0	; 63
    1772:	0f 90       	pop	r0
    1774:	1f 90       	pop	r1
    1776:	18 95       	reti

00001778 <__vector_10>:
ISR(TIMER0_COMP_vect) {
    1778:	1f 92       	push	r1
    177a:	0f 92       	push	r0
    177c:	0f b6       	in	r0, 0x3f	; 63
    177e:	0f 92       	push	r0
    1780:	11 24       	eor	r1, r1
    1782:	2f 93       	push	r18
    1784:	3f 93       	push	r19
    1786:	4f 93       	push	r20
    1788:	5f 93       	push	r21
    178a:	6f 93       	push	r22
    178c:	7f 93       	push	r23
    178e:	8f 93       	push	r24
    1790:	9f 93       	push	r25
    1792:	af 93       	push	r26
    1794:	bf 93       	push	r27
    1796:	ef 93       	push	r30
    1798:	ff 93       	push	r31
    179a:	df 93       	push	r29
    179c:	cf 93       	push	r28
    179e:	cd b7       	in	r28, 0x3d	; 61
    17a0:	de b7       	in	r29, 0x3e	; 62
	if (Gptr3 != '\0')
    17a2:	80 91 84 01 	lds	r24, 0x0184
    17a6:	90 91 85 01 	lds	r25, 0x0185
    17aa:	00 97       	sbiw	r24, 0x00	; 0
    17ac:	29 f0       	breq	.+10     	; 0x17b8 <__vector_10+0x40>
		Gptr3();
    17ae:	e0 91 84 01 	lds	r30, 0x0184
    17b2:	f0 91 85 01 	lds	r31, 0x0185
    17b6:	09 95       	icall
}
    17b8:	cf 91       	pop	r28
    17ba:	df 91       	pop	r29
    17bc:	ff 91       	pop	r31
    17be:	ef 91       	pop	r30
    17c0:	bf 91       	pop	r27
    17c2:	af 91       	pop	r26
    17c4:	9f 91       	pop	r25
    17c6:	8f 91       	pop	r24
    17c8:	7f 91       	pop	r23
    17ca:	6f 91       	pop	r22
    17cc:	5f 91       	pop	r21
    17ce:	4f 91       	pop	r20
    17d0:	3f 91       	pop	r19
    17d2:	2f 91       	pop	r18
    17d4:	0f 90       	pop	r0
    17d6:	0f be       	out	0x3f, r0	; 63
    17d8:	0f 90       	pop	r0
    17da:	1f 90       	pop	r1
    17dc:	18 95       	reti

000017de <MCAL_TWI_Master_Init>:
 */

#include "TWI.h"

// Master
void MCAL_TWI_Master_Init(void) {
    17de:	df 93       	push	r29
    17e0:	cf 93       	push	r28
    17e2:	cd b7       	in	r28, 0x3d	; 61
    17e4:	de b7       	in	r29, 0x3e	; 62
	//Enable TWI
	SET_BIT(TWCR, Pin2);
    17e6:	a6 e5       	ldi	r26, 0x56	; 86
    17e8:	b0 e0       	ldi	r27, 0x00	; 0
    17ea:	e6 e5       	ldi	r30, 0x56	; 86
    17ec:	f0 e0       	ldi	r31, 0x00	; 0
    17ee:	80 81       	ld	r24, Z
    17f0:	84 60       	ori	r24, 0x04	; 4
    17f2:	8c 93       	st	X, r24
	//Enable ACK
	SET_BIT(TWCR, Pin6);
    17f4:	a6 e5       	ldi	r26, 0x56	; 86
    17f6:	b0 e0       	ldi	r27, 0x00	; 0
    17f8:	e6 e5       	ldi	r30, 0x56	; 86
    17fa:	f0 e0       	ldi	r31, 0x00	; 0
    17fc:	80 81       	ld	r24, Z
    17fe:	80 64       	ori	r24, 0x40	; 64
    1800:	8c 93       	st	X, r24
	//Bit Rate
	TWBR = Bit_Rate;
    1802:	e0 e2       	ldi	r30, 0x20	; 32
    1804:	f0 e0       	ldi	r31, 0x00	; 0
    1806:	88 e9       	ldi	r24, 0x98	; 152
    1808:	80 83       	st	Z, r24
}
    180a:	cf 91       	pop	r28
    180c:	df 91       	pop	r29
    180e:	08 95       	ret

00001810 <MCAL_TWI_Master_SendStartCondition>:

void MCAL_TWI_Master_SendStartCondition(void) {
    1810:	df 93       	push	r29
    1812:	cf 93       	push	r28
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
	// Enable Start
	SET_BIT(TWCR, Pin5);
    1818:	a6 e5       	ldi	r26, 0x56	; 86
    181a:	b0 e0       	ldi	r27, 0x00	; 0
    181c:	e6 e5       	ldi	r30, 0x56	; 86
    181e:	f0 e0       	ldi	r31, 0x00	; 0
    1820:	80 81       	ld	r24, Z
    1822:	80 62       	ori	r24, 0x20	; 32
    1824:	8c 93       	st	X, r24
	//CLR Flag
	SET_BIT(TWCR, Pin7);
    1826:	a6 e5       	ldi	r26, 0x56	; 86
    1828:	b0 e0       	ldi	r27, 0x00	; 0
    182a:	e6 e5       	ldi	r30, 0x56	; 86
    182c:	f0 e0       	ldi	r31, 0x00	; 0
    182e:	80 81       	ld	r24, Z
    1830:	80 68       	ori	r24, 0x80	; 128
    1832:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    1834:	e6 e5       	ldi	r30, 0x56	; 86
    1836:	f0 e0       	ldi	r31, 0x00	; 0
    1838:	80 81       	ld	r24, Z
    183a:	88 23       	and	r24, r24
    183c:	dc f7       	brge	.-10     	; 0x1834 <MCAL_TWI_Master_SendStartCondition+0x24>
		;
}
    183e:	cf 91       	pop	r28
    1840:	df 91       	pop	r29
    1842:	08 95       	ret

00001844 <MCAL_TWI_Master_SendReStartCondition>:
void MCAL_TWI_Master_SendReStartCondition(void) {
    1844:	df 93       	push	r29
    1846:	cf 93       	push	r28
    1848:	cd b7       	in	r28, 0x3d	; 61
    184a:	de b7       	in	r29, 0x3e	; 62
	// Enable Start
	SET_BIT(TWCR, Pin5);
    184c:	a6 e5       	ldi	r26, 0x56	; 86
    184e:	b0 e0       	ldi	r27, 0x00	; 0
    1850:	e6 e5       	ldi	r30, 0x56	; 86
    1852:	f0 e0       	ldi	r31, 0x00	; 0
    1854:	80 81       	ld	r24, Z
    1856:	80 62       	ori	r24, 0x20	; 32
    1858:	8c 93       	st	X, r24
	//CLR Flag
	SET_BIT(TWCR, Pin7);
    185a:	a6 e5       	ldi	r26, 0x56	; 86
    185c:	b0 e0       	ldi	r27, 0x00	; 0
    185e:	e6 e5       	ldi	r30, 0x56	; 86
    1860:	f0 e0       	ldi	r31, 0x00	; 0
    1862:	80 81       	ld	r24, Z
    1864:	80 68       	ori	r24, 0x80	; 128
    1866:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    1868:	e6 e5       	ldi	r30, 0x56	; 86
    186a:	f0 e0       	ldi	r31, 0x00	; 0
    186c:	80 81       	ld	r24, Z
    186e:	88 23       	and	r24, r24
    1870:	dc f7       	brge	.-10     	; 0x1868 <MCAL_TWI_Master_SendReStartCondition+0x24>
		;
}
    1872:	cf 91       	pop	r28
    1874:	df 91       	pop	r29
    1876:	08 95       	ret

00001878 <MCAL_TWI_Master_SendStopCondition>:

void MCAL_TWI_Master_SendStopCondition(void) {
    1878:	df 93       	push	r29
    187a:	cf 93       	push	r28
    187c:	cd b7       	in	r28, 0x3d	; 61
    187e:	de b7       	in	r29, 0x3e	; 62
	// Enable Stop
	SET_BIT(TWCR, Pin4);
    1880:	a6 e5       	ldi	r26, 0x56	; 86
    1882:	b0 e0       	ldi	r27, 0x00	; 0
    1884:	e6 e5       	ldi	r30, 0x56	; 86
    1886:	f0 e0       	ldi	r31, 0x00	; 0
    1888:	80 81       	ld	r24, Z
    188a:	80 61       	ori	r24, 0x10	; 16
    188c:	8c 93       	st	X, r24
	//CLR Flag
	SET_BIT(TWCR, Pin7);
    188e:	a6 e5       	ldi	r26, 0x56	; 86
    1890:	b0 e0       	ldi	r27, 0x00	; 0
    1892:	e6 e5       	ldi	r30, 0x56	; 86
    1894:	f0 e0       	ldi	r31, 0x00	; 0
    1896:	80 81       	ld	r24, Z
    1898:	80 68       	ori	r24, 0x80	; 128
    189a:	8c 93       	st	X, r24
}
    189c:	cf 91       	pop	r28
    189e:	df 91       	pop	r29
    18a0:	08 95       	ret

000018a2 <MCAL_TWI_Master_SendSlaveAddWithWrite>:

void MCAL_TWI_Master_SendSlaveAddWithWrite(u8 Address) {
    18a2:	df 93       	push	r29
    18a4:	cf 93       	push	r28
    18a6:	0f 92       	push	r0
    18a8:	cd b7       	in	r28, 0x3d	; 61
    18aa:	de b7       	in	r29, 0x3e	; 62
    18ac:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Address << 1;
    18ae:	e3 e2       	ldi	r30, 0x23	; 35
    18b0:	f0 e0       	ldi	r31, 0x00	; 0
    18b2:	89 81       	ldd	r24, Y+1	; 0x01
    18b4:	88 0f       	add	r24, r24
    18b6:	80 83       	st	Z, r24
	//Write
	CLR_BIT(TWDR, Pin0);
    18b8:	a3 e2       	ldi	r26, 0x23	; 35
    18ba:	b0 e0       	ldi	r27, 0x00	; 0
    18bc:	e3 e2       	ldi	r30, 0x23	; 35
    18be:	f0 e0       	ldi	r31, 0x00	; 0
    18c0:	80 81       	ld	r24, Z
    18c2:	8e 7f       	andi	r24, 0xFE	; 254
    18c4:	8c 93       	st	X, r24
	//clr start cond
	CLR_BIT(TWCR, Pin5);
    18c6:	a6 e5       	ldi	r26, 0x56	; 86
    18c8:	b0 e0       	ldi	r27, 0x00	; 0
    18ca:	e6 e5       	ldi	r30, 0x56	; 86
    18cc:	f0 e0       	ldi	r31, 0x00	; 0
    18ce:	80 81       	ld	r24, Z
    18d0:	8f 7d       	andi	r24, 0xDF	; 223
    18d2:	8c 93       	st	X, r24
	//clr flage
	SET_BIT(TWCR, Pin7);
    18d4:	a6 e5       	ldi	r26, 0x56	; 86
    18d6:	b0 e0       	ldi	r27, 0x00	; 0
    18d8:	e6 e5       	ldi	r30, 0x56	; 86
    18da:	f0 e0       	ldi	r31, 0x00	; 0
    18dc:	80 81       	ld	r24, Z
    18de:	80 68       	ori	r24, 0x80	; 128
    18e0:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    18e2:	e6 e5       	ldi	r30, 0x56	; 86
    18e4:	f0 e0       	ldi	r31, 0x00	; 0
    18e6:	80 81       	ld	r24, Z
    18e8:	88 23       	and	r24, r24
    18ea:	dc f7       	brge	.-10     	; 0x18e2 <MCAL_TWI_Master_SendSlaveAddWithWrite+0x40>
		;
}
    18ec:	0f 90       	pop	r0
    18ee:	cf 91       	pop	r28
    18f0:	df 91       	pop	r29
    18f2:	08 95       	ret

000018f4 <MCAL_TWI_Master_SendSlaveAddWithRead>:
void MCAL_TWI_Master_SendSlaveAddWithRead(u8 Address) {
    18f4:	df 93       	push	r29
    18f6:	cf 93       	push	r28
    18f8:	0f 92       	push	r0
    18fa:	cd b7       	in	r28, 0x3d	; 61
    18fc:	de b7       	in	r29, 0x3e	; 62
    18fe:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Address << 1;
    1900:	e3 e2       	ldi	r30, 0x23	; 35
    1902:	f0 e0       	ldi	r31, 0x00	; 0
    1904:	89 81       	ldd	r24, Y+1	; 0x01
    1906:	88 0f       	add	r24, r24
    1908:	80 83       	st	Z, r24
	//Read
	SET_BIT(TWDR, Pin0);
    190a:	a3 e2       	ldi	r26, 0x23	; 35
    190c:	b0 e0       	ldi	r27, 0x00	; 0
    190e:	e3 e2       	ldi	r30, 0x23	; 35
    1910:	f0 e0       	ldi	r31, 0x00	; 0
    1912:	80 81       	ld	r24, Z
    1914:	81 60       	ori	r24, 0x01	; 1
    1916:	8c 93       	st	X, r24
	//clr start cond
	CLR_BIT(TWCR, Pin5);
    1918:	a6 e5       	ldi	r26, 0x56	; 86
    191a:	b0 e0       	ldi	r27, 0x00	; 0
    191c:	e6 e5       	ldi	r30, 0x56	; 86
    191e:	f0 e0       	ldi	r31, 0x00	; 0
    1920:	80 81       	ld	r24, Z
    1922:	8f 7d       	andi	r24, 0xDF	; 223
    1924:	8c 93       	st	X, r24
	//clr flage
	SET_BIT(TWCR, Pin7);
    1926:	a6 e5       	ldi	r26, 0x56	; 86
    1928:	b0 e0       	ldi	r27, 0x00	; 0
    192a:	e6 e5       	ldi	r30, 0x56	; 86
    192c:	f0 e0       	ldi	r31, 0x00	; 0
    192e:	80 81       	ld	r24, Z
    1930:	80 68       	ori	r24, 0x80	; 128
    1932:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    1934:	e6 e5       	ldi	r30, 0x56	; 86
    1936:	f0 e0       	ldi	r31, 0x00	; 0
    1938:	80 81       	ld	r24, Z
    193a:	88 23       	and	r24, r24
    193c:	dc f7       	brge	.-10     	; 0x1934 <MCAL_TWI_Master_SendSlaveAddWithRead+0x40>
		;
}
    193e:	0f 90       	pop	r0
    1940:	cf 91       	pop	r28
    1942:	df 91       	pop	r29
    1944:	08 95       	ret

00001946 <MCAL_TWI_Slave_Init>:

// Slave
void MCAL_TWI_Slave_Init(u8 Slave_Address) {
    1946:	df 93       	push	r29
    1948:	cf 93       	push	r28
    194a:	0f 92       	push	r0
    194c:	cd b7       	in	r28, 0x3d	; 61
    194e:	de b7       	in	r29, 0x3e	; 62
    1950:	89 83       	std	Y+1, r24	; 0x01
	//Enable TWI
	SET_BIT(TWCR, Pin2);
    1952:	a6 e5       	ldi	r26, 0x56	; 86
    1954:	b0 e0       	ldi	r27, 0x00	; 0
    1956:	e6 e5       	ldi	r30, 0x56	; 86
    1958:	f0 e0       	ldi	r31, 0x00	; 0
    195a:	80 81       	ld	r24, Z
    195c:	84 60       	ori	r24, 0x04	; 4
    195e:	8c 93       	st	X, r24
	//Enable ACK
	SET_BIT(TWCR, Pin6);
    1960:	a6 e5       	ldi	r26, 0x56	; 86
    1962:	b0 e0       	ldi	r27, 0x00	; 0
    1964:	e6 e5       	ldi	r30, 0x56	; 86
    1966:	f0 e0       	ldi	r31, 0x00	; 0
    1968:	80 81       	ld	r24, Z
    196a:	80 64       	ori	r24, 0x40	; 64
    196c:	8c 93       	st	X, r24
	//Set Slave Address
	TWAR = Slave_Address << 1;
    196e:	e2 e2       	ldi	r30, 0x22	; 34
    1970:	f0 e0       	ldi	r31, 0x00	; 0
    1972:	89 81       	ldd	r24, Y+1	; 0x01
    1974:	88 0f       	add	r24, r24
    1976:	80 83       	st	Z, r24
	//config general call
	CLR_BIT(TWAR, Pin0);
    1978:	a2 e2       	ldi	r26, 0x22	; 34
    197a:	b0 e0       	ldi	r27, 0x00	; 0
    197c:	e2 e2       	ldi	r30, 0x22	; 34
    197e:	f0 e0       	ldi	r31, 0x00	; 0
    1980:	80 81       	ld	r24, Z
    1982:	8e 7f       	andi	r24, 0xFE	; 254
    1984:	8c 93       	st	X, r24
	//CLr flag
	SET_BIT(TWCR, Pin7);
    1986:	a6 e5       	ldi	r26, 0x56	; 86
    1988:	b0 e0       	ldi	r27, 0x00	; 0
    198a:	e6 e5       	ldi	r30, 0x56	; 86
    198c:	f0 e0       	ldi	r31, 0x00	; 0
    198e:	80 81       	ld	r24, Z
    1990:	80 68       	ori	r24, 0x80	; 128
    1992:	8c 93       	st	X, r24
}
    1994:	0f 90       	pop	r0
    1996:	cf 91       	pop	r28
    1998:	df 91       	pop	r29
    199a:	08 95       	ret

0000199c <MCAL_TWI_Slave_Listen>:

void MCAL_TWI_Slave_Listen(void) {
    199c:	df 93       	push	r29
    199e:	cf 93       	push	r28
    19a0:	cd b7       	in	r28, 0x3d	; 61
    19a2:	de b7       	in	r29, 0x3e	; 62
	//clr flage
	SET_BIT(TWCR, Pin7);
    19a4:	a6 e5       	ldi	r26, 0x56	; 86
    19a6:	b0 e0       	ldi	r27, 0x00	; 0
    19a8:	e6 e5       	ldi	r30, 0x56	; 86
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	80 81       	ld	r24, Z
    19ae:	80 68       	ori	r24, 0x80	; 128
    19b0:	8c 93       	st	X, r24

}
    19b2:	cf 91       	pop	r28
    19b4:	df 91       	pop	r29
    19b6:	08 95       	ret

000019b8 <MCAL_TWI_SendData>:

// Common

void MCAL_TWI_SendData(u8 Data) {
    19b8:	df 93       	push	r29
    19ba:	cf 93       	push	r28
    19bc:	0f 92       	push	r0
    19be:	cd b7       	in	r28, 0x3d	; 61
    19c0:	de b7       	in	r29, 0x3e	; 62
    19c2:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Data;
    19c4:	e3 e2       	ldi	r30, 0x23	; 35
    19c6:	f0 e0       	ldi	r31, 0x00	; 0
    19c8:	89 81       	ldd	r24, Y+1	; 0x01
    19ca:	80 83       	st	Z, r24
	//clr flage
	SET_BIT(TWCR, Pin7);
    19cc:	a6 e5       	ldi	r26, 0x56	; 86
    19ce:	b0 e0       	ldi	r27, 0x00	; 0
    19d0:	e6 e5       	ldi	r30, 0x56	; 86
    19d2:	f0 e0       	ldi	r31, 0x00	; 0
    19d4:	80 81       	ld	r24, Z
    19d6:	80 68       	ori	r24, 0x80	; 128
    19d8:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    19da:	e6 e5       	ldi	r30, 0x56	; 86
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
    19de:	80 81       	ld	r24, Z
    19e0:	88 23       	and	r24, r24
    19e2:	dc f7       	brge	.-10     	; 0x19da <MCAL_TWI_SendData+0x22>
		;
}
    19e4:	0f 90       	pop	r0
    19e6:	cf 91       	pop	r28
    19e8:	df 91       	pop	r29
    19ea:	08 95       	ret

000019ec <MCAL_TWI_RecieveData>:
void MCAL_TWI_RecieveData(u8* Data) {
    19ec:	df 93       	push	r29
    19ee:	cf 93       	push	r28
    19f0:	00 d0       	rcall	.+0      	; 0x19f2 <MCAL_TWI_RecieveData+0x6>
    19f2:	cd b7       	in	r28, 0x3d	; 61
    19f4:	de b7       	in	r29, 0x3e	; 62
    19f6:	9a 83       	std	Y+2, r25	; 0x02
    19f8:	89 83       	std	Y+1, r24	; 0x01
	//clr flage
	SET_BIT(TWCR, Pin7);
    19fa:	a6 e5       	ldi	r26, 0x56	; 86
    19fc:	b0 e0       	ldi	r27, 0x00	; 0
    19fe:	e6 e5       	ldi	r30, 0x56	; 86
    1a00:	f0 e0       	ldi	r31, 0x00	; 0
    1a02:	80 81       	ld	r24, Z
    1a04:	80 68       	ori	r24, 0x80	; 128
    1a06:	8c 93       	st	X, r24
	//Wait
	while (GET_BIT(TWCR,Pin7) == 0)
    1a08:	e6 e5       	ldi	r30, 0x56	; 86
    1a0a:	f0 e0       	ldi	r31, 0x00	; 0
    1a0c:	80 81       	ld	r24, Z
    1a0e:	88 23       	and	r24, r24
    1a10:	dc f7       	brge	.-10     	; 0x1a08 <MCAL_TWI_RecieveData+0x1c>
		;
	*Data = TWDR;
    1a12:	e3 e2       	ldi	r30, 0x23	; 35
    1a14:	f0 e0       	ldi	r31, 0x00	; 0
    1a16:	80 81       	ld	r24, Z
    1a18:	e9 81       	ldd	r30, Y+1	; 0x01
    1a1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a1c:	80 83       	st	Z, r24
}
    1a1e:	0f 90       	pop	r0
    1a20:	0f 90       	pop	r0
    1a22:	cf 91       	pop	r28
    1a24:	df 91       	pop	r29
    1a26:	08 95       	ret

00001a28 <MCAL_Interrupt_u8SetRegister>:

void (*Gptr0)(void)= '\0' ;
void (*Gptr1)(void)= '\0' ;
void (*Gptr2)(void)= '\0' ;

void MCAL_Interrupt_u8SetRegister(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    1a28:	df 93       	push	r29
    1a2a:	cf 93       	push	r28
    1a2c:	00 d0       	rcall	.+0      	; 0x1a2e <MCAL_Interrupt_u8SetRegister+0x6>
    1a2e:	cd b7       	in	r28, 0x3d	; 61
    1a30:	de b7       	in	r29, 0x3e	; 62
    1a32:	89 83       	std	Y+1, r24	; 0x01
    1a34:	6a 83       	std	Y+2, r22	; 0x02
	if (Loc_u8PortValue == PORT_OUTPUT) {
    1a36:	8a 81       	ldd	r24, Y+2	; 0x02
    1a38:	8f 3f       	cpi	r24, 0xFF	; 255
    1a3a:	09 f5       	brne	.+66     	; 0x1a7e <MCAL_Interrupt_u8SetRegister+0x56>
		if (Loc_u8PortID == Sreg) {
    1a3c:	89 81       	ldd	r24, Y+1	; 0x01
    1a3e:	88 23       	and	r24, r24
    1a40:	29 f4       	brne	.+10     	; 0x1a4c <MCAL_Interrupt_u8SetRegister+0x24>
			SREG = PORT_OUTPUT;
    1a42:	ef e5       	ldi	r30, 0x5F	; 95
    1a44:	f0 e0       	ldi	r31, 0x00	; 0
    1a46:	8f ef       	ldi	r24, 0xFF	; 255
    1a48:	80 83       	st	Z, r24
    1a4a:	57 c0       	rjmp	.+174    	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    1a4c:	89 81       	ldd	r24, Y+1	; 0x01
    1a4e:	81 30       	cpi	r24, 0x01	; 1
    1a50:	29 f4       	brne	.+10     	; 0x1a5c <MCAL_Interrupt_u8SetRegister+0x34>
			GICR = PORT_OUTPUT;
    1a52:	eb e5       	ldi	r30, 0x5B	; 91
    1a54:	f0 e0       	ldi	r31, 0x00	; 0
    1a56:	8f ef       	ldi	r24, 0xFF	; 255
    1a58:	80 83       	st	Z, r24
    1a5a:	4f c0       	rjmp	.+158    	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    1a5c:	89 81       	ldd	r24, Y+1	; 0x01
    1a5e:	82 30       	cpi	r24, 0x02	; 2
    1a60:	29 f4       	brne	.+10     	; 0x1a6c <MCAL_Interrupt_u8SetRegister+0x44>
			MCUCR = PORT_OUTPUT;
    1a62:	e5 e5       	ldi	r30, 0x55	; 85
    1a64:	f0 e0       	ldi	r31, 0x00	; 0
    1a66:	8f ef       	ldi	r24, 0xFF	; 255
    1a68:	80 83       	st	Z, r24
    1a6a:	47 c0       	rjmp	.+142    	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    1a6c:	89 81       	ldd	r24, Y+1	; 0x01
    1a6e:	83 30       	cpi	r24, 0x03	; 3
    1a70:	09 f0       	breq	.+2      	; 0x1a74 <MCAL_Interrupt_u8SetRegister+0x4c>
    1a72:	43 c0       	rjmp	.+134    	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = PORT_OUTPUT;
    1a74:	e4 e5       	ldi	r30, 0x54	; 84
    1a76:	f0 e0       	ldi	r31, 0x00	; 0
    1a78:	8f ef       	ldi	r24, 0xFF	; 255
    1a7a:	80 83       	st	Z, r24
    1a7c:	3e c0       	rjmp	.+124    	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PortValue == PORT_INPUT) {
    1a7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a80:	88 23       	and	r24, r24
    1a82:	e1 f4       	brne	.+56     	; 0x1abc <MCAL_Interrupt_u8SetRegister+0x94>
		if (Loc_u8PortID == Sreg) {
    1a84:	89 81       	ldd	r24, Y+1	; 0x01
    1a86:	88 23       	and	r24, r24
    1a88:	21 f4       	brne	.+8      	; 0x1a92 <MCAL_Interrupt_u8SetRegister+0x6a>
			SREG = PORT_INPUT;
    1a8a:	ef e5       	ldi	r30, 0x5F	; 95
    1a8c:	f0 e0       	ldi	r31, 0x00	; 0
    1a8e:	10 82       	st	Z, r1
    1a90:	34 c0       	rjmp	.+104    	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    1a92:	89 81       	ldd	r24, Y+1	; 0x01
    1a94:	81 30       	cpi	r24, 0x01	; 1
    1a96:	21 f4       	brne	.+8      	; 0x1aa0 <MCAL_Interrupt_u8SetRegister+0x78>
			GICR = PORT_INPUT;
    1a98:	eb e5       	ldi	r30, 0x5B	; 91
    1a9a:	f0 e0       	ldi	r31, 0x00	; 0
    1a9c:	10 82       	st	Z, r1
    1a9e:	2d c0       	rjmp	.+90     	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    1aa0:	89 81       	ldd	r24, Y+1	; 0x01
    1aa2:	82 30       	cpi	r24, 0x02	; 2
    1aa4:	21 f4       	brne	.+8      	; 0x1aae <MCAL_Interrupt_u8SetRegister+0x86>
			MCUCR = PORT_INPUT;
    1aa6:	e5 e5       	ldi	r30, 0x55	; 85
    1aa8:	f0 e0       	ldi	r31, 0x00	; 0
    1aaa:	10 82       	st	Z, r1
    1aac:	26 c0       	rjmp	.+76     	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    1aae:	89 81       	ldd	r24, Y+1	; 0x01
    1ab0:	83 30       	cpi	r24, 0x03	; 3
    1ab2:	19 f5       	brne	.+70     	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = PORT_INPUT;
    1ab4:	e4 e5       	ldi	r30, 0x54	; 84
    1ab6:	f0 e0       	ldi	r31, 0x00	; 0
    1ab8:	10 82       	st	Z, r1
    1aba:	1f c0       	rjmp	.+62     	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else {
			//Do Nothing
		}
	} else {
		if (Loc_u8PortID == Sreg) {
    1abc:	89 81       	ldd	r24, Y+1	; 0x01
    1abe:	88 23       	and	r24, r24
    1ac0:	29 f4       	brne	.+10     	; 0x1acc <MCAL_Interrupt_u8SetRegister+0xa4>
			SREG = Loc_u8PortValue;
    1ac2:	ef e5       	ldi	r30, 0x5F	; 95
    1ac4:	f0 e0       	ldi	r31, 0x00	; 0
    1ac6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ac8:	80 83       	st	Z, r24
    1aca:	17 c0       	rjmp	.+46     	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Gicr) {
    1acc:	89 81       	ldd	r24, Y+1	; 0x01
    1ace:	81 30       	cpi	r24, 0x01	; 1
    1ad0:	29 f4       	brne	.+10     	; 0x1adc <MCAL_Interrupt_u8SetRegister+0xb4>
			GICR = Loc_u8PortValue;
    1ad2:	eb e5       	ldi	r30, 0x5B	; 91
    1ad4:	f0 e0       	ldi	r31, 0x00	; 0
    1ad6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad8:	80 83       	st	Z, r24
    1ada:	0f c0       	rjmp	.+30     	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucr) {
    1adc:	89 81       	ldd	r24, Y+1	; 0x01
    1ade:	82 30       	cpi	r24, 0x02	; 2
    1ae0:	29 f4       	brne	.+10     	; 0x1aec <MCAL_Interrupt_u8SetRegister+0xc4>
			MCUCR = Loc_u8PortValue;
    1ae2:	e5 e5       	ldi	r30, 0x55	; 85
    1ae4:	f0 e0       	ldi	r31, 0x00	; 0
    1ae6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae8:	80 83       	st	Z, r24
    1aea:	07 c0       	rjmp	.+14     	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
		} else if (Loc_u8PortID == Mcucsr) {
    1aec:	89 81       	ldd	r24, Y+1	; 0x01
    1aee:	83 30       	cpi	r24, 0x03	; 3
    1af0:	21 f4       	brne	.+8      	; 0x1afa <MCAL_Interrupt_u8SetRegister+0xd2>
			MCUCSR = Loc_u8PortValue;
    1af2:	e4 e5       	ldi	r30, 0x54	; 84
    1af4:	f0 e0       	ldi	r31, 0x00	; 0
    1af6:	8a 81       	ldd	r24, Y+2	; 0x02
    1af8:	80 83       	st	Z, r24
		}
	}
}
    1afa:	0f 90       	pop	r0
    1afc:	0f 90       	pop	r0
    1afe:	cf 91       	pop	r28
    1b00:	df 91       	pop	r29
    1b02:	08 95       	ret

00001b04 <MCAL_Interrupt_u8SetRegisterPin>:

void MCAL_Interrupt_u8SetRegisterPin(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    1b04:	df 93       	push	r29
    1b06:	cf 93       	push	r28
    1b08:	00 d0       	rcall	.+0      	; 0x1b0a <MCAL_Interrupt_u8SetRegisterPin+0x6>
    1b0a:	0f 92       	push	r0
    1b0c:	cd b7       	in	r28, 0x3d	; 61
    1b0e:	de b7       	in	r29, 0x3e	; 62
    1b10:	89 83       	std	Y+1, r24	; 0x01
    1b12:	6a 83       	std	Y+2, r22	; 0x02
    1b14:	4b 83       	std	Y+3, r20	; 0x03
	if (Loc_u8PinValue == Pin_High) {
    1b16:	8b 81       	ldd	r24, Y+3	; 0x03
    1b18:	81 30       	cpi	r24, 0x01	; 1
    1b1a:	09 f0       	breq	.+2      	; 0x1b1e <MCAL_Interrupt_u8SetRegisterPin+0x1a>
    1b1c:	5d c0       	rjmp	.+186    	; 0x1bd8 <MCAL_Interrupt_u8SetRegisterPin+0xd4>
		if (Loc_u8PortID == Sreg) {
    1b1e:	89 81       	ldd	r24, Y+1	; 0x01
    1b20:	88 23       	and	r24, r24
    1b22:	a1 f4       	brne	.+40     	; 0x1b4c <MCAL_Interrupt_u8SetRegisterPin+0x48>
			SET_BIT(SREG, Loc_u8PinID);
    1b24:	af e5       	ldi	r26, 0x5F	; 95
    1b26:	b0 e0       	ldi	r27, 0x00	; 0
    1b28:	ef e5       	ldi	r30, 0x5F	; 95
    1b2a:	f0 e0       	ldi	r31, 0x00	; 0
    1b2c:	80 81       	ld	r24, Z
    1b2e:	48 2f       	mov	r20, r24
    1b30:	8a 81       	ldd	r24, Y+2	; 0x02
    1b32:	28 2f       	mov	r18, r24
    1b34:	30 e0       	ldi	r19, 0x00	; 0
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	02 2e       	mov	r0, r18
    1b3c:	02 c0       	rjmp	.+4      	; 0x1b42 <MCAL_Interrupt_u8SetRegisterPin+0x3e>
    1b3e:	88 0f       	add	r24, r24
    1b40:	99 1f       	adc	r25, r25
    1b42:	0a 94       	dec	r0
    1b44:	e2 f7       	brpl	.-8      	; 0x1b3e <MCAL_Interrupt_u8SetRegisterPin+0x3a>
    1b46:	84 2b       	or	r24, r20
    1b48:	8c 93       	st	X, r24
    1b4a:	a9 c0       	rjmp	.+338    	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Gicr) {
    1b4c:	89 81       	ldd	r24, Y+1	; 0x01
    1b4e:	81 30       	cpi	r24, 0x01	; 1
    1b50:	a1 f4       	brne	.+40     	; 0x1b7a <MCAL_Interrupt_u8SetRegisterPin+0x76>
			SET_BIT(GICR, Loc_u8PinID);
    1b52:	ab e5       	ldi	r26, 0x5B	; 91
    1b54:	b0 e0       	ldi	r27, 0x00	; 0
    1b56:	eb e5       	ldi	r30, 0x5B	; 91
    1b58:	f0 e0       	ldi	r31, 0x00	; 0
    1b5a:	80 81       	ld	r24, Z
    1b5c:	48 2f       	mov	r20, r24
    1b5e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b60:	28 2f       	mov	r18, r24
    1b62:	30 e0       	ldi	r19, 0x00	; 0
    1b64:	81 e0       	ldi	r24, 0x01	; 1
    1b66:	90 e0       	ldi	r25, 0x00	; 0
    1b68:	02 2e       	mov	r0, r18
    1b6a:	02 c0       	rjmp	.+4      	; 0x1b70 <MCAL_Interrupt_u8SetRegisterPin+0x6c>
    1b6c:	88 0f       	add	r24, r24
    1b6e:	99 1f       	adc	r25, r25
    1b70:	0a 94       	dec	r0
    1b72:	e2 f7       	brpl	.-8      	; 0x1b6c <MCAL_Interrupt_u8SetRegisterPin+0x68>
    1b74:	84 2b       	or	r24, r20
    1b76:	8c 93       	st	X, r24
    1b78:	92 c0       	rjmp	.+292    	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucr) {
    1b7a:	89 81       	ldd	r24, Y+1	; 0x01
    1b7c:	82 30       	cpi	r24, 0x02	; 2
    1b7e:	a1 f4       	brne	.+40     	; 0x1ba8 <MCAL_Interrupt_u8SetRegisterPin+0xa4>
			SET_BIT(MCUCR, Loc_u8PinID);
    1b80:	a5 e5       	ldi	r26, 0x55	; 85
    1b82:	b0 e0       	ldi	r27, 0x00	; 0
    1b84:	e5 e5       	ldi	r30, 0x55	; 85
    1b86:	f0 e0       	ldi	r31, 0x00	; 0
    1b88:	80 81       	ld	r24, Z
    1b8a:	48 2f       	mov	r20, r24
    1b8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b8e:	28 2f       	mov	r18, r24
    1b90:	30 e0       	ldi	r19, 0x00	; 0
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	02 2e       	mov	r0, r18
    1b98:	02 c0       	rjmp	.+4      	; 0x1b9e <MCAL_Interrupt_u8SetRegisterPin+0x9a>
    1b9a:	88 0f       	add	r24, r24
    1b9c:	99 1f       	adc	r25, r25
    1b9e:	0a 94       	dec	r0
    1ba0:	e2 f7       	brpl	.-8      	; 0x1b9a <MCAL_Interrupt_u8SetRegisterPin+0x96>
    1ba2:	84 2b       	or	r24, r20
    1ba4:	8c 93       	st	X, r24
    1ba6:	7b c0       	rjmp	.+246    	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucsr) {
    1ba8:	89 81       	ldd	r24, Y+1	; 0x01
    1baa:	83 30       	cpi	r24, 0x03	; 3
    1bac:	09 f0       	breq	.+2      	; 0x1bb0 <MCAL_Interrupt_u8SetRegisterPin+0xac>
    1bae:	77 c0       	rjmp	.+238    	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
			SET_BIT(MCUCSR, Loc_u8PinID);
    1bb0:	a4 e5       	ldi	r26, 0x54	; 84
    1bb2:	b0 e0       	ldi	r27, 0x00	; 0
    1bb4:	e4 e5       	ldi	r30, 0x54	; 84
    1bb6:	f0 e0       	ldi	r31, 0x00	; 0
    1bb8:	80 81       	ld	r24, Z
    1bba:	48 2f       	mov	r20, r24
    1bbc:	8a 81       	ldd	r24, Y+2	; 0x02
    1bbe:	28 2f       	mov	r18, r24
    1bc0:	30 e0       	ldi	r19, 0x00	; 0
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	90 e0       	ldi	r25, 0x00	; 0
    1bc6:	02 2e       	mov	r0, r18
    1bc8:	02 c0       	rjmp	.+4      	; 0x1bce <MCAL_Interrupt_u8SetRegisterPin+0xca>
    1bca:	88 0f       	add	r24, r24
    1bcc:	99 1f       	adc	r25, r25
    1bce:	0a 94       	dec	r0
    1bd0:	e2 f7       	brpl	.-8      	; 0x1bca <MCAL_Interrupt_u8SetRegisterPin+0xc6>
    1bd2:	84 2b       	or	r24, r20
    1bd4:	8c 93       	st	X, r24
    1bd6:	63 c0       	rjmp	.+198    	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PinValue == Pin_Low) {
    1bd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bda:	88 23       	and	r24, r24
    1bdc:	09 f0       	breq	.+2      	; 0x1be0 <MCAL_Interrupt_u8SetRegisterPin+0xdc>
    1bde:	5f c0       	rjmp	.+190    	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		if (Loc_u8PortID == Sreg) {
    1be0:	89 81       	ldd	r24, Y+1	; 0x01
    1be2:	88 23       	and	r24, r24
    1be4:	a9 f4       	brne	.+42     	; 0x1c10 <MCAL_Interrupt_u8SetRegisterPin+0x10c>
			CLR_BIT(SREG, Loc_u8PinID);
    1be6:	af e5       	ldi	r26, 0x5F	; 95
    1be8:	b0 e0       	ldi	r27, 0x00	; 0
    1bea:	ef e5       	ldi	r30, 0x5F	; 95
    1bec:	f0 e0       	ldi	r31, 0x00	; 0
    1bee:	80 81       	ld	r24, Z
    1bf0:	48 2f       	mov	r20, r24
    1bf2:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf4:	28 2f       	mov	r18, r24
    1bf6:	30 e0       	ldi	r19, 0x00	; 0
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	02 2e       	mov	r0, r18
    1bfe:	02 c0       	rjmp	.+4      	; 0x1c04 <MCAL_Interrupt_u8SetRegisterPin+0x100>
    1c00:	88 0f       	add	r24, r24
    1c02:	99 1f       	adc	r25, r25
    1c04:	0a 94       	dec	r0
    1c06:	e2 f7       	brpl	.-8      	; 0x1c00 <MCAL_Interrupt_u8SetRegisterPin+0xfc>
    1c08:	80 95       	com	r24
    1c0a:	84 23       	and	r24, r20
    1c0c:	8c 93       	st	X, r24
    1c0e:	47 c0       	rjmp	.+142    	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Gicr) {
    1c10:	89 81       	ldd	r24, Y+1	; 0x01
    1c12:	81 30       	cpi	r24, 0x01	; 1
    1c14:	a9 f4       	brne	.+42     	; 0x1c40 <MCAL_Interrupt_u8SetRegisterPin+0x13c>
			CLR_BIT(GICR, Loc_u8PinID);
    1c16:	ab e5       	ldi	r26, 0x5B	; 91
    1c18:	b0 e0       	ldi	r27, 0x00	; 0
    1c1a:	eb e5       	ldi	r30, 0x5B	; 91
    1c1c:	f0 e0       	ldi	r31, 0x00	; 0
    1c1e:	80 81       	ld	r24, Z
    1c20:	48 2f       	mov	r20, r24
    1c22:	8a 81       	ldd	r24, Y+2	; 0x02
    1c24:	28 2f       	mov	r18, r24
    1c26:	30 e0       	ldi	r19, 0x00	; 0
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	02 2e       	mov	r0, r18
    1c2e:	02 c0       	rjmp	.+4      	; 0x1c34 <MCAL_Interrupt_u8SetRegisterPin+0x130>
    1c30:	88 0f       	add	r24, r24
    1c32:	99 1f       	adc	r25, r25
    1c34:	0a 94       	dec	r0
    1c36:	e2 f7       	brpl	.-8      	; 0x1c30 <MCAL_Interrupt_u8SetRegisterPin+0x12c>
    1c38:	80 95       	com	r24
    1c3a:	84 23       	and	r24, r20
    1c3c:	8c 93       	st	X, r24
    1c3e:	2f c0       	rjmp	.+94     	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucr) {
    1c40:	89 81       	ldd	r24, Y+1	; 0x01
    1c42:	82 30       	cpi	r24, 0x02	; 2
    1c44:	a9 f4       	brne	.+42     	; 0x1c70 <MCAL_Interrupt_u8SetRegisterPin+0x16c>
			CLR_BIT(MCUCR, Loc_u8PinID);
    1c46:	a5 e5       	ldi	r26, 0x55	; 85
    1c48:	b0 e0       	ldi	r27, 0x00	; 0
    1c4a:	e5 e5       	ldi	r30, 0x55	; 85
    1c4c:	f0 e0       	ldi	r31, 0x00	; 0
    1c4e:	80 81       	ld	r24, Z
    1c50:	48 2f       	mov	r20, r24
    1c52:	8a 81       	ldd	r24, Y+2	; 0x02
    1c54:	28 2f       	mov	r18, r24
    1c56:	30 e0       	ldi	r19, 0x00	; 0
    1c58:	81 e0       	ldi	r24, 0x01	; 1
    1c5a:	90 e0       	ldi	r25, 0x00	; 0
    1c5c:	02 2e       	mov	r0, r18
    1c5e:	02 c0       	rjmp	.+4      	; 0x1c64 <MCAL_Interrupt_u8SetRegisterPin+0x160>
    1c60:	88 0f       	add	r24, r24
    1c62:	99 1f       	adc	r25, r25
    1c64:	0a 94       	dec	r0
    1c66:	e2 f7       	brpl	.-8      	; 0x1c60 <MCAL_Interrupt_u8SetRegisterPin+0x15c>
    1c68:	80 95       	com	r24
    1c6a:	84 23       	and	r24, r20
    1c6c:	8c 93       	st	X, r24
    1c6e:	17 c0       	rjmp	.+46     	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
		} else if (Loc_u8PortID == Mcucsr) {
    1c70:	89 81       	ldd	r24, Y+1	; 0x01
    1c72:	83 30       	cpi	r24, 0x03	; 3
    1c74:	a1 f4       	brne	.+40     	; 0x1c9e <MCAL_Interrupt_u8SetRegisterPin+0x19a>
			CLR_BIT(MCUCSR, Loc_u8PinID);
    1c76:	a4 e5       	ldi	r26, 0x54	; 84
    1c78:	b0 e0       	ldi	r27, 0x00	; 0
    1c7a:	e4 e5       	ldi	r30, 0x54	; 84
    1c7c:	f0 e0       	ldi	r31, 0x00	; 0
    1c7e:	80 81       	ld	r24, Z
    1c80:	48 2f       	mov	r20, r24
    1c82:	8a 81       	ldd	r24, Y+2	; 0x02
    1c84:	28 2f       	mov	r18, r24
    1c86:	30 e0       	ldi	r19, 0x00	; 0
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	90 e0       	ldi	r25, 0x00	; 0
    1c8c:	02 2e       	mov	r0, r18
    1c8e:	02 c0       	rjmp	.+4      	; 0x1c94 <MCAL_Interrupt_u8SetRegisterPin+0x190>
    1c90:	88 0f       	add	r24, r24
    1c92:	99 1f       	adc	r25, r25
    1c94:	0a 94       	dec	r0
    1c96:	e2 f7       	brpl	.-8      	; 0x1c90 <MCAL_Interrupt_u8SetRegisterPin+0x18c>
    1c98:	80 95       	com	r24
    1c9a:	84 23       	and	r24, r20
    1c9c:	8c 93       	st	X, r24
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
}
    1c9e:	0f 90       	pop	r0
    1ca0:	0f 90       	pop	r0
    1ca2:	0f 90       	pop	r0
    1ca4:	cf 91       	pop	r28
    1ca6:	df 91       	pop	r29
    1ca8:	08 95       	ret

00001caa <MCAL_Interrupt_EXIT_CallBack_0>:

void MCAL_Interrupt_EXIT_CallBack_0(void (*ptr)(void)) {
    1caa:	df 93       	push	r29
    1cac:	cf 93       	push	r28
    1cae:	00 d0       	rcall	.+0      	; 0x1cb0 <MCAL_Interrupt_EXIT_CallBack_0+0x6>
    1cb0:	cd b7       	in	r28, 0x3d	; 61
    1cb2:	de b7       	in	r29, 0x3e	; 62
    1cb4:	9a 83       	std	Y+2, r25	; 0x02
    1cb6:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    1cb8:	89 81       	ldd	r24, Y+1	; 0x01
    1cba:	9a 81       	ldd	r25, Y+2	; 0x02
    1cbc:	00 97       	sbiw	r24, 0x00	; 0
    1cbe:	31 f0       	breq	.+12     	; 0x1ccc <MCAL_Interrupt_EXIT_CallBack_0+0x22>
		Gptr0 = ptr;
    1cc0:	89 81       	ldd	r24, Y+1	; 0x01
    1cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc4:	90 93 8b 01 	sts	0x018B, r25
    1cc8:	80 93 8a 01 	sts	0x018A, r24
}
    1ccc:	0f 90       	pop	r0
    1cce:	0f 90       	pop	r0
    1cd0:	cf 91       	pop	r28
    1cd2:	df 91       	pop	r29
    1cd4:	08 95       	ret

00001cd6 <MCAL_Interrupt_EXIT_CallBack_1>:
void MCAL_Interrupt_EXIT_CallBack_1(void (*ptr)(void)) {
    1cd6:	df 93       	push	r29
    1cd8:	cf 93       	push	r28
    1cda:	00 d0       	rcall	.+0      	; 0x1cdc <MCAL_Interrupt_EXIT_CallBack_1+0x6>
    1cdc:	cd b7       	in	r28, 0x3d	; 61
    1cde:	de b7       	in	r29, 0x3e	; 62
    1ce0:	9a 83       	std	Y+2, r25	; 0x02
    1ce2:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    1ce4:	89 81       	ldd	r24, Y+1	; 0x01
    1ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ce8:	00 97       	sbiw	r24, 0x00	; 0
    1cea:	31 f0       	breq	.+12     	; 0x1cf8 <MCAL_Interrupt_EXIT_CallBack_1+0x22>
		Gptr1 = ptr;
    1cec:	89 81       	ldd	r24, Y+1	; 0x01
    1cee:	9a 81       	ldd	r25, Y+2	; 0x02
    1cf0:	90 93 8d 01 	sts	0x018D, r25
    1cf4:	80 93 8c 01 	sts	0x018C, r24
}
    1cf8:	0f 90       	pop	r0
    1cfa:	0f 90       	pop	r0
    1cfc:	cf 91       	pop	r28
    1cfe:	df 91       	pop	r29
    1d00:	08 95       	ret

00001d02 <MCAL_Interrupt_EXIT_CallBack_2>:
void MCAL_Interrupt_EXIT_CallBack_2(void (*ptr)(void)) {
    1d02:	df 93       	push	r29
    1d04:	cf 93       	push	r28
    1d06:	00 d0       	rcall	.+0      	; 0x1d08 <MCAL_Interrupt_EXIT_CallBack_2+0x6>
    1d08:	cd b7       	in	r28, 0x3d	; 61
    1d0a:	de b7       	in	r29, 0x3e	; 62
    1d0c:	9a 83       	std	Y+2, r25	; 0x02
    1d0e:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    1d10:	89 81       	ldd	r24, Y+1	; 0x01
    1d12:	9a 81       	ldd	r25, Y+2	; 0x02
    1d14:	00 97       	sbiw	r24, 0x00	; 0
    1d16:	31 f0       	breq	.+12     	; 0x1d24 <MCAL_Interrupt_EXIT_CallBack_2+0x22>
		Gptr2 = ptr;
    1d18:	89 81       	ldd	r24, Y+1	; 0x01
    1d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d1c:	90 93 8f 01 	sts	0x018F, r25
    1d20:	80 93 8e 01 	sts	0x018E, r24
}
    1d24:	0f 90       	pop	r0
    1d26:	0f 90       	pop	r0
    1d28:	cf 91       	pop	r28
    1d2a:	df 91       	pop	r29
    1d2c:	08 95       	ret

00001d2e <MCAL_Interrupt_EnableGIE>:

void MCAL_Interrupt_EnableGIE(u8 Loc_u8value) {
    1d2e:	df 93       	push	r29
    1d30:	cf 93       	push	r28
    1d32:	0f 92       	push	r0
    1d34:	cd b7       	in	r28, 0x3d	; 61
    1d36:	de b7       	in	r29, 0x3e	; 62
    1d38:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8value == Enable) {
    1d3a:	89 81       	ldd	r24, Y+1	; 0x01
    1d3c:	81 30       	cpi	r24, 0x01	; 1
    1d3e:	31 f4       	brne	.+12     	; 0x1d4c <MCAL_Interrupt_EnableGIE+0x1e>
		MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_High);
    1d40:	80 e0       	ldi	r24, 0x00	; 0
    1d42:	67 e0       	ldi	r22, 0x07	; 7
    1d44:	41 e0       	ldi	r20, 0x01	; 1
    1d46:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
    1d4a:	08 c0       	rjmp	.+16     	; 0x1d5c <MCAL_Interrupt_EnableGIE+0x2e>
	} else if (Loc_u8value == Disable) {
    1d4c:	89 81       	ldd	r24, Y+1	; 0x01
    1d4e:	88 23       	and	r24, r24
    1d50:	29 f4       	brne	.+10     	; 0x1d5c <MCAL_Interrupt_EnableGIE+0x2e>
		MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_Low);
    1d52:	80 e0       	ldi	r24, 0x00	; 0
    1d54:	67 e0       	ldi	r22, 0x07	; 7
    1d56:	40 e0       	ldi	r20, 0x00	; 0
    1d58:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
	}
}
    1d5c:	0f 90       	pop	r0
    1d5e:	cf 91       	pop	r28
    1d60:	df 91       	pop	r29
    1d62:	08 95       	ret

00001d64 <MCAL_Interrupt_InterruptInit>:

void MCAL_Interrupt_InterruptInit() {
    1d64:	df 93       	push	r29
    1d66:	cf 93       	push	r28
    1d68:	cd b7       	in	r28, 0x3d	; 61
    1d6a:	de b7       	in	r29, 0x3e	; 62
	MCAL_Interrupt_u8SetRegisterPin(Sreg, SREG_Pin, Pin_High);
    1d6c:	80 e0       	ldi	r24, 0x00	; 0
    1d6e:	67 e0       	ldi	r22, 0x07	; 7
    1d70:	41 e0       	ldi	r20, 0x01	; 1
    1d72:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin6, Pin_High);
    1d76:	81 e0       	ldi	r24, 0x01	; 1
    1d78:	66 e0       	ldi	r22, 0x06	; 6
    1d7a:	41 e0       	ldi	r20, 0x01	; 1
    1d7c:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin7, Pin_High);
    1d80:	81 e0       	ldi	r24, 0x01	; 1
    1d82:	67 e0       	ldi	r22, 0x07	; 7
    1d84:	41 e0       	ldi	r20, 0x01	; 1
    1d86:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin5, Pin_High);
    1d8a:	81 e0       	ldi	r24, 0x01	; 1
    1d8c:	65 e0       	ldi	r22, 0x05	; 5
    1d8e:	41 e0       	ldi	r20, 0x01	; 1
    1d90:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin0 , Pin_High);
    1d94:	82 e0       	ldi	r24, 0x02	; 2
    1d96:	60 e0       	ldi	r22, 0x00	; 0
    1d98:	41 e0       	ldi	r20, 0x01	; 1
    1d9a:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin1 , Pin_High);
    1d9e:	82 e0       	ldi	r24, 0x02	; 2
    1da0:	61 e0       	ldi	r22, 0x01	; 1
    1da2:	41 e0       	ldi	r20, 0x01	; 1
    1da4:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
}
    1da8:	cf 91       	pop	r28
    1daa:	df 91       	pop	r29
    1dac:	08 95       	ret

00001dae <__vector_1>:

ISR(VECT_INT0) {
    1dae:	1f 92       	push	r1
    1db0:	0f 92       	push	r0
    1db2:	0f b6       	in	r0, 0x3f	; 63
    1db4:	0f 92       	push	r0
    1db6:	11 24       	eor	r1, r1
    1db8:	2f 93       	push	r18
    1dba:	3f 93       	push	r19
    1dbc:	4f 93       	push	r20
    1dbe:	5f 93       	push	r21
    1dc0:	6f 93       	push	r22
    1dc2:	7f 93       	push	r23
    1dc4:	8f 93       	push	r24
    1dc6:	9f 93       	push	r25
    1dc8:	af 93       	push	r26
    1dca:	bf 93       	push	r27
    1dcc:	ef 93       	push	r30
    1dce:	ff 93       	push	r31
    1dd0:	df 93       	push	r29
    1dd2:	cf 93       	push	r28
    1dd4:	cd b7       	in	r28, 0x3d	; 61
    1dd6:	de b7       	in	r29, 0x3e	; 62
	if (Gptr0 != '\0')
    1dd8:	80 91 8a 01 	lds	r24, 0x018A
    1ddc:	90 91 8b 01 	lds	r25, 0x018B
    1de0:	00 97       	sbiw	r24, 0x00	; 0
    1de2:	29 f0       	breq	.+10     	; 0x1dee <__vector_1+0x40>
		Gptr0();
    1de4:	e0 91 8a 01 	lds	r30, 0x018A
    1de8:	f0 91 8b 01 	lds	r31, 0x018B
    1dec:	09 95       	icall
}
    1dee:	cf 91       	pop	r28
    1df0:	df 91       	pop	r29
    1df2:	ff 91       	pop	r31
    1df4:	ef 91       	pop	r30
    1df6:	bf 91       	pop	r27
    1df8:	af 91       	pop	r26
    1dfa:	9f 91       	pop	r25
    1dfc:	8f 91       	pop	r24
    1dfe:	7f 91       	pop	r23
    1e00:	6f 91       	pop	r22
    1e02:	5f 91       	pop	r21
    1e04:	4f 91       	pop	r20
    1e06:	3f 91       	pop	r19
    1e08:	2f 91       	pop	r18
    1e0a:	0f 90       	pop	r0
    1e0c:	0f be       	out	0x3f, r0	; 63
    1e0e:	0f 90       	pop	r0
    1e10:	1f 90       	pop	r1
    1e12:	18 95       	reti

00001e14 <__vector_2>:
ISR(VECT_INT1) {
    1e14:	1f 92       	push	r1
    1e16:	0f 92       	push	r0
    1e18:	0f b6       	in	r0, 0x3f	; 63
    1e1a:	0f 92       	push	r0
    1e1c:	11 24       	eor	r1, r1
    1e1e:	2f 93       	push	r18
    1e20:	3f 93       	push	r19
    1e22:	4f 93       	push	r20
    1e24:	5f 93       	push	r21
    1e26:	6f 93       	push	r22
    1e28:	7f 93       	push	r23
    1e2a:	8f 93       	push	r24
    1e2c:	9f 93       	push	r25
    1e2e:	af 93       	push	r26
    1e30:	bf 93       	push	r27
    1e32:	ef 93       	push	r30
    1e34:	ff 93       	push	r31
    1e36:	df 93       	push	r29
    1e38:	cf 93       	push	r28
    1e3a:	cd b7       	in	r28, 0x3d	; 61
    1e3c:	de b7       	in	r29, 0x3e	; 62
	if (Gptr1 != '\0')
    1e3e:	80 91 8c 01 	lds	r24, 0x018C
    1e42:	90 91 8d 01 	lds	r25, 0x018D
    1e46:	00 97       	sbiw	r24, 0x00	; 0
    1e48:	29 f0       	breq	.+10     	; 0x1e54 <__vector_2+0x40>
		Gptr1();
    1e4a:	e0 91 8c 01 	lds	r30, 0x018C
    1e4e:	f0 91 8d 01 	lds	r31, 0x018D
    1e52:	09 95       	icall
}
    1e54:	cf 91       	pop	r28
    1e56:	df 91       	pop	r29
    1e58:	ff 91       	pop	r31
    1e5a:	ef 91       	pop	r30
    1e5c:	bf 91       	pop	r27
    1e5e:	af 91       	pop	r26
    1e60:	9f 91       	pop	r25
    1e62:	8f 91       	pop	r24
    1e64:	7f 91       	pop	r23
    1e66:	6f 91       	pop	r22
    1e68:	5f 91       	pop	r21
    1e6a:	4f 91       	pop	r20
    1e6c:	3f 91       	pop	r19
    1e6e:	2f 91       	pop	r18
    1e70:	0f 90       	pop	r0
    1e72:	0f be       	out	0x3f, r0	; 63
    1e74:	0f 90       	pop	r0
    1e76:	1f 90       	pop	r1
    1e78:	18 95       	reti

00001e7a <__vector_3>:
ISR(VECT_INT2) {
    1e7a:	1f 92       	push	r1
    1e7c:	0f 92       	push	r0
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	0f 92       	push	r0
    1e82:	11 24       	eor	r1, r1
    1e84:	2f 93       	push	r18
    1e86:	3f 93       	push	r19
    1e88:	4f 93       	push	r20
    1e8a:	5f 93       	push	r21
    1e8c:	6f 93       	push	r22
    1e8e:	7f 93       	push	r23
    1e90:	8f 93       	push	r24
    1e92:	9f 93       	push	r25
    1e94:	af 93       	push	r26
    1e96:	bf 93       	push	r27
    1e98:	ef 93       	push	r30
    1e9a:	ff 93       	push	r31
    1e9c:	df 93       	push	r29
    1e9e:	cf 93       	push	r28
    1ea0:	cd b7       	in	r28, 0x3d	; 61
    1ea2:	de b7       	in	r29, 0x3e	; 62
	if (Gptr2 != '\0')
    1ea4:	80 91 8e 01 	lds	r24, 0x018E
    1ea8:	90 91 8f 01 	lds	r25, 0x018F
    1eac:	00 97       	sbiw	r24, 0x00	; 0
    1eae:	29 f0       	breq	.+10     	; 0x1eba <__vector_3+0x40>
		Gptr2();
    1eb0:	e0 91 8e 01 	lds	r30, 0x018E
    1eb4:	f0 91 8f 01 	lds	r31, 0x018F
    1eb8:	09 95       	icall
}
    1eba:	cf 91       	pop	r28
    1ebc:	df 91       	pop	r29
    1ebe:	ff 91       	pop	r31
    1ec0:	ef 91       	pop	r30
    1ec2:	bf 91       	pop	r27
    1ec4:	af 91       	pop	r26
    1ec6:	9f 91       	pop	r25
    1ec8:	8f 91       	pop	r24
    1eca:	7f 91       	pop	r23
    1ecc:	6f 91       	pop	r22
    1ece:	5f 91       	pop	r21
    1ed0:	4f 91       	pop	r20
    1ed2:	3f 91       	pop	r19
    1ed4:	2f 91       	pop	r18
    1ed6:	0f 90       	pop	r0
    1ed8:	0f be       	out	0x3f, r0	; 63
    1eda:	0f 90       	pop	r0
    1edc:	1f 90       	pop	r1
    1ede:	18 95       	reti

00001ee0 <MCAL_DIO_u8SetPortDirection>:
 *      Author: Mohamed
 */

#include "DIO.h"

STD_Type MCAL_DIO_u8SetPortDirection(u8 Loc_u8PortID, u8 Loc_u8PortDirection) {
    1ee0:	df 93       	push	r29
    1ee2:	cf 93       	push	r28
    1ee4:	00 d0       	rcall	.+0      	; 0x1ee6 <MCAL_DIO_u8SetPortDirection+0x6>
    1ee6:	0f 92       	push	r0
    1ee8:	cd b7       	in	r28, 0x3d	; 61
    1eea:	de b7       	in	r29, 0x3e	; 62
    1eec:	8a 83       	std	Y+2, r24	; 0x02
    1eee:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    1ef0:	81 e0       	ldi	r24, 0x01	; 1
    1ef2:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PortDirection <= PORT_OUTPUT) {
    1ef4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef6:	84 30       	cpi	r24, 0x04	; 4
    1ef8:	08 f0       	brcs	.+2      	; 0x1efc <MCAL_DIO_u8SetPortDirection+0x1c>
    1efa:	6e c0       	rjmp	.+220    	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
		if (Loc_u8PortDirection == PORT_OUTPUT) {
    1efc:	8b 81       	ldd	r24, Y+3	; 0x03
    1efe:	8f 3f       	cpi	r24, 0xFF	; 255
    1f00:	29 f5       	brne	.+74     	; 0x1f4c <MCAL_DIO_u8SetPortDirection+0x6c>
			if (Loc_u8PortID == PortA) {
    1f02:	8a 81       	ldd	r24, Y+2	; 0x02
    1f04:	88 23       	and	r24, r24
    1f06:	31 f4       	brne	.+12     	; 0x1f14 <MCAL_DIO_u8SetPortDirection+0x34>
				DDRA = PORT_OUTPUT;
    1f08:	ea e3       	ldi	r30, 0x3A	; 58
    1f0a:	f0 e0       	ldi	r31, 0x00	; 0
    1f0c:	8f ef       	ldi	r24, 0xFF	; 255
    1f0e:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    1f10:	19 82       	std	Y+1, r1	; 0x01
    1f12:	62 c0       	rjmp	.+196    	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    1f14:	8a 81       	ldd	r24, Y+2	; 0x02
    1f16:	81 30       	cpi	r24, 0x01	; 1
    1f18:	31 f4       	brne	.+12     	; 0x1f26 <MCAL_DIO_u8SetPortDirection+0x46>
				DDRB = PORT_OUTPUT;
    1f1a:	e7 e3       	ldi	r30, 0x37	; 55
    1f1c:	f0 e0       	ldi	r31, 0x00	; 0
    1f1e:	8f ef       	ldi	r24, 0xFF	; 255
    1f20:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    1f22:	19 82       	std	Y+1, r1	; 0x01
    1f24:	59 c0       	rjmp	.+178    	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    1f26:	8a 81       	ldd	r24, Y+2	; 0x02
    1f28:	82 30       	cpi	r24, 0x02	; 2
    1f2a:	31 f4       	brne	.+12     	; 0x1f38 <MCAL_DIO_u8SetPortDirection+0x58>
				DDRC = PORT_OUTPUT;
    1f2c:	e4 e3       	ldi	r30, 0x34	; 52
    1f2e:	f0 e0       	ldi	r31, 0x00	; 0
    1f30:	8f ef       	ldi	r24, 0xFF	; 255
    1f32:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    1f34:	19 82       	std	Y+1, r1	; 0x01
    1f36:	50 c0       	rjmp	.+160    	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    1f38:	8a 81       	ldd	r24, Y+2	; 0x02
    1f3a:	83 30       	cpi	r24, 0x03	; 3
    1f3c:	09 f0       	breq	.+2      	; 0x1f40 <MCAL_DIO_u8SetPortDirection+0x60>
    1f3e:	4c c0       	rjmp	.+152    	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = PORT_OUTPUT;
    1f40:	e1 e3       	ldi	r30, 0x31	; 49
    1f42:	f0 e0       	ldi	r31, 0x00	; 0
    1f44:	8f ef       	ldi	r24, 0xFF	; 255
    1f46:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    1f48:	19 82       	std	Y+1, r1	; 0x01
    1f4a:	46 c0       	rjmp	.+140    	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PortDirection == PORT_INPUT) {
    1f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f4e:	88 23       	and	r24, r24
    1f50:	01 f5       	brne	.+64     	; 0x1f92 <MCAL_DIO_u8SetPortDirection+0xb2>
			if (Loc_u8PortID == PortA) {
    1f52:	8a 81       	ldd	r24, Y+2	; 0x02
    1f54:	88 23       	and	r24, r24
    1f56:	29 f4       	brne	.+10     	; 0x1f62 <MCAL_DIO_u8SetPortDirection+0x82>
				DDRA = PORT_INPUT;
    1f58:	ea e3       	ldi	r30, 0x3A	; 58
    1f5a:	f0 e0       	ldi	r31, 0x00	; 0
    1f5c:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    1f5e:	19 82       	std	Y+1, r1	; 0x01
    1f60:	3b c0       	rjmp	.+118    	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    1f62:	8a 81       	ldd	r24, Y+2	; 0x02
    1f64:	81 30       	cpi	r24, 0x01	; 1
    1f66:	29 f4       	brne	.+10     	; 0x1f72 <MCAL_DIO_u8SetPortDirection+0x92>
				DDRB = PORT_INPUT;
    1f68:	e7 e3       	ldi	r30, 0x37	; 55
    1f6a:	f0 e0       	ldi	r31, 0x00	; 0
    1f6c:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    1f6e:	19 82       	std	Y+1, r1	; 0x01
    1f70:	33 c0       	rjmp	.+102    	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    1f72:	8a 81       	ldd	r24, Y+2	; 0x02
    1f74:	82 30       	cpi	r24, 0x02	; 2
    1f76:	29 f4       	brne	.+10     	; 0x1f82 <MCAL_DIO_u8SetPortDirection+0xa2>
				DDRC = PORT_INPUT;
    1f78:	e4 e3       	ldi	r30, 0x34	; 52
    1f7a:	f0 e0       	ldi	r31, 0x00	; 0
    1f7c:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    1f7e:	19 82       	std	Y+1, r1	; 0x01
    1f80:	2b c0       	rjmp	.+86     	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    1f82:	8a 81       	ldd	r24, Y+2	; 0x02
    1f84:	83 30       	cpi	r24, 0x03	; 3
    1f86:	41 f5       	brne	.+80     	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = PORT_INPUT;
    1f88:	e1 e3       	ldi	r30, 0x31	; 49
    1f8a:	f0 e0       	ldi	r31, 0x00	; 0
    1f8c:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    1f8e:	19 82       	std	Y+1, r1	; 0x01
    1f90:	23 c0       	rjmp	.+70     	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else {
				//Do Nothing
			}
		} else {
			if (Loc_u8PortID == PortA) {
    1f92:	8a 81       	ldd	r24, Y+2	; 0x02
    1f94:	88 23       	and	r24, r24
    1f96:	31 f4       	brne	.+12     	; 0x1fa4 <MCAL_DIO_u8SetPortDirection+0xc4>
				DDRA = Loc_u8PortDirection;
    1f98:	ea e3       	ldi	r30, 0x3A	; 58
    1f9a:	f0 e0       	ldi	r31, 0x00	; 0
    1f9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9e:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    1fa0:	19 82       	std	Y+1, r1	; 0x01
    1fa2:	1a c0       	rjmp	.+52     	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortB) {
    1fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa6:	81 30       	cpi	r24, 0x01	; 1
    1fa8:	31 f4       	brne	.+12     	; 0x1fb6 <MCAL_DIO_u8SetPortDirection+0xd6>
				DDRB = Loc_u8PortDirection;
    1faa:	e7 e3       	ldi	r30, 0x37	; 55
    1fac:	f0 e0       	ldi	r31, 0x00	; 0
    1fae:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb0:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    1fb2:	19 82       	std	Y+1, r1	; 0x01
    1fb4:	11 c0       	rjmp	.+34     	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortC) {
    1fb6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb8:	82 30       	cpi	r24, 0x02	; 2
    1fba:	31 f4       	brne	.+12     	; 0x1fc8 <MCAL_DIO_u8SetPortDirection+0xe8>
				DDRC = Loc_u8PortDirection;
    1fbc:	e4 e3       	ldi	r30, 0x34	; 52
    1fbe:	f0 e0       	ldi	r31, 0x00	; 0
    1fc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc2:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    1fc4:	19 82       	std	Y+1, r1	; 0x01
    1fc6:	08 c0       	rjmp	.+16     	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
			} else if (Loc_u8PortID == PortD) {
    1fc8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fca:	83 30       	cpi	r24, 0x03	; 3
    1fcc:	29 f4       	brne	.+10     	; 0x1fd8 <MCAL_DIO_u8SetPortDirection+0xf8>
				DDRD = Loc_u8PortDirection;
    1fce:	e1 e3       	ldi	r30, 0x31	; 49
    1fd0:	f0 e0       	ldi	r31, 0x00	; 0
    1fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd4:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    1fd6:	19 82       	std	Y+1, r1	; 0x01
			}
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    1fd8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fda:	0f 90       	pop	r0
    1fdc:	0f 90       	pop	r0
    1fde:	0f 90       	pop	r0
    1fe0:	cf 91       	pop	r28
    1fe2:	df 91       	pop	r29
    1fe4:	08 95       	ret

00001fe6 <MCAL_DIO_u8SetPinDirection>:

STD_Type MCAL_DIO_u8SetPinDirection(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinDirection) {
    1fe6:	df 93       	push	r29
    1fe8:	cf 93       	push	r28
    1fea:	00 d0       	rcall	.+0      	; 0x1fec <MCAL_DIO_u8SetPinDirection+0x6>
    1fec:	00 d0       	rcall	.+0      	; 0x1fee <MCAL_DIO_u8SetPinDirection+0x8>
    1fee:	cd b7       	in	r28, 0x3d	; 61
    1ff0:	de b7       	in	r29, 0x3e	; 62
    1ff2:	8a 83       	std	Y+2, r24	; 0x02
    1ff4:	6b 83       	std	Y+3, r22	; 0x03
    1ff6:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins
    1ffc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffe:	84 30       	cpi	r24, 0x04	; 4
    2000:	08 f0       	brcs	.+2      	; 0x2004 <MCAL_DIO_u8SetPinDirection+0x1e>
    2002:	d4 c0       	rjmp	.+424    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	88 30       	cpi	r24, 0x08	; 8
    2008:	08 f0       	brcs	.+2      	; 0x200c <MCAL_DIO_u8SetPinDirection+0x26>
    200a:	d0 c0       	rjmp	.+416    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
    200c:	8c 81       	ldd	r24, Y+4	; 0x04
    200e:	82 30       	cpi	r24, 0x02	; 2
    2010:	08 f0       	brcs	.+2      	; 0x2014 <MCAL_DIO_u8SetPinDirection+0x2e>
    2012:	cc c0       	rjmp	.+408    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			&& Loc_u8PinDirection <= Pin_High) {
		if (Loc_u8PinDirection == Pin_High) {
    2014:	8c 81       	ldd	r24, Y+4	; 0x04
    2016:	81 30       	cpi	r24, 0x01	; 1
    2018:	09 f0       	breq	.+2      	; 0x201c <MCAL_DIO_u8SetPinDirection+0x36>
    201a:	61 c0       	rjmp	.+194    	; 0x20de <MCAL_DIO_u8SetPinDirection+0xf8>
			if (Loc_u8PortID == PortA) {
    201c:	8a 81       	ldd	r24, Y+2	; 0x02
    201e:	88 23       	and	r24, r24
    2020:	a9 f4       	brne	.+42     	; 0x204c <MCAL_DIO_u8SetPinDirection+0x66>
				SET_BIT(DDRA, Loc_u8PinID);
    2022:	aa e3       	ldi	r26, 0x3A	; 58
    2024:	b0 e0       	ldi	r27, 0x00	; 0
    2026:	ea e3       	ldi	r30, 0x3A	; 58
    2028:	f0 e0       	ldi	r31, 0x00	; 0
    202a:	80 81       	ld	r24, Z
    202c:	48 2f       	mov	r20, r24
    202e:	8b 81       	ldd	r24, Y+3	; 0x03
    2030:	28 2f       	mov	r18, r24
    2032:	30 e0       	ldi	r19, 0x00	; 0
    2034:	81 e0       	ldi	r24, 0x01	; 1
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	02 2e       	mov	r0, r18
    203a:	02 c0       	rjmp	.+4      	; 0x2040 <MCAL_DIO_u8SetPinDirection+0x5a>
    203c:	88 0f       	add	r24, r24
    203e:	99 1f       	adc	r25, r25
    2040:	0a 94       	dec	r0
    2042:	e2 f7       	brpl	.-8      	; 0x203c <MCAL_DIO_u8SetPinDirection+0x56>
    2044:	84 2b       	or	r24, r20
    2046:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2048:	19 82       	std	Y+1, r1	; 0x01
    204a:	b0 c0       	rjmp	.+352    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    204c:	8a 81       	ldd	r24, Y+2	; 0x02
    204e:	81 30       	cpi	r24, 0x01	; 1
    2050:	a9 f4       	brne	.+42     	; 0x207c <MCAL_DIO_u8SetPinDirection+0x96>
				SET_BIT(DDRB, Loc_u8PinID);
    2052:	a7 e3       	ldi	r26, 0x37	; 55
    2054:	b0 e0       	ldi	r27, 0x00	; 0
    2056:	e7 e3       	ldi	r30, 0x37	; 55
    2058:	f0 e0       	ldi	r31, 0x00	; 0
    205a:	80 81       	ld	r24, Z
    205c:	48 2f       	mov	r20, r24
    205e:	8b 81       	ldd	r24, Y+3	; 0x03
    2060:	28 2f       	mov	r18, r24
    2062:	30 e0       	ldi	r19, 0x00	; 0
    2064:	81 e0       	ldi	r24, 0x01	; 1
    2066:	90 e0       	ldi	r25, 0x00	; 0
    2068:	02 2e       	mov	r0, r18
    206a:	02 c0       	rjmp	.+4      	; 0x2070 <MCAL_DIO_u8SetPinDirection+0x8a>
    206c:	88 0f       	add	r24, r24
    206e:	99 1f       	adc	r25, r25
    2070:	0a 94       	dec	r0
    2072:	e2 f7       	brpl	.-8      	; 0x206c <MCAL_DIO_u8SetPinDirection+0x86>
    2074:	84 2b       	or	r24, r20
    2076:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2078:	19 82       	std	Y+1, r1	; 0x01
    207a:	98 c0       	rjmp	.+304    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    207c:	8a 81       	ldd	r24, Y+2	; 0x02
    207e:	82 30       	cpi	r24, 0x02	; 2
    2080:	a9 f4       	brne	.+42     	; 0x20ac <MCAL_DIO_u8SetPinDirection+0xc6>
				SET_BIT(DDRC, Loc_u8PinID);
    2082:	a4 e3       	ldi	r26, 0x34	; 52
    2084:	b0 e0       	ldi	r27, 0x00	; 0
    2086:	e4 e3       	ldi	r30, 0x34	; 52
    2088:	f0 e0       	ldi	r31, 0x00	; 0
    208a:	80 81       	ld	r24, Z
    208c:	48 2f       	mov	r20, r24
    208e:	8b 81       	ldd	r24, Y+3	; 0x03
    2090:	28 2f       	mov	r18, r24
    2092:	30 e0       	ldi	r19, 0x00	; 0
    2094:	81 e0       	ldi	r24, 0x01	; 1
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	02 2e       	mov	r0, r18
    209a:	02 c0       	rjmp	.+4      	; 0x20a0 <MCAL_DIO_u8SetPinDirection+0xba>
    209c:	88 0f       	add	r24, r24
    209e:	99 1f       	adc	r25, r25
    20a0:	0a 94       	dec	r0
    20a2:	e2 f7       	brpl	.-8      	; 0x209c <MCAL_DIO_u8SetPinDirection+0xb6>
    20a4:	84 2b       	or	r24, r20
    20a6:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    20a8:	19 82       	std	Y+1, r1	; 0x01
    20aa:	80 c0       	rjmp	.+256    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    20ac:	8a 81       	ldd	r24, Y+2	; 0x02
    20ae:	83 30       	cpi	r24, 0x03	; 3
    20b0:	09 f0       	breq	.+2      	; 0x20b4 <MCAL_DIO_u8SetPinDirection+0xce>
    20b2:	7c c0       	rjmp	.+248    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
				SET_BIT(DDRD, Loc_u8PinID);
    20b4:	a1 e3       	ldi	r26, 0x31	; 49
    20b6:	b0 e0       	ldi	r27, 0x00	; 0
    20b8:	e1 e3       	ldi	r30, 0x31	; 49
    20ba:	f0 e0       	ldi	r31, 0x00	; 0
    20bc:	80 81       	ld	r24, Z
    20be:	48 2f       	mov	r20, r24
    20c0:	8b 81       	ldd	r24, Y+3	; 0x03
    20c2:	28 2f       	mov	r18, r24
    20c4:	30 e0       	ldi	r19, 0x00	; 0
    20c6:	81 e0       	ldi	r24, 0x01	; 1
    20c8:	90 e0       	ldi	r25, 0x00	; 0
    20ca:	02 2e       	mov	r0, r18
    20cc:	02 c0       	rjmp	.+4      	; 0x20d2 <MCAL_DIO_u8SetPinDirection+0xec>
    20ce:	88 0f       	add	r24, r24
    20d0:	99 1f       	adc	r25, r25
    20d2:	0a 94       	dec	r0
    20d4:	e2 f7       	brpl	.-8      	; 0x20ce <MCAL_DIO_u8SetPinDirection+0xe8>
    20d6:	84 2b       	or	r24, r20
    20d8:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    20da:	19 82       	std	Y+1, r1	; 0x01
    20dc:	67 c0       	rjmp	.+206    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PinDirection == Pin_Low) {
    20de:	8c 81       	ldd	r24, Y+4	; 0x04
    20e0:	88 23       	and	r24, r24
    20e2:	09 f0       	breq	.+2      	; 0x20e6 <MCAL_DIO_u8SetPinDirection+0x100>
    20e4:	63 c0       	rjmp	.+198    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			if (Loc_u8PortID == PortA) {
    20e6:	8a 81       	ldd	r24, Y+2	; 0x02
    20e8:	88 23       	and	r24, r24
    20ea:	b1 f4       	brne	.+44     	; 0x2118 <MCAL_DIO_u8SetPinDirection+0x132>
				CLR_BIT(DDRA, Loc_u8PinID);
    20ec:	aa e3       	ldi	r26, 0x3A	; 58
    20ee:	b0 e0       	ldi	r27, 0x00	; 0
    20f0:	ea e3       	ldi	r30, 0x3A	; 58
    20f2:	f0 e0       	ldi	r31, 0x00	; 0
    20f4:	80 81       	ld	r24, Z
    20f6:	48 2f       	mov	r20, r24
    20f8:	8b 81       	ldd	r24, Y+3	; 0x03
    20fa:	28 2f       	mov	r18, r24
    20fc:	30 e0       	ldi	r19, 0x00	; 0
    20fe:	81 e0       	ldi	r24, 0x01	; 1
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	02 2e       	mov	r0, r18
    2104:	02 c0       	rjmp	.+4      	; 0x210a <MCAL_DIO_u8SetPinDirection+0x124>
    2106:	88 0f       	add	r24, r24
    2108:	99 1f       	adc	r25, r25
    210a:	0a 94       	dec	r0
    210c:	e2 f7       	brpl	.-8      	; 0x2106 <MCAL_DIO_u8SetPinDirection+0x120>
    210e:	80 95       	com	r24
    2110:	84 23       	and	r24, r20
    2112:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2114:	19 82       	std	Y+1, r1	; 0x01
    2116:	4a c0       	rjmp	.+148    	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    2118:	8a 81       	ldd	r24, Y+2	; 0x02
    211a:	81 30       	cpi	r24, 0x01	; 1
    211c:	b1 f4       	brne	.+44     	; 0x214a <MCAL_DIO_u8SetPinDirection+0x164>
				CLR_BIT(DDRB, Loc_u8PinID);
    211e:	a7 e3       	ldi	r26, 0x37	; 55
    2120:	b0 e0       	ldi	r27, 0x00	; 0
    2122:	e7 e3       	ldi	r30, 0x37	; 55
    2124:	f0 e0       	ldi	r31, 0x00	; 0
    2126:	80 81       	ld	r24, Z
    2128:	48 2f       	mov	r20, r24
    212a:	8b 81       	ldd	r24, Y+3	; 0x03
    212c:	28 2f       	mov	r18, r24
    212e:	30 e0       	ldi	r19, 0x00	; 0
    2130:	81 e0       	ldi	r24, 0x01	; 1
    2132:	90 e0       	ldi	r25, 0x00	; 0
    2134:	02 2e       	mov	r0, r18
    2136:	02 c0       	rjmp	.+4      	; 0x213c <MCAL_DIO_u8SetPinDirection+0x156>
    2138:	88 0f       	add	r24, r24
    213a:	99 1f       	adc	r25, r25
    213c:	0a 94       	dec	r0
    213e:	e2 f7       	brpl	.-8      	; 0x2138 <MCAL_DIO_u8SetPinDirection+0x152>
    2140:	80 95       	com	r24
    2142:	84 23       	and	r24, r20
    2144:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2146:	19 82       	std	Y+1, r1	; 0x01
    2148:	31 c0       	rjmp	.+98     	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    214a:	8a 81       	ldd	r24, Y+2	; 0x02
    214c:	82 30       	cpi	r24, 0x02	; 2
    214e:	b1 f4       	brne	.+44     	; 0x217c <MCAL_DIO_u8SetPinDirection+0x196>
				CLR_BIT(DDRC, Loc_u8PinID);
    2150:	a4 e3       	ldi	r26, 0x34	; 52
    2152:	b0 e0       	ldi	r27, 0x00	; 0
    2154:	e4 e3       	ldi	r30, 0x34	; 52
    2156:	f0 e0       	ldi	r31, 0x00	; 0
    2158:	80 81       	ld	r24, Z
    215a:	48 2f       	mov	r20, r24
    215c:	8b 81       	ldd	r24, Y+3	; 0x03
    215e:	28 2f       	mov	r18, r24
    2160:	30 e0       	ldi	r19, 0x00	; 0
    2162:	81 e0       	ldi	r24, 0x01	; 1
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	02 2e       	mov	r0, r18
    2168:	02 c0       	rjmp	.+4      	; 0x216e <MCAL_DIO_u8SetPinDirection+0x188>
    216a:	88 0f       	add	r24, r24
    216c:	99 1f       	adc	r25, r25
    216e:	0a 94       	dec	r0
    2170:	e2 f7       	brpl	.-8      	; 0x216a <MCAL_DIO_u8SetPinDirection+0x184>
    2172:	80 95       	com	r24
    2174:	84 23       	and	r24, r20
    2176:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2178:	19 82       	std	Y+1, r1	; 0x01
    217a:	18 c0       	rjmp	.+48     	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    217c:	8a 81       	ldd	r24, Y+2	; 0x02
    217e:	83 30       	cpi	r24, 0x03	; 3
    2180:	a9 f4       	brne	.+42     	; 0x21ac <MCAL_DIO_u8SetPinDirection+0x1c6>
				CLR_BIT(DDRD, Loc_u8PinID);
    2182:	a1 e3       	ldi	r26, 0x31	; 49
    2184:	b0 e0       	ldi	r27, 0x00	; 0
    2186:	e1 e3       	ldi	r30, 0x31	; 49
    2188:	f0 e0       	ldi	r31, 0x00	; 0
    218a:	80 81       	ld	r24, Z
    218c:	48 2f       	mov	r20, r24
    218e:	8b 81       	ldd	r24, Y+3	; 0x03
    2190:	28 2f       	mov	r18, r24
    2192:	30 e0       	ldi	r19, 0x00	; 0
    2194:	81 e0       	ldi	r24, 0x01	; 1
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	02 2e       	mov	r0, r18
    219a:	02 c0       	rjmp	.+4      	; 0x21a0 <MCAL_DIO_u8SetPinDirection+0x1ba>
    219c:	88 0f       	add	r24, r24
    219e:	99 1f       	adc	r25, r25
    21a0:	0a 94       	dec	r0
    21a2:	e2 f7       	brpl	.-8      	; 0x219c <MCAL_DIO_u8SetPinDirection+0x1b6>
    21a4:	80 95       	com	r24
    21a6:	84 23       	and	r24, r20
    21a8:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    21aa:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    21ac:	89 81       	ldd	r24, Y+1	; 0x01

}
    21ae:	0f 90       	pop	r0
    21b0:	0f 90       	pop	r0
    21b2:	0f 90       	pop	r0
    21b4:	0f 90       	pop	r0
    21b6:	cf 91       	pop	r28
    21b8:	df 91       	pop	r29
    21ba:	08 95       	ret

000021bc <MCAL_DIO_u8SetPortValue>:

STD_Type MCAL_DIO_u8SetPortValue(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    21bc:	df 93       	push	r29
    21be:	cf 93       	push	r28
    21c0:	00 d0       	rcall	.+0      	; 0x21c2 <MCAL_DIO_u8SetPortValue+0x6>
    21c2:	0f 92       	push	r0
    21c4:	cd b7       	in	r28, 0x3d	; 61
    21c6:	de b7       	in	r29, 0x3e	; 62
    21c8:	8a 83       	std	Y+2, r24	; 0x02
    21ca:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    21cc:	81 e0       	ldi	r24, 0x01	; 1
    21ce:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PortValue <= PORT_OUTPUT) {
    21d0:	8a 81       	ldd	r24, Y+2	; 0x02
    21d2:	84 30       	cpi	r24, 0x04	; 4
    21d4:	08 f0       	brcs	.+2      	; 0x21d8 <MCAL_DIO_u8SetPortValue+0x1c>
    21d6:	6e c0       	rjmp	.+220    	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
		if (Loc_u8PortValue == PORT_OUTPUT) {
    21d8:	8b 81       	ldd	r24, Y+3	; 0x03
    21da:	8f 3f       	cpi	r24, 0xFF	; 255
    21dc:	29 f5       	brne	.+74     	; 0x2228 <MCAL_DIO_u8SetPortValue+0x6c>
			if (Loc_u8PortID == PortA) {
    21de:	8a 81       	ldd	r24, Y+2	; 0x02
    21e0:	88 23       	and	r24, r24
    21e2:	31 f4       	brne	.+12     	; 0x21f0 <MCAL_DIO_u8SetPortValue+0x34>
				PORTA = PORT_OUTPUT;
    21e4:	eb e3       	ldi	r30, 0x3B	; 59
    21e6:	f0 e0       	ldi	r31, 0x00	; 0
    21e8:	8f ef       	ldi	r24, 0xFF	; 255
    21ea:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    21ec:	19 82       	std	Y+1, r1	; 0x01
    21ee:	62 c0       	rjmp	.+196    	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    21f0:	8a 81       	ldd	r24, Y+2	; 0x02
    21f2:	81 30       	cpi	r24, 0x01	; 1
    21f4:	31 f4       	brne	.+12     	; 0x2202 <MCAL_DIO_u8SetPortValue+0x46>
				PORTB = PORT_OUTPUT;
    21f6:	e8 e3       	ldi	r30, 0x38	; 56
    21f8:	f0 e0       	ldi	r31, 0x00	; 0
    21fa:	8f ef       	ldi	r24, 0xFF	; 255
    21fc:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    21fe:	19 82       	std	Y+1, r1	; 0x01
    2200:	59 c0       	rjmp	.+178    	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2202:	8a 81       	ldd	r24, Y+2	; 0x02
    2204:	82 30       	cpi	r24, 0x02	; 2
    2206:	31 f4       	brne	.+12     	; 0x2214 <MCAL_DIO_u8SetPortValue+0x58>
				PORTC = PORT_OUTPUT;
    2208:	e5 e3       	ldi	r30, 0x35	; 53
    220a:	f0 e0       	ldi	r31, 0x00	; 0
    220c:	8f ef       	ldi	r24, 0xFF	; 255
    220e:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2210:	19 82       	std	Y+1, r1	; 0x01
    2212:	50 c0       	rjmp	.+160    	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    2214:	8a 81       	ldd	r24, Y+2	; 0x02
    2216:	83 30       	cpi	r24, 0x03	; 3
    2218:	09 f0       	breq	.+2      	; 0x221c <MCAL_DIO_u8SetPortValue+0x60>
    221a:	4c c0       	rjmp	.+152    	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = PORT_OUTPUT;
    221c:	e2 e3       	ldi	r30, 0x32	; 50
    221e:	f0 e0       	ldi	r31, 0x00	; 0
    2220:	8f ef       	ldi	r24, 0xFF	; 255
    2222:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    2224:	19 82       	std	Y+1, r1	; 0x01
    2226:	46 c0       	rjmp	.+140    	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PortValue == PORT_INPUT) {
    2228:	8b 81       	ldd	r24, Y+3	; 0x03
    222a:	88 23       	and	r24, r24
    222c:	01 f5       	brne	.+64     	; 0x226e <MCAL_DIO_u8SetPortValue+0xb2>
			if (Loc_u8PortID == PortA) {
    222e:	8a 81       	ldd	r24, Y+2	; 0x02
    2230:	88 23       	and	r24, r24
    2232:	29 f4       	brne	.+10     	; 0x223e <MCAL_DIO_u8SetPortValue+0x82>
				PORTA = PORT_INPUT;
    2234:	eb e3       	ldi	r30, 0x3B	; 59
    2236:	f0 e0       	ldi	r31, 0x00	; 0
    2238:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    223a:	19 82       	std	Y+1, r1	; 0x01
    223c:	3b c0       	rjmp	.+118    	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    223e:	8a 81       	ldd	r24, Y+2	; 0x02
    2240:	81 30       	cpi	r24, 0x01	; 1
    2242:	29 f4       	brne	.+10     	; 0x224e <MCAL_DIO_u8SetPortValue+0x92>
				PORTB = PORT_INPUT;
    2244:	e8 e3       	ldi	r30, 0x38	; 56
    2246:	f0 e0       	ldi	r31, 0x00	; 0
    2248:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    224a:	19 82       	std	Y+1, r1	; 0x01
    224c:	33 c0       	rjmp	.+102    	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    224e:	8a 81       	ldd	r24, Y+2	; 0x02
    2250:	82 30       	cpi	r24, 0x02	; 2
    2252:	29 f4       	brne	.+10     	; 0x225e <MCAL_DIO_u8SetPortValue+0xa2>
				PORTC = PORT_INPUT;
    2254:	e5 e3       	ldi	r30, 0x35	; 53
    2256:	f0 e0       	ldi	r31, 0x00	; 0
    2258:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    225a:	19 82       	std	Y+1, r1	; 0x01
    225c:	2b c0       	rjmp	.+86     	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    225e:	8a 81       	ldd	r24, Y+2	; 0x02
    2260:	83 30       	cpi	r24, 0x03	; 3
    2262:	41 f5       	brne	.+80     	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = PORT_INPUT;
    2264:	e2 e3       	ldi	r30, 0x32	; 50
    2266:	f0 e0       	ldi	r31, 0x00	; 0
    2268:	10 82       	st	Z, r1
				Loc_u8Return_Value = E_OK;
    226a:	19 82       	std	Y+1, r1	; 0x01
    226c:	23 c0       	rjmp	.+70     	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else {
				//Do Nothing
			}
		} else {
			if (Loc_u8PortID == PortA) {
    226e:	8a 81       	ldd	r24, Y+2	; 0x02
    2270:	88 23       	and	r24, r24
    2272:	31 f4       	brne	.+12     	; 0x2280 <MCAL_DIO_u8SetPortValue+0xc4>
				PORTA = Loc_u8PortValue;
    2274:	eb e3       	ldi	r30, 0x3B	; 59
    2276:	f0 e0       	ldi	r31, 0x00	; 0
    2278:	8b 81       	ldd	r24, Y+3	; 0x03
    227a:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    227c:	19 82       	std	Y+1, r1	; 0x01
    227e:	1a c0       	rjmp	.+52     	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortB) {
    2280:	8a 81       	ldd	r24, Y+2	; 0x02
    2282:	81 30       	cpi	r24, 0x01	; 1
    2284:	31 f4       	brne	.+12     	; 0x2292 <MCAL_DIO_u8SetPortValue+0xd6>
				PORTB = Loc_u8PortValue;
    2286:	e8 e3       	ldi	r30, 0x38	; 56
    2288:	f0 e0       	ldi	r31, 0x00	; 0
    228a:	8b 81       	ldd	r24, Y+3	; 0x03
    228c:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    228e:	19 82       	std	Y+1, r1	; 0x01
    2290:	11 c0       	rjmp	.+34     	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortC) {
    2292:	8a 81       	ldd	r24, Y+2	; 0x02
    2294:	82 30       	cpi	r24, 0x02	; 2
    2296:	31 f4       	brne	.+12     	; 0x22a4 <MCAL_DIO_u8SetPortValue+0xe8>
				PORTC = Loc_u8PortValue;
    2298:	e5 e3       	ldi	r30, 0x35	; 53
    229a:	f0 e0       	ldi	r31, 0x00	; 0
    229c:	8b 81       	ldd	r24, Y+3	; 0x03
    229e:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    22a0:	19 82       	std	Y+1, r1	; 0x01
    22a2:	08 c0       	rjmp	.+16     	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
			} else if (Loc_u8PortID == PortD) {
    22a4:	8a 81       	ldd	r24, Y+2	; 0x02
    22a6:	83 30       	cpi	r24, 0x03	; 3
    22a8:	29 f4       	brne	.+10     	; 0x22b4 <MCAL_DIO_u8SetPortValue+0xf8>
				PORTD = Loc_u8PortValue;
    22aa:	e2 e3       	ldi	r30, 0x32	; 50
    22ac:	f0 e0       	ldi	r31, 0x00	; 0
    22ae:	8b 81       	ldd	r24, Y+3	; 0x03
    22b0:	80 83       	st	Z, r24
				Loc_u8Return_Value = E_OK;
    22b2:	19 82       	std	Y+1, r1	; 0x01
			}
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    22b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    22b6:	0f 90       	pop	r0
    22b8:	0f 90       	pop	r0
    22ba:	0f 90       	pop	r0
    22bc:	cf 91       	pop	r28
    22be:	df 91       	pop	r29
    22c0:	08 95       	ret

000022c2 <MCAL_DIO_u8SetPinValue>:

STD_Type MCAL_DIO_u8SetPinValue(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    22c2:	df 93       	push	r29
    22c4:	cf 93       	push	r28
    22c6:	00 d0       	rcall	.+0      	; 0x22c8 <MCAL_DIO_u8SetPinValue+0x6>
    22c8:	00 d0       	rcall	.+0      	; 0x22ca <MCAL_DIO_u8SetPinValue+0x8>
    22ca:	cd b7       	in	r28, 0x3d	; 61
    22cc:	de b7       	in	r29, 0x3e	; 62
    22ce:	8a 83       	std	Y+2, r24	; 0x02
    22d0:	6b 83       	std	Y+3, r22	; 0x03
    22d2:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    22d4:	81 e0       	ldi	r24, 0x01	; 1
    22d6:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins
    22d8:	8a 81       	ldd	r24, Y+2	; 0x02
    22da:	84 30       	cpi	r24, 0x04	; 4
    22dc:	08 f0       	brcs	.+2      	; 0x22e0 <MCAL_DIO_u8SetPinValue+0x1e>
    22de:	d4 c0       	rjmp	.+424    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
    22e0:	8b 81       	ldd	r24, Y+3	; 0x03
    22e2:	88 30       	cpi	r24, 0x08	; 8
    22e4:	08 f0       	brcs	.+2      	; 0x22e8 <MCAL_DIO_u8SetPinValue+0x26>
    22e6:	d0 c0       	rjmp	.+416    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
    22e8:	8c 81       	ldd	r24, Y+4	; 0x04
    22ea:	82 30       	cpi	r24, 0x02	; 2
    22ec:	08 f0       	brcs	.+2      	; 0x22f0 <MCAL_DIO_u8SetPinValue+0x2e>
    22ee:	cc c0       	rjmp	.+408    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			&& Loc_u8PinValue <= Pin_High) {
		if (Loc_u8PinValue == Pin_High) {
    22f0:	8c 81       	ldd	r24, Y+4	; 0x04
    22f2:	81 30       	cpi	r24, 0x01	; 1
    22f4:	09 f0       	breq	.+2      	; 0x22f8 <MCAL_DIO_u8SetPinValue+0x36>
    22f6:	61 c0       	rjmp	.+194    	; 0x23ba <MCAL_DIO_u8SetPinValue+0xf8>
			if (Loc_u8PortID == PortA) {
    22f8:	8a 81       	ldd	r24, Y+2	; 0x02
    22fa:	88 23       	and	r24, r24
    22fc:	a9 f4       	brne	.+42     	; 0x2328 <MCAL_DIO_u8SetPinValue+0x66>
				SET_BIT(PORTA, Loc_u8PinID);
    22fe:	ab e3       	ldi	r26, 0x3B	; 59
    2300:	b0 e0       	ldi	r27, 0x00	; 0
    2302:	eb e3       	ldi	r30, 0x3B	; 59
    2304:	f0 e0       	ldi	r31, 0x00	; 0
    2306:	80 81       	ld	r24, Z
    2308:	48 2f       	mov	r20, r24
    230a:	8b 81       	ldd	r24, Y+3	; 0x03
    230c:	28 2f       	mov	r18, r24
    230e:	30 e0       	ldi	r19, 0x00	; 0
    2310:	81 e0       	ldi	r24, 0x01	; 1
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	02 2e       	mov	r0, r18
    2316:	02 c0       	rjmp	.+4      	; 0x231c <MCAL_DIO_u8SetPinValue+0x5a>
    2318:	88 0f       	add	r24, r24
    231a:	99 1f       	adc	r25, r25
    231c:	0a 94       	dec	r0
    231e:	e2 f7       	brpl	.-8      	; 0x2318 <MCAL_DIO_u8SetPinValue+0x56>
    2320:	84 2b       	or	r24, r20
    2322:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2324:	19 82       	std	Y+1, r1	; 0x01
    2326:	b0 c0       	rjmp	.+352    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    2328:	8a 81       	ldd	r24, Y+2	; 0x02
    232a:	81 30       	cpi	r24, 0x01	; 1
    232c:	a9 f4       	brne	.+42     	; 0x2358 <MCAL_DIO_u8SetPinValue+0x96>
				SET_BIT(PORTB, Loc_u8PinID);
    232e:	a8 e3       	ldi	r26, 0x38	; 56
    2330:	b0 e0       	ldi	r27, 0x00	; 0
    2332:	e8 e3       	ldi	r30, 0x38	; 56
    2334:	f0 e0       	ldi	r31, 0x00	; 0
    2336:	80 81       	ld	r24, Z
    2338:	48 2f       	mov	r20, r24
    233a:	8b 81       	ldd	r24, Y+3	; 0x03
    233c:	28 2f       	mov	r18, r24
    233e:	30 e0       	ldi	r19, 0x00	; 0
    2340:	81 e0       	ldi	r24, 0x01	; 1
    2342:	90 e0       	ldi	r25, 0x00	; 0
    2344:	02 2e       	mov	r0, r18
    2346:	02 c0       	rjmp	.+4      	; 0x234c <MCAL_DIO_u8SetPinValue+0x8a>
    2348:	88 0f       	add	r24, r24
    234a:	99 1f       	adc	r25, r25
    234c:	0a 94       	dec	r0
    234e:	e2 f7       	brpl	.-8      	; 0x2348 <MCAL_DIO_u8SetPinValue+0x86>
    2350:	84 2b       	or	r24, r20
    2352:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2354:	19 82       	std	Y+1, r1	; 0x01
    2356:	98 c0       	rjmp	.+304    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    2358:	8a 81       	ldd	r24, Y+2	; 0x02
    235a:	82 30       	cpi	r24, 0x02	; 2
    235c:	a9 f4       	brne	.+42     	; 0x2388 <MCAL_DIO_u8SetPinValue+0xc6>
				SET_BIT(PORTC, Loc_u8PinID);
    235e:	a5 e3       	ldi	r26, 0x35	; 53
    2360:	b0 e0       	ldi	r27, 0x00	; 0
    2362:	e5 e3       	ldi	r30, 0x35	; 53
    2364:	f0 e0       	ldi	r31, 0x00	; 0
    2366:	80 81       	ld	r24, Z
    2368:	48 2f       	mov	r20, r24
    236a:	8b 81       	ldd	r24, Y+3	; 0x03
    236c:	28 2f       	mov	r18, r24
    236e:	30 e0       	ldi	r19, 0x00	; 0
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	90 e0       	ldi	r25, 0x00	; 0
    2374:	02 2e       	mov	r0, r18
    2376:	02 c0       	rjmp	.+4      	; 0x237c <MCAL_DIO_u8SetPinValue+0xba>
    2378:	88 0f       	add	r24, r24
    237a:	99 1f       	adc	r25, r25
    237c:	0a 94       	dec	r0
    237e:	e2 f7       	brpl	.-8      	; 0x2378 <MCAL_DIO_u8SetPinValue+0xb6>
    2380:	84 2b       	or	r24, r20
    2382:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2384:	19 82       	std	Y+1, r1	; 0x01
    2386:	80 c0       	rjmp	.+256    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    2388:	8a 81       	ldd	r24, Y+2	; 0x02
    238a:	83 30       	cpi	r24, 0x03	; 3
    238c:	09 f0       	breq	.+2      	; 0x2390 <MCAL_DIO_u8SetPinValue+0xce>
    238e:	7c c0       	rjmp	.+248    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
				SET_BIT(PORTD, Loc_u8PinID);
    2390:	a2 e3       	ldi	r26, 0x32	; 50
    2392:	b0 e0       	ldi	r27, 0x00	; 0
    2394:	e2 e3       	ldi	r30, 0x32	; 50
    2396:	f0 e0       	ldi	r31, 0x00	; 0
    2398:	80 81       	ld	r24, Z
    239a:	48 2f       	mov	r20, r24
    239c:	8b 81       	ldd	r24, Y+3	; 0x03
    239e:	28 2f       	mov	r18, r24
    23a0:	30 e0       	ldi	r19, 0x00	; 0
    23a2:	81 e0       	ldi	r24, 0x01	; 1
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	02 2e       	mov	r0, r18
    23a8:	02 c0       	rjmp	.+4      	; 0x23ae <MCAL_DIO_u8SetPinValue+0xec>
    23aa:	88 0f       	add	r24, r24
    23ac:	99 1f       	adc	r25, r25
    23ae:	0a 94       	dec	r0
    23b0:	e2 f7       	brpl	.-8      	; 0x23aa <MCAL_DIO_u8SetPinValue+0xe8>
    23b2:	84 2b       	or	r24, r20
    23b4:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    23b6:	19 82       	std	Y+1, r1	; 0x01
    23b8:	67 c0       	rjmp	.+206    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else {
				//Do Nothing
			}
		} else if (Loc_u8PinValue == Pin_Low) {
    23ba:	8c 81       	ldd	r24, Y+4	; 0x04
    23bc:	88 23       	and	r24, r24
    23be:	09 f0       	breq	.+2      	; 0x23c2 <MCAL_DIO_u8SetPinValue+0x100>
    23c0:	63 c0       	rjmp	.+198    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			if (Loc_u8PortID == PortA) {
    23c2:	8a 81       	ldd	r24, Y+2	; 0x02
    23c4:	88 23       	and	r24, r24
    23c6:	b1 f4       	brne	.+44     	; 0x23f4 <MCAL_DIO_u8SetPinValue+0x132>
				CLR_BIT(PORTA, Loc_u8PinID);
    23c8:	ab e3       	ldi	r26, 0x3B	; 59
    23ca:	b0 e0       	ldi	r27, 0x00	; 0
    23cc:	eb e3       	ldi	r30, 0x3B	; 59
    23ce:	f0 e0       	ldi	r31, 0x00	; 0
    23d0:	80 81       	ld	r24, Z
    23d2:	48 2f       	mov	r20, r24
    23d4:	8b 81       	ldd	r24, Y+3	; 0x03
    23d6:	28 2f       	mov	r18, r24
    23d8:	30 e0       	ldi	r19, 0x00	; 0
    23da:	81 e0       	ldi	r24, 0x01	; 1
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	02 2e       	mov	r0, r18
    23e0:	02 c0       	rjmp	.+4      	; 0x23e6 <MCAL_DIO_u8SetPinValue+0x124>
    23e2:	88 0f       	add	r24, r24
    23e4:	99 1f       	adc	r25, r25
    23e6:	0a 94       	dec	r0
    23e8:	e2 f7       	brpl	.-8      	; 0x23e2 <MCAL_DIO_u8SetPinValue+0x120>
    23ea:	80 95       	com	r24
    23ec:	84 23       	and	r24, r20
    23ee:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    23f0:	19 82       	std	Y+1, r1	; 0x01
    23f2:	4a c0       	rjmp	.+148    	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortB) {
    23f4:	8a 81       	ldd	r24, Y+2	; 0x02
    23f6:	81 30       	cpi	r24, 0x01	; 1
    23f8:	b1 f4       	brne	.+44     	; 0x2426 <MCAL_DIO_u8SetPinValue+0x164>
				CLR_BIT(PORTB, Loc_u8PinID);
    23fa:	a8 e3       	ldi	r26, 0x38	; 56
    23fc:	b0 e0       	ldi	r27, 0x00	; 0
    23fe:	e8 e3       	ldi	r30, 0x38	; 56
    2400:	f0 e0       	ldi	r31, 0x00	; 0
    2402:	80 81       	ld	r24, Z
    2404:	48 2f       	mov	r20, r24
    2406:	8b 81       	ldd	r24, Y+3	; 0x03
    2408:	28 2f       	mov	r18, r24
    240a:	30 e0       	ldi	r19, 0x00	; 0
    240c:	81 e0       	ldi	r24, 0x01	; 1
    240e:	90 e0       	ldi	r25, 0x00	; 0
    2410:	02 2e       	mov	r0, r18
    2412:	02 c0       	rjmp	.+4      	; 0x2418 <MCAL_DIO_u8SetPinValue+0x156>
    2414:	88 0f       	add	r24, r24
    2416:	99 1f       	adc	r25, r25
    2418:	0a 94       	dec	r0
    241a:	e2 f7       	brpl	.-8      	; 0x2414 <MCAL_DIO_u8SetPinValue+0x152>
    241c:	80 95       	com	r24
    241e:	84 23       	and	r24, r20
    2420:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2422:	19 82       	std	Y+1, r1	; 0x01
    2424:	31 c0       	rjmp	.+98     	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortC) {
    2426:	8a 81       	ldd	r24, Y+2	; 0x02
    2428:	82 30       	cpi	r24, 0x02	; 2
    242a:	b1 f4       	brne	.+44     	; 0x2458 <MCAL_DIO_u8SetPinValue+0x196>
				CLR_BIT(PORTC, Loc_u8PinID);
    242c:	a5 e3       	ldi	r26, 0x35	; 53
    242e:	b0 e0       	ldi	r27, 0x00	; 0
    2430:	e5 e3       	ldi	r30, 0x35	; 53
    2432:	f0 e0       	ldi	r31, 0x00	; 0
    2434:	80 81       	ld	r24, Z
    2436:	48 2f       	mov	r20, r24
    2438:	8b 81       	ldd	r24, Y+3	; 0x03
    243a:	28 2f       	mov	r18, r24
    243c:	30 e0       	ldi	r19, 0x00	; 0
    243e:	81 e0       	ldi	r24, 0x01	; 1
    2440:	90 e0       	ldi	r25, 0x00	; 0
    2442:	02 2e       	mov	r0, r18
    2444:	02 c0       	rjmp	.+4      	; 0x244a <MCAL_DIO_u8SetPinValue+0x188>
    2446:	88 0f       	add	r24, r24
    2448:	99 1f       	adc	r25, r25
    244a:	0a 94       	dec	r0
    244c:	e2 f7       	brpl	.-8      	; 0x2446 <MCAL_DIO_u8SetPinValue+0x184>
    244e:	80 95       	com	r24
    2450:	84 23       	and	r24, r20
    2452:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2454:	19 82       	std	Y+1, r1	; 0x01
    2456:	18 c0       	rjmp	.+48     	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
			} else if (Loc_u8PortID == PortD) {
    2458:	8a 81       	ldd	r24, Y+2	; 0x02
    245a:	83 30       	cpi	r24, 0x03	; 3
    245c:	a9 f4       	brne	.+42     	; 0x2488 <MCAL_DIO_u8SetPinValue+0x1c6>
				CLR_BIT(PORTD, Loc_u8PinID);
    245e:	a2 e3       	ldi	r26, 0x32	; 50
    2460:	b0 e0       	ldi	r27, 0x00	; 0
    2462:	e2 e3       	ldi	r30, 0x32	; 50
    2464:	f0 e0       	ldi	r31, 0x00	; 0
    2466:	80 81       	ld	r24, Z
    2468:	48 2f       	mov	r20, r24
    246a:	8b 81       	ldd	r24, Y+3	; 0x03
    246c:	28 2f       	mov	r18, r24
    246e:	30 e0       	ldi	r19, 0x00	; 0
    2470:	81 e0       	ldi	r24, 0x01	; 1
    2472:	90 e0       	ldi	r25, 0x00	; 0
    2474:	02 2e       	mov	r0, r18
    2476:	02 c0       	rjmp	.+4      	; 0x247c <MCAL_DIO_u8SetPinValue+0x1ba>
    2478:	88 0f       	add	r24, r24
    247a:	99 1f       	adc	r25, r25
    247c:	0a 94       	dec	r0
    247e:	e2 f7       	brpl	.-8      	; 0x2478 <MCAL_DIO_u8SetPinValue+0x1b6>
    2480:	80 95       	com	r24
    2482:	84 23       	and	r24, r20
    2484:	8c 93       	st	X, r24
				Loc_u8Return_Value = E_OK;
    2486:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2488:	89 81       	ldd	r24, Y+1	; 0x01

}
    248a:	0f 90       	pop	r0
    248c:	0f 90       	pop	r0
    248e:	0f 90       	pop	r0
    2490:	0f 90       	pop	r0
    2492:	cf 91       	pop	r28
    2494:	df 91       	pop	r29
    2496:	08 95       	ret

00002498 <MCAL_DIO_u8SGetPortValue>:

STD_Type MCAL_DIO_u8SGetPortValue(u8 Loc_u8PortID, u8* Loc_u8PortValue) {
    2498:	df 93       	push	r29
    249a:	cf 93       	push	r28
    249c:	00 d0       	rcall	.+0      	; 0x249e <MCAL_DIO_u8SGetPortValue+0x6>
    249e:	00 d0       	rcall	.+0      	; 0x24a0 <MCAL_DIO_u8SGetPortValue+0x8>
    24a0:	cd b7       	in	r28, 0x3d	; 61
    24a2:	de b7       	in	r29, 0x3e	; 62
    24a4:	8a 83       	std	Y+2, r24	; 0x02
    24a6:	7c 83       	std	Y+4, r23	; 0x04
    24a8:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    24aa:	81 e0       	ldi	r24, 0x01	; 1
    24ac:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD) {
    24ae:	8a 81       	ldd	r24, Y+2	; 0x02
    24b0:	84 30       	cpi	r24, 0x04	; 4
    24b2:	58 f5       	brcc	.+86     	; 0x250a <MCAL_DIO_u8SGetPortValue+0x72>
		if (Loc_u8PortID == PortA) {
    24b4:	8a 81       	ldd	r24, Y+2	; 0x02
    24b6:	88 23       	and	r24, r24
    24b8:	41 f4       	brne	.+16     	; 0x24ca <MCAL_DIO_u8SGetPortValue+0x32>
			*Loc_u8PortValue = PORTA;
    24ba:	eb e3       	ldi	r30, 0x3B	; 59
    24bc:	f0 e0       	ldi	r31, 0x00	; 0
    24be:	80 81       	ld	r24, Z
    24c0:	eb 81       	ldd	r30, Y+3	; 0x03
    24c2:	fc 81       	ldd	r31, Y+4	; 0x04
    24c4:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    24c6:	19 82       	std	Y+1, r1	; 0x01
    24c8:	20 c0       	rjmp	.+64     	; 0x250a <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortB) {
    24ca:	8a 81       	ldd	r24, Y+2	; 0x02
    24cc:	81 30       	cpi	r24, 0x01	; 1
    24ce:	41 f4       	brne	.+16     	; 0x24e0 <MCAL_DIO_u8SGetPortValue+0x48>
			*Loc_u8PortValue = PORTB;
    24d0:	e8 e3       	ldi	r30, 0x38	; 56
    24d2:	f0 e0       	ldi	r31, 0x00	; 0
    24d4:	80 81       	ld	r24, Z
    24d6:	eb 81       	ldd	r30, Y+3	; 0x03
    24d8:	fc 81       	ldd	r31, Y+4	; 0x04
    24da:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    24dc:	19 82       	std	Y+1, r1	; 0x01
    24de:	15 c0       	rjmp	.+42     	; 0x250a <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortC) {
    24e0:	8a 81       	ldd	r24, Y+2	; 0x02
    24e2:	82 30       	cpi	r24, 0x02	; 2
    24e4:	41 f4       	brne	.+16     	; 0x24f6 <MCAL_DIO_u8SGetPortValue+0x5e>
			*Loc_u8PortValue = PORTC;
    24e6:	e5 e3       	ldi	r30, 0x35	; 53
    24e8:	f0 e0       	ldi	r31, 0x00	; 0
    24ea:	80 81       	ld	r24, Z
    24ec:	eb 81       	ldd	r30, Y+3	; 0x03
    24ee:	fc 81       	ldd	r31, Y+4	; 0x04
    24f0:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    24f2:	19 82       	std	Y+1, r1	; 0x01
    24f4:	0a c0       	rjmp	.+20     	; 0x250a <MCAL_DIO_u8SGetPortValue+0x72>
		} else if (Loc_u8PortID == PortD) {
    24f6:	8a 81       	ldd	r24, Y+2	; 0x02
    24f8:	83 30       	cpi	r24, 0x03	; 3
    24fa:	39 f4       	brne	.+14     	; 0x250a <MCAL_DIO_u8SGetPortValue+0x72>
			*Loc_u8PortValue = PORTD;
    24fc:	e2 e3       	ldi	r30, 0x32	; 50
    24fe:	f0 e0       	ldi	r31, 0x00	; 0
    2500:	80 81       	ld	r24, Z
    2502:	eb 81       	ldd	r30, Y+3	; 0x03
    2504:	fc 81       	ldd	r31, Y+4	; 0x04
    2506:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    2508:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    250a:	89 81       	ldd	r24, Y+1	; 0x01
}
    250c:	0f 90       	pop	r0
    250e:	0f 90       	pop	r0
    2510:	0f 90       	pop	r0
    2512:	0f 90       	pop	r0
    2514:	cf 91       	pop	r28
    2516:	df 91       	pop	r29
    2518:	08 95       	ret

0000251a <MCAL_DIO_u8GetPinValue>:

STD_Type MCAL_DIO_u8GetPinValue(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8* Loc_u8PinValue) {
    251a:	df 93       	push	r29
    251c:	cf 93       	push	r28
    251e:	00 d0       	rcall	.+0      	; 0x2520 <MCAL_DIO_u8GetPinValue+0x6>
    2520:	00 d0       	rcall	.+0      	; 0x2522 <MCAL_DIO_u8GetPinValue+0x8>
    2522:	0f 92       	push	r0
    2524:	cd b7       	in	r28, 0x3d	; 61
    2526:	de b7       	in	r29, 0x3e	; 62
    2528:	8a 83       	std	Y+2, r24	; 0x02
    252a:	6b 83       	std	Y+3, r22	; 0x03
    252c:	5d 83       	std	Y+5, r21	; 0x05
    252e:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    2530:	81 e0       	ldi	r24, 0x01	; 1
    2532:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins) {
    2534:	8a 81       	ldd	r24, Y+2	; 0x02
    2536:	84 30       	cpi	r24, 0x04	; 4
    2538:	08 f0       	brcs	.+2      	; 0x253c <MCAL_DIO_u8GetPinValue+0x22>
    253a:	63 c0       	rjmp	.+198    	; 0x2602 <MCAL_DIO_u8GetPinValue+0xe8>
    253c:	8b 81       	ldd	r24, Y+3	; 0x03
    253e:	88 30       	cpi	r24, 0x08	; 8
    2540:	08 f0       	brcs	.+2      	; 0x2544 <MCAL_DIO_u8GetPinValue+0x2a>
    2542:	5f c0       	rjmp	.+190    	; 0x2602 <MCAL_DIO_u8GetPinValue+0xe8>
		if (Loc_u8PortID == PortA) {
    2544:	8a 81       	ldd	r24, Y+2	; 0x02
    2546:	88 23       	and	r24, r24
    2548:	a9 f4       	brne	.+42     	; 0x2574 <MCAL_DIO_u8GetPinValue+0x5a>
			*Loc_u8PinValue = GET_BIT(PINA, Loc_u8PinID);
    254a:	e9 e3       	ldi	r30, 0x39	; 57
    254c:	f0 e0       	ldi	r31, 0x00	; 0
    254e:	80 81       	ld	r24, Z
    2550:	28 2f       	mov	r18, r24
    2552:	30 e0       	ldi	r19, 0x00	; 0
    2554:	8b 81       	ldd	r24, Y+3	; 0x03
    2556:	88 2f       	mov	r24, r24
    2558:	90 e0       	ldi	r25, 0x00	; 0
    255a:	a9 01       	movw	r20, r18
    255c:	02 c0       	rjmp	.+4      	; 0x2562 <MCAL_DIO_u8GetPinValue+0x48>
    255e:	55 95       	asr	r21
    2560:	47 95       	ror	r20
    2562:	8a 95       	dec	r24
    2564:	e2 f7       	brpl	.-8      	; 0x255e <MCAL_DIO_u8GetPinValue+0x44>
    2566:	ca 01       	movw	r24, r20
    2568:	81 70       	andi	r24, 0x01	; 1
    256a:	ec 81       	ldd	r30, Y+4	; 0x04
    256c:	fd 81       	ldd	r31, Y+5	; 0x05
    256e:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    2570:	19 82       	std	Y+1, r1	; 0x01
    2572:	47 c0       	rjmp	.+142    	; 0x2602 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortB) {
    2574:	8a 81       	ldd	r24, Y+2	; 0x02
    2576:	81 30       	cpi	r24, 0x01	; 1
    2578:	a9 f4       	brne	.+42     	; 0x25a4 <MCAL_DIO_u8GetPinValue+0x8a>
			*Loc_u8PinValue = GET_BIT(PINB, Loc_u8PinID);
    257a:	e6 e3       	ldi	r30, 0x36	; 54
    257c:	f0 e0       	ldi	r31, 0x00	; 0
    257e:	80 81       	ld	r24, Z
    2580:	28 2f       	mov	r18, r24
    2582:	30 e0       	ldi	r19, 0x00	; 0
    2584:	8b 81       	ldd	r24, Y+3	; 0x03
    2586:	88 2f       	mov	r24, r24
    2588:	90 e0       	ldi	r25, 0x00	; 0
    258a:	a9 01       	movw	r20, r18
    258c:	02 c0       	rjmp	.+4      	; 0x2592 <MCAL_DIO_u8GetPinValue+0x78>
    258e:	55 95       	asr	r21
    2590:	47 95       	ror	r20
    2592:	8a 95       	dec	r24
    2594:	e2 f7       	brpl	.-8      	; 0x258e <MCAL_DIO_u8GetPinValue+0x74>
    2596:	ca 01       	movw	r24, r20
    2598:	81 70       	andi	r24, 0x01	; 1
    259a:	ec 81       	ldd	r30, Y+4	; 0x04
    259c:	fd 81       	ldd	r31, Y+5	; 0x05
    259e:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    25a0:	19 82       	std	Y+1, r1	; 0x01
    25a2:	2f c0       	rjmp	.+94     	; 0x2602 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortC) {
    25a4:	8a 81       	ldd	r24, Y+2	; 0x02
    25a6:	82 30       	cpi	r24, 0x02	; 2
    25a8:	a9 f4       	brne	.+42     	; 0x25d4 <MCAL_DIO_u8GetPinValue+0xba>
			*Loc_u8PinValue = GET_BIT(PINC, Loc_u8PinID);
    25aa:	e3 e3       	ldi	r30, 0x33	; 51
    25ac:	f0 e0       	ldi	r31, 0x00	; 0
    25ae:	80 81       	ld	r24, Z
    25b0:	28 2f       	mov	r18, r24
    25b2:	30 e0       	ldi	r19, 0x00	; 0
    25b4:	8b 81       	ldd	r24, Y+3	; 0x03
    25b6:	88 2f       	mov	r24, r24
    25b8:	90 e0       	ldi	r25, 0x00	; 0
    25ba:	a9 01       	movw	r20, r18
    25bc:	02 c0       	rjmp	.+4      	; 0x25c2 <MCAL_DIO_u8GetPinValue+0xa8>
    25be:	55 95       	asr	r21
    25c0:	47 95       	ror	r20
    25c2:	8a 95       	dec	r24
    25c4:	e2 f7       	brpl	.-8      	; 0x25be <MCAL_DIO_u8GetPinValue+0xa4>
    25c6:	ca 01       	movw	r24, r20
    25c8:	81 70       	andi	r24, 0x01	; 1
    25ca:	ec 81       	ldd	r30, Y+4	; 0x04
    25cc:	fd 81       	ldd	r31, Y+5	; 0x05
    25ce:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    25d0:	19 82       	std	Y+1, r1	; 0x01
    25d2:	17 c0       	rjmp	.+46     	; 0x2602 <MCAL_DIO_u8GetPinValue+0xe8>
		} else if (Loc_u8PortID == PortD) {
    25d4:	8a 81       	ldd	r24, Y+2	; 0x02
    25d6:	83 30       	cpi	r24, 0x03	; 3
    25d8:	a1 f4       	brne	.+40     	; 0x2602 <MCAL_DIO_u8GetPinValue+0xe8>
			*Loc_u8PinValue = GET_BIT(PIND, Loc_u8PinID);
    25da:	e0 e3       	ldi	r30, 0x30	; 48
    25dc:	f0 e0       	ldi	r31, 0x00	; 0
    25de:	80 81       	ld	r24, Z
    25e0:	28 2f       	mov	r18, r24
    25e2:	30 e0       	ldi	r19, 0x00	; 0
    25e4:	8b 81       	ldd	r24, Y+3	; 0x03
    25e6:	88 2f       	mov	r24, r24
    25e8:	90 e0       	ldi	r25, 0x00	; 0
    25ea:	a9 01       	movw	r20, r18
    25ec:	02 c0       	rjmp	.+4      	; 0x25f2 <MCAL_DIO_u8GetPinValue+0xd8>
    25ee:	55 95       	asr	r21
    25f0:	47 95       	ror	r20
    25f2:	8a 95       	dec	r24
    25f4:	e2 f7       	brpl	.-8      	; 0x25ee <MCAL_DIO_u8GetPinValue+0xd4>
    25f6:	ca 01       	movw	r24, r20
    25f8:	81 70       	andi	r24, 0x01	; 1
    25fa:	ec 81       	ldd	r30, Y+4	; 0x04
    25fc:	fd 81       	ldd	r31, Y+5	; 0x05
    25fe:	80 83       	st	Z, r24
			Loc_u8Return_Value = E_OK;
    2600:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2602:	89 81       	ldd	r24, Y+1	; 0x01
}
    2604:	0f 90       	pop	r0
    2606:	0f 90       	pop	r0
    2608:	0f 90       	pop	r0
    260a:	0f 90       	pop	r0
    260c:	0f 90       	pop	r0
    260e:	cf 91       	pop	r28
    2610:	df 91       	pop	r29
    2612:	08 95       	ret

00002614 <MCAL_DIO_u8TogglePortValue>:

STD_Type MCAL_DIO_u8TogglePortValue(u8 Loc_u8PortID) {
    2614:	df 93       	push	r29
    2616:	cf 93       	push	r28
    2618:	00 d0       	rcall	.+0      	; 0x261a <MCAL_DIO_u8TogglePortValue+0x6>
    261a:	cd b7       	in	r28, 0x3d	; 61
    261c:	de b7       	in	r29, 0x3e	; 62
    261e:	8a 83       	std	Y+2, r24	; 0x02
	u8 Loc_u8Return_Value = E_NOT_OK;
    2620:	81 e0       	ldi	r24, 0x01	; 1
    2622:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD) {
    2624:	8a 81       	ldd	r24, Y+2	; 0x02
    2626:	84 30       	cpi	r24, 0x04	; 4
    2628:	78 f5       	brcc	.+94     	; 0x2688 <MCAL_DIO_u8TogglePortValue+0x74>
		if (Loc_u8PortID == PortA) {
    262a:	8a 81       	ldd	r24, Y+2	; 0x02
    262c:	88 23       	and	r24, r24
    262e:	49 f4       	brne	.+18     	; 0x2642 <MCAL_DIO_u8TogglePortValue+0x2e>
			PORTA = ~PORTA;
    2630:	ab e3       	ldi	r26, 0x3B	; 59
    2632:	b0 e0       	ldi	r27, 0x00	; 0
    2634:	eb e3       	ldi	r30, 0x3B	; 59
    2636:	f0 e0       	ldi	r31, 0x00	; 0
    2638:	80 81       	ld	r24, Z
    263a:	80 95       	com	r24
    263c:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    263e:	19 82       	std	Y+1, r1	; 0x01
    2640:	23 c0       	rjmp	.+70     	; 0x2688 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortB) {
    2642:	8a 81       	ldd	r24, Y+2	; 0x02
    2644:	81 30       	cpi	r24, 0x01	; 1
    2646:	49 f4       	brne	.+18     	; 0x265a <MCAL_DIO_u8TogglePortValue+0x46>
			PORTB = ~PORTB;
    2648:	a8 e3       	ldi	r26, 0x38	; 56
    264a:	b0 e0       	ldi	r27, 0x00	; 0
    264c:	e8 e3       	ldi	r30, 0x38	; 56
    264e:	f0 e0       	ldi	r31, 0x00	; 0
    2650:	80 81       	ld	r24, Z
    2652:	80 95       	com	r24
    2654:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    2656:	19 82       	std	Y+1, r1	; 0x01
    2658:	17 c0       	rjmp	.+46     	; 0x2688 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortC) {
    265a:	8a 81       	ldd	r24, Y+2	; 0x02
    265c:	82 30       	cpi	r24, 0x02	; 2
    265e:	49 f4       	brne	.+18     	; 0x2672 <MCAL_DIO_u8TogglePortValue+0x5e>
			PORTC = ~PORTC;
    2660:	a5 e3       	ldi	r26, 0x35	; 53
    2662:	b0 e0       	ldi	r27, 0x00	; 0
    2664:	e5 e3       	ldi	r30, 0x35	; 53
    2666:	f0 e0       	ldi	r31, 0x00	; 0
    2668:	80 81       	ld	r24, Z
    266a:	80 95       	com	r24
    266c:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    266e:	19 82       	std	Y+1, r1	; 0x01
    2670:	0b c0       	rjmp	.+22     	; 0x2688 <MCAL_DIO_u8TogglePortValue+0x74>
		} else if (Loc_u8PortID == PortD) {
    2672:	8a 81       	ldd	r24, Y+2	; 0x02
    2674:	83 30       	cpi	r24, 0x03	; 3
    2676:	41 f4       	brne	.+16     	; 0x2688 <MCAL_DIO_u8TogglePortValue+0x74>
			PORTD = ~PORTD;
    2678:	a2 e3       	ldi	r26, 0x32	; 50
    267a:	b0 e0       	ldi	r27, 0x00	; 0
    267c:	e2 e3       	ldi	r30, 0x32	; 50
    267e:	f0 e0       	ldi	r31, 0x00	; 0
    2680:	80 81       	ld	r24, Z
    2682:	80 95       	com	r24
    2684:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    2686:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2688:	89 81       	ldd	r24, Y+1	; 0x01
}
    268a:	0f 90       	pop	r0
    268c:	0f 90       	pop	r0
    268e:	cf 91       	pop	r28
    2690:	df 91       	pop	r29
    2692:	08 95       	ret

00002694 <MCAL_DIO_u8TogglePinValue>:

STD_Type MCAL_DIO_u8TogglePinValue(u8 Loc_u8PortID, u8 Loc_u8PinID) {
    2694:	df 93       	push	r29
    2696:	cf 93       	push	r28
    2698:	00 d0       	rcall	.+0      	; 0x269a <MCAL_DIO_u8TogglePinValue+0x6>
    269a:	0f 92       	push	r0
    269c:	cd b7       	in	r28, 0x3d	; 61
    269e:	de b7       	in	r29, 0x3e	; 62
    26a0:	8a 83       	std	Y+2, r24	; 0x02
    26a2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8PortID <= PortD && Loc_u8PinID <= Num_Of_Pins) {
    26a8:	8a 81       	ldd	r24, Y+2	; 0x02
    26aa:	84 30       	cpi	r24, 0x04	; 4
    26ac:	08 f0       	brcs	.+2      	; 0x26b0 <MCAL_DIO_u8TogglePinValue+0x1c>
    26ae:	63 c0       	rjmp	.+198    	; 0x2776 <MCAL_DIO_u8TogglePinValue+0xe2>
    26b0:	8b 81       	ldd	r24, Y+3	; 0x03
    26b2:	88 30       	cpi	r24, 0x08	; 8
    26b4:	08 f0       	brcs	.+2      	; 0x26b8 <MCAL_DIO_u8TogglePinValue+0x24>
    26b6:	5f c0       	rjmp	.+190    	; 0x2776 <MCAL_DIO_u8TogglePinValue+0xe2>
		if (Loc_u8PortID == PortA) {
    26b8:	8a 81       	ldd	r24, Y+2	; 0x02
    26ba:	88 23       	and	r24, r24
    26bc:	a9 f4       	brne	.+42     	; 0x26e8 <MCAL_DIO_u8TogglePinValue+0x54>
			TOGGLE_BIT(PORTA, Loc_u8PinID);
    26be:	ab e3       	ldi	r26, 0x3B	; 59
    26c0:	b0 e0       	ldi	r27, 0x00	; 0
    26c2:	eb e3       	ldi	r30, 0x3B	; 59
    26c4:	f0 e0       	ldi	r31, 0x00	; 0
    26c6:	80 81       	ld	r24, Z
    26c8:	48 2f       	mov	r20, r24
    26ca:	8b 81       	ldd	r24, Y+3	; 0x03
    26cc:	28 2f       	mov	r18, r24
    26ce:	30 e0       	ldi	r19, 0x00	; 0
    26d0:	81 e0       	ldi	r24, 0x01	; 1
    26d2:	90 e0       	ldi	r25, 0x00	; 0
    26d4:	02 2e       	mov	r0, r18
    26d6:	02 c0       	rjmp	.+4      	; 0x26dc <MCAL_DIO_u8TogglePinValue+0x48>
    26d8:	88 0f       	add	r24, r24
    26da:	99 1f       	adc	r25, r25
    26dc:	0a 94       	dec	r0
    26de:	e2 f7       	brpl	.-8      	; 0x26d8 <MCAL_DIO_u8TogglePinValue+0x44>
    26e0:	84 27       	eor	r24, r20
    26e2:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    26e4:	19 82       	std	Y+1, r1	; 0x01
    26e6:	47 c0       	rjmp	.+142    	; 0x2776 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortB) {
    26e8:	8a 81       	ldd	r24, Y+2	; 0x02
    26ea:	81 30       	cpi	r24, 0x01	; 1
    26ec:	a9 f4       	brne	.+42     	; 0x2718 <MCAL_DIO_u8TogglePinValue+0x84>
			TOGGLE_BIT(PORTB, Loc_u8PinID);
    26ee:	a8 e3       	ldi	r26, 0x38	; 56
    26f0:	b0 e0       	ldi	r27, 0x00	; 0
    26f2:	e8 e3       	ldi	r30, 0x38	; 56
    26f4:	f0 e0       	ldi	r31, 0x00	; 0
    26f6:	80 81       	ld	r24, Z
    26f8:	48 2f       	mov	r20, r24
    26fa:	8b 81       	ldd	r24, Y+3	; 0x03
    26fc:	28 2f       	mov	r18, r24
    26fe:	30 e0       	ldi	r19, 0x00	; 0
    2700:	81 e0       	ldi	r24, 0x01	; 1
    2702:	90 e0       	ldi	r25, 0x00	; 0
    2704:	02 2e       	mov	r0, r18
    2706:	02 c0       	rjmp	.+4      	; 0x270c <MCAL_DIO_u8TogglePinValue+0x78>
    2708:	88 0f       	add	r24, r24
    270a:	99 1f       	adc	r25, r25
    270c:	0a 94       	dec	r0
    270e:	e2 f7       	brpl	.-8      	; 0x2708 <MCAL_DIO_u8TogglePinValue+0x74>
    2710:	84 27       	eor	r24, r20
    2712:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    2714:	19 82       	std	Y+1, r1	; 0x01
    2716:	2f c0       	rjmp	.+94     	; 0x2776 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortC) {
    2718:	8a 81       	ldd	r24, Y+2	; 0x02
    271a:	82 30       	cpi	r24, 0x02	; 2
    271c:	a9 f4       	brne	.+42     	; 0x2748 <MCAL_DIO_u8TogglePinValue+0xb4>
			TOGGLE_BIT(PORTC, Loc_u8PinID);
    271e:	a5 e3       	ldi	r26, 0x35	; 53
    2720:	b0 e0       	ldi	r27, 0x00	; 0
    2722:	e5 e3       	ldi	r30, 0x35	; 53
    2724:	f0 e0       	ldi	r31, 0x00	; 0
    2726:	80 81       	ld	r24, Z
    2728:	48 2f       	mov	r20, r24
    272a:	8b 81       	ldd	r24, Y+3	; 0x03
    272c:	28 2f       	mov	r18, r24
    272e:	30 e0       	ldi	r19, 0x00	; 0
    2730:	81 e0       	ldi	r24, 0x01	; 1
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	02 2e       	mov	r0, r18
    2736:	02 c0       	rjmp	.+4      	; 0x273c <MCAL_DIO_u8TogglePinValue+0xa8>
    2738:	88 0f       	add	r24, r24
    273a:	99 1f       	adc	r25, r25
    273c:	0a 94       	dec	r0
    273e:	e2 f7       	brpl	.-8      	; 0x2738 <MCAL_DIO_u8TogglePinValue+0xa4>
    2740:	84 27       	eor	r24, r20
    2742:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    2744:	19 82       	std	Y+1, r1	; 0x01
    2746:	17 c0       	rjmp	.+46     	; 0x2776 <MCAL_DIO_u8TogglePinValue+0xe2>
		} else if (Loc_u8PortID == PortD) {
    2748:	8a 81       	ldd	r24, Y+2	; 0x02
    274a:	83 30       	cpi	r24, 0x03	; 3
    274c:	a1 f4       	brne	.+40     	; 0x2776 <MCAL_DIO_u8TogglePinValue+0xe2>
			TOGGLE_BIT(PORTD, Loc_u8PinID);
    274e:	a2 e3       	ldi	r26, 0x32	; 50
    2750:	b0 e0       	ldi	r27, 0x00	; 0
    2752:	e2 e3       	ldi	r30, 0x32	; 50
    2754:	f0 e0       	ldi	r31, 0x00	; 0
    2756:	80 81       	ld	r24, Z
    2758:	48 2f       	mov	r20, r24
    275a:	8b 81       	ldd	r24, Y+3	; 0x03
    275c:	28 2f       	mov	r18, r24
    275e:	30 e0       	ldi	r19, 0x00	; 0
    2760:	81 e0       	ldi	r24, 0x01	; 1
    2762:	90 e0       	ldi	r25, 0x00	; 0
    2764:	02 2e       	mov	r0, r18
    2766:	02 c0       	rjmp	.+4      	; 0x276c <MCAL_DIO_u8TogglePinValue+0xd8>
    2768:	88 0f       	add	r24, r24
    276a:	99 1f       	adc	r25, r25
    276c:	0a 94       	dec	r0
    276e:	e2 f7       	brpl	.-8      	; 0x2768 <MCAL_DIO_u8TogglePinValue+0xd4>
    2770:	84 27       	eor	r24, r20
    2772:	8c 93       	st	X, r24
			Loc_u8Return_Value = E_OK;
    2774:	19 82       	std	Y+1, r1	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2776:	89 81       	ldd	r24, Y+1	; 0x01
}
    2778:	0f 90       	pop	r0
    277a:	0f 90       	pop	r0
    277c:	0f 90       	pop	r0
    277e:	cf 91       	pop	r28
    2780:	df 91       	pop	r29
    2782:	08 95       	ret

00002784 <MCAL_ADC_u8SetRegister>:

#include "ADC.h"

void (*Gptr_ADC)(void)= '\0' ;

void MCAL_ADC_u8SetRegister(u8 Loc_u8PortID, u8 Loc_u8PortValue) {
    2784:	df 93       	push	r29
    2786:	cf 93       	push	r28
    2788:	00 d0       	rcall	.+0      	; 0x278a <MCAL_ADC_u8SetRegister+0x6>
    278a:	cd b7       	in	r28, 0x3d	; 61
    278c:	de b7       	in	r29, 0x3e	; 62
    278e:	89 83       	std	Y+1, r24	; 0x01
    2790:	6a 83       	std	Y+2, r22	; 0x02
	if (Loc_u8PortValue == PORT_OUTPUT) {
    2792:	8a 81       	ldd	r24, Y+2	; 0x02
    2794:	8f 3f       	cpi	r24, 0xFF	; 255
    2796:	c1 f4       	brne	.+48     	; 0x27c8 <MCAL_ADC_u8SetRegister+0x44>
		if (Loc_u8PortID == Admux) {
    2798:	89 81       	ldd	r24, Y+1	; 0x01
    279a:	88 23       	and	r24, r24
    279c:	29 f4       	brne	.+10     	; 0x27a8 <MCAL_ADC_u8SetRegister+0x24>
			ADMUX = PORT_OUTPUT;
    279e:	e7 e2       	ldi	r30, 0x27	; 39
    27a0:	f0 e0       	ldi	r31, 0x00	; 0
    27a2:	8f ef       	ldi	r24, 0xFF	; 255
    27a4:	80 83       	st	Z, r24
    27a6:	3f c0       	rjmp	.+126    	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Adcsra) {
    27a8:	89 81       	ldd	r24, Y+1	; 0x01
    27aa:	81 30       	cpi	r24, 0x01	; 1
    27ac:	29 f4       	brne	.+10     	; 0x27b8 <MCAL_ADC_u8SetRegister+0x34>
			ADCSRA = PORT_OUTPUT;
    27ae:	e6 e2       	ldi	r30, 0x26	; 38
    27b0:	f0 e0       	ldi	r31, 0x00	; 0
    27b2:	8f ef       	ldi	r24, 0xFF	; 255
    27b4:	80 83       	st	Z, r24
    27b6:	37 c0       	rjmp	.+110    	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Sfior) {
    27b8:	89 81       	ldd	r24, Y+1	; 0x01
    27ba:	82 30       	cpi	r24, 0x02	; 2
    27bc:	a1 f5       	brne	.+104    	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
			SFIOR = PORT_OUTPUT;
    27be:	e0 e5       	ldi	r30, 0x50	; 80
    27c0:	f0 e0       	ldi	r31, 0x00	; 0
    27c2:	8f ef       	ldi	r24, 0xFF	; 255
    27c4:	80 83       	st	Z, r24
    27c6:	2f c0       	rjmp	.+94     	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PortValue == PORT_INPUT) {
    27c8:	8a 81       	ldd	r24, Y+2	; 0x02
    27ca:	88 23       	and	r24, r24
    27cc:	a9 f4       	brne	.+42     	; 0x27f8 <MCAL_ADC_u8SetRegister+0x74>
		if (Loc_u8PortID == Admux) {
    27ce:	89 81       	ldd	r24, Y+1	; 0x01
    27d0:	88 23       	and	r24, r24
    27d2:	21 f4       	brne	.+8      	; 0x27dc <MCAL_ADC_u8SetRegister+0x58>
			ADMUX = PORT_INPUT;
    27d4:	e7 e2       	ldi	r30, 0x27	; 39
    27d6:	f0 e0       	ldi	r31, 0x00	; 0
    27d8:	10 82       	st	Z, r1
    27da:	25 c0       	rjmp	.+74     	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Adcsra) {
    27dc:	89 81       	ldd	r24, Y+1	; 0x01
    27de:	81 30       	cpi	r24, 0x01	; 1
    27e0:	21 f4       	brne	.+8      	; 0x27ea <MCAL_ADC_u8SetRegister+0x66>
			ADCSRA = PORT_INPUT;
    27e2:	e6 e2       	ldi	r30, 0x26	; 38
    27e4:	f0 e0       	ldi	r31, 0x00	; 0
    27e6:	10 82       	st	Z, r1
    27e8:	1e c0       	rjmp	.+60     	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Sfior) {
    27ea:	89 81       	ldd	r24, Y+1	; 0x01
    27ec:	82 30       	cpi	r24, 0x02	; 2
    27ee:	d9 f4       	brne	.+54     	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
			SFIOR = PORT_INPUT;
    27f0:	e0 e5       	ldi	r30, 0x50	; 80
    27f2:	f0 e0       	ldi	r31, 0x00	; 0
    27f4:	10 82       	st	Z, r1
    27f6:	17 c0       	rjmp	.+46     	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
		} else {
			//Do Nothing
		}
	} else {
		if (Loc_u8PortID == Admux) {
    27f8:	89 81       	ldd	r24, Y+1	; 0x01
    27fa:	88 23       	and	r24, r24
    27fc:	29 f4       	brne	.+10     	; 0x2808 <MCAL_ADC_u8SetRegister+0x84>
			ADMUX = Loc_u8PortValue;
    27fe:	e7 e2       	ldi	r30, 0x27	; 39
    2800:	f0 e0       	ldi	r31, 0x00	; 0
    2802:	8a 81       	ldd	r24, Y+2	; 0x02
    2804:	80 83       	st	Z, r24
    2806:	0f c0       	rjmp	.+30     	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Adcsra) {
    2808:	89 81       	ldd	r24, Y+1	; 0x01
    280a:	81 30       	cpi	r24, 0x01	; 1
    280c:	29 f4       	brne	.+10     	; 0x2818 <MCAL_ADC_u8SetRegister+0x94>
			ADCSRA = Loc_u8PortValue;
    280e:	e6 e2       	ldi	r30, 0x26	; 38
    2810:	f0 e0       	ldi	r31, 0x00	; 0
    2812:	8a 81       	ldd	r24, Y+2	; 0x02
    2814:	80 83       	st	Z, r24
    2816:	07 c0       	rjmp	.+14     	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
		} else if (Loc_u8PortID == Sfior) {
    2818:	89 81       	ldd	r24, Y+1	; 0x01
    281a:	82 30       	cpi	r24, 0x02	; 2
    281c:	21 f4       	brne	.+8      	; 0x2826 <MCAL_ADC_u8SetRegister+0xa2>
			SFIOR = Loc_u8PortValue;
    281e:	e0 e5       	ldi	r30, 0x50	; 80
    2820:	f0 e0       	ldi	r31, 0x00	; 0
    2822:	8a 81       	ldd	r24, Y+2	; 0x02
    2824:	80 83       	st	Z, r24
		}
	}
}
    2826:	0f 90       	pop	r0
    2828:	0f 90       	pop	r0
    282a:	cf 91       	pop	r28
    282c:	df 91       	pop	r29
    282e:	08 95       	ret

00002830 <MCAL_ADC_u8SetRegisterPin>:

void MCAL_ADC_u8SetRegisterPin(u8 Loc_u8PortID, u8 Loc_u8PinID,
		u8 Loc_u8PinValue) {
    2830:	df 93       	push	r29
    2832:	cf 93       	push	r28
    2834:	00 d0       	rcall	.+0      	; 0x2836 <MCAL_ADC_u8SetRegisterPin+0x6>
    2836:	0f 92       	push	r0
    2838:	cd b7       	in	r28, 0x3d	; 61
    283a:	de b7       	in	r29, 0x3e	; 62
    283c:	89 83       	std	Y+1, r24	; 0x01
    283e:	6a 83       	std	Y+2, r22	; 0x02
    2840:	4b 83       	std	Y+3, r20	; 0x03
	if (Loc_u8PinValue == Pin_High) {
    2842:	8b 81       	ldd	r24, Y+3	; 0x03
    2844:	81 30       	cpi	r24, 0x01	; 1
    2846:	09 f0       	breq	.+2      	; 0x284a <MCAL_ADC_u8SetRegisterPin+0x1a>
    2848:	46 c0       	rjmp	.+140    	; 0x28d6 <MCAL_ADC_u8SetRegisterPin+0xa6>
		if (Loc_u8PortID == Admux) {
    284a:	89 81       	ldd	r24, Y+1	; 0x01
    284c:	88 23       	and	r24, r24
    284e:	a1 f4       	brne	.+40     	; 0x2878 <MCAL_ADC_u8SetRegisterPin+0x48>
			SET_BIT(ADMUX, Loc_u8PinID);
    2850:	a7 e2       	ldi	r26, 0x27	; 39
    2852:	b0 e0       	ldi	r27, 0x00	; 0
    2854:	e7 e2       	ldi	r30, 0x27	; 39
    2856:	f0 e0       	ldi	r31, 0x00	; 0
    2858:	80 81       	ld	r24, Z
    285a:	48 2f       	mov	r20, r24
    285c:	8a 81       	ldd	r24, Y+2	; 0x02
    285e:	28 2f       	mov	r18, r24
    2860:	30 e0       	ldi	r19, 0x00	; 0
    2862:	81 e0       	ldi	r24, 0x01	; 1
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	02 2e       	mov	r0, r18
    2868:	02 c0       	rjmp	.+4      	; 0x286e <MCAL_ADC_u8SetRegisterPin+0x3e>
    286a:	88 0f       	add	r24, r24
    286c:	99 1f       	adc	r25, r25
    286e:	0a 94       	dec	r0
    2870:	e2 f7       	brpl	.-8      	; 0x286a <MCAL_ADC_u8SetRegisterPin+0x3a>
    2872:	84 2b       	or	r24, r20
    2874:	8c 93       	st	X, r24
    2876:	7a c0       	rjmp	.+244    	; 0x296c <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else if (Loc_u8PortID == Adcsra) {
    2878:	89 81       	ldd	r24, Y+1	; 0x01
    287a:	81 30       	cpi	r24, 0x01	; 1
    287c:	a1 f4       	brne	.+40     	; 0x28a6 <MCAL_ADC_u8SetRegisterPin+0x76>
			SET_BIT(ADCSRA, Loc_u8PinID);
    287e:	a6 e2       	ldi	r26, 0x26	; 38
    2880:	b0 e0       	ldi	r27, 0x00	; 0
    2882:	e6 e2       	ldi	r30, 0x26	; 38
    2884:	f0 e0       	ldi	r31, 0x00	; 0
    2886:	80 81       	ld	r24, Z
    2888:	48 2f       	mov	r20, r24
    288a:	8a 81       	ldd	r24, Y+2	; 0x02
    288c:	28 2f       	mov	r18, r24
    288e:	30 e0       	ldi	r19, 0x00	; 0
    2890:	81 e0       	ldi	r24, 0x01	; 1
    2892:	90 e0       	ldi	r25, 0x00	; 0
    2894:	02 2e       	mov	r0, r18
    2896:	02 c0       	rjmp	.+4      	; 0x289c <MCAL_ADC_u8SetRegisterPin+0x6c>
    2898:	88 0f       	add	r24, r24
    289a:	99 1f       	adc	r25, r25
    289c:	0a 94       	dec	r0
    289e:	e2 f7       	brpl	.-8      	; 0x2898 <MCAL_ADC_u8SetRegisterPin+0x68>
    28a0:	84 2b       	or	r24, r20
    28a2:	8c 93       	st	X, r24
    28a4:	63 c0       	rjmp	.+198    	; 0x296c <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else if (Loc_u8PortID == Sfior) {
    28a6:	89 81       	ldd	r24, Y+1	; 0x01
    28a8:	82 30       	cpi	r24, 0x02	; 2
    28aa:	09 f0       	breq	.+2      	; 0x28ae <MCAL_ADC_u8SetRegisterPin+0x7e>
    28ac:	5f c0       	rjmp	.+190    	; 0x296c <MCAL_ADC_u8SetRegisterPin+0x13c>
			SET_BIT(SFIOR, Loc_u8PinID);
    28ae:	a0 e5       	ldi	r26, 0x50	; 80
    28b0:	b0 e0       	ldi	r27, 0x00	; 0
    28b2:	e0 e5       	ldi	r30, 0x50	; 80
    28b4:	f0 e0       	ldi	r31, 0x00	; 0
    28b6:	80 81       	ld	r24, Z
    28b8:	48 2f       	mov	r20, r24
    28ba:	8a 81       	ldd	r24, Y+2	; 0x02
    28bc:	28 2f       	mov	r18, r24
    28be:	30 e0       	ldi	r19, 0x00	; 0
    28c0:	81 e0       	ldi	r24, 0x01	; 1
    28c2:	90 e0       	ldi	r25, 0x00	; 0
    28c4:	02 2e       	mov	r0, r18
    28c6:	02 c0       	rjmp	.+4      	; 0x28cc <MCAL_ADC_u8SetRegisterPin+0x9c>
    28c8:	88 0f       	add	r24, r24
    28ca:	99 1f       	adc	r25, r25
    28cc:	0a 94       	dec	r0
    28ce:	e2 f7       	brpl	.-8      	; 0x28c8 <MCAL_ADC_u8SetRegisterPin+0x98>
    28d0:	84 2b       	or	r24, r20
    28d2:	8c 93       	st	X, r24
    28d4:	4b c0       	rjmp	.+150    	; 0x296c <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else {
			//Do Nothing
		}
	} else if (Loc_u8PinValue == Pin_Low) {
    28d6:	8b 81       	ldd	r24, Y+3	; 0x03
    28d8:	88 23       	and	r24, r24
    28da:	09 f0       	breq	.+2      	; 0x28de <MCAL_ADC_u8SetRegisterPin+0xae>
    28dc:	47 c0       	rjmp	.+142    	; 0x296c <MCAL_ADC_u8SetRegisterPin+0x13c>
		if (Loc_u8PortID == Admux) {
    28de:	89 81       	ldd	r24, Y+1	; 0x01
    28e0:	88 23       	and	r24, r24
    28e2:	a9 f4       	brne	.+42     	; 0x290e <MCAL_ADC_u8SetRegisterPin+0xde>
			CLR_BIT(ADMUX, Loc_u8PinID);
    28e4:	a7 e2       	ldi	r26, 0x27	; 39
    28e6:	b0 e0       	ldi	r27, 0x00	; 0
    28e8:	e7 e2       	ldi	r30, 0x27	; 39
    28ea:	f0 e0       	ldi	r31, 0x00	; 0
    28ec:	80 81       	ld	r24, Z
    28ee:	48 2f       	mov	r20, r24
    28f0:	8a 81       	ldd	r24, Y+2	; 0x02
    28f2:	28 2f       	mov	r18, r24
    28f4:	30 e0       	ldi	r19, 0x00	; 0
    28f6:	81 e0       	ldi	r24, 0x01	; 1
    28f8:	90 e0       	ldi	r25, 0x00	; 0
    28fa:	02 2e       	mov	r0, r18
    28fc:	02 c0       	rjmp	.+4      	; 0x2902 <MCAL_ADC_u8SetRegisterPin+0xd2>
    28fe:	88 0f       	add	r24, r24
    2900:	99 1f       	adc	r25, r25
    2902:	0a 94       	dec	r0
    2904:	e2 f7       	brpl	.-8      	; 0x28fe <MCAL_ADC_u8SetRegisterPin+0xce>
    2906:	80 95       	com	r24
    2908:	84 23       	and	r24, r20
    290a:	8c 93       	st	X, r24
    290c:	2f c0       	rjmp	.+94     	; 0x296c <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else if (Loc_u8PortID == Adcsra) {
    290e:	89 81       	ldd	r24, Y+1	; 0x01
    2910:	81 30       	cpi	r24, 0x01	; 1
    2912:	a9 f4       	brne	.+42     	; 0x293e <MCAL_ADC_u8SetRegisterPin+0x10e>
			CLR_BIT(ADCSRA, Loc_u8PinID);
    2914:	a6 e2       	ldi	r26, 0x26	; 38
    2916:	b0 e0       	ldi	r27, 0x00	; 0
    2918:	e6 e2       	ldi	r30, 0x26	; 38
    291a:	f0 e0       	ldi	r31, 0x00	; 0
    291c:	80 81       	ld	r24, Z
    291e:	48 2f       	mov	r20, r24
    2920:	8a 81       	ldd	r24, Y+2	; 0x02
    2922:	28 2f       	mov	r18, r24
    2924:	30 e0       	ldi	r19, 0x00	; 0
    2926:	81 e0       	ldi	r24, 0x01	; 1
    2928:	90 e0       	ldi	r25, 0x00	; 0
    292a:	02 2e       	mov	r0, r18
    292c:	02 c0       	rjmp	.+4      	; 0x2932 <MCAL_ADC_u8SetRegisterPin+0x102>
    292e:	88 0f       	add	r24, r24
    2930:	99 1f       	adc	r25, r25
    2932:	0a 94       	dec	r0
    2934:	e2 f7       	brpl	.-8      	; 0x292e <MCAL_ADC_u8SetRegisterPin+0xfe>
    2936:	80 95       	com	r24
    2938:	84 23       	and	r24, r20
    293a:	8c 93       	st	X, r24
    293c:	17 c0       	rjmp	.+46     	; 0x296c <MCAL_ADC_u8SetRegisterPin+0x13c>
		} else if (Loc_u8PortID == Sfior) {
    293e:	89 81       	ldd	r24, Y+1	; 0x01
    2940:	82 30       	cpi	r24, 0x02	; 2
    2942:	a1 f4       	brne	.+40     	; 0x296c <MCAL_ADC_u8SetRegisterPin+0x13c>
			CLR_BIT(SFIOR, Loc_u8PinID);
    2944:	a0 e5       	ldi	r26, 0x50	; 80
    2946:	b0 e0       	ldi	r27, 0x00	; 0
    2948:	e0 e5       	ldi	r30, 0x50	; 80
    294a:	f0 e0       	ldi	r31, 0x00	; 0
    294c:	80 81       	ld	r24, Z
    294e:	48 2f       	mov	r20, r24
    2950:	8a 81       	ldd	r24, Y+2	; 0x02
    2952:	28 2f       	mov	r18, r24
    2954:	30 e0       	ldi	r19, 0x00	; 0
    2956:	81 e0       	ldi	r24, 0x01	; 1
    2958:	90 e0       	ldi	r25, 0x00	; 0
    295a:	02 2e       	mov	r0, r18
    295c:	02 c0       	rjmp	.+4      	; 0x2962 <MCAL_ADC_u8SetRegisterPin+0x132>
    295e:	88 0f       	add	r24, r24
    2960:	99 1f       	adc	r25, r25
    2962:	0a 94       	dec	r0
    2964:	e2 f7       	brpl	.-8      	; 0x295e <MCAL_ADC_u8SetRegisterPin+0x12e>
    2966:	80 95       	com	r24
    2968:	84 23       	and	r24, r20
    296a:	8c 93       	st	X, r24
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
}
    296c:	0f 90       	pop	r0
    296e:	0f 90       	pop	r0
    2970:	0f 90       	pop	r0
    2972:	cf 91       	pop	r28
    2974:	df 91       	pop	r29
    2976:	08 95       	ret

00002978 <MCAL_ADC_AdcInit>:

void MCAL_ADC_AdcInit(u8 Loc_u8Position) {
    2978:	df 93       	push	r29
    297a:	cf 93       	push	r28
    297c:	0f 92       	push	r0
    297e:	cd b7       	in	r28, 0x3d	; 61
    2980:	de b7       	in	r29, 0x3e	; 62
    2982:	89 83       	std	Y+1, r24	; 0x01
	MCAL_ADC_u8SetRegister(Adcsra, ADCSRA_VALUE);
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	6f ea       	ldi	r22, 0xAF	; 175
    2988:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
	MCAL_ADC_u8SetRegisterPin(Sfior, 7, Pin_Low);
    298c:	82 e0       	ldi	r24, 0x02	; 2
    298e:	67 e0       	ldi	r22, 0x07	; 7
    2990:	40 e0       	ldi	r20, 0x00	; 0
    2992:	0e 94 18 14 	call	0x2830	; 0x2830 <MCAL_ADC_u8SetRegisterPin>
	MCAL_ADC_u8SetRegisterPin(Sfior, 6, Pin_Low);
    2996:	82 e0       	ldi	r24, 0x02	; 2
    2998:	66 e0       	ldi	r22, 0x06	; 6
    299a:	40 e0       	ldi	r20, 0x00	; 0
    299c:	0e 94 18 14 	call	0x2830	; 0x2830 <MCAL_ADC_u8SetRegisterPin>
	MCAL_ADC_u8SetRegisterPin(Sfior, 5, Pin_Low);
    29a0:	82 e0       	ldi	r24, 0x02	; 2
    29a2:	65 e0       	ldi	r22, 0x05	; 5
    29a4:	40 e0       	ldi	r20, 0x00	; 0
    29a6:	0e 94 18 14 	call	0x2830	; 0x2830 <MCAL_ADC_u8SetRegisterPin>
	MCAL_Interrupt_u8SetRegisterPin(SREG, 7, Pin_High);
    29aa:	ef e5       	ldi	r30, 0x5F	; 95
    29ac:	f0 e0       	ldi	r31, 0x00	; 0
    29ae:	80 81       	ld	r24, Z
    29b0:	88 2f       	mov	r24, r24
    29b2:	90 e0       	ldi	r25, 0x00	; 0
    29b4:	67 e0       	ldi	r22, 0x07	; 7
    29b6:	70 e0       	ldi	r23, 0x00	; 0
    29b8:	41 e0       	ldi	r20, 0x01	; 1
    29ba:	50 e0       	ldi	r21, 0x00	; 0
    29bc:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
	if (Loc_u8Position == Adc_0) {
    29c0:	89 81       	ldd	r24, Y+1	; 0x01
    29c2:	88 23       	and	r24, r24
    29c4:	29 f4       	brne	.+10     	; 0x29d0 <MCAL_ADC_AdcInit+0x58>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc0);
    29c6:	80 e0       	ldi	r24, 0x00	; 0
    29c8:	60 e4       	ldi	r22, 0x40	; 64
    29ca:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
    29ce:	37 c0       	rjmp	.+110    	; 0x2a3e <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_1) {
    29d0:	89 81       	ldd	r24, Y+1	; 0x01
    29d2:	81 30       	cpi	r24, 0x01	; 1
    29d4:	29 f4       	brne	.+10     	; 0x29e0 <MCAL_ADC_AdcInit+0x68>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc1);
    29d6:	80 e0       	ldi	r24, 0x00	; 0
    29d8:	61 e4       	ldi	r22, 0x41	; 65
    29da:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
    29de:	2f c0       	rjmp	.+94     	; 0x2a3e <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_2) {
    29e0:	89 81       	ldd	r24, Y+1	; 0x01
    29e2:	82 30       	cpi	r24, 0x02	; 2
    29e4:	29 f4       	brne	.+10     	; 0x29f0 <MCAL_ADC_AdcInit+0x78>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc2);
    29e6:	80 e0       	ldi	r24, 0x00	; 0
    29e8:	62 e4       	ldi	r22, 0x42	; 66
    29ea:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
    29ee:	27 c0       	rjmp	.+78     	; 0x2a3e <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_3) {
    29f0:	89 81       	ldd	r24, Y+1	; 0x01
    29f2:	83 30       	cpi	r24, 0x03	; 3
    29f4:	29 f4       	brne	.+10     	; 0x2a00 <MCAL_ADC_AdcInit+0x88>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc3);
    29f6:	80 e0       	ldi	r24, 0x00	; 0
    29f8:	63 e4       	ldi	r22, 0x43	; 67
    29fa:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
    29fe:	1f c0       	rjmp	.+62     	; 0x2a3e <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_4) {
    2a00:	89 81       	ldd	r24, Y+1	; 0x01
    2a02:	84 30       	cpi	r24, 0x04	; 4
    2a04:	29 f4       	brne	.+10     	; 0x2a10 <MCAL_ADC_AdcInit+0x98>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc4);
    2a06:	80 e0       	ldi	r24, 0x00	; 0
    2a08:	64 e4       	ldi	r22, 0x44	; 68
    2a0a:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
    2a0e:	17 c0       	rjmp	.+46     	; 0x2a3e <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_5) {
    2a10:	89 81       	ldd	r24, Y+1	; 0x01
    2a12:	85 30       	cpi	r24, 0x05	; 5
    2a14:	29 f4       	brne	.+10     	; 0x2a20 <MCAL_ADC_AdcInit+0xa8>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc5);
    2a16:	80 e0       	ldi	r24, 0x00	; 0
    2a18:	65 e4       	ldi	r22, 0x45	; 69
    2a1a:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
    2a1e:	0f c0       	rjmp	.+30     	; 0x2a3e <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_6) {
    2a20:	89 81       	ldd	r24, Y+1	; 0x01
    2a22:	86 30       	cpi	r24, 0x06	; 6
    2a24:	29 f4       	brne	.+10     	; 0x2a30 <MCAL_ADC_AdcInit+0xb8>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc6);
    2a26:	80 e0       	ldi	r24, 0x00	; 0
    2a28:	66 e4       	ldi	r22, 0x46	; 70
    2a2a:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
    2a2e:	07 c0       	rjmp	.+14     	; 0x2a3e <MCAL_ADC_AdcInit+0xc6>
	} else if (Loc_u8Position == Adc_7) {
    2a30:	89 81       	ldd	r24, Y+1	; 0x01
    2a32:	87 30       	cpi	r24, 0x07	; 7
    2a34:	21 f4       	brne	.+8      	; 0x2a3e <MCAL_ADC_AdcInit+0xc6>
		MCAL_ADC_u8SetRegister(Admux, ADUMX_Value_Adc7);
    2a36:	80 e0       	ldi	r24, 0x00	; 0
    2a38:	67 e4       	ldi	r22, 0x47	; 71
    2a3a:	0e 94 c2 13 	call	0x2784	; 0x2784 <MCAL_ADC_u8SetRegister>
	} else {
		//Do Nothing
	}
}
    2a3e:	0f 90       	pop	r0
    2a40:	cf 91       	pop	r28
    2a42:	df 91       	pop	r29
    2a44:	08 95       	ret

00002a46 <MCAL_ADC_AdcStartConversion>:

void MCAL_ADC_AdcStartConversion(u8 Loc_u8Value) {
    2a46:	df 93       	push	r29
    2a48:	cf 93       	push	r28
    2a4a:	0f 92       	push	r0
    2a4c:	cd b7       	in	r28, 0x3d	; 61
    2a4e:	de b7       	in	r29, 0x3e	; 62
    2a50:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8Value == Enable) {
    2a52:	89 81       	ldd	r24, Y+1	; 0x01
    2a54:	81 30       	cpi	r24, 0x01	; 1
    2a56:	31 f4       	brne	.+12     	; 0x2a64 <MCAL_ADC_AdcStartConversion+0x1e>
		MCAL_ADC_u8SetRegisterPin(Adcsra, 6, Enable);
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	66 e0       	ldi	r22, 0x06	; 6
    2a5c:	41 e0       	ldi	r20, 0x01	; 1
    2a5e:	0e 94 18 14 	call	0x2830	; 0x2830 <MCAL_ADC_u8SetRegisterPin>
    2a62:	08 c0       	rjmp	.+16     	; 0x2a74 <MCAL_ADC_AdcStartConversion+0x2e>
	} else if (Loc_u8Value == Disable) {
    2a64:	89 81       	ldd	r24, Y+1	; 0x01
    2a66:	88 23       	and	r24, r24
    2a68:	29 f4       	brne	.+10     	; 0x2a74 <MCAL_ADC_AdcStartConversion+0x2e>
		MCAL_ADC_u8SetRegisterPin(Adcsra, 6, Disable);
    2a6a:	81 e0       	ldi	r24, 0x01	; 1
    2a6c:	66 e0       	ldi	r22, 0x06	; 6
    2a6e:	40 e0       	ldi	r20, 0x00	; 0
    2a70:	0e 94 18 14 	call	0x2830	; 0x2830 <MCAL_ADC_u8SetRegisterPin>
	} else {
		//NOTHING
	}
}
    2a74:	0f 90       	pop	r0
    2a76:	cf 91       	pop	r28
    2a78:	df 91       	pop	r29
    2a7a:	08 95       	ret

00002a7c <MCAL_ADC_u8AdcSetValue>:

u8 MCAL_ADC_u8AdcSetValue(u16 *Loc_u16Value) {
    2a7c:	df 93       	push	r29
    2a7e:	cf 93       	push	r28
    2a80:	00 d0       	rcall	.+0      	; 0x2a82 <MCAL_ADC_u8AdcSetValue+0x6>
    2a82:	0f 92       	push	r0
    2a84:	cd b7       	in	r28, 0x3d	; 61
    2a86:	de b7       	in	r29, 0x3e	; 62
    2a88:	9b 83       	std	Y+3, r25	; 0x03
    2a8a:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_u8ReturnValue = E_NOT_OK;
    2a8c:	81 e0       	ldi	r24, 0x01	; 1
    2a8e:	89 83       	std	Y+1, r24	; 0x01
	*Loc_u16Value = (((u32) ADC * 5000) / 1024);
    2a90:	e4 e2       	ldi	r30, 0x24	; 36
    2a92:	f0 e0       	ldi	r31, 0x00	; 0
    2a94:	80 81       	ld	r24, Z
    2a96:	91 81       	ldd	r25, Z+1	; 0x01
    2a98:	cc 01       	movw	r24, r24
    2a9a:	a0 e0       	ldi	r26, 0x00	; 0
    2a9c:	b0 e0       	ldi	r27, 0x00	; 0
    2a9e:	28 e8       	ldi	r18, 0x88	; 136
    2aa0:	33 e1       	ldi	r19, 0x13	; 19
    2aa2:	40 e0       	ldi	r20, 0x00	; 0
    2aa4:	50 e0       	ldi	r21, 0x00	; 0
    2aa6:	bc 01       	movw	r22, r24
    2aa8:	cd 01       	movw	r24, r26
    2aaa:	0e 94 aa 3d 	call	0x7b54	; 0x7b54 <__mulsi3>
    2aae:	dc 01       	movw	r26, r24
    2ab0:	cb 01       	movw	r24, r22
    2ab2:	07 2e       	mov	r0, r23
    2ab4:	7a e0       	ldi	r23, 0x0A	; 10
    2ab6:	b6 95       	lsr	r27
    2ab8:	a7 95       	ror	r26
    2aba:	97 95       	ror	r25
    2abc:	87 95       	ror	r24
    2abe:	7a 95       	dec	r23
    2ac0:	d1 f7       	brne	.-12     	; 0x2ab6 <MCAL_ADC_u8AdcSetValue+0x3a>
    2ac2:	70 2d       	mov	r23, r0
    2ac4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ac6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ac8:	91 83       	std	Z+1, r25	; 0x01
    2aca:	80 83       	st	Z, r24
	return LOC_u8ReturnValue;
    2acc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ace:	0f 90       	pop	r0
    2ad0:	0f 90       	pop	r0
    2ad2:	0f 90       	pop	r0
    2ad4:	cf 91       	pop	r28
    2ad6:	df 91       	pop	r29
    2ad8:	08 95       	ret

00002ada <MCAL_ADC_EXIT_CallBack>:

void MCAL_ADC_EXIT_CallBack(void (*ptr)(void)) {
    2ada:	df 93       	push	r29
    2adc:	cf 93       	push	r28
    2ade:	00 d0       	rcall	.+0      	; 0x2ae0 <MCAL_ADC_EXIT_CallBack+0x6>
    2ae0:	cd b7       	in	r28, 0x3d	; 61
    2ae2:	de b7       	in	r29, 0x3e	; 62
    2ae4:	9a 83       	std	Y+2, r25	; 0x02
    2ae6:	89 83       	std	Y+1, r24	; 0x01
	if (ptr != '\0')
    2ae8:	89 81       	ldd	r24, Y+1	; 0x01
    2aea:	9a 81       	ldd	r25, Y+2	; 0x02
    2aec:	00 97       	sbiw	r24, 0x00	; 0
    2aee:	31 f0       	breq	.+12     	; 0x2afc <MCAL_ADC_EXIT_CallBack+0x22>
		Gptr_ADC = ptr;
    2af0:	89 81       	ldd	r24, Y+1	; 0x01
    2af2:	9a 81       	ldd	r25, Y+2	; 0x02
    2af4:	90 93 91 01 	sts	0x0191, r25
    2af8:	80 93 90 01 	sts	0x0190, r24
}
    2afc:	0f 90       	pop	r0
    2afe:	0f 90       	pop	r0
    2b00:	cf 91       	pop	r28
    2b02:	df 91       	pop	r29
    2b04:	08 95       	ret

00002b06 <__vector_16>:

ISR(ADC_vect) {
    2b06:	1f 92       	push	r1
    2b08:	0f 92       	push	r0
    2b0a:	0f b6       	in	r0, 0x3f	; 63
    2b0c:	0f 92       	push	r0
    2b0e:	11 24       	eor	r1, r1
    2b10:	2f 93       	push	r18
    2b12:	3f 93       	push	r19
    2b14:	4f 93       	push	r20
    2b16:	5f 93       	push	r21
    2b18:	6f 93       	push	r22
    2b1a:	7f 93       	push	r23
    2b1c:	8f 93       	push	r24
    2b1e:	9f 93       	push	r25
    2b20:	af 93       	push	r26
    2b22:	bf 93       	push	r27
    2b24:	ef 93       	push	r30
    2b26:	ff 93       	push	r31
    2b28:	df 93       	push	r29
    2b2a:	cf 93       	push	r28
    2b2c:	cd b7       	in	r28, 0x3d	; 61
    2b2e:	de b7       	in	r29, 0x3e	; 62
	if (Gptr_ADC != '\0')
    2b30:	80 91 90 01 	lds	r24, 0x0190
    2b34:	90 91 91 01 	lds	r25, 0x0191
    2b38:	00 97       	sbiw	r24, 0x00	; 0
    2b3a:	29 f0       	breq	.+10     	; 0x2b46 <__vector_16+0x40>
		Gptr_ADC();
    2b3c:	e0 91 90 01 	lds	r30, 0x0190
    2b40:	f0 91 91 01 	lds	r31, 0x0191
    2b44:	09 95       	icall
}
    2b46:	cf 91       	pop	r28
    2b48:	df 91       	pop	r29
    2b4a:	ff 91       	pop	r31
    2b4c:	ef 91       	pop	r30
    2b4e:	bf 91       	pop	r27
    2b50:	af 91       	pop	r26
    2b52:	9f 91       	pop	r25
    2b54:	8f 91       	pop	r24
    2b56:	7f 91       	pop	r23
    2b58:	6f 91       	pop	r22
    2b5a:	5f 91       	pop	r21
    2b5c:	4f 91       	pop	r20
    2b5e:	3f 91       	pop	r19
    2b60:	2f 91       	pop	r18
    2b62:	0f 90       	pop	r0
    2b64:	0f be       	out	0x3f, r0	; 63
    2b66:	0f 90       	pop	r0
    2b68:	1f 90       	pop	r1
    2b6a:	18 95       	reti

00002b6c <ultrasonic_init>:
volatile  u16 start_time=NUM0,end_time=NUM0,timeDiff=NUM0;
volatile  u16 ovfCounter_start,ovfCounter_end;
extern volatile   u16 OvfCounter;

void ultrasonic_init(void)
{
    2b6c:	df 93       	push	r29
    2b6e:	cf 93       	push	r28
    2b70:	cd b7       	in	r28, 0x3d	; 61
    2b72:	de b7       	in	r29, 0x3e	; 62
    MCAL_DIO_u8SetPinDirection(ECHO_PORT,ECHO_PIN,Pin_Low);      //  echo
    2b74:	83 e0       	ldi	r24, 0x03	; 3
    2b76:	62 e0       	ldi	r22, 0x02	; 2
    2b78:	40 e0       	ldi	r20, 0x00	; 0
    2b7a:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
    MCAL_DIO_u8SetPinDirection(TRIG_PORT,TRIG_PIN,Pin_High);  //  trigger
    2b7e:	83 e0       	ldi	r24, 0x03	; 3
    2b80:	66 e0       	ldi	r22, 0x06	; 6
    2b82:	41 e0       	ldi	r20, 0x01	; 1
    2b84:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
    MCAL_Interrupt_EXIT_CallBack_0(&EXTI_action);                             // external interrupt call back
    2b88:	8c e4       	ldi	r24, 0x4C	; 76
    2b8a:	97 e1       	ldi	r25, 0x17	; 23
    2b8c:	0e 94 55 0e 	call	0x1caa	; 0x1caa <MCAL_Interrupt_EXIT_CallBack_0>
}
    2b90:	cf 91       	pop	r28
    2b92:	df 91       	pop	r29
    2b94:	08 95       	ret

00002b96 <ultrasonic_sendTrigger>:

void ultrasonic_sendTrigger(void)
{
    2b96:	df 93       	push	r29
    2b98:	cf 93       	push	r28
    2b9a:	cd b7       	in	r28, 0x3d	; 61
    2b9c:	de b7       	in	r29, 0x3e	; 62
    2b9e:	68 97       	sbiw	r28, 0x18	; 24
    2ba0:	0f b6       	in	r0, 0x3f	; 63
    2ba2:	f8 94       	cli
    2ba4:	de bf       	out	0x3e, r29	; 62
    2ba6:	0f be       	out	0x3f, r0	; 63
    2ba8:	cd bf       	out	0x3d, r28	; 61
	MCAL_DIO_u8SetPinValue(TRIG_PORT,TRIG_PIN,Pin_High);    // high
    2baa:	83 e0       	ldi	r24, 0x03	; 3
    2bac:	66 e0       	ldi	r22, 0x06	; 6
    2bae:	41 e0       	ldi	r20, 0x01	; 1
    2bb0:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    2bb4:	80 e0       	ldi	r24, 0x00	; 0
    2bb6:	90 e0       	ldi	r25, 0x00	; 0
    2bb8:	a0 e2       	ldi	r26, 0x20	; 32
    2bba:	b1 e4       	ldi	r27, 0x41	; 65
    2bbc:	8d 8b       	std	Y+21, r24	; 0x15
    2bbe:	9e 8b       	std	Y+22, r25	; 0x16
    2bc0:	af 8b       	std	Y+23, r26	; 0x17
    2bc2:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2bc4:	6d 89       	ldd	r22, Y+21	; 0x15
    2bc6:	7e 89       	ldd	r23, Y+22	; 0x16
    2bc8:	8f 89       	ldd	r24, Y+23	; 0x17
    2bca:	98 8d       	ldd	r25, Y+24	; 0x18
    2bcc:	2b ea       	ldi	r18, 0xAB	; 171
    2bce:	3a ea       	ldi	r19, 0xAA	; 170
    2bd0:	4a ea       	ldi	r20, 0xAA	; 170
    2bd2:	50 e4       	ldi	r21, 0x40	; 64
    2bd4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2bd8:	dc 01       	movw	r26, r24
    2bda:	cb 01       	movw	r24, r22
    2bdc:	89 8b       	std	Y+17, r24	; 0x11
    2bde:	9a 8b       	std	Y+18, r25	; 0x12
    2be0:	ab 8b       	std	Y+19, r26	; 0x13
    2be2:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    2be4:	69 89       	ldd	r22, Y+17	; 0x11
    2be6:	7a 89       	ldd	r23, Y+18	; 0x12
    2be8:	8b 89       	ldd	r24, Y+19	; 0x13
    2bea:	9c 89       	ldd	r25, Y+20	; 0x14
    2bec:	20 e0       	ldi	r18, 0x00	; 0
    2bee:	30 e0       	ldi	r19, 0x00	; 0
    2bf0:	40 e8       	ldi	r20, 0x80	; 128
    2bf2:	5f e3       	ldi	r21, 0x3F	; 63
    2bf4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2bf8:	88 23       	and	r24, r24
    2bfa:	1c f4       	brge	.+6      	; 0x2c02 <ultrasonic_sendTrigger+0x6c>
		__ticks = 1;
    2bfc:	81 e0       	ldi	r24, 0x01	; 1
    2bfe:	88 8b       	std	Y+16, r24	; 0x10
    2c00:	91 c0       	rjmp	.+290    	; 0x2d24 <ultrasonic_sendTrigger+0x18e>
	else if (__tmp > 255)
    2c02:	69 89       	ldd	r22, Y+17	; 0x11
    2c04:	7a 89       	ldd	r23, Y+18	; 0x12
    2c06:	8b 89       	ldd	r24, Y+19	; 0x13
    2c08:	9c 89       	ldd	r25, Y+20	; 0x14
    2c0a:	20 e0       	ldi	r18, 0x00	; 0
    2c0c:	30 e0       	ldi	r19, 0x00	; 0
    2c0e:	4f e7       	ldi	r20, 0x7F	; 127
    2c10:	53 e4       	ldi	r21, 0x43	; 67
    2c12:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2c16:	18 16       	cp	r1, r24
    2c18:	0c f0       	brlt	.+2      	; 0x2c1c <ultrasonic_sendTrigger+0x86>
    2c1a:	7b c0       	rjmp	.+246    	; 0x2d12 <ultrasonic_sendTrigger+0x17c>
	{
		_delay_ms(__us / 1000.0);
    2c1c:	6d 89       	ldd	r22, Y+21	; 0x15
    2c1e:	7e 89       	ldd	r23, Y+22	; 0x16
    2c20:	8f 89       	ldd	r24, Y+23	; 0x17
    2c22:	98 8d       	ldd	r25, Y+24	; 0x18
    2c24:	20 e0       	ldi	r18, 0x00	; 0
    2c26:	30 e0       	ldi	r19, 0x00	; 0
    2c28:	4a e7       	ldi	r20, 0x7A	; 122
    2c2a:	54 e4       	ldi	r21, 0x44	; 68
    2c2c:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2c30:	dc 01       	movw	r26, r24
    2c32:	cb 01       	movw	r24, r22
    2c34:	8c 87       	std	Y+12, r24	; 0x0c
    2c36:	9d 87       	std	Y+13, r25	; 0x0d
    2c38:	ae 87       	std	Y+14, r26	; 0x0e
    2c3a:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2c3c:	6c 85       	ldd	r22, Y+12	; 0x0c
    2c3e:	7d 85       	ldd	r23, Y+13	; 0x0d
    2c40:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c42:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c44:	20 e0       	ldi	r18, 0x00	; 0
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	4a e7       	ldi	r20, 0x7A	; 122
    2c4a:	55 e4       	ldi	r21, 0x45	; 69
    2c4c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c50:	dc 01       	movw	r26, r24
    2c52:	cb 01       	movw	r24, r22
    2c54:	88 87       	std	Y+8, r24	; 0x08
    2c56:	99 87       	std	Y+9, r25	; 0x09
    2c58:	aa 87       	std	Y+10, r26	; 0x0a
    2c5a:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    2c5c:	68 85       	ldd	r22, Y+8	; 0x08
    2c5e:	79 85       	ldd	r23, Y+9	; 0x09
    2c60:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c62:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c64:	20 e0       	ldi	r18, 0x00	; 0
    2c66:	30 e0       	ldi	r19, 0x00	; 0
    2c68:	40 e8       	ldi	r20, 0x80	; 128
    2c6a:	5f e3       	ldi	r21, 0x3F	; 63
    2c6c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2c70:	88 23       	and	r24, r24
    2c72:	2c f4       	brge	.+10     	; 0x2c7e <ultrasonic_sendTrigger+0xe8>
		__ticks = 1;
    2c74:	81 e0       	ldi	r24, 0x01	; 1
    2c76:	90 e0       	ldi	r25, 0x00	; 0
    2c78:	9f 83       	std	Y+7, r25	; 0x07
    2c7a:	8e 83       	std	Y+6, r24	; 0x06
    2c7c:	3f c0       	rjmp	.+126    	; 0x2cfc <ultrasonic_sendTrigger+0x166>
	else if (__tmp > 65535)
    2c7e:	68 85       	ldd	r22, Y+8	; 0x08
    2c80:	79 85       	ldd	r23, Y+9	; 0x09
    2c82:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c84:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c86:	20 e0       	ldi	r18, 0x00	; 0
    2c88:	3f ef       	ldi	r19, 0xFF	; 255
    2c8a:	4f e7       	ldi	r20, 0x7F	; 127
    2c8c:	57 e4       	ldi	r21, 0x47	; 71
    2c8e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2c92:	18 16       	cp	r1, r24
    2c94:	4c f5       	brge	.+82     	; 0x2ce8 <ultrasonic_sendTrigger+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c96:	6c 85       	ldd	r22, Y+12	; 0x0c
    2c98:	7d 85       	ldd	r23, Y+13	; 0x0d
    2c9a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c9c:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c9e:	20 e0       	ldi	r18, 0x00	; 0
    2ca0:	30 e0       	ldi	r19, 0x00	; 0
    2ca2:	40 e2       	ldi	r20, 0x20	; 32
    2ca4:	51 e4       	ldi	r21, 0x41	; 65
    2ca6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2caa:	dc 01       	movw	r26, r24
    2cac:	cb 01       	movw	r24, r22
    2cae:	bc 01       	movw	r22, r24
    2cb0:	cd 01       	movw	r24, r26
    2cb2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2cb6:	dc 01       	movw	r26, r24
    2cb8:	cb 01       	movw	r24, r22
    2cba:	9f 83       	std	Y+7, r25	; 0x07
    2cbc:	8e 83       	std	Y+6, r24	; 0x06
    2cbe:	0f c0       	rjmp	.+30     	; 0x2cde <ultrasonic_sendTrigger+0x148>
    2cc0:	80 e9       	ldi	r24, 0x90	; 144
    2cc2:	91 e0       	ldi	r25, 0x01	; 1
    2cc4:	9d 83       	std	Y+5, r25	; 0x05
    2cc6:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2cc8:	8c 81       	ldd	r24, Y+4	; 0x04
    2cca:	9d 81       	ldd	r25, Y+5	; 0x05
    2ccc:	01 97       	sbiw	r24, 0x01	; 1
    2cce:	f1 f7       	brne	.-4      	; 0x2ccc <ultrasonic_sendTrigger+0x136>
    2cd0:	9d 83       	std	Y+5, r25	; 0x05
    2cd2:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2cd4:	8e 81       	ldd	r24, Y+6	; 0x06
    2cd6:	9f 81       	ldd	r25, Y+7	; 0x07
    2cd8:	01 97       	sbiw	r24, 0x01	; 1
    2cda:	9f 83       	std	Y+7, r25	; 0x07
    2cdc:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2cde:	8e 81       	ldd	r24, Y+6	; 0x06
    2ce0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ce2:	00 97       	sbiw	r24, 0x00	; 0
    2ce4:	69 f7       	brne	.-38     	; 0x2cc0 <ultrasonic_sendTrigger+0x12a>
    2ce6:	24 c0       	rjmp	.+72     	; 0x2d30 <ultrasonic_sendTrigger+0x19a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2ce8:	68 85       	ldd	r22, Y+8	; 0x08
    2cea:	79 85       	ldd	r23, Y+9	; 0x09
    2cec:	8a 85       	ldd	r24, Y+10	; 0x0a
    2cee:	9b 85       	ldd	r25, Y+11	; 0x0b
    2cf0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2cf4:	dc 01       	movw	r26, r24
    2cf6:	cb 01       	movw	r24, r22
    2cf8:	9f 83       	std	Y+7, r25	; 0x07
    2cfa:	8e 83       	std	Y+6, r24	; 0x06
    2cfc:	8e 81       	ldd	r24, Y+6	; 0x06
    2cfe:	9f 81       	ldd	r25, Y+7	; 0x07
    2d00:	9b 83       	std	Y+3, r25	; 0x03
    2d02:	8a 83       	std	Y+2, r24	; 0x02
    2d04:	8a 81       	ldd	r24, Y+2	; 0x02
    2d06:	9b 81       	ldd	r25, Y+3	; 0x03
    2d08:	01 97       	sbiw	r24, 0x01	; 1
    2d0a:	f1 f7       	brne	.-4      	; 0x2d08 <ultrasonic_sendTrigger+0x172>
    2d0c:	9b 83       	std	Y+3, r25	; 0x03
    2d0e:	8a 83       	std	Y+2, r24	; 0x02
    2d10:	0f c0       	rjmp	.+30     	; 0x2d30 <ultrasonic_sendTrigger+0x19a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2d12:	69 89       	ldd	r22, Y+17	; 0x11
    2d14:	7a 89       	ldd	r23, Y+18	; 0x12
    2d16:	8b 89       	ldd	r24, Y+19	; 0x13
    2d18:	9c 89       	ldd	r25, Y+20	; 0x14
    2d1a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d1e:	dc 01       	movw	r26, r24
    2d20:	cb 01       	movw	r24, r22
    2d22:	88 8b       	std	Y+16, r24	; 0x10
    2d24:	88 89       	ldd	r24, Y+16	; 0x10
    2d26:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2d28:	89 81       	ldd	r24, Y+1	; 0x01
    2d2a:	8a 95       	dec	r24
    2d2c:	f1 f7       	brne	.-4      	; 0x2d2a <ultrasonic_sendTrigger+0x194>
    2d2e:	89 83       	std	Y+1, r24	; 0x01
    _delay_us(10);                                             // 10 micro seconds delay
    MCAL_DIO_u8SetPinValue(TRIG_PORT,TRIG_PIN,Pin_Low);     // low
    2d30:	83 e0       	ldi	r24, 0x03	; 3
    2d32:	66 e0       	ldi	r22, 0x06	; 6
    2d34:	40 e0       	ldi	r20, 0x00	; 0
    2d36:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
}
    2d3a:	68 96       	adiw	r28, 0x18	; 24
    2d3c:	0f b6       	in	r0, 0x3f	; 63
    2d3e:	f8 94       	cli
    2d40:	de bf       	out	0x3e, r29	; 62
    2d42:	0f be       	out	0x3f, r0	; 63
    2d44:	cd bf       	out	0x3d, r28	; 61
    2d46:	cf 91       	pop	r28
    2d48:	df 91       	pop	r29
    2d4a:	08 95       	ret

00002d4c <ultrasonic_get_Distance>:

void ultrasonic_get_Distance(f32* returned_distance)
{
    2d4c:	df 93       	push	r29
    2d4e:	cf 93       	push	r28
    2d50:	cd b7       	in	r28, 0x3d	; 61
    2d52:	de b7       	in	r29, 0x3e	; 62
    2d54:	60 97       	sbiw	r28, 0x10	; 16
    2d56:	0f b6       	in	r0, 0x3f	; 63
    2d58:	f8 94       	cli
    2d5a:	de bf       	out	0x3e, r29	; 62
    2d5c:	0f be       	out	0x3f, r0	; 63
    2d5e:	cd bf       	out	0x3d, r28	; 61
    2d60:	98 8b       	std	Y+16, r25	; 0x10
    2d62:	8f 87       	std	Y+15, r24	; 0x0f
    ultrasonic_sendTrigger();                                  // send trigger
    2d64:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <ultrasonic_sendTrigger>
	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin6, Pin_High);
    2d68:	81 e0       	ldi	r24, 0x01	; 1
    2d6a:	66 e0       	ldi	r22, 0x06	; 6
    2d6c:	41 e0       	ldi	r20, 0x01	; 1
    2d6e:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
    MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin0 , Pin_High);
    2d72:	82 e0       	ldi	r24, 0x02	; 2
    2d74:	60 e0       	ldi	r22, 0x00	; 0
    2d76:	41 e0       	ldi	r20, 0x01	; 1
    2d78:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
    	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin1 , Pin_High);
    2d7c:	82 e0       	ldi	r24, 0x02	; 2
    2d7e:	61 e0       	ldi	r22, 0x01	; 1
    2d80:	41 e0       	ldi	r20, 0x01	; 1
    2d82:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
    2d86:	80 e0       	ldi	r24, 0x00	; 0
    2d88:	90 e0       	ldi	r25, 0x00	; 0
    2d8a:	a8 e4       	ldi	r26, 0x48	; 72
    2d8c:	b2 e4       	ldi	r27, 0x42	; 66
    2d8e:	8b 87       	std	Y+11, r24	; 0x0b
    2d90:	9c 87       	std	Y+12, r25	; 0x0c
    2d92:	ad 87       	std	Y+13, r26	; 0x0d
    2d94:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2d96:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d98:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d9e:	20 e0       	ldi	r18, 0x00	; 0
    2da0:	30 e0       	ldi	r19, 0x00	; 0
    2da2:	4a e7       	ldi	r20, 0x7A	; 122
    2da4:	55 e4       	ldi	r21, 0x45	; 69
    2da6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2daa:	dc 01       	movw	r26, r24
    2dac:	cb 01       	movw	r24, r22
    2dae:	8f 83       	std	Y+7, r24	; 0x07
    2db0:	98 87       	std	Y+8, r25	; 0x08
    2db2:	a9 87       	std	Y+9, r26	; 0x09
    2db4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2db6:	6f 81       	ldd	r22, Y+7	; 0x07
    2db8:	78 85       	ldd	r23, Y+8	; 0x08
    2dba:	89 85       	ldd	r24, Y+9	; 0x09
    2dbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dbe:	20 e0       	ldi	r18, 0x00	; 0
    2dc0:	30 e0       	ldi	r19, 0x00	; 0
    2dc2:	40 e8       	ldi	r20, 0x80	; 128
    2dc4:	5f e3       	ldi	r21, 0x3F	; 63
    2dc6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2dca:	88 23       	and	r24, r24
    2dcc:	2c f4       	brge	.+10     	; 0x2dd8 <ultrasonic_get_Distance+0x8c>
		__ticks = 1;
    2dce:	81 e0       	ldi	r24, 0x01	; 1
    2dd0:	90 e0       	ldi	r25, 0x00	; 0
    2dd2:	9e 83       	std	Y+6, r25	; 0x06
    2dd4:	8d 83       	std	Y+5, r24	; 0x05
    2dd6:	3f c0       	rjmp	.+126    	; 0x2e56 <ultrasonic_get_Distance+0x10a>
	else if (__tmp > 65535)
    2dd8:	6f 81       	ldd	r22, Y+7	; 0x07
    2dda:	78 85       	ldd	r23, Y+8	; 0x08
    2ddc:	89 85       	ldd	r24, Y+9	; 0x09
    2dde:	9a 85       	ldd	r25, Y+10	; 0x0a
    2de0:	20 e0       	ldi	r18, 0x00	; 0
    2de2:	3f ef       	ldi	r19, 0xFF	; 255
    2de4:	4f e7       	ldi	r20, 0x7F	; 127
    2de6:	57 e4       	ldi	r21, 0x47	; 71
    2de8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2dec:	18 16       	cp	r1, r24
    2dee:	4c f5       	brge	.+82     	; 0x2e42 <ultrasonic_get_Distance+0xf6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2df0:	6b 85       	ldd	r22, Y+11	; 0x0b
    2df2:	7c 85       	ldd	r23, Y+12	; 0x0c
    2df4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2df6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2df8:	20 e0       	ldi	r18, 0x00	; 0
    2dfa:	30 e0       	ldi	r19, 0x00	; 0
    2dfc:	40 e2       	ldi	r20, 0x20	; 32
    2dfe:	51 e4       	ldi	r21, 0x41	; 65
    2e00:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2e04:	dc 01       	movw	r26, r24
    2e06:	cb 01       	movw	r24, r22
    2e08:	bc 01       	movw	r22, r24
    2e0a:	cd 01       	movw	r24, r26
    2e0c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e10:	dc 01       	movw	r26, r24
    2e12:	cb 01       	movw	r24, r22
    2e14:	9e 83       	std	Y+6, r25	; 0x06
    2e16:	8d 83       	std	Y+5, r24	; 0x05
    2e18:	0f c0       	rjmp	.+30     	; 0x2e38 <ultrasonic_get_Distance+0xec>
    2e1a:	80 e9       	ldi	r24, 0x90	; 144
    2e1c:	91 e0       	ldi	r25, 0x01	; 1
    2e1e:	9c 83       	std	Y+4, r25	; 0x04
    2e20:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2e22:	8b 81       	ldd	r24, Y+3	; 0x03
    2e24:	9c 81       	ldd	r25, Y+4	; 0x04
    2e26:	01 97       	sbiw	r24, 0x01	; 1
    2e28:	f1 f7       	brne	.-4      	; 0x2e26 <ultrasonic_get_Distance+0xda>
    2e2a:	9c 83       	std	Y+4, r25	; 0x04
    2e2c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e2e:	8d 81       	ldd	r24, Y+5	; 0x05
    2e30:	9e 81       	ldd	r25, Y+6	; 0x06
    2e32:	01 97       	sbiw	r24, 0x01	; 1
    2e34:	9e 83       	std	Y+6, r25	; 0x06
    2e36:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e38:	8d 81       	ldd	r24, Y+5	; 0x05
    2e3a:	9e 81       	ldd	r25, Y+6	; 0x06
    2e3c:	00 97       	sbiw	r24, 0x00	; 0
    2e3e:	69 f7       	brne	.-38     	; 0x2e1a <ultrasonic_get_Distance+0xce>
    2e40:	14 c0       	rjmp	.+40     	; 0x2e6a <ultrasonic_get_Distance+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e42:	6f 81       	ldd	r22, Y+7	; 0x07
    2e44:	78 85       	ldd	r23, Y+8	; 0x08
    2e46:	89 85       	ldd	r24, Y+9	; 0x09
    2e48:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e4a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e4e:	dc 01       	movw	r26, r24
    2e50:	cb 01       	movw	r24, r22
    2e52:	9e 83       	std	Y+6, r25	; 0x06
    2e54:	8d 83       	std	Y+5, r24	; 0x05
    2e56:	8d 81       	ldd	r24, Y+5	; 0x05
    2e58:	9e 81       	ldd	r25, Y+6	; 0x06
    2e5a:	9a 83       	std	Y+2, r25	; 0x02
    2e5c:	89 83       	std	Y+1, r24	; 0x01
    2e5e:	89 81       	ldd	r24, Y+1	; 0x01
    2e60:	9a 81       	ldd	r25, Y+2	; 0x02
    2e62:	01 97       	sbiw	r24, 0x01	; 1
    2e64:	f1 f7       	brne	.-4      	; 0x2e62 <ultrasonic_get_Distance+0x116>
    2e66:	9a 83       	std	Y+2, r25	; 0x02
    2e68:	89 83       	std	Y+1, r24	; 0x01
    _delay_ms(50);                                             // stability delay
    *returned_distance=distance;                               // get the distance
    2e6a:	80 91 92 01 	lds	r24, 0x0192
    2e6e:	90 91 93 01 	lds	r25, 0x0193
    2e72:	a0 91 94 01 	lds	r26, 0x0194
    2e76:	b0 91 95 01 	lds	r27, 0x0195
    2e7a:	ef 85       	ldd	r30, Y+15	; 0x0f
    2e7c:	f8 89       	ldd	r31, Y+16	; 0x10
    2e7e:	80 83       	st	Z, r24
    2e80:	91 83       	std	Z+1, r25	; 0x01
    2e82:	a2 83       	std	Z+2, r26	; 0x02
    2e84:	b3 83       	std	Z+3, r27	; 0x03
}
    2e86:	60 96       	adiw	r28, 0x10	; 16
    2e88:	0f b6       	in	r0, 0x3f	; 63
    2e8a:	f8 94       	cli
    2e8c:	de bf       	out	0x3e, r29	; 62
    2e8e:	0f be       	out	0x3f, r0	; 63
    2e90:	cd bf       	out	0x3d, r28	; 61
    2e92:	cf 91       	pop	r28
    2e94:	df 91       	pop	r29
    2e96:	08 95       	ret

00002e98 <EXTI_action>:
void EXTI_action(void)                                       // call back function
{
    2e98:	df 93       	push	r29
    2e9a:	cf 93       	push	r28
    2e9c:	cd b7       	in	r28, 0x3d	; 61
    2e9e:	de b7       	in	r29, 0x3e	; 62

    if (exit_count<=2)          // check for counter status
    2ea0:	80 91 6d 01 	lds	r24, 0x016D
    2ea4:	83 30       	cpi	r24, 0x03	; 3
    2ea6:	08 f0       	brcs	.+2      	; 0x2eaa <EXTI_action+0x12>
    2ea8:	82 c0       	rjmp	.+260    	; 0x2fae <EXTI_action+0x116>
    {
         if (exit_count==NUM1)      // check if it is the first entry
    2eaa:	80 91 6d 01 	lds	r24, 0x016D
    2eae:	81 30       	cpi	r24, 0x01	; 1
    2eb0:	09 f5       	brne	.+66     	; 0x2ef4 <EXTI_action+0x5c>
        {
            // store the start time value
            start_time=TCNT0;
    2eb2:	e2 e5       	ldi	r30, 0x52	; 82
    2eb4:	f0 e0       	ldi	r31, 0x00	; 0
    2eb6:	80 81       	ld	r24, Z
    2eb8:	88 2f       	mov	r24, r24
    2eba:	90 e0       	ldi	r25, 0x00	; 0
    2ebc:	90 93 97 01 	sts	0x0197, r25
    2ec0:	80 93 96 01 	sts	0x0196, r24

            // store number of OVFs at the start of the signal
            ovfCounter_start=OvfCounter;
    2ec4:	80 91 82 01 	lds	r24, 0x0182
    2ec8:	90 91 83 01 	lds	r25, 0x0183
    2ecc:	90 93 28 06 	sts	0x0628, r25
    2ed0:	80 93 27 06 	sts	0x0627, r24

            // at the first entry  we change the capture edge to falling edge to capture echo signal
        	MCAL_Interrupt_u8SetRegisterPin(Gicr, GICR_Pin6, Pin_High);
    2ed4:	81 e0       	ldi	r24, 0x01	; 1
    2ed6:	66 e0       	ldi	r22, 0x06	; 6
    2ed8:	41 e0       	ldi	r20, 0x01	; 1
    2eda:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
            MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin0 , Pin_Low);
    2ede:	82 e0       	ldi	r24, 0x02	; 2
    2ee0:	60 e0       	ldi	r22, 0x00	; 0
    2ee2:	40 e0       	ldi	r20, 0x00	; 0
    2ee4:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
        	MCAL_Interrupt_u8SetRegisterPin(Mcucr,MCUCR_Pin1 , Pin_High);
    2ee8:	82 e0       	ldi	r24, 0x02	; 2
    2eea:	61 e0       	ldi	r22, 0x01	; 1
    2eec:	41 e0       	ldi	r20, 0x01	; 1
    2eee:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <MCAL_Interrupt_u8SetRegisterPin>
    2ef2:	58 c0       	rjmp	.+176    	; 0x2fa4 <EXTI_action+0x10c>
        }

        else if(exit_count==2) // check if it's the second entry
    2ef4:	80 91 6d 01 	lds	r24, 0x016D
    2ef8:	82 30       	cpi	r24, 0x02	; 2
    2efa:	09 f0       	breq	.+2      	; 0x2efe <EXTI_action+0x66>
    2efc:	53 c0       	rjmp	.+166    	; 0x2fa4 <EXTI_action+0x10c>
        {
            //store end time value
            end_time=TCNT0;
    2efe:	e2 e5       	ldi	r30, 0x52	; 82
    2f00:	f0 e0       	ldi	r31, 0x00	; 0
    2f02:	80 81       	ld	r24, Z
    2f04:	88 2f       	mov	r24, r24
    2f06:	90 e0       	ldi	r25, 0x00	; 0
    2f08:	90 93 99 01 	sts	0x0199, r25
    2f0c:	80 93 98 01 	sts	0x0198, r24

            //store number of OVFs at the end of signal
            ovfCounter_end=OvfCounter;
    2f10:	80 91 82 01 	lds	r24, 0x0182
    2f14:	90 91 83 01 	lds	r25, 0x0183
    2f18:	90 93 26 06 	sts	0x0626, r25
    2f1c:	80 93 25 06 	sts	0x0625, r24

            //calculate the time difference between start and end
            timeDiff=(end_time+(256*ovfCounter_end))-(start_time+(256*ovfCounter_start));
    2f20:	80 91 25 06 	lds	r24, 0x0625
    2f24:	90 91 26 06 	lds	r25, 0x0626
    2f28:	38 2f       	mov	r19, r24
    2f2a:	22 27       	eor	r18, r18
    2f2c:	80 91 98 01 	lds	r24, 0x0198
    2f30:	90 91 99 01 	lds	r25, 0x0199
    2f34:	a9 01       	movw	r20, r18
    2f36:	48 0f       	add	r20, r24
    2f38:	59 1f       	adc	r21, r25
    2f3a:	80 91 27 06 	lds	r24, 0x0627
    2f3e:	90 91 28 06 	lds	r25, 0x0628
    2f42:	38 2f       	mov	r19, r24
    2f44:	22 27       	eor	r18, r18
    2f46:	80 91 96 01 	lds	r24, 0x0196
    2f4a:	90 91 97 01 	lds	r25, 0x0197
    2f4e:	82 0f       	add	r24, r18
    2f50:	93 1f       	adc	r25, r19
    2f52:	9a 01       	movw	r18, r20
    2f54:	28 1b       	sub	r18, r24
    2f56:	39 0b       	sbc	r19, r25
    2f58:	c9 01       	movw	r24, r18
    2f5a:	90 93 9b 01 	sts	0x019B, r25
    2f5e:	80 93 9a 01 	sts	0x019A, r24

            //calculate the distance
            distance=timeDiff*0.068;//     f32 ton=(h(64/16000000))/2 >>     distance=ton34000;
    2f62:	80 91 9a 01 	lds	r24, 0x019A
    2f66:	90 91 9b 01 	lds	r25, 0x019B
    2f6a:	cc 01       	movw	r24, r24
    2f6c:	a0 e0       	ldi	r26, 0x00	; 0
    2f6e:	b0 e0       	ldi	r27, 0x00	; 0
    2f70:	bc 01       	movw	r22, r24
    2f72:	cd 01       	movw	r24, r26
    2f74:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    2f78:	dc 01       	movw	r26, r24
    2f7a:	cb 01       	movw	r24, r22
    2f7c:	bc 01       	movw	r22, r24
    2f7e:	cd 01       	movw	r24, r26
    2f80:	26 e9       	ldi	r18, 0x96	; 150
    2f82:	33 e4       	ldi	r19, 0x43	; 67
    2f84:	4b e8       	ldi	r20, 0x8B	; 139
    2f86:	5d e3       	ldi	r21, 0x3D	; 61
    2f88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2f8c:	dc 01       	movw	r26, r24
    2f8e:	cb 01       	movw	r24, r22
    2f90:	80 93 92 01 	sts	0x0192, r24
    2f94:	90 93 93 01 	sts	0x0193, r25
    2f98:	a0 93 94 01 	sts	0x0194, r26
    2f9c:	b0 93 95 01 	sts	0x0195, r27

            //reset the counter to calculate new signal
            exit_count=NUM0;
    2fa0:	10 92 6d 01 	sts	0x016D, r1

        }

        //increase the counter to sync with the entry state
        exit_count++;
    2fa4:	80 91 6d 01 	lds	r24, 0x016D
    2fa8:	8f 5f       	subi	r24, 0xFF	; 255
    2faa:	80 93 6d 01 	sts	0x016D, r24
    }

}
    2fae:	cf 91       	pop	r28
    2fb0:	df 91       	pop	r29
    2fb2:	08 95       	ret

00002fb4 <HAL_LED_u8LedInit>:
 *  Created on: Sep 25, 2023
 *      Author: Mohamed
 */
#include "LED.h"

STD_Type HAL_LED_u8LedInit(u8 Loc_u8LEDPortID, u8 Loc_u8LEDPinID) {
    2fb4:	df 93       	push	r29
    2fb6:	cf 93       	push	r28
    2fb8:	00 d0       	rcall	.+0      	; 0x2fba <HAL_LED_u8LedInit+0x6>
    2fba:	0f 92       	push	r0
    2fbc:	cd b7       	in	r28, 0x3d	; 61
    2fbe:	de b7       	in	r29, 0x3e	; 62
    2fc0:	8a 83       	std	Y+2, r24	; 0x02
    2fc2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    2fc4:	81 e0       	ldi	r24, 0x01	; 1
    2fc6:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8LEDPortID <= PortD && Loc_u8LEDPinID <= Num_Of_Pins) {
    2fc8:	8a 81       	ldd	r24, Y+2	; 0x02
    2fca:	84 30       	cpi	r24, 0x04	; 4
    2fcc:	48 f4       	brcc	.+18     	; 0x2fe0 <HAL_LED_u8LedInit+0x2c>
    2fce:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd0:	88 30       	cpi	r24, 0x08	; 8
    2fd2:	30 f4       	brcc	.+12     	; 0x2fe0 <HAL_LED_u8LedInit+0x2c>
		Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8LEDPortID,
    2fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd6:	6b 81       	ldd	r22, Y+3	; 0x03
    2fd8:	41 e0       	ldi	r20, 0x01	; 1
    2fda:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
    2fde:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8LEDPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    2fe0:	89 81       	ldd	r24, Y+1	; 0x01
}
    2fe2:	0f 90       	pop	r0
    2fe4:	0f 90       	pop	r0
    2fe6:	0f 90       	pop	r0
    2fe8:	cf 91       	pop	r28
    2fea:	df 91       	pop	r29
    2fec:	08 95       	ret

00002fee <HAL_LED_u8LedMode>:

STD_Type HAL_LED_u8LedMode(u8 Loc_u8LEDPortID, u8 Loc_u8LEDPinID,
		u8 Loc_u8LEDMode) {
    2fee:	df 93       	push	r29
    2ff0:	cf 93       	push	r28
    2ff2:	00 d0       	rcall	.+0      	; 0x2ff4 <HAL_LED_u8LedMode+0x6>
    2ff4:	00 d0       	rcall	.+0      	; 0x2ff6 <HAL_LED_u8LedMode+0x8>
    2ff6:	cd b7       	in	r28, 0x3d	; 61
    2ff8:	de b7       	in	r29, 0x3e	; 62
    2ffa:	8a 83       	std	Y+2, r24	; 0x02
    2ffc:	6b 83       	std	Y+3, r22	; 0x03
    2ffe:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    3000:	81 e0       	ldi	r24, 0x01	; 1
    3002:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8LEDPortID <= PortD && Loc_u8LEDPinID <= Num_Of_Pins
    3004:	8a 81       	ldd	r24, Y+2	; 0x02
    3006:	84 30       	cpi	r24, 0x04	; 4
    3008:	10 f5       	brcc	.+68     	; 0x304e <HAL_LED_u8LedMode+0x60>
    300a:	8b 81       	ldd	r24, Y+3	; 0x03
    300c:	88 30       	cpi	r24, 0x08	; 8
    300e:	f8 f4       	brcc	.+62     	; 0x304e <HAL_LED_u8LedMode+0x60>
    3010:	8c 81       	ldd	r24, Y+4	; 0x04
    3012:	83 30       	cpi	r24, 0x03	; 3
    3014:	e0 f4       	brcc	.+56     	; 0x304e <HAL_LED_u8LedMode+0x60>
			&& Loc_u8LEDMode <= LED_TOG) {
		if (Loc_u8LEDMode == LED_ON) {
    3016:	8c 81       	ldd	r24, Y+4	; 0x04
    3018:	81 30       	cpi	r24, 0x01	; 1
    301a:	39 f4       	brne	.+14     	; 0x302a <HAL_LED_u8LedMode+0x3c>
			Loc_u8Return_Value = MCAL_DIO_u8SetPinValue(Loc_u8LEDPortID,
    301c:	8a 81       	ldd	r24, Y+2	; 0x02
    301e:	6b 81       	ldd	r22, Y+3	; 0x03
    3020:	41 e0       	ldi	r20, 0x01	; 1
    3022:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    3026:	89 83       	std	Y+1, r24	; 0x01
    3028:	12 c0       	rjmp	.+36     	; 0x304e <HAL_LED_u8LedMode+0x60>
					Loc_u8LEDPinID, Pin_High);
		} else if (Loc_u8LEDMode == LED_OFF) {
    302a:	8c 81       	ldd	r24, Y+4	; 0x04
    302c:	88 23       	and	r24, r24
    302e:	39 f4       	brne	.+14     	; 0x303e <HAL_LED_u8LedMode+0x50>
			Loc_u8Return_Value = MCAL_DIO_u8SetPinValue(Loc_u8LEDPortID,
    3030:	8a 81       	ldd	r24, Y+2	; 0x02
    3032:	6b 81       	ldd	r22, Y+3	; 0x03
    3034:	40 e0       	ldi	r20, 0x00	; 0
    3036:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    303a:	89 83       	std	Y+1, r24	; 0x01
    303c:	08 c0       	rjmp	.+16     	; 0x304e <HAL_LED_u8LedMode+0x60>
					Loc_u8LEDPinID, Pin_Low);
		} else if (Loc_u8LEDMode == LED_TOG) {
    303e:	8c 81       	ldd	r24, Y+4	; 0x04
    3040:	82 30       	cpi	r24, 0x02	; 2
    3042:	29 f4       	brne	.+10     	; 0x304e <HAL_LED_u8LedMode+0x60>
			Loc_u8Return_Value = MCAL_DIO_u8TogglePinValue(Loc_u8LEDPortID,
    3044:	8a 81       	ldd	r24, Y+2	; 0x02
    3046:	6b 81       	ldd	r22, Y+3	; 0x03
    3048:	0e 94 4a 13 	call	0x2694	; 0x2694 <MCAL_DIO_u8TogglePinValue>
    304c:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    304e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3050:	0f 90       	pop	r0
    3052:	0f 90       	pop	r0
    3054:	0f 90       	pop	r0
    3056:	0f 90       	pop	r0
    3058:	cf 91       	pop	r28
    305a:	df 91       	pop	r29
    305c:	08 95       	ret

0000305e <HAL_LCD_u8LCDInit>:

#include "LCD.h"

//static u32 Counter = 0;

void HAL_LCD_u8LCDInit() {
    305e:	0f 93       	push	r16
    3060:	1f 93       	push	r17
    3062:	df 93       	push	r29
    3064:	cf 93       	push	r28
    3066:	cd b7       	in	r28, 0x3d	; 61
    3068:	de b7       	in	r29, 0x3e	; 62
    306a:	c6 54       	subi	r28, 0x46	; 70
    306c:	d0 40       	sbci	r29, 0x00	; 0
    306e:	0f b6       	in	r0, 0x3f	; 63
    3070:	f8 94       	cli
    3072:	de bf       	out	0x3e, r29	; 62
    3074:	0f be       	out	0x3f, r0	; 63
    3076:	cd bf       	out	0x3d, r28	; 61
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D7_PIN, Pin_High);
    3078:	80 e0       	ldi	r24, 0x00	; 0
    307a:	67 e0       	ldi	r22, 0x07	; 7
    307c:	41 e0       	ldi	r20, 0x01	; 1
    307e:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D6_PIN, Pin_High);
    3082:	80 e0       	ldi	r24, 0x00	; 0
    3084:	66 e0       	ldi	r22, 0x06	; 6
    3086:	41 e0       	ldi	r20, 0x01	; 1
    3088:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D5_PIN, Pin_High);
    308c:	80 e0       	ldi	r24, 0x00	; 0
    308e:	65 e0       	ldi	r22, 0x05	; 5
    3090:	41 e0       	ldi	r20, 0x01	; 1
    3092:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(LCD_D_PORT, LCD_D4_PIN, Pin_High);
    3096:	80 e0       	ldi	r24, 0x00	; 0
    3098:	64 e0       	ldi	r22, 0x04	; 4
    309a:	41 e0       	ldi	r20, 0x01	; 1
    309c:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(RS_Port, RS_Pin, Pin_High);
    30a0:	81 e0       	ldi	r24, 0x01	; 1
    30a2:	61 e0       	ldi	r22, 0x01	; 1
    30a4:	41 e0       	ldi	r20, 0x01	; 1
    30a6:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(RW_Port, RW_Pin, Pin_High);
    30aa:	81 e0       	ldi	r24, 0x01	; 1
    30ac:	62 e0       	ldi	r22, 0x02	; 2
    30ae:	41 e0       	ldi	r20, 0x01	; 1
    30b0:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
	MCAL_DIO_u8SetPinDirection(Enable_PORT, Enable_PIN, Pin_High);
    30b4:	81 e0       	ldi	r24, 0x01	; 1
    30b6:	63 e0       	ldi	r22, 0x03	; 3
    30b8:	41 e0       	ldi	r20, 0x01	; 1
    30ba:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
    30be:	fe 01       	movw	r30, r28
    30c0:	ed 5b       	subi	r30, 0xBD	; 189
    30c2:	ff 4f       	sbci	r31, 0xFF	; 255
    30c4:	80 e0       	ldi	r24, 0x00	; 0
    30c6:	90 e0       	ldi	r25, 0x00	; 0
    30c8:	a0 e0       	ldi	r26, 0x00	; 0
    30ca:	b0 e4       	ldi	r27, 0x40	; 64
    30cc:	80 83       	st	Z, r24
    30ce:	91 83       	std	Z+1, r25	; 0x01
    30d0:	a2 83       	std	Z+2, r26	; 0x02
    30d2:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30d4:	8e 01       	movw	r16, r28
    30d6:	01 5c       	subi	r16, 0xC1	; 193
    30d8:	1f 4f       	sbci	r17, 0xFF	; 255
    30da:	fe 01       	movw	r30, r28
    30dc:	ed 5b       	subi	r30, 0xBD	; 189
    30de:	ff 4f       	sbci	r31, 0xFF	; 255
    30e0:	60 81       	ld	r22, Z
    30e2:	71 81       	ldd	r23, Z+1	; 0x01
    30e4:	82 81       	ldd	r24, Z+2	; 0x02
    30e6:	93 81       	ldd	r25, Z+3	; 0x03
    30e8:	20 e0       	ldi	r18, 0x00	; 0
    30ea:	30 e0       	ldi	r19, 0x00	; 0
    30ec:	4a e7       	ldi	r20, 0x7A	; 122
    30ee:	55 e4       	ldi	r21, 0x45	; 69
    30f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    30f4:	dc 01       	movw	r26, r24
    30f6:	cb 01       	movw	r24, r22
    30f8:	f8 01       	movw	r30, r16
    30fa:	80 83       	st	Z, r24
    30fc:	91 83       	std	Z+1, r25	; 0x01
    30fe:	a2 83       	std	Z+2, r26	; 0x02
    3100:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3102:	fe 01       	movw	r30, r28
    3104:	ff 96       	adiw	r30, 0x3f	; 63
    3106:	60 81       	ld	r22, Z
    3108:	71 81       	ldd	r23, Z+1	; 0x01
    310a:	82 81       	ldd	r24, Z+2	; 0x02
    310c:	93 81       	ldd	r25, Z+3	; 0x03
    310e:	20 e0       	ldi	r18, 0x00	; 0
    3110:	30 e0       	ldi	r19, 0x00	; 0
    3112:	40 e8       	ldi	r20, 0x80	; 128
    3114:	5f e3       	ldi	r21, 0x3F	; 63
    3116:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    311a:	88 23       	and	r24, r24
    311c:	2c f4       	brge	.+10     	; 0x3128 <HAL_LCD_u8LCDInit+0xca>
		__ticks = 1;
    311e:	81 e0       	ldi	r24, 0x01	; 1
    3120:	90 e0       	ldi	r25, 0x00	; 0
    3122:	9e af       	std	Y+62, r25	; 0x3e
    3124:	8d af       	std	Y+61, r24	; 0x3d
    3126:	46 c0       	rjmp	.+140    	; 0x31b4 <HAL_LCD_u8LCDInit+0x156>
	else if (__tmp > 65535)
    3128:	fe 01       	movw	r30, r28
    312a:	ff 96       	adiw	r30, 0x3f	; 63
    312c:	60 81       	ld	r22, Z
    312e:	71 81       	ldd	r23, Z+1	; 0x01
    3130:	82 81       	ldd	r24, Z+2	; 0x02
    3132:	93 81       	ldd	r25, Z+3	; 0x03
    3134:	20 e0       	ldi	r18, 0x00	; 0
    3136:	3f ef       	ldi	r19, 0xFF	; 255
    3138:	4f e7       	ldi	r20, 0x7F	; 127
    313a:	57 e4       	ldi	r21, 0x47	; 71
    313c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3140:	18 16       	cp	r1, r24
    3142:	64 f5       	brge	.+88     	; 0x319c <HAL_LCD_u8LCDInit+0x13e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3144:	fe 01       	movw	r30, r28
    3146:	ed 5b       	subi	r30, 0xBD	; 189
    3148:	ff 4f       	sbci	r31, 0xFF	; 255
    314a:	60 81       	ld	r22, Z
    314c:	71 81       	ldd	r23, Z+1	; 0x01
    314e:	82 81       	ldd	r24, Z+2	; 0x02
    3150:	93 81       	ldd	r25, Z+3	; 0x03
    3152:	20 e0       	ldi	r18, 0x00	; 0
    3154:	30 e0       	ldi	r19, 0x00	; 0
    3156:	40 e2       	ldi	r20, 0x20	; 32
    3158:	51 e4       	ldi	r21, 0x41	; 65
    315a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    315e:	dc 01       	movw	r26, r24
    3160:	cb 01       	movw	r24, r22
    3162:	bc 01       	movw	r22, r24
    3164:	cd 01       	movw	r24, r26
    3166:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    316a:	dc 01       	movw	r26, r24
    316c:	cb 01       	movw	r24, r22
    316e:	9e af       	std	Y+62, r25	; 0x3e
    3170:	8d af       	std	Y+61, r24	; 0x3d
    3172:	0f c0       	rjmp	.+30     	; 0x3192 <HAL_LCD_u8LCDInit+0x134>
    3174:	80 e9       	ldi	r24, 0x90	; 144
    3176:	91 e0       	ldi	r25, 0x01	; 1
    3178:	9c af       	std	Y+60, r25	; 0x3c
    317a:	8b af       	std	Y+59, r24	; 0x3b
    317c:	8b ad       	ldd	r24, Y+59	; 0x3b
    317e:	9c ad       	ldd	r25, Y+60	; 0x3c
    3180:	01 97       	sbiw	r24, 0x01	; 1
    3182:	f1 f7       	brne	.-4      	; 0x3180 <HAL_LCD_u8LCDInit+0x122>
    3184:	9c af       	std	Y+60, r25	; 0x3c
    3186:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3188:	8d ad       	ldd	r24, Y+61	; 0x3d
    318a:	9e ad       	ldd	r25, Y+62	; 0x3e
    318c:	01 97       	sbiw	r24, 0x01	; 1
    318e:	9e af       	std	Y+62, r25	; 0x3e
    3190:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3192:	8d ad       	ldd	r24, Y+61	; 0x3d
    3194:	9e ad       	ldd	r25, Y+62	; 0x3e
    3196:	00 97       	sbiw	r24, 0x00	; 0
    3198:	69 f7       	brne	.-38     	; 0x3174 <HAL_LCD_u8LCDInit+0x116>
    319a:	16 c0       	rjmp	.+44     	; 0x31c8 <HAL_LCD_u8LCDInit+0x16a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    319c:	fe 01       	movw	r30, r28
    319e:	ff 96       	adiw	r30, 0x3f	; 63
    31a0:	60 81       	ld	r22, Z
    31a2:	71 81       	ldd	r23, Z+1	; 0x01
    31a4:	82 81       	ldd	r24, Z+2	; 0x02
    31a6:	93 81       	ldd	r25, Z+3	; 0x03
    31a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    31ac:	dc 01       	movw	r26, r24
    31ae:	cb 01       	movw	r24, r22
    31b0:	9e af       	std	Y+62, r25	; 0x3e
    31b2:	8d af       	std	Y+61, r24	; 0x3d
    31b4:	8d ad       	ldd	r24, Y+61	; 0x3d
    31b6:	9e ad       	ldd	r25, Y+62	; 0x3e
    31b8:	9a af       	std	Y+58, r25	; 0x3a
    31ba:	89 af       	std	Y+57, r24	; 0x39
    31bc:	89 ad       	ldd	r24, Y+57	; 0x39
    31be:	9a ad       	ldd	r25, Y+58	; 0x3a
    31c0:	01 97       	sbiw	r24, 0x01	; 1
    31c2:	f1 f7       	brne	.-4      	; 0x31c0 <HAL_LCD_u8LCDInit+0x162>
    31c4:	9a af       	std	Y+58, r25	; 0x3a
    31c6:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Reset);
    31c8:	82 e0       	ldi	r24, 0x02	; 2
    31ca:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
    31ce:	80 e0       	ldi	r24, 0x00	; 0
    31d0:	90 e0       	ldi	r25, 0x00	; 0
    31d2:	a0 e0       	ldi	r26, 0x00	; 0
    31d4:	b0 e4       	ldi	r27, 0x40	; 64
    31d6:	8d ab       	std	Y+53, r24	; 0x35
    31d8:	9e ab       	std	Y+54, r25	; 0x36
    31da:	af ab       	std	Y+55, r26	; 0x37
    31dc:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    31de:	6d a9       	ldd	r22, Y+53	; 0x35
    31e0:	7e a9       	ldd	r23, Y+54	; 0x36
    31e2:	8f a9       	ldd	r24, Y+55	; 0x37
    31e4:	98 ad       	ldd	r25, Y+56	; 0x38
    31e6:	20 e0       	ldi	r18, 0x00	; 0
    31e8:	30 e0       	ldi	r19, 0x00	; 0
    31ea:	4a e7       	ldi	r20, 0x7A	; 122
    31ec:	55 e4       	ldi	r21, 0x45	; 69
    31ee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    31f2:	dc 01       	movw	r26, r24
    31f4:	cb 01       	movw	r24, r22
    31f6:	89 ab       	std	Y+49, r24	; 0x31
    31f8:	9a ab       	std	Y+50, r25	; 0x32
    31fa:	ab ab       	std	Y+51, r26	; 0x33
    31fc:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    31fe:	69 a9       	ldd	r22, Y+49	; 0x31
    3200:	7a a9       	ldd	r23, Y+50	; 0x32
    3202:	8b a9       	ldd	r24, Y+51	; 0x33
    3204:	9c a9       	ldd	r25, Y+52	; 0x34
    3206:	20 e0       	ldi	r18, 0x00	; 0
    3208:	30 e0       	ldi	r19, 0x00	; 0
    320a:	40 e8       	ldi	r20, 0x80	; 128
    320c:	5f e3       	ldi	r21, 0x3F	; 63
    320e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3212:	88 23       	and	r24, r24
    3214:	2c f4       	brge	.+10     	; 0x3220 <HAL_LCD_u8LCDInit+0x1c2>
		__ticks = 1;
    3216:	81 e0       	ldi	r24, 0x01	; 1
    3218:	90 e0       	ldi	r25, 0x00	; 0
    321a:	98 ab       	std	Y+48, r25	; 0x30
    321c:	8f a7       	std	Y+47, r24	; 0x2f
    321e:	3f c0       	rjmp	.+126    	; 0x329e <HAL_LCD_u8LCDInit+0x240>
	else if (__tmp > 65535)
    3220:	69 a9       	ldd	r22, Y+49	; 0x31
    3222:	7a a9       	ldd	r23, Y+50	; 0x32
    3224:	8b a9       	ldd	r24, Y+51	; 0x33
    3226:	9c a9       	ldd	r25, Y+52	; 0x34
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	3f ef       	ldi	r19, 0xFF	; 255
    322c:	4f e7       	ldi	r20, 0x7F	; 127
    322e:	57 e4       	ldi	r21, 0x47	; 71
    3230:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3234:	18 16       	cp	r1, r24
    3236:	4c f5       	brge	.+82     	; 0x328a <HAL_LCD_u8LCDInit+0x22c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3238:	6d a9       	ldd	r22, Y+53	; 0x35
    323a:	7e a9       	ldd	r23, Y+54	; 0x36
    323c:	8f a9       	ldd	r24, Y+55	; 0x37
    323e:	98 ad       	ldd	r25, Y+56	; 0x38
    3240:	20 e0       	ldi	r18, 0x00	; 0
    3242:	30 e0       	ldi	r19, 0x00	; 0
    3244:	40 e2       	ldi	r20, 0x20	; 32
    3246:	51 e4       	ldi	r21, 0x41	; 65
    3248:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    324c:	dc 01       	movw	r26, r24
    324e:	cb 01       	movw	r24, r22
    3250:	bc 01       	movw	r22, r24
    3252:	cd 01       	movw	r24, r26
    3254:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3258:	dc 01       	movw	r26, r24
    325a:	cb 01       	movw	r24, r22
    325c:	98 ab       	std	Y+48, r25	; 0x30
    325e:	8f a7       	std	Y+47, r24	; 0x2f
    3260:	0f c0       	rjmp	.+30     	; 0x3280 <HAL_LCD_u8LCDInit+0x222>
    3262:	80 e9       	ldi	r24, 0x90	; 144
    3264:	91 e0       	ldi	r25, 0x01	; 1
    3266:	9e a7       	std	Y+46, r25	; 0x2e
    3268:	8d a7       	std	Y+45, r24	; 0x2d
    326a:	8d a5       	ldd	r24, Y+45	; 0x2d
    326c:	9e a5       	ldd	r25, Y+46	; 0x2e
    326e:	01 97       	sbiw	r24, 0x01	; 1
    3270:	f1 f7       	brne	.-4      	; 0x326e <HAL_LCD_u8LCDInit+0x210>
    3272:	9e a7       	std	Y+46, r25	; 0x2e
    3274:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3276:	8f a5       	ldd	r24, Y+47	; 0x2f
    3278:	98 a9       	ldd	r25, Y+48	; 0x30
    327a:	01 97       	sbiw	r24, 0x01	; 1
    327c:	98 ab       	std	Y+48, r25	; 0x30
    327e:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3280:	8f a5       	ldd	r24, Y+47	; 0x2f
    3282:	98 a9       	ldd	r25, Y+48	; 0x30
    3284:	00 97       	sbiw	r24, 0x00	; 0
    3286:	69 f7       	brne	.-38     	; 0x3262 <HAL_LCD_u8LCDInit+0x204>
    3288:	14 c0       	rjmp	.+40     	; 0x32b2 <HAL_LCD_u8LCDInit+0x254>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    328a:	69 a9       	ldd	r22, Y+49	; 0x31
    328c:	7a a9       	ldd	r23, Y+50	; 0x32
    328e:	8b a9       	ldd	r24, Y+51	; 0x33
    3290:	9c a9       	ldd	r25, Y+52	; 0x34
    3292:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3296:	dc 01       	movw	r26, r24
    3298:	cb 01       	movw	r24, r22
    329a:	98 ab       	std	Y+48, r25	; 0x30
    329c:	8f a7       	std	Y+47, r24	; 0x2f
    329e:	8f a5       	ldd	r24, Y+47	; 0x2f
    32a0:	98 a9       	ldd	r25, Y+48	; 0x30
    32a2:	9c a7       	std	Y+44, r25	; 0x2c
    32a4:	8b a7       	std	Y+43, r24	; 0x2b
    32a6:	8b a5       	ldd	r24, Y+43	; 0x2b
    32a8:	9c a5       	ldd	r25, Y+44	; 0x2c
    32aa:	01 97       	sbiw	r24, 0x01	; 1
    32ac:	f1 f7       	brne	.-4      	; 0x32aa <HAL_LCD_u8LCDInit+0x24c>
    32ae:	9c a7       	std	Y+44, r25	; 0x2c
    32b0:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Function_Set);
    32b2:	88 e2       	ldi	r24, 0x28	; 40
    32b4:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
    32b8:	80 e0       	ldi	r24, 0x00	; 0
    32ba:	90 e0       	ldi	r25, 0x00	; 0
    32bc:	a0 e0       	ldi	r26, 0x00	; 0
    32be:	b0 e4       	ldi	r27, 0x40	; 64
    32c0:	8f a3       	std	Y+39, r24	; 0x27
    32c2:	98 a7       	std	Y+40, r25	; 0x28
    32c4:	a9 a7       	std	Y+41, r26	; 0x29
    32c6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    32c8:	6f a1       	ldd	r22, Y+39	; 0x27
    32ca:	78 a5       	ldd	r23, Y+40	; 0x28
    32cc:	89 a5       	ldd	r24, Y+41	; 0x29
    32ce:	9a a5       	ldd	r25, Y+42	; 0x2a
    32d0:	20 e0       	ldi	r18, 0x00	; 0
    32d2:	30 e0       	ldi	r19, 0x00	; 0
    32d4:	4a e7       	ldi	r20, 0x7A	; 122
    32d6:	55 e4       	ldi	r21, 0x45	; 69
    32d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    32dc:	dc 01       	movw	r26, r24
    32de:	cb 01       	movw	r24, r22
    32e0:	8b a3       	std	Y+35, r24	; 0x23
    32e2:	9c a3       	std	Y+36, r25	; 0x24
    32e4:	ad a3       	std	Y+37, r26	; 0x25
    32e6:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    32e8:	6b a1       	ldd	r22, Y+35	; 0x23
    32ea:	7c a1       	ldd	r23, Y+36	; 0x24
    32ec:	8d a1       	ldd	r24, Y+37	; 0x25
    32ee:	9e a1       	ldd	r25, Y+38	; 0x26
    32f0:	20 e0       	ldi	r18, 0x00	; 0
    32f2:	30 e0       	ldi	r19, 0x00	; 0
    32f4:	40 e8       	ldi	r20, 0x80	; 128
    32f6:	5f e3       	ldi	r21, 0x3F	; 63
    32f8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    32fc:	88 23       	and	r24, r24
    32fe:	2c f4       	brge	.+10     	; 0x330a <HAL_LCD_u8LCDInit+0x2ac>
		__ticks = 1;
    3300:	81 e0       	ldi	r24, 0x01	; 1
    3302:	90 e0       	ldi	r25, 0x00	; 0
    3304:	9a a3       	std	Y+34, r25	; 0x22
    3306:	89 a3       	std	Y+33, r24	; 0x21
    3308:	3f c0       	rjmp	.+126    	; 0x3388 <HAL_LCD_u8LCDInit+0x32a>
	else if (__tmp > 65535)
    330a:	6b a1       	ldd	r22, Y+35	; 0x23
    330c:	7c a1       	ldd	r23, Y+36	; 0x24
    330e:	8d a1       	ldd	r24, Y+37	; 0x25
    3310:	9e a1       	ldd	r25, Y+38	; 0x26
    3312:	20 e0       	ldi	r18, 0x00	; 0
    3314:	3f ef       	ldi	r19, 0xFF	; 255
    3316:	4f e7       	ldi	r20, 0x7F	; 127
    3318:	57 e4       	ldi	r21, 0x47	; 71
    331a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    331e:	18 16       	cp	r1, r24
    3320:	4c f5       	brge	.+82     	; 0x3374 <HAL_LCD_u8LCDInit+0x316>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3322:	6f a1       	ldd	r22, Y+39	; 0x27
    3324:	78 a5       	ldd	r23, Y+40	; 0x28
    3326:	89 a5       	ldd	r24, Y+41	; 0x29
    3328:	9a a5       	ldd	r25, Y+42	; 0x2a
    332a:	20 e0       	ldi	r18, 0x00	; 0
    332c:	30 e0       	ldi	r19, 0x00	; 0
    332e:	40 e2       	ldi	r20, 0x20	; 32
    3330:	51 e4       	ldi	r21, 0x41	; 65
    3332:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3336:	dc 01       	movw	r26, r24
    3338:	cb 01       	movw	r24, r22
    333a:	bc 01       	movw	r22, r24
    333c:	cd 01       	movw	r24, r26
    333e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3342:	dc 01       	movw	r26, r24
    3344:	cb 01       	movw	r24, r22
    3346:	9a a3       	std	Y+34, r25	; 0x22
    3348:	89 a3       	std	Y+33, r24	; 0x21
    334a:	0f c0       	rjmp	.+30     	; 0x336a <HAL_LCD_u8LCDInit+0x30c>
    334c:	80 e9       	ldi	r24, 0x90	; 144
    334e:	91 e0       	ldi	r25, 0x01	; 1
    3350:	98 a3       	std	Y+32, r25	; 0x20
    3352:	8f 8f       	std	Y+31, r24	; 0x1f
    3354:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3356:	98 a1       	ldd	r25, Y+32	; 0x20
    3358:	01 97       	sbiw	r24, 0x01	; 1
    335a:	f1 f7       	brne	.-4      	; 0x3358 <HAL_LCD_u8LCDInit+0x2fa>
    335c:	98 a3       	std	Y+32, r25	; 0x20
    335e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3360:	89 a1       	ldd	r24, Y+33	; 0x21
    3362:	9a a1       	ldd	r25, Y+34	; 0x22
    3364:	01 97       	sbiw	r24, 0x01	; 1
    3366:	9a a3       	std	Y+34, r25	; 0x22
    3368:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    336a:	89 a1       	ldd	r24, Y+33	; 0x21
    336c:	9a a1       	ldd	r25, Y+34	; 0x22
    336e:	00 97       	sbiw	r24, 0x00	; 0
    3370:	69 f7       	brne	.-38     	; 0x334c <HAL_LCD_u8LCDInit+0x2ee>
    3372:	14 c0       	rjmp	.+40     	; 0x339c <HAL_LCD_u8LCDInit+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3374:	6b a1       	ldd	r22, Y+35	; 0x23
    3376:	7c a1       	ldd	r23, Y+36	; 0x24
    3378:	8d a1       	ldd	r24, Y+37	; 0x25
    337a:	9e a1       	ldd	r25, Y+38	; 0x26
    337c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3380:	dc 01       	movw	r26, r24
    3382:	cb 01       	movw	r24, r22
    3384:	9a a3       	std	Y+34, r25	; 0x22
    3386:	89 a3       	std	Y+33, r24	; 0x21
    3388:	89 a1       	ldd	r24, Y+33	; 0x21
    338a:	9a a1       	ldd	r25, Y+34	; 0x22
    338c:	9e 8f       	std	Y+30, r25	; 0x1e
    338e:	8d 8f       	std	Y+29, r24	; 0x1d
    3390:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3392:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3394:	01 97       	sbiw	r24, 0x01	; 1
    3396:	f1 f7       	brne	.-4      	; 0x3394 <HAL_LCD_u8LCDInit+0x336>
    3398:	9e 8f       	std	Y+30, r25	; 0x1e
    339a:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Mode);
    339c:	8f e0       	ldi	r24, 0x0F	; 15
    339e:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
    33a2:	80 e0       	ldi	r24, 0x00	; 0
    33a4:	90 e0       	ldi	r25, 0x00	; 0
    33a6:	a0 e0       	ldi	r26, 0x00	; 0
    33a8:	b0 e4       	ldi	r27, 0x40	; 64
    33aa:	89 8f       	std	Y+25, r24	; 0x19
    33ac:	9a 8f       	std	Y+26, r25	; 0x1a
    33ae:	ab 8f       	std	Y+27, r26	; 0x1b
    33b0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    33b2:	69 8d       	ldd	r22, Y+25	; 0x19
    33b4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    33b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    33b8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    33ba:	20 e0       	ldi	r18, 0x00	; 0
    33bc:	30 e0       	ldi	r19, 0x00	; 0
    33be:	4a e7       	ldi	r20, 0x7A	; 122
    33c0:	55 e4       	ldi	r21, 0x45	; 69
    33c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    33c6:	dc 01       	movw	r26, r24
    33c8:	cb 01       	movw	r24, r22
    33ca:	8d 8b       	std	Y+21, r24	; 0x15
    33cc:	9e 8b       	std	Y+22, r25	; 0x16
    33ce:	af 8b       	std	Y+23, r26	; 0x17
    33d0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    33d2:	6d 89       	ldd	r22, Y+21	; 0x15
    33d4:	7e 89       	ldd	r23, Y+22	; 0x16
    33d6:	8f 89       	ldd	r24, Y+23	; 0x17
    33d8:	98 8d       	ldd	r25, Y+24	; 0x18
    33da:	20 e0       	ldi	r18, 0x00	; 0
    33dc:	30 e0       	ldi	r19, 0x00	; 0
    33de:	40 e8       	ldi	r20, 0x80	; 128
    33e0:	5f e3       	ldi	r21, 0x3F	; 63
    33e2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    33e6:	88 23       	and	r24, r24
    33e8:	2c f4       	brge	.+10     	; 0x33f4 <HAL_LCD_u8LCDInit+0x396>
		__ticks = 1;
    33ea:	81 e0       	ldi	r24, 0x01	; 1
    33ec:	90 e0       	ldi	r25, 0x00	; 0
    33ee:	9c 8b       	std	Y+20, r25	; 0x14
    33f0:	8b 8b       	std	Y+19, r24	; 0x13
    33f2:	3f c0       	rjmp	.+126    	; 0x3472 <HAL_LCD_u8LCDInit+0x414>
	else if (__tmp > 65535)
    33f4:	6d 89       	ldd	r22, Y+21	; 0x15
    33f6:	7e 89       	ldd	r23, Y+22	; 0x16
    33f8:	8f 89       	ldd	r24, Y+23	; 0x17
    33fa:	98 8d       	ldd	r25, Y+24	; 0x18
    33fc:	20 e0       	ldi	r18, 0x00	; 0
    33fe:	3f ef       	ldi	r19, 0xFF	; 255
    3400:	4f e7       	ldi	r20, 0x7F	; 127
    3402:	57 e4       	ldi	r21, 0x47	; 71
    3404:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3408:	18 16       	cp	r1, r24
    340a:	4c f5       	brge	.+82     	; 0x345e <HAL_LCD_u8LCDInit+0x400>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    340c:	69 8d       	ldd	r22, Y+25	; 0x19
    340e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3410:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3412:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3414:	20 e0       	ldi	r18, 0x00	; 0
    3416:	30 e0       	ldi	r19, 0x00	; 0
    3418:	40 e2       	ldi	r20, 0x20	; 32
    341a:	51 e4       	ldi	r21, 0x41	; 65
    341c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3420:	dc 01       	movw	r26, r24
    3422:	cb 01       	movw	r24, r22
    3424:	bc 01       	movw	r22, r24
    3426:	cd 01       	movw	r24, r26
    3428:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    342c:	dc 01       	movw	r26, r24
    342e:	cb 01       	movw	r24, r22
    3430:	9c 8b       	std	Y+20, r25	; 0x14
    3432:	8b 8b       	std	Y+19, r24	; 0x13
    3434:	0f c0       	rjmp	.+30     	; 0x3454 <HAL_LCD_u8LCDInit+0x3f6>
    3436:	80 e9       	ldi	r24, 0x90	; 144
    3438:	91 e0       	ldi	r25, 0x01	; 1
    343a:	9a 8b       	std	Y+18, r25	; 0x12
    343c:	89 8b       	std	Y+17, r24	; 0x11
    343e:	89 89       	ldd	r24, Y+17	; 0x11
    3440:	9a 89       	ldd	r25, Y+18	; 0x12
    3442:	01 97       	sbiw	r24, 0x01	; 1
    3444:	f1 f7       	brne	.-4      	; 0x3442 <HAL_LCD_u8LCDInit+0x3e4>
    3446:	9a 8b       	std	Y+18, r25	; 0x12
    3448:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    344a:	8b 89       	ldd	r24, Y+19	; 0x13
    344c:	9c 89       	ldd	r25, Y+20	; 0x14
    344e:	01 97       	sbiw	r24, 0x01	; 1
    3450:	9c 8b       	std	Y+20, r25	; 0x14
    3452:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3454:	8b 89       	ldd	r24, Y+19	; 0x13
    3456:	9c 89       	ldd	r25, Y+20	; 0x14
    3458:	00 97       	sbiw	r24, 0x00	; 0
    345a:	69 f7       	brne	.-38     	; 0x3436 <HAL_LCD_u8LCDInit+0x3d8>
    345c:	14 c0       	rjmp	.+40     	; 0x3486 <HAL_LCD_u8LCDInit+0x428>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    345e:	6d 89       	ldd	r22, Y+21	; 0x15
    3460:	7e 89       	ldd	r23, Y+22	; 0x16
    3462:	8f 89       	ldd	r24, Y+23	; 0x17
    3464:	98 8d       	ldd	r25, Y+24	; 0x18
    3466:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    346a:	dc 01       	movw	r26, r24
    346c:	cb 01       	movw	r24, r22
    346e:	9c 8b       	std	Y+20, r25	; 0x14
    3470:	8b 8b       	std	Y+19, r24	; 0x13
    3472:	8b 89       	ldd	r24, Y+19	; 0x13
    3474:	9c 89       	ldd	r25, Y+20	; 0x14
    3476:	98 8b       	std	Y+16, r25	; 0x10
    3478:	8f 87       	std	Y+15, r24	; 0x0f
    347a:	8f 85       	ldd	r24, Y+15	; 0x0f
    347c:	98 89       	ldd	r25, Y+16	; 0x10
    347e:	01 97       	sbiw	r24, 0x01	; 1
    3480:	f1 f7       	brne	.-4      	; 0x347e <HAL_LCD_u8LCDInit+0x420>
    3482:	98 8b       	std	Y+16, r25	; 0x10
    3484:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Clear);
    3486:	81 e0       	ldi	r24, 0x01	; 1
    3488:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
    348c:	80 e0       	ldi	r24, 0x00	; 0
    348e:	90 e0       	ldi	r25, 0x00	; 0
    3490:	a0 e0       	ldi	r26, 0x00	; 0
    3492:	b0 e4       	ldi	r27, 0x40	; 64
    3494:	8b 87       	std	Y+11, r24	; 0x0b
    3496:	9c 87       	std	Y+12, r25	; 0x0c
    3498:	ad 87       	std	Y+13, r26	; 0x0d
    349a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    349c:	6b 85       	ldd	r22, Y+11	; 0x0b
    349e:	7c 85       	ldd	r23, Y+12	; 0x0c
    34a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    34a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    34a4:	20 e0       	ldi	r18, 0x00	; 0
    34a6:	30 e0       	ldi	r19, 0x00	; 0
    34a8:	4a e7       	ldi	r20, 0x7A	; 122
    34aa:	55 e4       	ldi	r21, 0x45	; 69
    34ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    34b0:	dc 01       	movw	r26, r24
    34b2:	cb 01       	movw	r24, r22
    34b4:	8f 83       	std	Y+7, r24	; 0x07
    34b6:	98 87       	std	Y+8, r25	; 0x08
    34b8:	a9 87       	std	Y+9, r26	; 0x09
    34ba:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    34bc:	6f 81       	ldd	r22, Y+7	; 0x07
    34be:	78 85       	ldd	r23, Y+8	; 0x08
    34c0:	89 85       	ldd	r24, Y+9	; 0x09
    34c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    34c4:	20 e0       	ldi	r18, 0x00	; 0
    34c6:	30 e0       	ldi	r19, 0x00	; 0
    34c8:	40 e8       	ldi	r20, 0x80	; 128
    34ca:	5f e3       	ldi	r21, 0x3F	; 63
    34cc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    34d0:	88 23       	and	r24, r24
    34d2:	2c f4       	brge	.+10     	; 0x34de <HAL_LCD_u8LCDInit+0x480>
		__ticks = 1;
    34d4:	81 e0       	ldi	r24, 0x01	; 1
    34d6:	90 e0       	ldi	r25, 0x00	; 0
    34d8:	9e 83       	std	Y+6, r25	; 0x06
    34da:	8d 83       	std	Y+5, r24	; 0x05
    34dc:	3f c0       	rjmp	.+126    	; 0x355c <HAL_LCD_u8LCDInit+0x4fe>
	else if (__tmp > 65535)
    34de:	6f 81       	ldd	r22, Y+7	; 0x07
    34e0:	78 85       	ldd	r23, Y+8	; 0x08
    34e2:	89 85       	ldd	r24, Y+9	; 0x09
    34e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    34e6:	20 e0       	ldi	r18, 0x00	; 0
    34e8:	3f ef       	ldi	r19, 0xFF	; 255
    34ea:	4f e7       	ldi	r20, 0x7F	; 127
    34ec:	57 e4       	ldi	r21, 0x47	; 71
    34ee:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    34f2:	18 16       	cp	r1, r24
    34f4:	4c f5       	brge	.+82     	; 0x3548 <HAL_LCD_u8LCDInit+0x4ea>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    34f6:	6b 85       	ldd	r22, Y+11	; 0x0b
    34f8:	7c 85       	ldd	r23, Y+12	; 0x0c
    34fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    34fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    34fe:	20 e0       	ldi	r18, 0x00	; 0
    3500:	30 e0       	ldi	r19, 0x00	; 0
    3502:	40 e2       	ldi	r20, 0x20	; 32
    3504:	51 e4       	ldi	r21, 0x41	; 65
    3506:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    350a:	dc 01       	movw	r26, r24
    350c:	cb 01       	movw	r24, r22
    350e:	bc 01       	movw	r22, r24
    3510:	cd 01       	movw	r24, r26
    3512:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3516:	dc 01       	movw	r26, r24
    3518:	cb 01       	movw	r24, r22
    351a:	9e 83       	std	Y+6, r25	; 0x06
    351c:	8d 83       	std	Y+5, r24	; 0x05
    351e:	0f c0       	rjmp	.+30     	; 0x353e <HAL_LCD_u8LCDInit+0x4e0>
    3520:	80 e9       	ldi	r24, 0x90	; 144
    3522:	91 e0       	ldi	r25, 0x01	; 1
    3524:	9c 83       	std	Y+4, r25	; 0x04
    3526:	8b 83       	std	Y+3, r24	; 0x03
    3528:	8b 81       	ldd	r24, Y+3	; 0x03
    352a:	9c 81       	ldd	r25, Y+4	; 0x04
    352c:	01 97       	sbiw	r24, 0x01	; 1
    352e:	f1 f7       	brne	.-4      	; 0x352c <HAL_LCD_u8LCDInit+0x4ce>
    3530:	9c 83       	std	Y+4, r25	; 0x04
    3532:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3534:	8d 81       	ldd	r24, Y+5	; 0x05
    3536:	9e 81       	ldd	r25, Y+6	; 0x06
    3538:	01 97       	sbiw	r24, 0x01	; 1
    353a:	9e 83       	std	Y+6, r25	; 0x06
    353c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    353e:	8d 81       	ldd	r24, Y+5	; 0x05
    3540:	9e 81       	ldd	r25, Y+6	; 0x06
    3542:	00 97       	sbiw	r24, 0x00	; 0
    3544:	69 f7       	brne	.-38     	; 0x3520 <HAL_LCD_u8LCDInit+0x4c2>
    3546:	14 c0       	rjmp	.+40     	; 0x3570 <HAL_LCD_u8LCDInit+0x512>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3548:	6f 81       	ldd	r22, Y+7	; 0x07
    354a:	78 85       	ldd	r23, Y+8	; 0x08
    354c:	89 85       	ldd	r24, Y+9	; 0x09
    354e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3550:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3554:	dc 01       	movw	r26, r24
    3556:	cb 01       	movw	r24, r22
    3558:	9e 83       	std	Y+6, r25	; 0x06
    355a:	8d 83       	std	Y+5, r24	; 0x05
    355c:	8d 81       	ldd	r24, Y+5	; 0x05
    355e:	9e 81       	ldd	r25, Y+6	; 0x06
    3560:	9a 83       	std	Y+2, r25	; 0x02
    3562:	89 83       	std	Y+1, r24	; 0x01
    3564:	89 81       	ldd	r24, Y+1	; 0x01
    3566:	9a 81       	ldd	r25, Y+2	; 0x02
    3568:	01 97       	sbiw	r24, 0x01	; 1
    356a:	f1 f7       	brne	.-4      	; 0x3568 <HAL_LCD_u8LCDInit+0x50a>
    356c:	9a 83       	std	Y+2, r25	; 0x02
    356e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Entry_Mode);
    3570:	86 e0       	ldi	r24, 0x06	; 6
    3572:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
}
    3576:	ca 5b       	subi	r28, 0xBA	; 186
    3578:	df 4f       	sbci	r29, 0xFF	; 255
    357a:	0f b6       	in	r0, 0x3f	; 63
    357c:	f8 94       	cli
    357e:	de bf       	out	0x3e, r29	; 62
    3580:	0f be       	out	0x3f, r0	; 63
    3582:	cd bf       	out	0x3d, r28	; 61
    3584:	cf 91       	pop	r28
    3586:	df 91       	pop	r29
    3588:	1f 91       	pop	r17
    358a:	0f 91       	pop	r16
    358c:	08 95       	ret

0000358e <HAL_LCD_u8SendCommands>:

void HAL_LCD_u8SendCommands(u8 Loc_u8LCD_Command) {
    358e:	df 93       	push	r29
    3590:	cf 93       	push	r28
    3592:	cd b7       	in	r28, 0x3d	; 61
    3594:	de b7       	in	r29, 0x3e	; 62
    3596:	6d 97       	sbiw	r28, 0x1d	; 29
    3598:	0f b6       	in	r0, 0x3f	; 63
    359a:	f8 94       	cli
    359c:	de bf       	out	0x3e, r29	; 62
    359e:	0f be       	out	0x3f, r0	; 63
    35a0:	cd bf       	out	0x3d, r28	; 61
    35a2:	8d 8f       	std	Y+29, r24	; 0x1d
	MCAL_DIO_u8SetPinValue(RS_Port, RS_Pin, RS_Low);
    35a4:	81 e0       	ldi	r24, 0x01	; 1
    35a6:	61 e0       	ldi	r22, 0x01	; 1
    35a8:	40 e0       	ldi	r20, 0x00	; 0
    35aa:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(RW_Port, RW_Pin, RW_Low);
    35ae:	81 e0       	ldi	r24, 0x01	; 1
    35b0:	62 e0       	ldi	r22, 0x02	; 2
    35b2:	40 e0       	ldi	r20, 0x00	; 0
    35b4:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPortValue(LCD_D_PORT, Loc_u8LCD_Command);
    35b8:	80 e0       	ldi	r24, 0x00	; 0
    35ba:	6d 8d       	ldd	r22, Y+29	; 0x1d
    35bc:	0e 94 de 10 	call	0x21bc	; 0x21bc <MCAL_DIO_u8SetPortValue>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    35c0:	81 e0       	ldi	r24, 0x01	; 1
    35c2:	63 e0       	ldi	r22, 0x03	; 3
    35c4:	41 e0       	ldi	r20, 0x01	; 1
    35c6:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    35ca:	80 e0       	ldi	r24, 0x00	; 0
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	a0 e0       	ldi	r26, 0x00	; 0
    35d0:	b0 e4       	ldi	r27, 0x40	; 64
    35d2:	89 8f       	std	Y+25, r24	; 0x19
    35d4:	9a 8f       	std	Y+26, r25	; 0x1a
    35d6:	ab 8f       	std	Y+27, r26	; 0x1b
    35d8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    35da:	69 8d       	ldd	r22, Y+25	; 0x19
    35dc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    35de:	8b 8d       	ldd	r24, Y+27	; 0x1b
    35e0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    35e2:	20 e0       	ldi	r18, 0x00	; 0
    35e4:	30 e0       	ldi	r19, 0x00	; 0
    35e6:	4a e7       	ldi	r20, 0x7A	; 122
    35e8:	55 e4       	ldi	r21, 0x45	; 69
    35ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    35ee:	dc 01       	movw	r26, r24
    35f0:	cb 01       	movw	r24, r22
    35f2:	8d 8b       	std	Y+21, r24	; 0x15
    35f4:	9e 8b       	std	Y+22, r25	; 0x16
    35f6:	af 8b       	std	Y+23, r26	; 0x17
    35f8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    35fa:	6d 89       	ldd	r22, Y+21	; 0x15
    35fc:	7e 89       	ldd	r23, Y+22	; 0x16
    35fe:	8f 89       	ldd	r24, Y+23	; 0x17
    3600:	98 8d       	ldd	r25, Y+24	; 0x18
    3602:	20 e0       	ldi	r18, 0x00	; 0
    3604:	30 e0       	ldi	r19, 0x00	; 0
    3606:	40 e8       	ldi	r20, 0x80	; 128
    3608:	5f e3       	ldi	r21, 0x3F	; 63
    360a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    360e:	88 23       	and	r24, r24
    3610:	2c f4       	brge	.+10     	; 0x361c <HAL_LCD_u8SendCommands+0x8e>
		__ticks = 1;
    3612:	81 e0       	ldi	r24, 0x01	; 1
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	9c 8b       	std	Y+20, r25	; 0x14
    3618:	8b 8b       	std	Y+19, r24	; 0x13
    361a:	3f c0       	rjmp	.+126    	; 0x369a <HAL_LCD_u8SendCommands+0x10c>
	else if (__tmp > 65535)
    361c:	6d 89       	ldd	r22, Y+21	; 0x15
    361e:	7e 89       	ldd	r23, Y+22	; 0x16
    3620:	8f 89       	ldd	r24, Y+23	; 0x17
    3622:	98 8d       	ldd	r25, Y+24	; 0x18
    3624:	20 e0       	ldi	r18, 0x00	; 0
    3626:	3f ef       	ldi	r19, 0xFF	; 255
    3628:	4f e7       	ldi	r20, 0x7F	; 127
    362a:	57 e4       	ldi	r21, 0x47	; 71
    362c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3630:	18 16       	cp	r1, r24
    3632:	4c f5       	brge	.+82     	; 0x3686 <HAL_LCD_u8SendCommands+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3634:	69 8d       	ldd	r22, Y+25	; 0x19
    3636:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3638:	8b 8d       	ldd	r24, Y+27	; 0x1b
    363a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    363c:	20 e0       	ldi	r18, 0x00	; 0
    363e:	30 e0       	ldi	r19, 0x00	; 0
    3640:	40 e2       	ldi	r20, 0x20	; 32
    3642:	51 e4       	ldi	r21, 0x41	; 65
    3644:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3648:	dc 01       	movw	r26, r24
    364a:	cb 01       	movw	r24, r22
    364c:	bc 01       	movw	r22, r24
    364e:	cd 01       	movw	r24, r26
    3650:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3654:	dc 01       	movw	r26, r24
    3656:	cb 01       	movw	r24, r22
    3658:	9c 8b       	std	Y+20, r25	; 0x14
    365a:	8b 8b       	std	Y+19, r24	; 0x13
    365c:	0f c0       	rjmp	.+30     	; 0x367c <HAL_LCD_u8SendCommands+0xee>
    365e:	80 e9       	ldi	r24, 0x90	; 144
    3660:	91 e0       	ldi	r25, 0x01	; 1
    3662:	9a 8b       	std	Y+18, r25	; 0x12
    3664:	89 8b       	std	Y+17, r24	; 0x11
    3666:	89 89       	ldd	r24, Y+17	; 0x11
    3668:	9a 89       	ldd	r25, Y+18	; 0x12
    366a:	01 97       	sbiw	r24, 0x01	; 1
    366c:	f1 f7       	brne	.-4      	; 0x366a <HAL_LCD_u8SendCommands+0xdc>
    366e:	9a 8b       	std	Y+18, r25	; 0x12
    3670:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3672:	8b 89       	ldd	r24, Y+19	; 0x13
    3674:	9c 89       	ldd	r25, Y+20	; 0x14
    3676:	01 97       	sbiw	r24, 0x01	; 1
    3678:	9c 8b       	std	Y+20, r25	; 0x14
    367a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    367c:	8b 89       	ldd	r24, Y+19	; 0x13
    367e:	9c 89       	ldd	r25, Y+20	; 0x14
    3680:	00 97       	sbiw	r24, 0x00	; 0
    3682:	69 f7       	brne	.-38     	; 0x365e <HAL_LCD_u8SendCommands+0xd0>
    3684:	14 c0       	rjmp	.+40     	; 0x36ae <HAL_LCD_u8SendCommands+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3686:	6d 89       	ldd	r22, Y+21	; 0x15
    3688:	7e 89       	ldd	r23, Y+22	; 0x16
    368a:	8f 89       	ldd	r24, Y+23	; 0x17
    368c:	98 8d       	ldd	r25, Y+24	; 0x18
    368e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3692:	dc 01       	movw	r26, r24
    3694:	cb 01       	movw	r24, r22
    3696:	9c 8b       	std	Y+20, r25	; 0x14
    3698:	8b 8b       	std	Y+19, r24	; 0x13
    369a:	8b 89       	ldd	r24, Y+19	; 0x13
    369c:	9c 89       	ldd	r25, Y+20	; 0x14
    369e:	98 8b       	std	Y+16, r25	; 0x10
    36a0:	8f 87       	std	Y+15, r24	; 0x0f
    36a2:	8f 85       	ldd	r24, Y+15	; 0x0f
    36a4:	98 89       	ldd	r25, Y+16	; 0x10
    36a6:	01 97       	sbiw	r24, 0x01	; 1
    36a8:	f1 f7       	brne	.-4      	; 0x36a6 <HAL_LCD_u8SendCommands+0x118>
    36aa:	98 8b       	std	Y+16, r25	; 0x10
    36ac:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    36ae:	81 e0       	ldi	r24, 0x01	; 1
    36b0:	63 e0       	ldi	r22, 0x03	; 3
    36b2:	40 e0       	ldi	r20, 0x00	; 0
    36b4:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPortValue(LCD_D_PORT, (Loc_u8LCD_Command << 4));
    36b8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    36ba:	98 2f       	mov	r25, r24
    36bc:	92 95       	swap	r25
    36be:	90 7f       	andi	r25, 0xF0	; 240
    36c0:	80 e0       	ldi	r24, 0x00	; 0
    36c2:	69 2f       	mov	r22, r25
    36c4:	0e 94 de 10 	call	0x21bc	; 0x21bc <MCAL_DIO_u8SetPortValue>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    36c8:	81 e0       	ldi	r24, 0x01	; 1
    36ca:	63 e0       	ldi	r22, 0x03	; 3
    36cc:	41 e0       	ldi	r20, 0x01	; 1
    36ce:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    36d2:	80 e0       	ldi	r24, 0x00	; 0
    36d4:	90 e0       	ldi	r25, 0x00	; 0
    36d6:	a0 e0       	ldi	r26, 0x00	; 0
    36d8:	b0 e4       	ldi	r27, 0x40	; 64
    36da:	8b 87       	std	Y+11, r24	; 0x0b
    36dc:	9c 87       	std	Y+12, r25	; 0x0c
    36de:	ad 87       	std	Y+13, r26	; 0x0d
    36e0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    36e2:	6b 85       	ldd	r22, Y+11	; 0x0b
    36e4:	7c 85       	ldd	r23, Y+12	; 0x0c
    36e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    36e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    36ea:	20 e0       	ldi	r18, 0x00	; 0
    36ec:	30 e0       	ldi	r19, 0x00	; 0
    36ee:	4a e7       	ldi	r20, 0x7A	; 122
    36f0:	55 e4       	ldi	r21, 0x45	; 69
    36f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    36f6:	dc 01       	movw	r26, r24
    36f8:	cb 01       	movw	r24, r22
    36fa:	8f 83       	std	Y+7, r24	; 0x07
    36fc:	98 87       	std	Y+8, r25	; 0x08
    36fe:	a9 87       	std	Y+9, r26	; 0x09
    3700:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3702:	6f 81       	ldd	r22, Y+7	; 0x07
    3704:	78 85       	ldd	r23, Y+8	; 0x08
    3706:	89 85       	ldd	r24, Y+9	; 0x09
    3708:	9a 85       	ldd	r25, Y+10	; 0x0a
    370a:	20 e0       	ldi	r18, 0x00	; 0
    370c:	30 e0       	ldi	r19, 0x00	; 0
    370e:	40 e8       	ldi	r20, 0x80	; 128
    3710:	5f e3       	ldi	r21, 0x3F	; 63
    3712:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3716:	88 23       	and	r24, r24
    3718:	2c f4       	brge	.+10     	; 0x3724 <HAL_LCD_u8SendCommands+0x196>
		__ticks = 1;
    371a:	81 e0       	ldi	r24, 0x01	; 1
    371c:	90 e0       	ldi	r25, 0x00	; 0
    371e:	9e 83       	std	Y+6, r25	; 0x06
    3720:	8d 83       	std	Y+5, r24	; 0x05
    3722:	3f c0       	rjmp	.+126    	; 0x37a2 <HAL_LCD_u8SendCommands+0x214>
	else if (__tmp > 65535)
    3724:	6f 81       	ldd	r22, Y+7	; 0x07
    3726:	78 85       	ldd	r23, Y+8	; 0x08
    3728:	89 85       	ldd	r24, Y+9	; 0x09
    372a:	9a 85       	ldd	r25, Y+10	; 0x0a
    372c:	20 e0       	ldi	r18, 0x00	; 0
    372e:	3f ef       	ldi	r19, 0xFF	; 255
    3730:	4f e7       	ldi	r20, 0x7F	; 127
    3732:	57 e4       	ldi	r21, 0x47	; 71
    3734:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3738:	18 16       	cp	r1, r24
    373a:	4c f5       	brge	.+82     	; 0x378e <HAL_LCD_u8SendCommands+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    373c:	6b 85       	ldd	r22, Y+11	; 0x0b
    373e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3740:	8d 85       	ldd	r24, Y+13	; 0x0d
    3742:	9e 85       	ldd	r25, Y+14	; 0x0e
    3744:	20 e0       	ldi	r18, 0x00	; 0
    3746:	30 e0       	ldi	r19, 0x00	; 0
    3748:	40 e2       	ldi	r20, 0x20	; 32
    374a:	51 e4       	ldi	r21, 0x41	; 65
    374c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3750:	dc 01       	movw	r26, r24
    3752:	cb 01       	movw	r24, r22
    3754:	bc 01       	movw	r22, r24
    3756:	cd 01       	movw	r24, r26
    3758:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    375c:	dc 01       	movw	r26, r24
    375e:	cb 01       	movw	r24, r22
    3760:	9e 83       	std	Y+6, r25	; 0x06
    3762:	8d 83       	std	Y+5, r24	; 0x05
    3764:	0f c0       	rjmp	.+30     	; 0x3784 <HAL_LCD_u8SendCommands+0x1f6>
    3766:	80 e9       	ldi	r24, 0x90	; 144
    3768:	91 e0       	ldi	r25, 0x01	; 1
    376a:	9c 83       	std	Y+4, r25	; 0x04
    376c:	8b 83       	std	Y+3, r24	; 0x03
    376e:	8b 81       	ldd	r24, Y+3	; 0x03
    3770:	9c 81       	ldd	r25, Y+4	; 0x04
    3772:	01 97       	sbiw	r24, 0x01	; 1
    3774:	f1 f7       	brne	.-4      	; 0x3772 <HAL_LCD_u8SendCommands+0x1e4>
    3776:	9c 83       	std	Y+4, r25	; 0x04
    3778:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    377a:	8d 81       	ldd	r24, Y+5	; 0x05
    377c:	9e 81       	ldd	r25, Y+6	; 0x06
    377e:	01 97       	sbiw	r24, 0x01	; 1
    3780:	9e 83       	std	Y+6, r25	; 0x06
    3782:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3784:	8d 81       	ldd	r24, Y+5	; 0x05
    3786:	9e 81       	ldd	r25, Y+6	; 0x06
    3788:	00 97       	sbiw	r24, 0x00	; 0
    378a:	69 f7       	brne	.-38     	; 0x3766 <HAL_LCD_u8SendCommands+0x1d8>
    378c:	14 c0       	rjmp	.+40     	; 0x37b6 <HAL_LCD_u8SendCommands+0x228>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    378e:	6f 81       	ldd	r22, Y+7	; 0x07
    3790:	78 85       	ldd	r23, Y+8	; 0x08
    3792:	89 85       	ldd	r24, Y+9	; 0x09
    3794:	9a 85       	ldd	r25, Y+10	; 0x0a
    3796:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    379a:	dc 01       	movw	r26, r24
    379c:	cb 01       	movw	r24, r22
    379e:	9e 83       	std	Y+6, r25	; 0x06
    37a0:	8d 83       	std	Y+5, r24	; 0x05
    37a2:	8d 81       	ldd	r24, Y+5	; 0x05
    37a4:	9e 81       	ldd	r25, Y+6	; 0x06
    37a6:	9a 83       	std	Y+2, r25	; 0x02
    37a8:	89 83       	std	Y+1, r24	; 0x01
    37aa:	89 81       	ldd	r24, Y+1	; 0x01
    37ac:	9a 81       	ldd	r25, Y+2	; 0x02
    37ae:	01 97       	sbiw	r24, 0x01	; 1
    37b0:	f1 f7       	brne	.-4      	; 0x37ae <HAL_LCD_u8SendCommands+0x220>
    37b2:	9a 83       	std	Y+2, r25	; 0x02
    37b4:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    37b6:	81 e0       	ldi	r24, 0x01	; 1
    37b8:	63 e0       	ldi	r22, 0x03	; 3
    37ba:	40 e0       	ldi	r20, 0x00	; 0
    37bc:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
}
    37c0:	6d 96       	adiw	r28, 0x1d	; 29
    37c2:	0f b6       	in	r0, 0x3f	; 63
    37c4:	f8 94       	cli
    37c6:	de bf       	out	0x3e, r29	; 62
    37c8:	0f be       	out	0x3f, r0	; 63
    37ca:	cd bf       	out	0x3d, r28	; 61
    37cc:	cf 91       	pop	r28
    37ce:	df 91       	pop	r29
    37d0:	08 95       	ret

000037d2 <HAL_LCD_u8SendChar>:

void HAL_LCD_u8SendChar(u8 Loc_u8LCD_Char) {
    37d2:	df 93       	push	r29
    37d4:	cf 93       	push	r28
    37d6:	cd b7       	in	r28, 0x3d	; 61
    37d8:	de b7       	in	r29, 0x3e	; 62
    37da:	6d 97       	sbiw	r28, 0x1d	; 29
    37dc:	0f b6       	in	r0, 0x3f	; 63
    37de:	f8 94       	cli
    37e0:	de bf       	out	0x3e, r29	; 62
    37e2:	0f be       	out	0x3f, r0	; 63
    37e4:	cd bf       	out	0x3d, r28	; 61
    37e6:	8d 8f       	std	Y+29, r24	; 0x1d
	MCAL_DIO_u8SetPinValue(RS_Port, RS_Pin, RS_High);
    37e8:	81 e0       	ldi	r24, 0x01	; 1
    37ea:	61 e0       	ldi	r22, 0x01	; 1
    37ec:	41 e0       	ldi	r20, 0x01	; 1
    37ee:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPinValue(RW_Port, RW_Pin, RW_Low);
    37f2:	81 e0       	ldi	r24, 0x01	; 1
    37f4:	62 e0       	ldi	r22, 0x02	; 2
    37f6:	40 e0       	ldi	r20, 0x00	; 0
    37f8:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPortValue(LCD_D_PORT, Loc_u8LCD_Char);
    37fc:	80 e0       	ldi	r24, 0x00	; 0
    37fe:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3800:	0e 94 de 10 	call	0x21bc	; 0x21bc <MCAL_DIO_u8SetPortValue>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    3804:	81 e0       	ldi	r24, 0x01	; 1
    3806:	63 e0       	ldi	r22, 0x03	; 3
    3808:	41 e0       	ldi	r20, 0x01	; 1
    380a:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    380e:	80 e0       	ldi	r24, 0x00	; 0
    3810:	90 e0       	ldi	r25, 0x00	; 0
    3812:	a0 e0       	ldi	r26, 0x00	; 0
    3814:	b0 e4       	ldi	r27, 0x40	; 64
    3816:	89 8f       	std	Y+25, r24	; 0x19
    3818:	9a 8f       	std	Y+26, r25	; 0x1a
    381a:	ab 8f       	std	Y+27, r26	; 0x1b
    381c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    381e:	69 8d       	ldd	r22, Y+25	; 0x19
    3820:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3822:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3824:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3826:	20 e0       	ldi	r18, 0x00	; 0
    3828:	30 e0       	ldi	r19, 0x00	; 0
    382a:	4a e7       	ldi	r20, 0x7A	; 122
    382c:	55 e4       	ldi	r21, 0x45	; 69
    382e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3832:	dc 01       	movw	r26, r24
    3834:	cb 01       	movw	r24, r22
    3836:	8d 8b       	std	Y+21, r24	; 0x15
    3838:	9e 8b       	std	Y+22, r25	; 0x16
    383a:	af 8b       	std	Y+23, r26	; 0x17
    383c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    383e:	6d 89       	ldd	r22, Y+21	; 0x15
    3840:	7e 89       	ldd	r23, Y+22	; 0x16
    3842:	8f 89       	ldd	r24, Y+23	; 0x17
    3844:	98 8d       	ldd	r25, Y+24	; 0x18
    3846:	20 e0       	ldi	r18, 0x00	; 0
    3848:	30 e0       	ldi	r19, 0x00	; 0
    384a:	40 e8       	ldi	r20, 0x80	; 128
    384c:	5f e3       	ldi	r21, 0x3F	; 63
    384e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3852:	88 23       	and	r24, r24
    3854:	2c f4       	brge	.+10     	; 0x3860 <HAL_LCD_u8SendChar+0x8e>
		__ticks = 1;
    3856:	81 e0       	ldi	r24, 0x01	; 1
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	9c 8b       	std	Y+20, r25	; 0x14
    385c:	8b 8b       	std	Y+19, r24	; 0x13
    385e:	3f c0       	rjmp	.+126    	; 0x38de <HAL_LCD_u8SendChar+0x10c>
	else if (__tmp > 65535)
    3860:	6d 89       	ldd	r22, Y+21	; 0x15
    3862:	7e 89       	ldd	r23, Y+22	; 0x16
    3864:	8f 89       	ldd	r24, Y+23	; 0x17
    3866:	98 8d       	ldd	r25, Y+24	; 0x18
    3868:	20 e0       	ldi	r18, 0x00	; 0
    386a:	3f ef       	ldi	r19, 0xFF	; 255
    386c:	4f e7       	ldi	r20, 0x7F	; 127
    386e:	57 e4       	ldi	r21, 0x47	; 71
    3870:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3874:	18 16       	cp	r1, r24
    3876:	4c f5       	brge	.+82     	; 0x38ca <HAL_LCD_u8SendChar+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3878:	69 8d       	ldd	r22, Y+25	; 0x19
    387a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    387c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    387e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3880:	20 e0       	ldi	r18, 0x00	; 0
    3882:	30 e0       	ldi	r19, 0x00	; 0
    3884:	40 e2       	ldi	r20, 0x20	; 32
    3886:	51 e4       	ldi	r21, 0x41	; 65
    3888:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    388c:	dc 01       	movw	r26, r24
    388e:	cb 01       	movw	r24, r22
    3890:	bc 01       	movw	r22, r24
    3892:	cd 01       	movw	r24, r26
    3894:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3898:	dc 01       	movw	r26, r24
    389a:	cb 01       	movw	r24, r22
    389c:	9c 8b       	std	Y+20, r25	; 0x14
    389e:	8b 8b       	std	Y+19, r24	; 0x13
    38a0:	0f c0       	rjmp	.+30     	; 0x38c0 <HAL_LCD_u8SendChar+0xee>
    38a2:	80 e9       	ldi	r24, 0x90	; 144
    38a4:	91 e0       	ldi	r25, 0x01	; 1
    38a6:	9a 8b       	std	Y+18, r25	; 0x12
    38a8:	89 8b       	std	Y+17, r24	; 0x11
    38aa:	89 89       	ldd	r24, Y+17	; 0x11
    38ac:	9a 89       	ldd	r25, Y+18	; 0x12
    38ae:	01 97       	sbiw	r24, 0x01	; 1
    38b0:	f1 f7       	brne	.-4      	; 0x38ae <HAL_LCD_u8SendChar+0xdc>
    38b2:	9a 8b       	std	Y+18, r25	; 0x12
    38b4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    38b6:	8b 89       	ldd	r24, Y+19	; 0x13
    38b8:	9c 89       	ldd	r25, Y+20	; 0x14
    38ba:	01 97       	sbiw	r24, 0x01	; 1
    38bc:	9c 8b       	std	Y+20, r25	; 0x14
    38be:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    38c0:	8b 89       	ldd	r24, Y+19	; 0x13
    38c2:	9c 89       	ldd	r25, Y+20	; 0x14
    38c4:	00 97       	sbiw	r24, 0x00	; 0
    38c6:	69 f7       	brne	.-38     	; 0x38a2 <HAL_LCD_u8SendChar+0xd0>
    38c8:	14 c0       	rjmp	.+40     	; 0x38f2 <HAL_LCD_u8SendChar+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    38ca:	6d 89       	ldd	r22, Y+21	; 0x15
    38cc:	7e 89       	ldd	r23, Y+22	; 0x16
    38ce:	8f 89       	ldd	r24, Y+23	; 0x17
    38d0:	98 8d       	ldd	r25, Y+24	; 0x18
    38d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38d6:	dc 01       	movw	r26, r24
    38d8:	cb 01       	movw	r24, r22
    38da:	9c 8b       	std	Y+20, r25	; 0x14
    38dc:	8b 8b       	std	Y+19, r24	; 0x13
    38de:	8b 89       	ldd	r24, Y+19	; 0x13
    38e0:	9c 89       	ldd	r25, Y+20	; 0x14
    38e2:	98 8b       	std	Y+16, r25	; 0x10
    38e4:	8f 87       	std	Y+15, r24	; 0x0f
    38e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    38e8:	98 89       	ldd	r25, Y+16	; 0x10
    38ea:	01 97       	sbiw	r24, 0x01	; 1
    38ec:	f1 f7       	brne	.-4      	; 0x38ea <HAL_LCD_u8SendChar+0x118>
    38ee:	98 8b       	std	Y+16, r25	; 0x10
    38f0:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    38f2:	81 e0       	ldi	r24, 0x01	; 1
    38f4:	63 e0       	ldi	r22, 0x03	; 3
    38f6:	40 e0       	ldi	r20, 0x00	; 0
    38f8:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
	MCAL_DIO_u8SetPortValue(LCD_D_PORT, (Loc_u8LCD_Char << 4));
    38fc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    38fe:	98 2f       	mov	r25, r24
    3900:	92 95       	swap	r25
    3902:	90 7f       	andi	r25, 0xF0	; 240
    3904:	80 e0       	ldi	r24, 0x00	; 0
    3906:	69 2f       	mov	r22, r25
    3908:	0e 94 de 10 	call	0x21bc	; 0x21bc <MCAL_DIO_u8SetPortValue>
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_High);
    390c:	81 e0       	ldi	r24, 0x01	; 1
    390e:	63 e0       	ldi	r22, 0x03	; 3
    3910:	41 e0       	ldi	r20, 0x01	; 1
    3912:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    3916:	80 e0       	ldi	r24, 0x00	; 0
    3918:	90 e0       	ldi	r25, 0x00	; 0
    391a:	a0 e0       	ldi	r26, 0x00	; 0
    391c:	b0 e4       	ldi	r27, 0x40	; 64
    391e:	8b 87       	std	Y+11, r24	; 0x0b
    3920:	9c 87       	std	Y+12, r25	; 0x0c
    3922:	ad 87       	std	Y+13, r26	; 0x0d
    3924:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3926:	6b 85       	ldd	r22, Y+11	; 0x0b
    3928:	7c 85       	ldd	r23, Y+12	; 0x0c
    392a:	8d 85       	ldd	r24, Y+13	; 0x0d
    392c:	9e 85       	ldd	r25, Y+14	; 0x0e
    392e:	20 e0       	ldi	r18, 0x00	; 0
    3930:	30 e0       	ldi	r19, 0x00	; 0
    3932:	4a e7       	ldi	r20, 0x7A	; 122
    3934:	55 e4       	ldi	r21, 0x45	; 69
    3936:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    393a:	dc 01       	movw	r26, r24
    393c:	cb 01       	movw	r24, r22
    393e:	8f 83       	std	Y+7, r24	; 0x07
    3940:	98 87       	std	Y+8, r25	; 0x08
    3942:	a9 87       	std	Y+9, r26	; 0x09
    3944:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3946:	6f 81       	ldd	r22, Y+7	; 0x07
    3948:	78 85       	ldd	r23, Y+8	; 0x08
    394a:	89 85       	ldd	r24, Y+9	; 0x09
    394c:	9a 85       	ldd	r25, Y+10	; 0x0a
    394e:	20 e0       	ldi	r18, 0x00	; 0
    3950:	30 e0       	ldi	r19, 0x00	; 0
    3952:	40 e8       	ldi	r20, 0x80	; 128
    3954:	5f e3       	ldi	r21, 0x3F	; 63
    3956:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    395a:	88 23       	and	r24, r24
    395c:	2c f4       	brge	.+10     	; 0x3968 <HAL_LCD_u8SendChar+0x196>
		__ticks = 1;
    395e:	81 e0       	ldi	r24, 0x01	; 1
    3960:	90 e0       	ldi	r25, 0x00	; 0
    3962:	9e 83       	std	Y+6, r25	; 0x06
    3964:	8d 83       	std	Y+5, r24	; 0x05
    3966:	3f c0       	rjmp	.+126    	; 0x39e6 <HAL_LCD_u8SendChar+0x214>
	else if (__tmp > 65535)
    3968:	6f 81       	ldd	r22, Y+7	; 0x07
    396a:	78 85       	ldd	r23, Y+8	; 0x08
    396c:	89 85       	ldd	r24, Y+9	; 0x09
    396e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3970:	20 e0       	ldi	r18, 0x00	; 0
    3972:	3f ef       	ldi	r19, 0xFF	; 255
    3974:	4f e7       	ldi	r20, 0x7F	; 127
    3976:	57 e4       	ldi	r21, 0x47	; 71
    3978:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    397c:	18 16       	cp	r1, r24
    397e:	4c f5       	brge	.+82     	; 0x39d2 <HAL_LCD_u8SendChar+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3980:	6b 85       	ldd	r22, Y+11	; 0x0b
    3982:	7c 85       	ldd	r23, Y+12	; 0x0c
    3984:	8d 85       	ldd	r24, Y+13	; 0x0d
    3986:	9e 85       	ldd	r25, Y+14	; 0x0e
    3988:	20 e0       	ldi	r18, 0x00	; 0
    398a:	30 e0       	ldi	r19, 0x00	; 0
    398c:	40 e2       	ldi	r20, 0x20	; 32
    398e:	51 e4       	ldi	r21, 0x41	; 65
    3990:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3994:	dc 01       	movw	r26, r24
    3996:	cb 01       	movw	r24, r22
    3998:	bc 01       	movw	r22, r24
    399a:	cd 01       	movw	r24, r26
    399c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39a0:	dc 01       	movw	r26, r24
    39a2:	cb 01       	movw	r24, r22
    39a4:	9e 83       	std	Y+6, r25	; 0x06
    39a6:	8d 83       	std	Y+5, r24	; 0x05
    39a8:	0f c0       	rjmp	.+30     	; 0x39c8 <HAL_LCD_u8SendChar+0x1f6>
    39aa:	80 e9       	ldi	r24, 0x90	; 144
    39ac:	91 e0       	ldi	r25, 0x01	; 1
    39ae:	9c 83       	std	Y+4, r25	; 0x04
    39b0:	8b 83       	std	Y+3, r24	; 0x03
    39b2:	8b 81       	ldd	r24, Y+3	; 0x03
    39b4:	9c 81       	ldd	r25, Y+4	; 0x04
    39b6:	01 97       	sbiw	r24, 0x01	; 1
    39b8:	f1 f7       	brne	.-4      	; 0x39b6 <HAL_LCD_u8SendChar+0x1e4>
    39ba:	9c 83       	std	Y+4, r25	; 0x04
    39bc:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39be:	8d 81       	ldd	r24, Y+5	; 0x05
    39c0:	9e 81       	ldd	r25, Y+6	; 0x06
    39c2:	01 97       	sbiw	r24, 0x01	; 1
    39c4:	9e 83       	std	Y+6, r25	; 0x06
    39c6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39c8:	8d 81       	ldd	r24, Y+5	; 0x05
    39ca:	9e 81       	ldd	r25, Y+6	; 0x06
    39cc:	00 97       	sbiw	r24, 0x00	; 0
    39ce:	69 f7       	brne	.-38     	; 0x39aa <HAL_LCD_u8SendChar+0x1d8>
    39d0:	14 c0       	rjmp	.+40     	; 0x39fa <HAL_LCD_u8SendChar+0x228>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    39d2:	6f 81       	ldd	r22, Y+7	; 0x07
    39d4:	78 85       	ldd	r23, Y+8	; 0x08
    39d6:	89 85       	ldd	r24, Y+9	; 0x09
    39d8:	9a 85       	ldd	r25, Y+10	; 0x0a
    39da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39de:	dc 01       	movw	r26, r24
    39e0:	cb 01       	movw	r24, r22
    39e2:	9e 83       	std	Y+6, r25	; 0x06
    39e4:	8d 83       	std	Y+5, r24	; 0x05
    39e6:	8d 81       	ldd	r24, Y+5	; 0x05
    39e8:	9e 81       	ldd	r25, Y+6	; 0x06
    39ea:	9a 83       	std	Y+2, r25	; 0x02
    39ec:	89 83       	std	Y+1, r24	; 0x01
    39ee:	89 81       	ldd	r24, Y+1	; 0x01
    39f0:	9a 81       	ldd	r25, Y+2	; 0x02
    39f2:	01 97       	sbiw	r24, 0x01	; 1
    39f4:	f1 f7       	brne	.-4      	; 0x39f2 <HAL_LCD_u8SendChar+0x220>
    39f6:	9a 83       	std	Y+2, r25	; 0x02
    39f8:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
    39fa:	81 e0       	ldi	r24, 0x01	; 1
    39fc:	63 e0       	ldi	r22, 0x03	; 3
    39fe:	40 e0       	ldi	r20, 0x00	; 0
    3a00:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
}
    3a04:	6d 96       	adiw	r28, 0x1d	; 29
    3a06:	0f b6       	in	r0, 0x3f	; 63
    3a08:	f8 94       	cli
    3a0a:	de bf       	out	0x3e, r29	; 62
    3a0c:	0f be       	out	0x3f, r0	; 63
    3a0e:	cd bf       	out	0x3d, r28	; 61
    3a10:	cf 91       	pop	r28
    3a12:	df 91       	pop	r29
    3a14:	08 95       	ret

00003a16 <HAL_LCD_u8SendString>:

void HAL_LCD_u8SendString(u8 * Loc_u8LCD_String) {
    3a16:	df 93       	push	r29
    3a18:	cf 93       	push	r28
    3a1a:	00 d0       	rcall	.+0      	; 0x3a1c <HAL_LCD_u8SendString+0x6>
    3a1c:	00 d0       	rcall	.+0      	; 0x3a1e <HAL_LCD_u8SendString+0x8>
    3a1e:	00 d0       	rcall	.+0      	; 0x3a20 <HAL_LCD_u8SendString+0xa>
    3a20:	cd b7       	in	r28, 0x3d	; 61
    3a22:	de b7       	in	r29, 0x3e	; 62
    3a24:	9e 83       	std	Y+6, r25	; 0x06
    3a26:	8d 83       	std	Y+5, r24	; 0x05
	for (u32 count = 0; Loc_u8LCD_String[count] != '\0'; count++) {
    3a28:	19 82       	std	Y+1, r1	; 0x01
    3a2a:	1a 82       	std	Y+2, r1	; 0x02
    3a2c:	1b 82       	std	Y+3, r1	; 0x03
    3a2e:	1c 82       	std	Y+4, r1	; 0x04
    3a30:	15 c0       	rjmp	.+42     	; 0x3a5c <HAL_LCD_u8SendString+0x46>
		HAL_LCD_u8SendChar(Loc_u8LCD_String[count]);
    3a32:	29 81       	ldd	r18, Y+1	; 0x01
    3a34:	3a 81       	ldd	r19, Y+2	; 0x02
    3a36:	8d 81       	ldd	r24, Y+5	; 0x05
    3a38:	9e 81       	ldd	r25, Y+6	; 0x06
    3a3a:	fc 01       	movw	r30, r24
    3a3c:	e2 0f       	add	r30, r18
    3a3e:	f3 1f       	adc	r31, r19
    3a40:	80 81       	ld	r24, Z
    3a42:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <HAL_LCD_u8SendChar>
	_delay_ms(2);
	MCAL_DIO_u8SetPinValue(Enable_PORT, Enable_PIN, Enable_Low);
}

void HAL_LCD_u8SendString(u8 * Loc_u8LCD_String) {
	for (u32 count = 0; Loc_u8LCD_String[count] != '\0'; count++) {
    3a46:	89 81       	ldd	r24, Y+1	; 0x01
    3a48:	9a 81       	ldd	r25, Y+2	; 0x02
    3a4a:	ab 81       	ldd	r26, Y+3	; 0x03
    3a4c:	bc 81       	ldd	r27, Y+4	; 0x04
    3a4e:	01 96       	adiw	r24, 0x01	; 1
    3a50:	a1 1d       	adc	r26, r1
    3a52:	b1 1d       	adc	r27, r1
    3a54:	89 83       	std	Y+1, r24	; 0x01
    3a56:	9a 83       	std	Y+2, r25	; 0x02
    3a58:	ab 83       	std	Y+3, r26	; 0x03
    3a5a:	bc 83       	std	Y+4, r27	; 0x04
    3a5c:	29 81       	ldd	r18, Y+1	; 0x01
    3a5e:	3a 81       	ldd	r19, Y+2	; 0x02
    3a60:	8d 81       	ldd	r24, Y+5	; 0x05
    3a62:	9e 81       	ldd	r25, Y+6	; 0x06
    3a64:	fc 01       	movw	r30, r24
    3a66:	e2 0f       	add	r30, r18
    3a68:	f3 1f       	adc	r31, r19
    3a6a:	80 81       	ld	r24, Z
    3a6c:	88 23       	and	r24, r24
    3a6e:	09 f7       	brne	.-62     	; 0x3a32 <HAL_LCD_u8SendString+0x1c>
		HAL_LCD_u8SendChar(Loc_u8LCD_String[count]);
	}
}
    3a70:	26 96       	adiw	r28, 0x06	; 6
    3a72:	0f b6       	in	r0, 0x3f	; 63
    3a74:	f8 94       	cli
    3a76:	de bf       	out	0x3e, r29	; 62
    3a78:	0f be       	out	0x3f, r0	; 63
    3a7a:	cd bf       	out	0x3d, r28	; 61
    3a7c:	cf 91       	pop	r28
    3a7e:	df 91       	pop	r29
    3a80:	08 95       	ret

00003a82 <HAL_LCD_u8SendNumber>:

void HAL_LCD_u8SendNumber(u16 Loc_u8LCD_Number) {
    3a82:	df 93       	push	r29
    3a84:	cf 93       	push	r28
    3a86:	cd b7       	in	r28, 0x3d	; 61
    3a88:	de b7       	in	r29, 0x3e	; 62
    3a8a:	2c 97       	sbiw	r28, 0x0c	; 12
    3a8c:	0f b6       	in	r0, 0x3f	; 63
    3a8e:	f8 94       	cli
    3a90:	de bf       	out	0x3e, r29	; 62
    3a92:	0f be       	out	0x3f, r0	; 63
    3a94:	cd bf       	out	0x3d, r28	; 61
    3a96:	9c 87       	std	Y+12, r25	; 0x0c
    3a98:	8b 87       	std	Y+11, r24	; 0x0b
	u8 str[10];
	itoa(Loc_u8LCD_Number, str, 10);
    3a9a:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a9c:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a9e:	9e 01       	movw	r18, r28
    3aa0:	2f 5f       	subi	r18, 0xFF	; 255
    3aa2:	3f 4f       	sbci	r19, 0xFF	; 255
    3aa4:	b9 01       	movw	r22, r18
    3aa6:	4a e0       	ldi	r20, 0x0A	; 10
    3aa8:	50 e0       	ldi	r21, 0x00	; 0
    3aaa:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <itoa>
	HAL_LCD_u8SendString(str);
    3aae:	ce 01       	movw	r24, r28
    3ab0:	01 96       	adiw	r24, 0x01	; 1
    3ab2:	0e 94 0b 1d 	call	0x3a16	; 0x3a16 <HAL_LCD_u8SendString>
}
    3ab6:	2c 96       	adiw	r28, 0x0c	; 12
    3ab8:	0f b6       	in	r0, 0x3f	; 63
    3aba:	f8 94       	cli
    3abc:	de bf       	out	0x3e, r29	; 62
    3abe:	0f be       	out	0x3f, r0	; 63
    3ac0:	cd bf       	out	0x3d, r28	; 61
    3ac2:	cf 91       	pop	r28
    3ac4:	df 91       	pop	r29
    3ac6:	08 95       	ret

00003ac8 <HAL_LCD_u8GoTo>:

void HAL_LCD_u8GoTo(u8 Loc_u8TypeOfShift, u8 Loc_u8NumOfShift) {
    3ac8:	df 93       	push	r29
    3aca:	cf 93       	push	r28
    3acc:	cd b7       	in	r28, 0x3d	; 61
    3ace:	de b7       	in	r29, 0x3e	; 62
    3ad0:	c2 54       	subi	r28, 0x42	; 66
    3ad2:	d0 40       	sbci	r29, 0x00	; 0
    3ad4:	0f b6       	in	r0, 0x3f	; 63
    3ad6:	f8 94       	cli
    3ad8:	de bf       	out	0x3e, r29	; 62
    3ada:	0f be       	out	0x3f, r0	; 63
    3adc:	cd bf       	out	0x3d, r28	; 61
    3ade:	fe 01       	movw	r30, r28
    3ae0:	ef 5b       	subi	r30, 0xBF	; 191
    3ae2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ae4:	80 83       	st	Z, r24
    3ae6:	fe 01       	movw	r30, r28
    3ae8:	ee 5b       	subi	r30, 0xBE	; 190
    3aea:	ff 4f       	sbci	r31, 0xFF	; 255
    3aec:	60 83       	st	Z, r22
	if (Loc_u8TypeOfShift == Right_Shift) {
    3aee:	fe 01       	movw	r30, r28
    3af0:	ef 5b       	subi	r30, 0xBF	; 191
    3af2:	ff 4f       	sbci	r31, 0xFF	; 255
    3af4:	80 81       	ld	r24, Z
    3af6:	81 30       	cpi	r24, 0x01	; 1
    3af8:	09 f0       	breq	.+2      	; 0x3afc <HAL_LCD_u8GoTo+0x34>
    3afa:	a0 c0       	rjmp	.+320    	; 0x3c3c <HAL_LCD_u8GoTo+0x174>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    3afc:	fe 01       	movw	r30, r28
    3afe:	fd 96       	adiw	r30, 0x3d	; 61
    3b00:	10 82       	st	Z, r1
    3b02:	11 82       	std	Z+1, r1	; 0x01
    3b04:	12 82       	std	Z+2, r1	; 0x02
    3b06:	13 82       	std	Z+3, r1	; 0x03
    3b08:	84 c0       	rjmp	.+264    	; 0x3c12 <HAL_LCD_u8GoTo+0x14a>
    3b0a:	80 e0       	ldi	r24, 0x00	; 0
    3b0c:	90 e0       	ldi	r25, 0x00	; 0
    3b0e:	a0 e0       	ldi	r26, 0x00	; 0
    3b10:	b0 e4       	ldi	r27, 0x40	; 64
    3b12:	8d ab       	std	Y+53, r24	; 0x35
    3b14:	9e ab       	std	Y+54, r25	; 0x36
    3b16:	af ab       	std	Y+55, r26	; 0x37
    3b18:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b1a:	6d a9       	ldd	r22, Y+53	; 0x35
    3b1c:	7e a9       	ldd	r23, Y+54	; 0x36
    3b1e:	8f a9       	ldd	r24, Y+55	; 0x37
    3b20:	98 ad       	ldd	r25, Y+56	; 0x38
    3b22:	20 e0       	ldi	r18, 0x00	; 0
    3b24:	30 e0       	ldi	r19, 0x00	; 0
    3b26:	4a e7       	ldi	r20, 0x7A	; 122
    3b28:	55 e4       	ldi	r21, 0x45	; 69
    3b2a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b2e:	dc 01       	movw	r26, r24
    3b30:	cb 01       	movw	r24, r22
    3b32:	89 ab       	std	Y+49, r24	; 0x31
    3b34:	9a ab       	std	Y+50, r25	; 0x32
    3b36:	ab ab       	std	Y+51, r26	; 0x33
    3b38:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3b3a:	69 a9       	ldd	r22, Y+49	; 0x31
    3b3c:	7a a9       	ldd	r23, Y+50	; 0x32
    3b3e:	8b a9       	ldd	r24, Y+51	; 0x33
    3b40:	9c a9       	ldd	r25, Y+52	; 0x34
    3b42:	20 e0       	ldi	r18, 0x00	; 0
    3b44:	30 e0       	ldi	r19, 0x00	; 0
    3b46:	40 e8       	ldi	r20, 0x80	; 128
    3b48:	5f e3       	ldi	r21, 0x3F	; 63
    3b4a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b4e:	88 23       	and	r24, r24
    3b50:	2c f4       	brge	.+10     	; 0x3b5c <HAL_LCD_u8GoTo+0x94>
		__ticks = 1;
    3b52:	81 e0       	ldi	r24, 0x01	; 1
    3b54:	90 e0       	ldi	r25, 0x00	; 0
    3b56:	98 ab       	std	Y+48, r25	; 0x30
    3b58:	8f a7       	std	Y+47, r24	; 0x2f
    3b5a:	3f c0       	rjmp	.+126    	; 0x3bda <HAL_LCD_u8GoTo+0x112>
	else if (__tmp > 65535)
    3b5c:	69 a9       	ldd	r22, Y+49	; 0x31
    3b5e:	7a a9       	ldd	r23, Y+50	; 0x32
    3b60:	8b a9       	ldd	r24, Y+51	; 0x33
    3b62:	9c a9       	ldd	r25, Y+52	; 0x34
    3b64:	20 e0       	ldi	r18, 0x00	; 0
    3b66:	3f ef       	ldi	r19, 0xFF	; 255
    3b68:	4f e7       	ldi	r20, 0x7F	; 127
    3b6a:	57 e4       	ldi	r21, 0x47	; 71
    3b6c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b70:	18 16       	cp	r1, r24
    3b72:	4c f5       	brge	.+82     	; 0x3bc6 <HAL_LCD_u8GoTo+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b74:	6d a9       	ldd	r22, Y+53	; 0x35
    3b76:	7e a9       	ldd	r23, Y+54	; 0x36
    3b78:	8f a9       	ldd	r24, Y+55	; 0x37
    3b7a:	98 ad       	ldd	r25, Y+56	; 0x38
    3b7c:	20 e0       	ldi	r18, 0x00	; 0
    3b7e:	30 e0       	ldi	r19, 0x00	; 0
    3b80:	40 e2       	ldi	r20, 0x20	; 32
    3b82:	51 e4       	ldi	r21, 0x41	; 65
    3b84:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b88:	dc 01       	movw	r26, r24
    3b8a:	cb 01       	movw	r24, r22
    3b8c:	bc 01       	movw	r22, r24
    3b8e:	cd 01       	movw	r24, r26
    3b90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b94:	dc 01       	movw	r26, r24
    3b96:	cb 01       	movw	r24, r22
    3b98:	98 ab       	std	Y+48, r25	; 0x30
    3b9a:	8f a7       	std	Y+47, r24	; 0x2f
    3b9c:	0f c0       	rjmp	.+30     	; 0x3bbc <HAL_LCD_u8GoTo+0xf4>
    3b9e:	80 e9       	ldi	r24, 0x90	; 144
    3ba0:	91 e0       	ldi	r25, 0x01	; 1
    3ba2:	9e a7       	std	Y+46, r25	; 0x2e
    3ba4:	8d a7       	std	Y+45, r24	; 0x2d
    3ba6:	8d a5       	ldd	r24, Y+45	; 0x2d
    3ba8:	9e a5       	ldd	r25, Y+46	; 0x2e
    3baa:	01 97       	sbiw	r24, 0x01	; 1
    3bac:	f1 f7       	brne	.-4      	; 0x3baa <HAL_LCD_u8GoTo+0xe2>
    3bae:	9e a7       	std	Y+46, r25	; 0x2e
    3bb0:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3bb2:	8f a5       	ldd	r24, Y+47	; 0x2f
    3bb4:	98 a9       	ldd	r25, Y+48	; 0x30
    3bb6:	01 97       	sbiw	r24, 0x01	; 1
    3bb8:	98 ab       	std	Y+48, r25	; 0x30
    3bba:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3bbc:	8f a5       	ldd	r24, Y+47	; 0x2f
    3bbe:	98 a9       	ldd	r25, Y+48	; 0x30
    3bc0:	00 97       	sbiw	r24, 0x00	; 0
    3bc2:	69 f7       	brne	.-38     	; 0x3b9e <HAL_LCD_u8GoTo+0xd6>
    3bc4:	14 c0       	rjmp	.+40     	; 0x3bee <HAL_LCD_u8GoTo+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3bc6:	69 a9       	ldd	r22, Y+49	; 0x31
    3bc8:	7a a9       	ldd	r23, Y+50	; 0x32
    3bca:	8b a9       	ldd	r24, Y+51	; 0x33
    3bcc:	9c a9       	ldd	r25, Y+52	; 0x34
    3bce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bd2:	dc 01       	movw	r26, r24
    3bd4:	cb 01       	movw	r24, r22
    3bd6:	98 ab       	std	Y+48, r25	; 0x30
    3bd8:	8f a7       	std	Y+47, r24	; 0x2f
    3bda:	8f a5       	ldd	r24, Y+47	; 0x2f
    3bdc:	98 a9       	ldd	r25, Y+48	; 0x30
    3bde:	9c a7       	std	Y+44, r25	; 0x2c
    3be0:	8b a7       	std	Y+43, r24	; 0x2b
    3be2:	8b a5       	ldd	r24, Y+43	; 0x2b
    3be4:	9c a5       	ldd	r25, Y+44	; 0x2c
    3be6:	01 97       	sbiw	r24, 0x01	; 1
    3be8:	f1 f7       	brne	.-4      	; 0x3be6 <HAL_LCD_u8GoTo+0x11e>
    3bea:	9c a7       	std	Y+44, r25	; 0x2c
    3bec:	8b a7       	std	Y+43, r24	; 0x2b
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
    3bee:	8c e1       	ldi	r24, 0x1C	; 28
    3bf0:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
	HAL_LCD_u8SendString(str);
}

void HAL_LCD_u8GoTo(u8 Loc_u8TypeOfShift, u8 Loc_u8NumOfShift) {
	if (Loc_u8TypeOfShift == Right_Shift) {
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    3bf4:	fe 01       	movw	r30, r28
    3bf6:	fd 96       	adiw	r30, 0x3d	; 61
    3bf8:	80 81       	ld	r24, Z
    3bfa:	91 81       	ldd	r25, Z+1	; 0x01
    3bfc:	a2 81       	ldd	r26, Z+2	; 0x02
    3bfe:	b3 81       	ldd	r27, Z+3	; 0x03
    3c00:	01 96       	adiw	r24, 0x01	; 1
    3c02:	a1 1d       	adc	r26, r1
    3c04:	b1 1d       	adc	r27, r1
    3c06:	fe 01       	movw	r30, r28
    3c08:	fd 96       	adiw	r30, 0x3d	; 61
    3c0a:	80 83       	st	Z, r24
    3c0c:	91 83       	std	Z+1, r25	; 0x01
    3c0e:	a2 83       	std	Z+2, r26	; 0x02
    3c10:	b3 83       	std	Z+3, r27	; 0x03
    3c12:	fe 01       	movw	r30, r28
    3c14:	ee 5b       	subi	r30, 0xBE	; 190
    3c16:	ff 4f       	sbci	r31, 0xFF	; 255
    3c18:	80 81       	ld	r24, Z
    3c1a:	28 2f       	mov	r18, r24
    3c1c:	30 e0       	ldi	r19, 0x00	; 0
    3c1e:	40 e0       	ldi	r20, 0x00	; 0
    3c20:	50 e0       	ldi	r21, 0x00	; 0
    3c22:	fe 01       	movw	r30, r28
    3c24:	fd 96       	adiw	r30, 0x3d	; 61
    3c26:	80 81       	ld	r24, Z
    3c28:	91 81       	ldd	r25, Z+1	; 0x01
    3c2a:	a2 81       	ldd	r26, Z+2	; 0x02
    3c2c:	b3 81       	ldd	r27, Z+3	; 0x03
    3c2e:	82 17       	cp	r24, r18
    3c30:	93 07       	cpc	r25, r19
    3c32:	a4 07       	cpc	r26, r20
    3c34:	b5 07       	cpc	r27, r21
    3c36:	08 f4       	brcc	.+2      	; 0x3c3a <HAL_LCD_u8GoTo+0x172>
    3c38:	68 cf       	rjmp	.-304    	; 0x3b0a <HAL_LCD_u8GoTo+0x42>
    3c3a:	98 c1       	rjmp	.+816    	; 0x3f6c <HAL_LCD_u8GoTo+0x4a4>
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == Left_Shift) {
    3c3c:	fe 01       	movw	r30, r28
    3c3e:	ef 5b       	subi	r30, 0xBF	; 191
    3c40:	ff 4f       	sbci	r31, 0xFF	; 255
    3c42:	80 81       	ld	r24, Z
    3c44:	88 23       	and	r24, r24
    3c46:	09 f0       	breq	.+2      	; 0x3c4a <HAL_LCD_u8GoTo+0x182>
    3c48:	98 c0       	rjmp	.+304    	; 0x3d7a <HAL_LCD_u8GoTo+0x2b2>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    3c4a:	19 ae       	std	Y+57, r1	; 0x39
    3c4c:	1a ae       	std	Y+58, r1	; 0x3a
    3c4e:	1b ae       	std	Y+59, r1	; 0x3b
    3c50:	1c ae       	std	Y+60, r1	; 0x3c
    3c52:	80 c0       	rjmp	.+256    	; 0x3d54 <HAL_LCD_u8GoTo+0x28c>
    3c54:	80 e0       	ldi	r24, 0x00	; 0
    3c56:	90 e0       	ldi	r25, 0x00	; 0
    3c58:	a0 e0       	ldi	r26, 0x00	; 0
    3c5a:	b0 e4       	ldi	r27, 0x40	; 64
    3c5c:	8f a3       	std	Y+39, r24	; 0x27
    3c5e:	98 a7       	std	Y+40, r25	; 0x28
    3c60:	a9 a7       	std	Y+41, r26	; 0x29
    3c62:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3c64:	6f a1       	ldd	r22, Y+39	; 0x27
    3c66:	78 a5       	ldd	r23, Y+40	; 0x28
    3c68:	89 a5       	ldd	r24, Y+41	; 0x29
    3c6a:	9a a5       	ldd	r25, Y+42	; 0x2a
    3c6c:	20 e0       	ldi	r18, 0x00	; 0
    3c6e:	30 e0       	ldi	r19, 0x00	; 0
    3c70:	4a e7       	ldi	r20, 0x7A	; 122
    3c72:	55 e4       	ldi	r21, 0x45	; 69
    3c74:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3c78:	dc 01       	movw	r26, r24
    3c7a:	cb 01       	movw	r24, r22
    3c7c:	8b a3       	std	Y+35, r24	; 0x23
    3c7e:	9c a3       	std	Y+36, r25	; 0x24
    3c80:	ad a3       	std	Y+37, r26	; 0x25
    3c82:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3c84:	6b a1       	ldd	r22, Y+35	; 0x23
    3c86:	7c a1       	ldd	r23, Y+36	; 0x24
    3c88:	8d a1       	ldd	r24, Y+37	; 0x25
    3c8a:	9e a1       	ldd	r25, Y+38	; 0x26
    3c8c:	20 e0       	ldi	r18, 0x00	; 0
    3c8e:	30 e0       	ldi	r19, 0x00	; 0
    3c90:	40 e8       	ldi	r20, 0x80	; 128
    3c92:	5f e3       	ldi	r21, 0x3F	; 63
    3c94:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3c98:	88 23       	and	r24, r24
    3c9a:	2c f4       	brge	.+10     	; 0x3ca6 <HAL_LCD_u8GoTo+0x1de>
		__ticks = 1;
    3c9c:	81 e0       	ldi	r24, 0x01	; 1
    3c9e:	90 e0       	ldi	r25, 0x00	; 0
    3ca0:	9a a3       	std	Y+34, r25	; 0x22
    3ca2:	89 a3       	std	Y+33, r24	; 0x21
    3ca4:	3f c0       	rjmp	.+126    	; 0x3d24 <HAL_LCD_u8GoTo+0x25c>
	else if (__tmp > 65535)
    3ca6:	6b a1       	ldd	r22, Y+35	; 0x23
    3ca8:	7c a1       	ldd	r23, Y+36	; 0x24
    3caa:	8d a1       	ldd	r24, Y+37	; 0x25
    3cac:	9e a1       	ldd	r25, Y+38	; 0x26
    3cae:	20 e0       	ldi	r18, 0x00	; 0
    3cb0:	3f ef       	ldi	r19, 0xFF	; 255
    3cb2:	4f e7       	ldi	r20, 0x7F	; 127
    3cb4:	57 e4       	ldi	r21, 0x47	; 71
    3cb6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3cba:	18 16       	cp	r1, r24
    3cbc:	4c f5       	brge	.+82     	; 0x3d10 <HAL_LCD_u8GoTo+0x248>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3cbe:	6f a1       	ldd	r22, Y+39	; 0x27
    3cc0:	78 a5       	ldd	r23, Y+40	; 0x28
    3cc2:	89 a5       	ldd	r24, Y+41	; 0x29
    3cc4:	9a a5       	ldd	r25, Y+42	; 0x2a
    3cc6:	20 e0       	ldi	r18, 0x00	; 0
    3cc8:	30 e0       	ldi	r19, 0x00	; 0
    3cca:	40 e2       	ldi	r20, 0x20	; 32
    3ccc:	51 e4       	ldi	r21, 0x41	; 65
    3cce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3cd2:	dc 01       	movw	r26, r24
    3cd4:	cb 01       	movw	r24, r22
    3cd6:	bc 01       	movw	r22, r24
    3cd8:	cd 01       	movw	r24, r26
    3cda:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3cde:	dc 01       	movw	r26, r24
    3ce0:	cb 01       	movw	r24, r22
    3ce2:	9a a3       	std	Y+34, r25	; 0x22
    3ce4:	89 a3       	std	Y+33, r24	; 0x21
    3ce6:	0f c0       	rjmp	.+30     	; 0x3d06 <HAL_LCD_u8GoTo+0x23e>
    3ce8:	80 e9       	ldi	r24, 0x90	; 144
    3cea:	91 e0       	ldi	r25, 0x01	; 1
    3cec:	98 a3       	std	Y+32, r25	; 0x20
    3cee:	8f 8f       	std	Y+31, r24	; 0x1f
    3cf0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3cf2:	98 a1       	ldd	r25, Y+32	; 0x20
    3cf4:	01 97       	sbiw	r24, 0x01	; 1
    3cf6:	f1 f7       	brne	.-4      	; 0x3cf4 <HAL_LCD_u8GoTo+0x22c>
    3cf8:	98 a3       	std	Y+32, r25	; 0x20
    3cfa:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3cfc:	89 a1       	ldd	r24, Y+33	; 0x21
    3cfe:	9a a1       	ldd	r25, Y+34	; 0x22
    3d00:	01 97       	sbiw	r24, 0x01	; 1
    3d02:	9a a3       	std	Y+34, r25	; 0x22
    3d04:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3d06:	89 a1       	ldd	r24, Y+33	; 0x21
    3d08:	9a a1       	ldd	r25, Y+34	; 0x22
    3d0a:	00 97       	sbiw	r24, 0x00	; 0
    3d0c:	69 f7       	brne	.-38     	; 0x3ce8 <HAL_LCD_u8GoTo+0x220>
    3d0e:	14 c0       	rjmp	.+40     	; 0x3d38 <HAL_LCD_u8GoTo+0x270>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3d10:	6b a1       	ldd	r22, Y+35	; 0x23
    3d12:	7c a1       	ldd	r23, Y+36	; 0x24
    3d14:	8d a1       	ldd	r24, Y+37	; 0x25
    3d16:	9e a1       	ldd	r25, Y+38	; 0x26
    3d18:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d1c:	dc 01       	movw	r26, r24
    3d1e:	cb 01       	movw	r24, r22
    3d20:	9a a3       	std	Y+34, r25	; 0x22
    3d22:	89 a3       	std	Y+33, r24	; 0x21
    3d24:	89 a1       	ldd	r24, Y+33	; 0x21
    3d26:	9a a1       	ldd	r25, Y+34	; 0x22
    3d28:	9e 8f       	std	Y+30, r25	; 0x1e
    3d2a:	8d 8f       	std	Y+29, r24	; 0x1d
    3d2c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3d2e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3d30:	01 97       	sbiw	r24, 0x01	; 1
    3d32:	f1 f7       	brne	.-4      	; 0x3d30 <HAL_LCD_u8GoTo+0x268>
    3d34:	9e 8f       	std	Y+30, r25	; 0x1e
    3d36:	8d 8f       	std	Y+29, r24	; 0x1d
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Left_Shift_Command);
    3d38:	88 e1       	ldi	r24, 0x18	; 24
    3d3a:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Right_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == Left_Shift) {
		for (u32 count = 0; count < Loc_u8NumOfShift; count++) {
    3d3e:	89 ad       	ldd	r24, Y+57	; 0x39
    3d40:	9a ad       	ldd	r25, Y+58	; 0x3a
    3d42:	ab ad       	ldd	r26, Y+59	; 0x3b
    3d44:	bc ad       	ldd	r27, Y+60	; 0x3c
    3d46:	01 96       	adiw	r24, 0x01	; 1
    3d48:	a1 1d       	adc	r26, r1
    3d4a:	b1 1d       	adc	r27, r1
    3d4c:	89 af       	std	Y+57, r24	; 0x39
    3d4e:	9a af       	std	Y+58, r25	; 0x3a
    3d50:	ab af       	std	Y+59, r26	; 0x3b
    3d52:	bc af       	std	Y+60, r27	; 0x3c
    3d54:	fe 01       	movw	r30, r28
    3d56:	ee 5b       	subi	r30, 0xBE	; 190
    3d58:	ff 4f       	sbci	r31, 0xFF	; 255
    3d5a:	80 81       	ld	r24, Z
    3d5c:	28 2f       	mov	r18, r24
    3d5e:	30 e0       	ldi	r19, 0x00	; 0
    3d60:	40 e0       	ldi	r20, 0x00	; 0
    3d62:	50 e0       	ldi	r21, 0x00	; 0
    3d64:	89 ad       	ldd	r24, Y+57	; 0x39
    3d66:	9a ad       	ldd	r25, Y+58	; 0x3a
    3d68:	ab ad       	ldd	r26, Y+59	; 0x3b
    3d6a:	bc ad       	ldd	r27, Y+60	; 0x3c
    3d6c:	82 17       	cp	r24, r18
    3d6e:	93 07       	cpc	r25, r19
    3d70:	a4 07       	cpc	r26, r20
    3d72:	b5 07       	cpc	r27, r21
    3d74:	08 f4       	brcc	.+2      	; 0x3d78 <HAL_LCD_u8GoTo+0x2b0>
    3d76:	6e cf       	rjmp	.-292    	; 0x3c54 <HAL_LCD_u8GoTo+0x18c>
    3d78:	f9 c0       	rjmp	.+498    	; 0x3f6c <HAL_LCD_u8GoTo+0x4a4>
			_delay_ms(2);
			HAL_LCD_u8SendCommands(Left_Shift_Command);
		}
	} else if (Loc_u8TypeOfShift == First_Line) {
    3d7a:	fe 01       	movw	r30, r28
    3d7c:	ef 5b       	subi	r30, 0xBF	; 191
    3d7e:	ff 4f       	sbci	r31, 0xFF	; 255
    3d80:	80 81       	ld	r24, Z
    3d82:	82 30       	cpi	r24, 0x02	; 2
    3d84:	09 f0       	breq	.+2      	; 0x3d88 <HAL_LCD_u8GoTo+0x2c0>
    3d86:	76 c0       	rjmp	.+236    	; 0x3e74 <HAL_LCD_u8GoTo+0x3ac>
    3d88:	80 e0       	ldi	r24, 0x00	; 0
    3d8a:	90 e0       	ldi	r25, 0x00	; 0
    3d8c:	a0 e0       	ldi	r26, 0x00	; 0
    3d8e:	b0 e4       	ldi	r27, 0x40	; 64
    3d90:	89 8f       	std	Y+25, r24	; 0x19
    3d92:	9a 8f       	std	Y+26, r25	; 0x1a
    3d94:	ab 8f       	std	Y+27, r26	; 0x1b
    3d96:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3d98:	69 8d       	ldd	r22, Y+25	; 0x19
    3d9a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3d9c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3d9e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3da0:	20 e0       	ldi	r18, 0x00	; 0
    3da2:	30 e0       	ldi	r19, 0x00	; 0
    3da4:	4a e7       	ldi	r20, 0x7A	; 122
    3da6:	55 e4       	ldi	r21, 0x45	; 69
    3da8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3dac:	dc 01       	movw	r26, r24
    3dae:	cb 01       	movw	r24, r22
    3db0:	8d 8b       	std	Y+21, r24	; 0x15
    3db2:	9e 8b       	std	Y+22, r25	; 0x16
    3db4:	af 8b       	std	Y+23, r26	; 0x17
    3db6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3db8:	6d 89       	ldd	r22, Y+21	; 0x15
    3dba:	7e 89       	ldd	r23, Y+22	; 0x16
    3dbc:	8f 89       	ldd	r24, Y+23	; 0x17
    3dbe:	98 8d       	ldd	r25, Y+24	; 0x18
    3dc0:	20 e0       	ldi	r18, 0x00	; 0
    3dc2:	30 e0       	ldi	r19, 0x00	; 0
    3dc4:	40 e8       	ldi	r20, 0x80	; 128
    3dc6:	5f e3       	ldi	r21, 0x3F	; 63
    3dc8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3dcc:	88 23       	and	r24, r24
    3dce:	2c f4       	brge	.+10     	; 0x3dda <HAL_LCD_u8GoTo+0x312>
		__ticks = 1;
    3dd0:	81 e0       	ldi	r24, 0x01	; 1
    3dd2:	90 e0       	ldi	r25, 0x00	; 0
    3dd4:	9c 8b       	std	Y+20, r25	; 0x14
    3dd6:	8b 8b       	std	Y+19, r24	; 0x13
    3dd8:	3f c0       	rjmp	.+126    	; 0x3e58 <HAL_LCD_u8GoTo+0x390>
	else if (__tmp > 65535)
    3dda:	6d 89       	ldd	r22, Y+21	; 0x15
    3ddc:	7e 89       	ldd	r23, Y+22	; 0x16
    3dde:	8f 89       	ldd	r24, Y+23	; 0x17
    3de0:	98 8d       	ldd	r25, Y+24	; 0x18
    3de2:	20 e0       	ldi	r18, 0x00	; 0
    3de4:	3f ef       	ldi	r19, 0xFF	; 255
    3de6:	4f e7       	ldi	r20, 0x7F	; 127
    3de8:	57 e4       	ldi	r21, 0x47	; 71
    3dea:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3dee:	18 16       	cp	r1, r24
    3df0:	4c f5       	brge	.+82     	; 0x3e44 <HAL_LCD_u8GoTo+0x37c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3df2:	69 8d       	ldd	r22, Y+25	; 0x19
    3df4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3df6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3df8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3dfa:	20 e0       	ldi	r18, 0x00	; 0
    3dfc:	30 e0       	ldi	r19, 0x00	; 0
    3dfe:	40 e2       	ldi	r20, 0x20	; 32
    3e00:	51 e4       	ldi	r21, 0x41	; 65
    3e02:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3e06:	dc 01       	movw	r26, r24
    3e08:	cb 01       	movw	r24, r22
    3e0a:	bc 01       	movw	r22, r24
    3e0c:	cd 01       	movw	r24, r26
    3e0e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e12:	dc 01       	movw	r26, r24
    3e14:	cb 01       	movw	r24, r22
    3e16:	9c 8b       	std	Y+20, r25	; 0x14
    3e18:	8b 8b       	std	Y+19, r24	; 0x13
    3e1a:	0f c0       	rjmp	.+30     	; 0x3e3a <HAL_LCD_u8GoTo+0x372>
    3e1c:	80 e9       	ldi	r24, 0x90	; 144
    3e1e:	91 e0       	ldi	r25, 0x01	; 1
    3e20:	9a 8b       	std	Y+18, r25	; 0x12
    3e22:	89 8b       	std	Y+17, r24	; 0x11
    3e24:	89 89       	ldd	r24, Y+17	; 0x11
    3e26:	9a 89       	ldd	r25, Y+18	; 0x12
    3e28:	01 97       	sbiw	r24, 0x01	; 1
    3e2a:	f1 f7       	brne	.-4      	; 0x3e28 <HAL_LCD_u8GoTo+0x360>
    3e2c:	9a 8b       	std	Y+18, r25	; 0x12
    3e2e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e30:	8b 89       	ldd	r24, Y+19	; 0x13
    3e32:	9c 89       	ldd	r25, Y+20	; 0x14
    3e34:	01 97       	sbiw	r24, 0x01	; 1
    3e36:	9c 8b       	std	Y+20, r25	; 0x14
    3e38:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e3a:	8b 89       	ldd	r24, Y+19	; 0x13
    3e3c:	9c 89       	ldd	r25, Y+20	; 0x14
    3e3e:	00 97       	sbiw	r24, 0x00	; 0
    3e40:	69 f7       	brne	.-38     	; 0x3e1c <HAL_LCD_u8GoTo+0x354>
    3e42:	14 c0       	rjmp	.+40     	; 0x3e6c <HAL_LCD_u8GoTo+0x3a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e44:	6d 89       	ldd	r22, Y+21	; 0x15
    3e46:	7e 89       	ldd	r23, Y+22	; 0x16
    3e48:	8f 89       	ldd	r24, Y+23	; 0x17
    3e4a:	98 8d       	ldd	r25, Y+24	; 0x18
    3e4c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3e50:	dc 01       	movw	r26, r24
    3e52:	cb 01       	movw	r24, r22
    3e54:	9c 8b       	std	Y+20, r25	; 0x14
    3e56:	8b 8b       	std	Y+19, r24	; 0x13
    3e58:	8b 89       	ldd	r24, Y+19	; 0x13
    3e5a:	9c 89       	ldd	r25, Y+20	; 0x14
    3e5c:	98 8b       	std	Y+16, r25	; 0x10
    3e5e:	8f 87       	std	Y+15, r24	; 0x0f
    3e60:	8f 85       	ldd	r24, Y+15	; 0x0f
    3e62:	98 89       	ldd	r25, Y+16	; 0x10
    3e64:	01 97       	sbiw	r24, 0x01	; 1
    3e66:	f1 f7       	brne	.-4      	; 0x3e64 <HAL_LCD_u8GoTo+0x39c>
    3e68:	98 8b       	std	Y+16, r25	; 0x10
    3e6a:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(2);
		HAL_LCD_u8SendCommands(beginning_1stLine);
    3e6c:	80 e8       	ldi	r24, 0x80	; 128
    3e6e:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
    3e72:	7c c0       	rjmp	.+248    	; 0x3f6c <HAL_LCD_u8GoTo+0x4a4>
	} else if (Loc_u8TypeOfShift == Second_Line) {
    3e74:	fe 01       	movw	r30, r28
    3e76:	ef 5b       	subi	r30, 0xBF	; 191
    3e78:	ff 4f       	sbci	r31, 0xFF	; 255
    3e7a:	80 81       	ld	r24, Z
    3e7c:	83 30       	cpi	r24, 0x03	; 3
    3e7e:	09 f0       	breq	.+2      	; 0x3e82 <HAL_LCD_u8GoTo+0x3ba>
    3e80:	75 c0       	rjmp	.+234    	; 0x3f6c <HAL_LCD_u8GoTo+0x4a4>
    3e82:	80 e0       	ldi	r24, 0x00	; 0
    3e84:	90 e0       	ldi	r25, 0x00	; 0
    3e86:	a0 e0       	ldi	r26, 0x00	; 0
    3e88:	b0 e4       	ldi	r27, 0x40	; 64
    3e8a:	8b 87       	std	Y+11, r24	; 0x0b
    3e8c:	9c 87       	std	Y+12, r25	; 0x0c
    3e8e:	ad 87       	std	Y+13, r26	; 0x0d
    3e90:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3e92:	6b 85       	ldd	r22, Y+11	; 0x0b
    3e94:	7c 85       	ldd	r23, Y+12	; 0x0c
    3e96:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e98:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e9a:	20 e0       	ldi	r18, 0x00	; 0
    3e9c:	30 e0       	ldi	r19, 0x00	; 0
    3e9e:	4a e7       	ldi	r20, 0x7A	; 122
    3ea0:	55 e4       	ldi	r21, 0x45	; 69
    3ea2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ea6:	dc 01       	movw	r26, r24
    3ea8:	cb 01       	movw	r24, r22
    3eaa:	8f 83       	std	Y+7, r24	; 0x07
    3eac:	98 87       	std	Y+8, r25	; 0x08
    3eae:	a9 87       	std	Y+9, r26	; 0x09
    3eb0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3eb2:	6f 81       	ldd	r22, Y+7	; 0x07
    3eb4:	78 85       	ldd	r23, Y+8	; 0x08
    3eb6:	89 85       	ldd	r24, Y+9	; 0x09
    3eb8:	9a 85       	ldd	r25, Y+10	; 0x0a
    3eba:	20 e0       	ldi	r18, 0x00	; 0
    3ebc:	30 e0       	ldi	r19, 0x00	; 0
    3ebe:	40 e8       	ldi	r20, 0x80	; 128
    3ec0:	5f e3       	ldi	r21, 0x3F	; 63
    3ec2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3ec6:	88 23       	and	r24, r24
    3ec8:	2c f4       	brge	.+10     	; 0x3ed4 <HAL_LCD_u8GoTo+0x40c>
		__ticks = 1;
    3eca:	81 e0       	ldi	r24, 0x01	; 1
    3ecc:	90 e0       	ldi	r25, 0x00	; 0
    3ece:	9e 83       	std	Y+6, r25	; 0x06
    3ed0:	8d 83       	std	Y+5, r24	; 0x05
    3ed2:	3f c0       	rjmp	.+126    	; 0x3f52 <HAL_LCD_u8GoTo+0x48a>
	else if (__tmp > 65535)
    3ed4:	6f 81       	ldd	r22, Y+7	; 0x07
    3ed6:	78 85       	ldd	r23, Y+8	; 0x08
    3ed8:	89 85       	ldd	r24, Y+9	; 0x09
    3eda:	9a 85       	ldd	r25, Y+10	; 0x0a
    3edc:	20 e0       	ldi	r18, 0x00	; 0
    3ede:	3f ef       	ldi	r19, 0xFF	; 255
    3ee0:	4f e7       	ldi	r20, 0x7F	; 127
    3ee2:	57 e4       	ldi	r21, 0x47	; 71
    3ee4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3ee8:	18 16       	cp	r1, r24
    3eea:	4c f5       	brge	.+82     	; 0x3f3e <HAL_LCD_u8GoTo+0x476>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3eec:	6b 85       	ldd	r22, Y+11	; 0x0b
    3eee:	7c 85       	ldd	r23, Y+12	; 0x0c
    3ef0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ef2:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ef4:	20 e0       	ldi	r18, 0x00	; 0
    3ef6:	30 e0       	ldi	r19, 0x00	; 0
    3ef8:	40 e2       	ldi	r20, 0x20	; 32
    3efa:	51 e4       	ldi	r21, 0x41	; 65
    3efc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f00:	dc 01       	movw	r26, r24
    3f02:	cb 01       	movw	r24, r22
    3f04:	bc 01       	movw	r22, r24
    3f06:	cd 01       	movw	r24, r26
    3f08:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f0c:	dc 01       	movw	r26, r24
    3f0e:	cb 01       	movw	r24, r22
    3f10:	9e 83       	std	Y+6, r25	; 0x06
    3f12:	8d 83       	std	Y+5, r24	; 0x05
    3f14:	0f c0       	rjmp	.+30     	; 0x3f34 <HAL_LCD_u8GoTo+0x46c>
    3f16:	80 e9       	ldi	r24, 0x90	; 144
    3f18:	91 e0       	ldi	r25, 0x01	; 1
    3f1a:	9c 83       	std	Y+4, r25	; 0x04
    3f1c:	8b 83       	std	Y+3, r24	; 0x03
    3f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f20:	9c 81       	ldd	r25, Y+4	; 0x04
    3f22:	01 97       	sbiw	r24, 0x01	; 1
    3f24:	f1 f7       	brne	.-4      	; 0x3f22 <HAL_LCD_u8GoTo+0x45a>
    3f26:	9c 83       	std	Y+4, r25	; 0x04
    3f28:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f2a:	8d 81       	ldd	r24, Y+5	; 0x05
    3f2c:	9e 81       	ldd	r25, Y+6	; 0x06
    3f2e:	01 97       	sbiw	r24, 0x01	; 1
    3f30:	9e 83       	std	Y+6, r25	; 0x06
    3f32:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f34:	8d 81       	ldd	r24, Y+5	; 0x05
    3f36:	9e 81       	ldd	r25, Y+6	; 0x06
    3f38:	00 97       	sbiw	r24, 0x00	; 0
    3f3a:	69 f7       	brne	.-38     	; 0x3f16 <HAL_LCD_u8GoTo+0x44e>
    3f3c:	14 c0       	rjmp	.+40     	; 0x3f66 <HAL_LCD_u8GoTo+0x49e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f3e:	6f 81       	ldd	r22, Y+7	; 0x07
    3f40:	78 85       	ldd	r23, Y+8	; 0x08
    3f42:	89 85       	ldd	r24, Y+9	; 0x09
    3f44:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f46:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f4a:	dc 01       	movw	r26, r24
    3f4c:	cb 01       	movw	r24, r22
    3f4e:	9e 83       	std	Y+6, r25	; 0x06
    3f50:	8d 83       	std	Y+5, r24	; 0x05
    3f52:	8d 81       	ldd	r24, Y+5	; 0x05
    3f54:	9e 81       	ldd	r25, Y+6	; 0x06
    3f56:	9a 83       	std	Y+2, r25	; 0x02
    3f58:	89 83       	std	Y+1, r24	; 0x01
    3f5a:	89 81       	ldd	r24, Y+1	; 0x01
    3f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f5e:	01 97       	sbiw	r24, 0x01	; 1
    3f60:	f1 f7       	brne	.-4      	; 0x3f5e <HAL_LCD_u8GoTo+0x496>
    3f62:	9a 83       	std	Y+2, r25	; 0x02
    3f64:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(2);
		HAL_LCD_u8SendCommands(beginning_2stLine);
    3f66:	80 ec       	ldi	r24, 0xC0	; 192
    3f68:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
	}
}
    3f6c:	ce 5b       	subi	r28, 0xBE	; 190
    3f6e:	df 4f       	sbci	r29, 0xFF	; 255
    3f70:	0f b6       	in	r0, 0x3f	; 63
    3f72:	f8 94       	cli
    3f74:	de bf       	out	0x3e, r29	; 62
    3f76:	0f be       	out	0x3f, r0	; 63
    3f78:	cd bf       	out	0x3d, r28	; 61
    3f7a:	cf 91       	pop	r28
    3f7c:	df 91       	pop	r29
    3f7e:	08 95       	ret

00003f80 <HAL_LCD_u8Clear>:

void HAL_LCD_u8Clear() {
    3f80:	df 93       	push	r29
    3f82:	cf 93       	push	r28
    3f84:	cd b7       	in	r28, 0x3d	; 61
    3f86:	de b7       	in	r29, 0x3e	; 62
    3f88:	2e 97       	sbiw	r28, 0x0e	; 14
    3f8a:	0f b6       	in	r0, 0x3f	; 63
    3f8c:	f8 94       	cli
    3f8e:	de bf       	out	0x3e, r29	; 62
    3f90:	0f be       	out	0x3f, r0	; 63
    3f92:	cd bf       	out	0x3d, r28	; 61
    3f94:	80 e0       	ldi	r24, 0x00	; 0
    3f96:	90 e0       	ldi	r25, 0x00	; 0
    3f98:	a0 e0       	ldi	r26, 0x00	; 0
    3f9a:	b0 e4       	ldi	r27, 0x40	; 64
    3f9c:	8b 87       	std	Y+11, r24	; 0x0b
    3f9e:	9c 87       	std	Y+12, r25	; 0x0c
    3fa0:	ad 87       	std	Y+13, r26	; 0x0d
    3fa2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3fa4:	6b 85       	ldd	r22, Y+11	; 0x0b
    3fa6:	7c 85       	ldd	r23, Y+12	; 0x0c
    3fa8:	8d 85       	ldd	r24, Y+13	; 0x0d
    3faa:	9e 85       	ldd	r25, Y+14	; 0x0e
    3fac:	20 e0       	ldi	r18, 0x00	; 0
    3fae:	30 e0       	ldi	r19, 0x00	; 0
    3fb0:	4a e7       	ldi	r20, 0x7A	; 122
    3fb2:	55 e4       	ldi	r21, 0x45	; 69
    3fb4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3fb8:	dc 01       	movw	r26, r24
    3fba:	cb 01       	movw	r24, r22
    3fbc:	8f 83       	std	Y+7, r24	; 0x07
    3fbe:	98 87       	std	Y+8, r25	; 0x08
    3fc0:	a9 87       	std	Y+9, r26	; 0x09
    3fc2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3fc4:	6f 81       	ldd	r22, Y+7	; 0x07
    3fc6:	78 85       	ldd	r23, Y+8	; 0x08
    3fc8:	89 85       	ldd	r24, Y+9	; 0x09
    3fca:	9a 85       	ldd	r25, Y+10	; 0x0a
    3fcc:	20 e0       	ldi	r18, 0x00	; 0
    3fce:	30 e0       	ldi	r19, 0x00	; 0
    3fd0:	40 e8       	ldi	r20, 0x80	; 128
    3fd2:	5f e3       	ldi	r21, 0x3F	; 63
    3fd4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3fd8:	88 23       	and	r24, r24
    3fda:	2c f4       	brge	.+10     	; 0x3fe6 <HAL_LCD_u8Clear+0x66>
		__ticks = 1;
    3fdc:	81 e0       	ldi	r24, 0x01	; 1
    3fde:	90 e0       	ldi	r25, 0x00	; 0
    3fe0:	9e 83       	std	Y+6, r25	; 0x06
    3fe2:	8d 83       	std	Y+5, r24	; 0x05
    3fe4:	3f c0       	rjmp	.+126    	; 0x4064 <HAL_LCD_u8Clear+0xe4>
	else if (__tmp > 65535)
    3fe6:	6f 81       	ldd	r22, Y+7	; 0x07
    3fe8:	78 85       	ldd	r23, Y+8	; 0x08
    3fea:	89 85       	ldd	r24, Y+9	; 0x09
    3fec:	9a 85       	ldd	r25, Y+10	; 0x0a
    3fee:	20 e0       	ldi	r18, 0x00	; 0
    3ff0:	3f ef       	ldi	r19, 0xFF	; 255
    3ff2:	4f e7       	ldi	r20, 0x7F	; 127
    3ff4:	57 e4       	ldi	r21, 0x47	; 71
    3ff6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3ffa:	18 16       	cp	r1, r24
    3ffc:	4c f5       	brge	.+82     	; 0x4050 <HAL_LCD_u8Clear+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ffe:	6b 85       	ldd	r22, Y+11	; 0x0b
    4000:	7c 85       	ldd	r23, Y+12	; 0x0c
    4002:	8d 85       	ldd	r24, Y+13	; 0x0d
    4004:	9e 85       	ldd	r25, Y+14	; 0x0e
    4006:	20 e0       	ldi	r18, 0x00	; 0
    4008:	30 e0       	ldi	r19, 0x00	; 0
    400a:	40 e2       	ldi	r20, 0x20	; 32
    400c:	51 e4       	ldi	r21, 0x41	; 65
    400e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4012:	dc 01       	movw	r26, r24
    4014:	cb 01       	movw	r24, r22
    4016:	bc 01       	movw	r22, r24
    4018:	cd 01       	movw	r24, r26
    401a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    401e:	dc 01       	movw	r26, r24
    4020:	cb 01       	movw	r24, r22
    4022:	9e 83       	std	Y+6, r25	; 0x06
    4024:	8d 83       	std	Y+5, r24	; 0x05
    4026:	0f c0       	rjmp	.+30     	; 0x4046 <HAL_LCD_u8Clear+0xc6>
    4028:	80 e9       	ldi	r24, 0x90	; 144
    402a:	91 e0       	ldi	r25, 0x01	; 1
    402c:	9c 83       	std	Y+4, r25	; 0x04
    402e:	8b 83       	std	Y+3, r24	; 0x03
    4030:	8b 81       	ldd	r24, Y+3	; 0x03
    4032:	9c 81       	ldd	r25, Y+4	; 0x04
    4034:	01 97       	sbiw	r24, 0x01	; 1
    4036:	f1 f7       	brne	.-4      	; 0x4034 <HAL_LCD_u8Clear+0xb4>
    4038:	9c 83       	std	Y+4, r25	; 0x04
    403a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    403c:	8d 81       	ldd	r24, Y+5	; 0x05
    403e:	9e 81       	ldd	r25, Y+6	; 0x06
    4040:	01 97       	sbiw	r24, 0x01	; 1
    4042:	9e 83       	std	Y+6, r25	; 0x06
    4044:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4046:	8d 81       	ldd	r24, Y+5	; 0x05
    4048:	9e 81       	ldd	r25, Y+6	; 0x06
    404a:	00 97       	sbiw	r24, 0x00	; 0
    404c:	69 f7       	brne	.-38     	; 0x4028 <HAL_LCD_u8Clear+0xa8>
    404e:	14 c0       	rjmp	.+40     	; 0x4078 <HAL_LCD_u8Clear+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4050:	6f 81       	ldd	r22, Y+7	; 0x07
    4052:	78 85       	ldd	r23, Y+8	; 0x08
    4054:	89 85       	ldd	r24, Y+9	; 0x09
    4056:	9a 85       	ldd	r25, Y+10	; 0x0a
    4058:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    405c:	dc 01       	movw	r26, r24
    405e:	cb 01       	movw	r24, r22
    4060:	9e 83       	std	Y+6, r25	; 0x06
    4062:	8d 83       	std	Y+5, r24	; 0x05
    4064:	8d 81       	ldd	r24, Y+5	; 0x05
    4066:	9e 81       	ldd	r25, Y+6	; 0x06
    4068:	9a 83       	std	Y+2, r25	; 0x02
    406a:	89 83       	std	Y+1, r24	; 0x01
    406c:	89 81       	ldd	r24, Y+1	; 0x01
    406e:	9a 81       	ldd	r25, Y+2	; 0x02
    4070:	01 97       	sbiw	r24, 0x01	; 1
    4072:	f1 f7       	brne	.-4      	; 0x4070 <HAL_LCD_u8Clear+0xf0>
    4074:	9a 83       	std	Y+2, r25	; 0x02
    4076:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	HAL_LCD_u8SendCommands(Display_Clear);
    4078:	81 e0       	ldi	r24, 0x01	; 1
    407a:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
}
    407e:	2e 96       	adiw	r28, 0x0e	; 14
    4080:	0f b6       	in	r0, 0x3f	; 63
    4082:	f8 94       	cli
    4084:	de bf       	out	0x3e, r29	; 62
    4086:	0f be       	out	0x3f, r0	; 63
    4088:	cd bf       	out	0x3d, r28	; 61
    408a:	cf 91       	pop	r28
    408c:	df 91       	pop	r29
    408e:	08 95       	ret

00004090 <HAL_LCD_u8CustomChar>:

void HAL_LCD_u8CustomChar(u8 Loc_u8Location, u8* Loc_u8msg) {
    4090:	df 93       	push	r29
    4092:	cf 93       	push	r28
    4094:	00 d0       	rcall	.+0      	; 0x4096 <HAL_LCD_u8CustomChar+0x6>
    4096:	00 d0       	rcall	.+0      	; 0x4098 <HAL_LCD_u8CustomChar+0x8>
    4098:	cd b7       	in	r28, 0x3d	; 61
    409a:	de b7       	in	r29, 0x3e	; 62
    409c:	8a 83       	std	Y+2, r24	; 0x02
    409e:	7c 83       	std	Y+4, r23	; 0x04
    40a0:	6b 83       	std	Y+3, r22	; 0x03
	if (Loc_u8Location < 8) {
    40a2:	8a 81       	ldd	r24, Y+2	; 0x02
    40a4:	88 30       	cpi	r24, 0x08	; 8
    40a6:	f8 f4       	brcc	.+62     	; 0x40e6 <HAL_LCD_u8CustomChar+0x56>
		HAL_LCD_u8SendCommands(0x40 + (Loc_u8Location*8));
    40a8:	8a 81       	ldd	r24, Y+2	; 0x02
    40aa:	88 2f       	mov	r24, r24
    40ac:	90 e0       	ldi	r25, 0x00	; 0
    40ae:	08 96       	adiw	r24, 0x08	; 8
    40b0:	88 0f       	add	r24, r24
    40b2:	99 1f       	adc	r25, r25
    40b4:	88 0f       	add	r24, r24
    40b6:	99 1f       	adc	r25, r25
    40b8:	88 0f       	add	r24, r24
    40ba:	99 1f       	adc	r25, r25
    40bc:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
		for( u8 count = 0; count < 8; count++)
    40c0:	19 82       	std	Y+1, r1	; 0x01
    40c2:	0e c0       	rjmp	.+28     	; 0x40e0 <HAL_LCD_u8CustomChar+0x50>
			HAL_LCD_u8SendChar(Loc_u8msg[count]);
    40c4:	89 81       	ldd	r24, Y+1	; 0x01
    40c6:	28 2f       	mov	r18, r24
    40c8:	30 e0       	ldi	r19, 0x00	; 0
    40ca:	8b 81       	ldd	r24, Y+3	; 0x03
    40cc:	9c 81       	ldd	r25, Y+4	; 0x04
    40ce:	fc 01       	movw	r30, r24
    40d0:	e2 0f       	add	r30, r18
    40d2:	f3 1f       	adc	r31, r19
    40d4:	80 81       	ld	r24, Z
    40d6:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <HAL_LCD_u8SendChar>
}

void HAL_LCD_u8CustomChar(u8 Loc_u8Location, u8* Loc_u8msg) {
	if (Loc_u8Location < 8) {
		HAL_LCD_u8SendCommands(0x40 + (Loc_u8Location*8));
		for( u8 count = 0; count < 8; count++)
    40da:	89 81       	ldd	r24, Y+1	; 0x01
    40dc:	8f 5f       	subi	r24, 0xFF	; 255
    40de:	89 83       	std	Y+1, r24	; 0x01
    40e0:	89 81       	ldd	r24, Y+1	; 0x01
    40e2:	88 30       	cpi	r24, 0x08	; 8
    40e4:	78 f3       	brcs	.-34     	; 0x40c4 <HAL_LCD_u8CustomChar+0x34>
			HAL_LCD_u8SendChar(Loc_u8msg[count]);
	}
	HAL_LCD_u8SendCommands(0x02);
    40e6:	82 e0       	ldi	r24, 0x02	; 2
    40e8:	0e 94 c7 1a 	call	0x358e	; 0x358e <HAL_LCD_u8SendCommands>
}
    40ec:	0f 90       	pop	r0
    40ee:	0f 90       	pop	r0
    40f0:	0f 90       	pop	r0
    40f2:	0f 90       	pop	r0
    40f4:	cf 91       	pop	r28
    40f6:	df 91       	pop	r29
    40f8:	08 95       	ret

000040fa <HAL_KeyPad_u8KeyPadInit>:

u8 array[4][4] = { { '1', '2', '3', 'A' }, { '4', '5', '6', 'B' }, { '7', '8',
		'9', 'C' }, { '*', '0', '#', 'D' } };
u8 KetPadValue = 0;

void HAL_KeyPad_u8KeyPadInit() {
    40fa:	df 93       	push	r29
    40fc:	cf 93       	push	r28
    40fe:	cd b7       	in	r28, 0x3d	; 61
    4100:	de b7       	in	r29, 0x3e	; 62
	MCAL_DIO_u8SetPortDirection(2, 0x0F);
    4102:	82 e0       	ldi	r24, 0x02	; 2
    4104:	6f e0       	ldi	r22, 0x0F	; 15
    4106:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <MCAL_DIO_u8SetPortDirection>
	MCAL_DIO_u8SetPortValue(2, PORT_OUTPUT);
    410a:	82 e0       	ldi	r24, 0x02	; 2
    410c:	6f ef       	ldi	r22, 0xFF	; 255
    410e:	0e 94 de 10 	call	0x21bc	; 0x21bc <MCAL_DIO_u8SetPortValue>
}
    4112:	cf 91       	pop	r28
    4114:	df 91       	pop	r29
    4116:	08 95       	ret

00004118 <HAL_KeyPad_u8GetKeyPressed>:
//		c--;
//		MCAL_DIO_u8SetPinValue(2, col, 1);
//	}
//}

void HAL_KeyPad_u8GetKeyPressed(u8 *Button) {
    4118:	df 93       	push	r29
    411a:	cf 93       	push	r28
    411c:	cd b7       	in	r28, 0x3d	; 61
    411e:	de b7       	in	r29, 0x3e	; 62
    4120:	a2 97       	sbiw	r28, 0x22	; 34
    4122:	0f b6       	in	r0, 0x3f	; 63
    4124:	f8 94       	cli
    4126:	de bf       	out	0x3e, r29	; 62
    4128:	0f be       	out	0x3f, r0	; 63
    412a:	cd bf       	out	0x3d, r28	; 61
    412c:	9a a3       	std	Y+34, r25	; 0x22
    412e:	89 a3       	std	Y+33, r24	; 0x21

	u8 LOC_u8Col, LOC_u8Row, LOC_u8Status = 7, LOC_u8PinValue;
    4130:	87 e0       	ldi	r24, 0x07	; 7
    4132:	8d 8f       	std	Y+29, r24	; 0x1d
	*Button = 0;
    4134:	e9 a1       	ldd	r30, Y+33	; 0x21
    4136:	fa a1       	ldd	r31, Y+34	; 0x22
    4138:	10 82       	st	Z, r1
	for (LOC_u8Row = 0; LOC_u8Row < 4; LOC_u8Row++) {
    413a:	1e 8e       	std	Y+30, r1	; 0x1e
    413c:	2f c1       	rjmp	.+606    	; 0x439c <HAL_KeyPad_u8GetKeyPressed+0x284>
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R0,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R1,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R2,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R3,Pin_HIGH);
		MCAL_DIO_u8SetPinValue(2, LOC_u8Row, 0);
    413e:	82 e0       	ldi	r24, 0x02	; 2
    4140:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4142:	40 e0       	ldi	r20, 0x00	; 0
    4144:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
		for (LOC_u8Col = 0; LOC_u8Col < 4; LOC_u8Col++) {
    4148:	1f 8e       	std	Y+31, r1	; 0x1f
    414a:	1c c1       	rjmp	.+568    	; 0x4384 <HAL_KeyPad_u8GetKeyPressed+0x26c>
			MCAL_DIO_u8GetPinValue(2, (LOC_u8Col + 4), &LOC_u8PinValue);
    414c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    414e:	98 2f       	mov	r25, r24
    4150:	9c 5f       	subi	r25, 0xFC	; 252
    4152:	9e 01       	movw	r18, r28
    4154:	20 5e       	subi	r18, 0xE0	; 224
    4156:	3f 4f       	sbci	r19, 0xFF	; 255
    4158:	82 e0       	ldi	r24, 0x02	; 2
    415a:	69 2f       	mov	r22, r25
    415c:	a9 01       	movw	r20, r18
    415e:	0e 94 8d 12 	call	0x251a	; 0x251a <MCAL_DIO_u8GetPinValue>
			LOC_u8Status = LOC_u8PinValue; //new
    4162:	88 a1       	ldd	r24, Y+32	; 0x20
    4164:	8d 8f       	std	Y+29, r24	; 0x1d
			if (LOC_u8PinValue == 0) {
    4166:	88 a1       	ldd	r24, Y+32	; 0x20
    4168:	88 23       	and	r24, r24
    416a:	09 f0       	breq	.+2      	; 0x416e <HAL_KeyPad_u8GetKeyPressed+0x56>
    416c:	08 c1       	rjmp	.+528    	; 0x437e <HAL_KeyPad_u8GetKeyPressed+0x266>
    416e:	80 e0       	ldi	r24, 0x00	; 0
    4170:	90 e0       	ldi	r25, 0x00	; 0
    4172:	a0 ea       	ldi	r26, 0xA0	; 160
    4174:	b0 e4       	ldi	r27, 0x40	; 64
    4176:	89 8f       	std	Y+25, r24	; 0x19
    4178:	9a 8f       	std	Y+26, r25	; 0x1a
    417a:	ab 8f       	std	Y+27, r26	; 0x1b
    417c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    417e:	69 8d       	ldd	r22, Y+25	; 0x19
    4180:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4182:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4184:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4186:	20 e0       	ldi	r18, 0x00	; 0
    4188:	30 e0       	ldi	r19, 0x00	; 0
    418a:	4a e7       	ldi	r20, 0x7A	; 122
    418c:	55 e4       	ldi	r21, 0x45	; 69
    418e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4192:	dc 01       	movw	r26, r24
    4194:	cb 01       	movw	r24, r22
    4196:	8d 8b       	std	Y+21, r24	; 0x15
    4198:	9e 8b       	std	Y+22, r25	; 0x16
    419a:	af 8b       	std	Y+23, r26	; 0x17
    419c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    419e:	6d 89       	ldd	r22, Y+21	; 0x15
    41a0:	7e 89       	ldd	r23, Y+22	; 0x16
    41a2:	8f 89       	ldd	r24, Y+23	; 0x17
    41a4:	98 8d       	ldd	r25, Y+24	; 0x18
    41a6:	20 e0       	ldi	r18, 0x00	; 0
    41a8:	30 e0       	ldi	r19, 0x00	; 0
    41aa:	40 e8       	ldi	r20, 0x80	; 128
    41ac:	5f e3       	ldi	r21, 0x3F	; 63
    41ae:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    41b2:	88 23       	and	r24, r24
    41b4:	2c f4       	brge	.+10     	; 0x41c0 <HAL_KeyPad_u8GetKeyPressed+0xa8>
		__ticks = 1;
    41b6:	81 e0       	ldi	r24, 0x01	; 1
    41b8:	90 e0       	ldi	r25, 0x00	; 0
    41ba:	9c 8b       	std	Y+20, r25	; 0x14
    41bc:	8b 8b       	std	Y+19, r24	; 0x13
    41be:	3f c0       	rjmp	.+126    	; 0x423e <HAL_KeyPad_u8GetKeyPressed+0x126>
	else if (__tmp > 65535)
    41c0:	6d 89       	ldd	r22, Y+21	; 0x15
    41c2:	7e 89       	ldd	r23, Y+22	; 0x16
    41c4:	8f 89       	ldd	r24, Y+23	; 0x17
    41c6:	98 8d       	ldd	r25, Y+24	; 0x18
    41c8:	20 e0       	ldi	r18, 0x00	; 0
    41ca:	3f ef       	ldi	r19, 0xFF	; 255
    41cc:	4f e7       	ldi	r20, 0x7F	; 127
    41ce:	57 e4       	ldi	r21, 0x47	; 71
    41d0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    41d4:	18 16       	cp	r1, r24
    41d6:	4c f5       	brge	.+82     	; 0x422a <HAL_KeyPad_u8GetKeyPressed+0x112>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41d8:	69 8d       	ldd	r22, Y+25	; 0x19
    41da:	7a 8d       	ldd	r23, Y+26	; 0x1a
    41dc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    41de:	9c 8d       	ldd	r25, Y+28	; 0x1c
    41e0:	20 e0       	ldi	r18, 0x00	; 0
    41e2:	30 e0       	ldi	r19, 0x00	; 0
    41e4:	40 e2       	ldi	r20, 0x20	; 32
    41e6:	51 e4       	ldi	r21, 0x41	; 65
    41e8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    41ec:	dc 01       	movw	r26, r24
    41ee:	cb 01       	movw	r24, r22
    41f0:	bc 01       	movw	r22, r24
    41f2:	cd 01       	movw	r24, r26
    41f4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41f8:	dc 01       	movw	r26, r24
    41fa:	cb 01       	movw	r24, r22
    41fc:	9c 8b       	std	Y+20, r25	; 0x14
    41fe:	8b 8b       	std	Y+19, r24	; 0x13
    4200:	0f c0       	rjmp	.+30     	; 0x4220 <HAL_KeyPad_u8GetKeyPressed+0x108>
    4202:	80 e9       	ldi	r24, 0x90	; 144
    4204:	91 e0       	ldi	r25, 0x01	; 1
    4206:	9a 8b       	std	Y+18, r25	; 0x12
    4208:	89 8b       	std	Y+17, r24	; 0x11
    420a:	89 89       	ldd	r24, Y+17	; 0x11
    420c:	9a 89       	ldd	r25, Y+18	; 0x12
    420e:	01 97       	sbiw	r24, 0x01	; 1
    4210:	f1 f7       	brne	.-4      	; 0x420e <HAL_KeyPad_u8GetKeyPressed+0xf6>
    4212:	9a 8b       	std	Y+18, r25	; 0x12
    4214:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4216:	8b 89       	ldd	r24, Y+19	; 0x13
    4218:	9c 89       	ldd	r25, Y+20	; 0x14
    421a:	01 97       	sbiw	r24, 0x01	; 1
    421c:	9c 8b       	std	Y+20, r25	; 0x14
    421e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4220:	8b 89       	ldd	r24, Y+19	; 0x13
    4222:	9c 89       	ldd	r25, Y+20	; 0x14
    4224:	00 97       	sbiw	r24, 0x00	; 0
    4226:	69 f7       	brne	.-38     	; 0x4202 <HAL_KeyPad_u8GetKeyPressed+0xea>
    4228:	14 c0       	rjmp	.+40     	; 0x4252 <HAL_KeyPad_u8GetKeyPressed+0x13a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    422a:	6d 89       	ldd	r22, Y+21	; 0x15
    422c:	7e 89       	ldd	r23, Y+22	; 0x16
    422e:	8f 89       	ldd	r24, Y+23	; 0x17
    4230:	98 8d       	ldd	r25, Y+24	; 0x18
    4232:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4236:	dc 01       	movw	r26, r24
    4238:	cb 01       	movw	r24, r22
    423a:	9c 8b       	std	Y+20, r25	; 0x14
    423c:	8b 8b       	std	Y+19, r24	; 0x13
    423e:	8b 89       	ldd	r24, Y+19	; 0x13
    4240:	9c 89       	ldd	r25, Y+20	; 0x14
    4242:	98 8b       	std	Y+16, r25	; 0x10
    4244:	8f 87       	std	Y+15, r24	; 0x0f
    4246:	8f 85       	ldd	r24, Y+15	; 0x0f
    4248:	98 89       	ldd	r25, Y+16	; 0x10
    424a:	01 97       	sbiw	r24, 0x01	; 1
    424c:	f1 f7       	brne	.-4      	; 0x424a <HAL_KeyPad_u8GetKeyPressed+0x132>
    424e:	98 8b       	std	Y+16, r25	; 0x10
    4250:	8f 87       	std	Y+15, r24	; 0x0f
				_delay_ms(5); //new
				MCAL_DIO_u8GetPinValue(2, (LOC_u8Col + 4), &LOC_u8PinValue); //new
    4252:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4254:	98 2f       	mov	r25, r24
    4256:	9c 5f       	subi	r25, 0xFC	; 252
    4258:	9e 01       	movw	r18, r28
    425a:	20 5e       	subi	r18, 0xE0	; 224
    425c:	3f 4f       	sbci	r19, 0xFF	; 255
    425e:	82 e0       	ldi	r24, 0x02	; 2
    4260:	69 2f       	mov	r22, r25
    4262:	a9 01       	movw	r20, r18
    4264:	0e 94 8d 12 	call	0x251a	; 0x251a <MCAL_DIO_u8GetPinValue>
				if (LOC_u8PinValue == 1) //new
    4268:	88 a1       	ldd	r24, Y+32	; 0x20
    426a:	81 30       	cpi	r24, 0x01	; 1
    426c:	09 f0       	breq	.+2      	; 0x4270 <HAL_KeyPad_u8GetKeyPressed+0x158>
    426e:	8e c0       	rjmp	.+284    	; 0x438c <HAL_KeyPad_u8GetKeyPressed+0x274>
    4270:	80 e0       	ldi	r24, 0x00	; 0
    4272:	90 e0       	ldi	r25, 0x00	; 0
    4274:	a0 ea       	ldi	r26, 0xA0	; 160
    4276:	b0 e4       	ldi	r27, 0x40	; 64
    4278:	8b 87       	std	Y+11, r24	; 0x0b
    427a:	9c 87       	std	Y+12, r25	; 0x0c
    427c:	ad 87       	std	Y+13, r26	; 0x0d
    427e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4280:	6b 85       	ldd	r22, Y+11	; 0x0b
    4282:	7c 85       	ldd	r23, Y+12	; 0x0c
    4284:	8d 85       	ldd	r24, Y+13	; 0x0d
    4286:	9e 85       	ldd	r25, Y+14	; 0x0e
    4288:	20 e0       	ldi	r18, 0x00	; 0
    428a:	30 e0       	ldi	r19, 0x00	; 0
    428c:	4a e7       	ldi	r20, 0x7A	; 122
    428e:	55 e4       	ldi	r21, 0x45	; 69
    4290:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4294:	dc 01       	movw	r26, r24
    4296:	cb 01       	movw	r24, r22
    4298:	8f 83       	std	Y+7, r24	; 0x07
    429a:	98 87       	std	Y+8, r25	; 0x08
    429c:	a9 87       	std	Y+9, r26	; 0x09
    429e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    42a0:	6f 81       	ldd	r22, Y+7	; 0x07
    42a2:	78 85       	ldd	r23, Y+8	; 0x08
    42a4:	89 85       	ldd	r24, Y+9	; 0x09
    42a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    42a8:	20 e0       	ldi	r18, 0x00	; 0
    42aa:	30 e0       	ldi	r19, 0x00	; 0
    42ac:	40 e8       	ldi	r20, 0x80	; 128
    42ae:	5f e3       	ldi	r21, 0x3F	; 63
    42b0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    42b4:	88 23       	and	r24, r24
    42b6:	2c f4       	brge	.+10     	; 0x42c2 <HAL_KeyPad_u8GetKeyPressed+0x1aa>
		__ticks = 1;
    42b8:	81 e0       	ldi	r24, 0x01	; 1
    42ba:	90 e0       	ldi	r25, 0x00	; 0
    42bc:	9e 83       	std	Y+6, r25	; 0x06
    42be:	8d 83       	std	Y+5, r24	; 0x05
    42c0:	3f c0       	rjmp	.+126    	; 0x4340 <HAL_KeyPad_u8GetKeyPressed+0x228>
	else if (__tmp > 65535)
    42c2:	6f 81       	ldd	r22, Y+7	; 0x07
    42c4:	78 85       	ldd	r23, Y+8	; 0x08
    42c6:	89 85       	ldd	r24, Y+9	; 0x09
    42c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    42ca:	20 e0       	ldi	r18, 0x00	; 0
    42cc:	3f ef       	ldi	r19, 0xFF	; 255
    42ce:	4f e7       	ldi	r20, 0x7F	; 127
    42d0:	57 e4       	ldi	r21, 0x47	; 71
    42d2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    42d6:	18 16       	cp	r1, r24
    42d8:	4c f5       	brge	.+82     	; 0x432c <HAL_KeyPad_u8GetKeyPressed+0x214>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    42da:	6b 85       	ldd	r22, Y+11	; 0x0b
    42dc:	7c 85       	ldd	r23, Y+12	; 0x0c
    42de:	8d 85       	ldd	r24, Y+13	; 0x0d
    42e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    42e2:	20 e0       	ldi	r18, 0x00	; 0
    42e4:	30 e0       	ldi	r19, 0x00	; 0
    42e6:	40 e2       	ldi	r20, 0x20	; 32
    42e8:	51 e4       	ldi	r21, 0x41	; 65
    42ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    42ee:	dc 01       	movw	r26, r24
    42f0:	cb 01       	movw	r24, r22
    42f2:	bc 01       	movw	r22, r24
    42f4:	cd 01       	movw	r24, r26
    42f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42fa:	dc 01       	movw	r26, r24
    42fc:	cb 01       	movw	r24, r22
    42fe:	9e 83       	std	Y+6, r25	; 0x06
    4300:	8d 83       	std	Y+5, r24	; 0x05
    4302:	0f c0       	rjmp	.+30     	; 0x4322 <HAL_KeyPad_u8GetKeyPressed+0x20a>
    4304:	80 e9       	ldi	r24, 0x90	; 144
    4306:	91 e0       	ldi	r25, 0x01	; 1
    4308:	9c 83       	std	Y+4, r25	; 0x04
    430a:	8b 83       	std	Y+3, r24	; 0x03
    430c:	8b 81       	ldd	r24, Y+3	; 0x03
    430e:	9c 81       	ldd	r25, Y+4	; 0x04
    4310:	01 97       	sbiw	r24, 0x01	; 1
    4312:	f1 f7       	brne	.-4      	; 0x4310 <HAL_KeyPad_u8GetKeyPressed+0x1f8>
    4314:	9c 83       	std	Y+4, r25	; 0x04
    4316:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4318:	8d 81       	ldd	r24, Y+5	; 0x05
    431a:	9e 81       	ldd	r25, Y+6	; 0x06
    431c:	01 97       	sbiw	r24, 0x01	; 1
    431e:	9e 83       	std	Y+6, r25	; 0x06
    4320:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4322:	8d 81       	ldd	r24, Y+5	; 0x05
    4324:	9e 81       	ldd	r25, Y+6	; 0x06
    4326:	00 97       	sbiw	r24, 0x00	; 0
    4328:	69 f7       	brne	.-38     	; 0x4304 <HAL_KeyPad_u8GetKeyPressed+0x1ec>
    432a:	14 c0       	rjmp	.+40     	; 0x4354 <HAL_KeyPad_u8GetKeyPressed+0x23c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    432c:	6f 81       	ldd	r22, Y+7	; 0x07
    432e:	78 85       	ldd	r23, Y+8	; 0x08
    4330:	89 85       	ldd	r24, Y+9	; 0x09
    4332:	9a 85       	ldd	r25, Y+10	; 0x0a
    4334:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4338:	dc 01       	movw	r26, r24
    433a:	cb 01       	movw	r24, r22
    433c:	9e 83       	std	Y+6, r25	; 0x06
    433e:	8d 83       	std	Y+5, r24	; 0x05
    4340:	8d 81       	ldd	r24, Y+5	; 0x05
    4342:	9e 81       	ldd	r25, Y+6	; 0x06
    4344:	9a 83       	std	Y+2, r25	; 0x02
    4346:	89 83       	std	Y+1, r24	; 0x01
    4348:	89 81       	ldd	r24, Y+1	; 0x01
    434a:	9a 81       	ldd	r25, Y+2	; 0x02
    434c:	01 97       	sbiw	r24, 0x01	; 1
    434e:	f1 f7       	brne	.-4      	; 0x434c <HAL_KeyPad_u8GetKeyPressed+0x234>
    4350:	9a 83       	std	Y+2, r25	; 0x02
    4352:	89 83       	std	Y+1, r24	; 0x01
						{
					_delay_ms(5);
					*Button = array[LOC_u8Row][LOC_u8Col];
    4354:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4356:	48 2f       	mov	r20, r24
    4358:	50 e0       	ldi	r21, 0x00	; 0
    435a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    435c:	28 2f       	mov	r18, r24
    435e:	30 e0       	ldi	r19, 0x00	; 0
    4360:	ca 01       	movw	r24, r20
    4362:	88 0f       	add	r24, r24
    4364:	99 1f       	adc	r25, r25
    4366:	88 0f       	add	r24, r24
    4368:	99 1f       	adc	r25, r25
    436a:	82 0f       	add	r24, r18
    436c:	93 1f       	adc	r25, r19
    436e:	fc 01       	movw	r30, r24
    4370:	e2 59       	subi	r30, 0x92	; 146
    4372:	fe 4f       	sbci	r31, 0xFE	; 254
    4374:	80 81       	ld	r24, Z
    4376:	e9 a1       	ldd	r30, Y+33	; 0x21
    4378:	fa a1       	ldd	r31, Y+34	; 0x22
    437a:	80 83       	st	Z, r24
    437c:	07 c0       	rjmp	.+14     	; 0x438c <HAL_KeyPad_u8GetKeyPressed+0x274>
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R0,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R1,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R2,Pin_HIGH);
		//  LOC_u8Return_Value = MCAL_DIO_u8SetPinValue(KeyPad_Port,R3,Pin_HIGH);
		MCAL_DIO_u8SetPinValue(2, LOC_u8Row, 0);
		for (LOC_u8Col = 0; LOC_u8Col < 4; LOC_u8Col++) {
    437e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4380:	8f 5f       	subi	r24, 0xFF	; 255
    4382:	8f 8f       	std	Y+31, r24	; 0x1f
    4384:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4386:	84 30       	cpi	r24, 0x04	; 4
    4388:	08 f4       	brcc	.+2      	; 0x438c <HAL_KeyPad_u8GetKeyPressed+0x274>
    438a:	e0 ce       	rjmp	.-576    	; 0x414c <HAL_KeyPad_u8GetKeyPressed+0x34>
					*Button = array[LOC_u8Row][LOC_u8Col];
				}
				break;
			}
		}
		MCAL_DIO_u8SetPinValue(2, LOC_u8Row, 1);
    438c:	82 e0       	ldi	r24, 0x02	; 2
    438e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4390:	41 e0       	ldi	r20, 0x01	; 1
    4392:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>

void HAL_KeyPad_u8GetKeyPressed(u8 *Button) {

	u8 LOC_u8Col, LOC_u8Row, LOC_u8Status = 7, LOC_u8PinValue;
	*Button = 0;
	for (LOC_u8Row = 0; LOC_u8Row < 4; LOC_u8Row++) {
    4396:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4398:	8f 5f       	subi	r24, 0xFF	; 255
    439a:	8e 8f       	std	Y+30, r24	; 0x1e
    439c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    439e:	84 30       	cpi	r24, 0x04	; 4
    43a0:	08 f4       	brcc	.+2      	; 0x43a4 <HAL_KeyPad_u8GetKeyPressed+0x28c>
    43a2:	cd ce       	rjmp	.-614    	; 0x413e <HAL_KeyPad_u8GetKeyPressed+0x26>
		 {
		 break;
		 }
		 */
	}
}
    43a4:	a2 96       	adiw	r28, 0x22	; 34
    43a6:	0f b6       	in	r0, 0x3f	; 63
    43a8:	f8 94       	cli
    43aa:	de bf       	out	0x3e, r29	; 62
    43ac:	0f be       	out	0x3f, r0	; 63
    43ae:	cd bf       	out	0x3d, r28	; 61
    43b0:	cf 91       	pop	r28
    43b2:	df 91       	pop	r29
    43b4:	08 95       	ret

000043b6 <HAL_Buzzer_u8BuzzerInit>:
 *      Author: Mohamed
 */

#include "Buzzer.h"

STD_Type HAL_Buzzer_u8BuzzerInit(u8 Loc_u8BuzzerPortID, u8 Loc_u8BuzzerPinID) {
    43b6:	df 93       	push	r29
    43b8:	cf 93       	push	r28
    43ba:	00 d0       	rcall	.+0      	; 0x43bc <HAL_Buzzer_u8BuzzerInit+0x6>
    43bc:	0f 92       	push	r0
    43be:	cd b7       	in	r28, 0x3d	; 61
    43c0:	de b7       	in	r29, 0x3e	; 62
    43c2:	8a 83       	std	Y+2, r24	; 0x02
    43c4:	6b 83       	std	Y+3, r22	; 0x03
	u8 Loc_u8Return_Value = E_NOT_OK;
    43c6:	81 e0       	ldi	r24, 0x01	; 1
    43c8:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8BuzzerPortID <= PortD && Loc_u8BuzzerPinID <= Num_Of_Pins) {
    43ca:	8a 81       	ldd	r24, Y+2	; 0x02
    43cc:	84 30       	cpi	r24, 0x04	; 4
    43ce:	48 f4       	brcc	.+18     	; 0x43e2 <HAL_Buzzer_u8BuzzerInit+0x2c>
    43d0:	8b 81       	ldd	r24, Y+3	; 0x03
    43d2:	88 30       	cpi	r24, 0x08	; 8
    43d4:	30 f4       	brcc	.+12     	; 0x43e2 <HAL_Buzzer_u8BuzzerInit+0x2c>
		Loc_u8Return_Value=Loc_u8Return_Value = MCAL_DIO_u8SetPinDirection(Loc_u8BuzzerPortID,
    43d6:	8a 81       	ldd	r24, Y+2	; 0x02
    43d8:	6b 81       	ldd	r22, Y+3	; 0x03
    43da:	41 e0       	ldi	r20, 0x01	; 1
    43dc:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <MCAL_DIO_u8SetPinDirection>
    43e0:	89 83       	std	Y+1, r24	; 0x01
				Loc_u8BuzzerPinID, Pin_High);
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    43e2:	89 81       	ldd	r24, Y+1	; 0x01
}
    43e4:	0f 90       	pop	r0
    43e6:	0f 90       	pop	r0
    43e8:	0f 90       	pop	r0
    43ea:	cf 91       	pop	r28
    43ec:	df 91       	pop	r29
    43ee:	08 95       	ret

000043f0 <HAL_Buzzer_u8BuzzerMode>:

STD_Type HAL_Buzzer_u8BuzzerMode(u8 Loc_u8BuzzerPortID, u8 Loc_u8BuzzerPinID,
		u8 Loc_u8BuzzerMode) {
    43f0:	df 93       	push	r29
    43f2:	cf 93       	push	r28
    43f4:	00 d0       	rcall	.+0      	; 0x43f6 <HAL_Buzzer_u8BuzzerMode+0x6>
    43f6:	00 d0       	rcall	.+0      	; 0x43f8 <HAL_Buzzer_u8BuzzerMode+0x8>
    43f8:	cd b7       	in	r28, 0x3d	; 61
    43fa:	de b7       	in	r29, 0x3e	; 62
    43fc:	8a 83       	std	Y+2, r24	; 0x02
    43fe:	6b 83       	std	Y+3, r22	; 0x03
    4400:	4c 83       	std	Y+4, r20	; 0x04
	u8 Loc_u8Return_Value = E_NOT_OK;
    4402:	81 e0       	ldi	r24, 0x01	; 1
    4404:	89 83       	std	Y+1, r24	; 0x01
	if (Loc_u8BuzzerPortID <= PortD && Loc_u8BuzzerPinID <= Num_Of_Pins
    4406:	8a 81       	ldd	r24, Y+2	; 0x02
    4408:	84 30       	cpi	r24, 0x04	; 4
    440a:	10 f5       	brcc	.+68     	; 0x4450 <HAL_Buzzer_u8BuzzerMode+0x60>
    440c:	8b 81       	ldd	r24, Y+3	; 0x03
    440e:	88 30       	cpi	r24, 0x08	; 8
    4410:	f8 f4       	brcc	.+62     	; 0x4450 <HAL_Buzzer_u8BuzzerMode+0x60>
    4412:	8c 81       	ldd	r24, Y+4	; 0x04
    4414:	83 30       	cpi	r24, 0x03	; 3
    4416:	e0 f4       	brcc	.+56     	; 0x4450 <HAL_Buzzer_u8BuzzerMode+0x60>
			&& Loc_u8BuzzerMode <= Buzzer_TOG) {
		if (Loc_u8BuzzerMode == Buzzer_ON) {
    4418:	8c 81       	ldd	r24, Y+4	; 0x04
    441a:	81 30       	cpi	r24, 0x01	; 1
    441c:	39 f4       	brne	.+14     	; 0x442c <HAL_Buzzer_u8BuzzerMode+0x3c>
			Loc_u8Return_Value=MCAL_DIO_u8SetPinValue(Loc_u8BuzzerPortID, Loc_u8BuzzerPinID, Pin_High);
    441e:	8a 81       	ldd	r24, Y+2	; 0x02
    4420:	6b 81       	ldd	r22, Y+3	; 0x03
    4422:	41 e0       	ldi	r20, 0x01	; 1
    4424:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    4428:	89 83       	std	Y+1, r24	; 0x01
    442a:	12 c0       	rjmp	.+36     	; 0x4450 <HAL_Buzzer_u8BuzzerMode+0x60>
		} else if (Loc_u8BuzzerMode == Buzzer_OFF) {
    442c:	8c 81       	ldd	r24, Y+4	; 0x04
    442e:	88 23       	and	r24, r24
    4430:	39 f4       	brne	.+14     	; 0x4440 <HAL_Buzzer_u8BuzzerMode+0x50>
			Loc_u8Return_Value=MCAL_DIO_u8SetPinValue(Loc_u8BuzzerPortID, Loc_u8BuzzerPinID, Pin_Low);
    4432:	8a 81       	ldd	r24, Y+2	; 0x02
    4434:	6b 81       	ldd	r22, Y+3	; 0x03
    4436:	40 e0       	ldi	r20, 0x00	; 0
    4438:	0e 94 61 11 	call	0x22c2	; 0x22c2 <MCAL_DIO_u8SetPinValue>
    443c:	89 83       	std	Y+1, r24	; 0x01
    443e:	08 c0       	rjmp	.+16     	; 0x4450 <HAL_Buzzer_u8BuzzerMode+0x60>
		} else if (Loc_u8BuzzerMode == Buzzer_TOG) {
    4440:	8c 81       	ldd	r24, Y+4	; 0x04
    4442:	82 30       	cpi	r24, 0x02	; 2
    4444:	29 f4       	brne	.+10     	; 0x4450 <HAL_Buzzer_u8BuzzerMode+0x60>
			Loc_u8Return_Value=MCAL_DIO_u8TogglePinValue(Loc_u8BuzzerPortID,Loc_u8BuzzerPinID);
    4446:	8a 81       	ldd	r24, Y+2	; 0x02
    4448:	6b 81       	ldd	r22, Y+3	; 0x03
    444a:	0e 94 4a 13 	call	0x2694	; 0x2694 <MCAL_DIO_u8TogglePinValue>
    444e:	89 83       	std	Y+1, r24	; 0x01
			//Do Nothing
		}
	} else {
		//Do Nothing
	}
	return Loc_u8Return_Value;
    4450:	89 81       	ldd	r24, Y+1	; 0x01
}
    4452:	0f 90       	pop	r0
    4454:	0f 90       	pop	r0
    4456:	0f 90       	pop	r0
    4458:	0f 90       	pop	r0
    445a:	cf 91       	pop	r28
    445c:	df 91       	pop	r29
    445e:	08 95       	ret

00004460 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    4460:	df 93       	push	r29
    4462:	cf 93       	push	r28
    4464:	cd b7       	in	r28, 0x3d	; 61
    4466:	de b7       	in	r29, 0x3e	; 62
    4468:	2e 97       	sbiw	r28, 0x0e	; 14
    446a:	0f b6       	in	r0, 0x3f	; 63
    446c:	f8 94       	cli
    446e:	de bf       	out	0x3e, r29	; 62
    4470:	0f be       	out	0x3f, r0	; 63
    4472:	cd bf       	out	0x3d, r28	; 61
    4474:	9e 87       	std	Y+14, r25	; 0x0e
    4476:	8d 87       	std	Y+13, r24	; 0x0d
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    4478:	1e 82       	std	Y+6, r1	; 0x06
    447a:	1d 82       	std	Y+5, r1	; 0x05

	vTaskSuspendAll();
    447c:	0e 94 3c 33 	call	0x6678	; 0x6678 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    4480:	80 91 9d 01 	lds	r24, 0x019D
    4484:	88 23       	and	r24, r24
    4486:	29 f4       	brne	.+10     	; 0x4492 <pvPortMalloc+0x32>
		{
			prvHeapInit();
    4488:	0e 94 97 23 	call	0x472e	; 0x472e <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
    448c:	81 e0       	ldi	r24, 0x01	; 1
    448e:	80 93 9d 01 	sts	0x019D, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    4492:	8d 85       	ldd	r24, Y+13	; 0x0d
    4494:	9e 85       	ldd	r25, Y+14	; 0x0e
    4496:	00 97       	sbiw	r24, 0x00	; 0
    4498:	51 f0       	breq	.+20     	; 0x44ae <pvPortMalloc+0x4e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    449a:	80 91 80 01 	lds	r24, 0x0180
    449e:	90 91 81 01 	lds	r25, 0x0181
    44a2:	2d 85       	ldd	r18, Y+13	; 0x0d
    44a4:	3e 85       	ldd	r19, Y+14	; 0x0e
    44a6:	82 0f       	add	r24, r18
    44a8:	93 1f       	adc	r25, r19
    44aa:	9e 87       	std	Y+14, r25	; 0x0e
    44ac:	8d 87       	std	Y+13, r24	; 0x0d
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    44ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    44b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    44b2:	00 97       	sbiw	r24, 0x00	; 0
    44b4:	09 f4       	brne	.+2      	; 0x44b8 <pvPortMalloc+0x58>
    44b6:	af c0       	rjmp	.+350    	; 0x4616 <pvPortMalloc+0x1b6>
    44b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    44ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    44bc:	23 e0       	ldi	r18, 0x03	; 3
    44be:	87 3e       	cpi	r24, 0xE7	; 231
    44c0:	92 07       	cpc	r25, r18
    44c2:	08 f0       	brcs	.+2      	; 0x44c6 <pvPortMalloc+0x66>
    44c4:	a8 c0       	rjmp	.+336    	; 0x4616 <pvPortMalloc+0x1b6>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    44c6:	86 e8       	ldi	r24, 0x86	; 134
    44c8:	95 e0       	ldi	r25, 0x05	; 5
    44ca:	9a 87       	std	Y+10, r25	; 0x0a
    44cc:	89 87       	std	Y+9, r24	; 0x09
			pxBlock = xStart.pxNextFreeBlock;
    44ce:	80 91 86 05 	lds	r24, 0x0586
    44d2:	90 91 87 05 	lds	r25, 0x0587
    44d6:	9c 87       	std	Y+12, r25	; 0x0c
    44d8:	8b 87       	std	Y+11, r24	; 0x0b
    44da:	0a c0       	rjmp	.+20     	; 0x44f0 <pvPortMalloc+0x90>
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
			{
				pxPreviousBlock = pxBlock;
    44dc:	8b 85       	ldd	r24, Y+11	; 0x0b
    44de:	9c 85       	ldd	r25, Y+12	; 0x0c
    44e0:	9a 87       	std	Y+10, r25	; 0x0a
    44e2:	89 87       	std	Y+9, r24	; 0x09
				pxBlock = pxBlock->pxNextFreeBlock;
    44e4:	eb 85       	ldd	r30, Y+11	; 0x0b
    44e6:	fc 85       	ldd	r31, Y+12	; 0x0c
    44e8:	80 81       	ld	r24, Z
    44ea:	91 81       	ldd	r25, Z+1	; 0x01
    44ec:	9c 87       	std	Y+12, r25	; 0x0c
    44ee:	8b 87       	std	Y+11, r24	; 0x0b
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    44f0:	eb 85       	ldd	r30, Y+11	; 0x0b
    44f2:	fc 85       	ldd	r31, Y+12	; 0x0c
    44f4:	22 81       	ldd	r18, Z+2	; 0x02
    44f6:	33 81       	ldd	r19, Z+3	; 0x03
    44f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    44fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    44fc:	28 17       	cp	r18, r24
    44fe:	39 07       	cpc	r19, r25
    4500:	30 f4       	brcc	.+12     	; 0x450e <pvPortMalloc+0xae>
    4502:	eb 85       	ldd	r30, Y+11	; 0x0b
    4504:	fc 85       	ldd	r31, Y+12	; 0x0c
    4506:	80 81       	ld	r24, Z
    4508:	91 81       	ldd	r25, Z+1	; 0x01
    450a:	00 97       	sbiw	r24, 0x00	; 0
    450c:	39 f7       	brne	.-50     	; 0x44dc <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    450e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4510:	9c 85       	ldd	r25, Y+12	; 0x0c
    4512:	45 e0       	ldi	r20, 0x05	; 5
    4514:	8a 38       	cpi	r24, 0x8A	; 138
    4516:	94 07       	cpc	r25, r20
    4518:	09 f4       	brne	.+2      	; 0x451c <pvPortMalloc+0xbc>
    451a:	7d c0       	rjmp	.+250    	; 0x4616 <pvPortMalloc+0x1b6>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    451c:	e9 85       	ldd	r30, Y+9	; 0x09
    451e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4520:	20 81       	ld	r18, Z
    4522:	31 81       	ldd	r19, Z+1	; 0x01
    4524:	80 91 80 01 	lds	r24, 0x0180
    4528:	90 91 81 01 	lds	r25, 0x0181
    452c:	82 0f       	add	r24, r18
    452e:	93 1f       	adc	r25, r19
    4530:	9e 83       	std	Y+6, r25	; 0x06
    4532:	8d 83       	std	Y+5, r24	; 0x05

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    4534:	eb 85       	ldd	r30, Y+11	; 0x0b
    4536:	fc 85       	ldd	r31, Y+12	; 0x0c
    4538:	80 81       	ld	r24, Z
    453a:	91 81       	ldd	r25, Z+1	; 0x01
    453c:	e9 85       	ldd	r30, Y+9	; 0x09
    453e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4540:	91 83       	std	Z+1, r25	; 0x01
    4542:	80 83       	st	Z, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    4544:	eb 85       	ldd	r30, Y+11	; 0x0b
    4546:	fc 85       	ldd	r31, Y+12	; 0x0c
    4548:	22 81       	ldd	r18, Z+2	; 0x02
    454a:	33 81       	ldd	r19, Z+3	; 0x03
    454c:	8d 85       	ldd	r24, Y+13	; 0x0d
    454e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4550:	28 1b       	sub	r18, r24
    4552:	39 0b       	sbc	r19, r25
    4554:	80 91 80 01 	lds	r24, 0x0180
    4558:	90 91 81 01 	lds	r25, 0x0181
    455c:	88 0f       	add	r24, r24
    455e:	99 1f       	adc	r25, r25
    4560:	82 17       	cp	r24, r18
    4562:	93 07       	cpc	r25, r19
    4564:	08 f0       	brcs	.+2      	; 0x4568 <pvPortMalloc+0x108>
    4566:	47 c0       	rjmp	.+142    	; 0x45f6 <pvPortMalloc+0x196>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    4568:	2b 85       	ldd	r18, Y+11	; 0x0b
    456a:	3c 85       	ldd	r19, Y+12	; 0x0c
    456c:	8d 85       	ldd	r24, Y+13	; 0x0d
    456e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4570:	82 0f       	add	r24, r18
    4572:	93 1f       	adc	r25, r19
    4574:	98 87       	std	Y+8, r25	; 0x08
    4576:	8f 83       	std	Y+7, r24	; 0x07

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    4578:	eb 85       	ldd	r30, Y+11	; 0x0b
    457a:	fc 85       	ldd	r31, Y+12	; 0x0c
    457c:	22 81       	ldd	r18, Z+2	; 0x02
    457e:	33 81       	ldd	r19, Z+3	; 0x03
    4580:	8d 85       	ldd	r24, Y+13	; 0x0d
    4582:	9e 85       	ldd	r25, Y+14	; 0x0e
    4584:	a9 01       	movw	r20, r18
    4586:	48 1b       	sub	r20, r24
    4588:	59 0b       	sbc	r21, r25
    458a:	ca 01       	movw	r24, r20
    458c:	ef 81       	ldd	r30, Y+7	; 0x07
    458e:	f8 85       	ldd	r31, Y+8	; 0x08
    4590:	93 83       	std	Z+3, r25	; 0x03
    4592:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->xBlockSize = xWantedSize;
    4594:	eb 85       	ldd	r30, Y+11	; 0x0b
    4596:	fc 85       	ldd	r31, Y+12	; 0x0c
    4598:	8d 85       	ldd	r24, Y+13	; 0x0d
    459a:	9e 85       	ldd	r25, Y+14	; 0x0e
    459c:	93 83       	std	Z+3, r25	; 0x03
    459e:	82 83       	std	Z+2, r24	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    45a0:	ef 81       	ldd	r30, Y+7	; 0x07
    45a2:	f8 85       	ldd	r31, Y+8	; 0x08
    45a4:	82 81       	ldd	r24, Z+2	; 0x02
    45a6:	93 81       	ldd	r25, Z+3	; 0x03
    45a8:	9a 83       	std	Y+2, r25	; 0x02
    45aa:	89 83       	std	Y+1, r24	; 0x01
    45ac:	86 e8       	ldi	r24, 0x86	; 134
    45ae:	95 e0       	ldi	r25, 0x05	; 5
    45b0:	9c 83       	std	Y+4, r25	; 0x04
    45b2:	8b 83       	std	Y+3, r24	; 0x03
    45b4:	06 c0       	rjmp	.+12     	; 0x45c2 <pvPortMalloc+0x162>
    45b6:	eb 81       	ldd	r30, Y+3	; 0x03
    45b8:	fc 81       	ldd	r31, Y+4	; 0x04
    45ba:	80 81       	ld	r24, Z
    45bc:	91 81       	ldd	r25, Z+1	; 0x01
    45be:	9c 83       	std	Y+4, r25	; 0x04
    45c0:	8b 83       	std	Y+3, r24	; 0x03
    45c2:	eb 81       	ldd	r30, Y+3	; 0x03
    45c4:	fc 81       	ldd	r31, Y+4	; 0x04
    45c6:	01 90       	ld	r0, Z+
    45c8:	f0 81       	ld	r31, Z
    45ca:	e0 2d       	mov	r30, r0
    45cc:	22 81       	ldd	r18, Z+2	; 0x02
    45ce:	33 81       	ldd	r19, Z+3	; 0x03
    45d0:	89 81       	ldd	r24, Y+1	; 0x01
    45d2:	9a 81       	ldd	r25, Y+2	; 0x02
    45d4:	28 17       	cp	r18, r24
    45d6:	39 07       	cpc	r19, r25
    45d8:	70 f3       	brcs	.-36     	; 0x45b6 <pvPortMalloc+0x156>
    45da:	eb 81       	ldd	r30, Y+3	; 0x03
    45dc:	fc 81       	ldd	r31, Y+4	; 0x04
    45de:	80 81       	ld	r24, Z
    45e0:	91 81       	ldd	r25, Z+1	; 0x01
    45e2:	ef 81       	ldd	r30, Y+7	; 0x07
    45e4:	f8 85       	ldd	r31, Y+8	; 0x08
    45e6:	91 83       	std	Z+1, r25	; 0x01
    45e8:	80 83       	st	Z, r24
    45ea:	eb 81       	ldd	r30, Y+3	; 0x03
    45ec:	fc 81       	ldd	r31, Y+4	; 0x04
    45ee:	8f 81       	ldd	r24, Y+7	; 0x07
    45f0:	98 85       	ldd	r25, Y+8	; 0x08
    45f2:	91 83       	std	Z+1, r25	; 0x01
    45f4:	80 83       	st	Z, r24
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    45f6:	20 91 7e 01 	lds	r18, 0x017E
    45fa:	30 91 7f 01 	lds	r19, 0x017F
    45fe:	eb 85       	ldd	r30, Y+11	; 0x0b
    4600:	fc 85       	ldd	r31, Y+12	; 0x0c
    4602:	82 81       	ldd	r24, Z+2	; 0x02
    4604:	93 81       	ldd	r25, Z+3	; 0x03
    4606:	a9 01       	movw	r20, r18
    4608:	48 1b       	sub	r20, r24
    460a:	59 0b       	sbc	r21, r25
    460c:	ca 01       	movw	r24, r20
    460e:	90 93 7f 01 	sts	0x017F, r25
    4612:	80 93 7e 01 	sts	0x017E, r24
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    4616:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    461a:	8d 81       	ldd	r24, Y+5	; 0x05
    461c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    461e:	2e 96       	adiw	r28, 0x0e	; 14
    4620:	0f b6       	in	r0, 0x3f	; 63
    4622:	f8 94       	cli
    4624:	de bf       	out	0x3e, r29	; 62
    4626:	0f be       	out	0x3f, r0	; 63
    4628:	cd bf       	out	0x3d, r28	; 61
    462a:	cf 91       	pop	r28
    462c:	df 91       	pop	r29
    462e:	08 95       	ret

00004630 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    4630:	df 93       	push	r29
    4632:	cf 93       	push	r28
    4634:	cd b7       	in	r28, 0x3d	; 61
    4636:	de b7       	in	r29, 0x3e	; 62
    4638:	2a 97       	sbiw	r28, 0x0a	; 10
    463a:	0f b6       	in	r0, 0x3f	; 63
    463c:	f8 94       	cli
    463e:	de bf       	out	0x3e, r29	; 62
    4640:	0f be       	out	0x3f, r0	; 63
    4642:	cd bf       	out	0x3d, r28	; 61
    4644:	9a 87       	std	Y+10, r25	; 0x0a
    4646:	89 87       	std	Y+9, r24	; 0x09
uint8_t *puc = ( uint8_t * ) pv;
    4648:	89 85       	ldd	r24, Y+9	; 0x09
    464a:	9a 85       	ldd	r25, Y+10	; 0x0a
    464c:	98 87       	std	Y+8, r25	; 0x08
    464e:	8f 83       	std	Y+7, r24	; 0x07
BlockLink_t *pxLink;

	if( pv != NULL )
    4650:	89 85       	ldd	r24, Y+9	; 0x09
    4652:	9a 85       	ldd	r25, Y+10	; 0x0a
    4654:	00 97       	sbiw	r24, 0x00	; 0
    4656:	09 f4       	brne	.+2      	; 0x465a <vPortFree+0x2a>
    4658:	4f c0       	rjmp	.+158    	; 0x46f8 <vPortFree+0xc8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    465a:	80 91 80 01 	lds	r24, 0x0180
    465e:	90 91 81 01 	lds	r25, 0x0181
    4662:	22 27       	eor	r18, r18
    4664:	33 27       	eor	r19, r19
    4666:	28 1b       	sub	r18, r24
    4668:	39 0b       	sbc	r19, r25
    466a:	8f 81       	ldd	r24, Y+7	; 0x07
    466c:	98 85       	ldd	r25, Y+8	; 0x08
    466e:	82 0f       	add	r24, r18
    4670:	93 1f       	adc	r25, r19
    4672:	98 87       	std	Y+8, r25	; 0x08
    4674:	8f 83       	std	Y+7, r24	; 0x07

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
    4676:	8f 81       	ldd	r24, Y+7	; 0x07
    4678:	98 85       	ldd	r25, Y+8	; 0x08
    467a:	9e 83       	std	Y+6, r25	; 0x06
    467c:	8d 83       	std	Y+5, r24	; 0x05

		vTaskSuspendAll();
    467e:	0e 94 3c 33 	call	0x6678	; 0x6678 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    4682:	ed 81       	ldd	r30, Y+5	; 0x05
    4684:	fe 81       	ldd	r31, Y+6	; 0x06
    4686:	82 81       	ldd	r24, Z+2	; 0x02
    4688:	93 81       	ldd	r25, Z+3	; 0x03
    468a:	9a 83       	std	Y+2, r25	; 0x02
    468c:	89 83       	std	Y+1, r24	; 0x01
    468e:	86 e8       	ldi	r24, 0x86	; 134
    4690:	95 e0       	ldi	r25, 0x05	; 5
    4692:	9c 83       	std	Y+4, r25	; 0x04
    4694:	8b 83       	std	Y+3, r24	; 0x03
    4696:	06 c0       	rjmp	.+12     	; 0x46a4 <vPortFree+0x74>
    4698:	eb 81       	ldd	r30, Y+3	; 0x03
    469a:	fc 81       	ldd	r31, Y+4	; 0x04
    469c:	80 81       	ld	r24, Z
    469e:	91 81       	ldd	r25, Z+1	; 0x01
    46a0:	9c 83       	std	Y+4, r25	; 0x04
    46a2:	8b 83       	std	Y+3, r24	; 0x03
    46a4:	eb 81       	ldd	r30, Y+3	; 0x03
    46a6:	fc 81       	ldd	r31, Y+4	; 0x04
    46a8:	01 90       	ld	r0, Z+
    46aa:	f0 81       	ld	r31, Z
    46ac:	e0 2d       	mov	r30, r0
    46ae:	22 81       	ldd	r18, Z+2	; 0x02
    46b0:	33 81       	ldd	r19, Z+3	; 0x03
    46b2:	89 81       	ldd	r24, Y+1	; 0x01
    46b4:	9a 81       	ldd	r25, Y+2	; 0x02
    46b6:	28 17       	cp	r18, r24
    46b8:	39 07       	cpc	r19, r25
    46ba:	70 f3       	brcs	.-36     	; 0x4698 <vPortFree+0x68>
    46bc:	eb 81       	ldd	r30, Y+3	; 0x03
    46be:	fc 81       	ldd	r31, Y+4	; 0x04
    46c0:	80 81       	ld	r24, Z
    46c2:	91 81       	ldd	r25, Z+1	; 0x01
    46c4:	ed 81       	ldd	r30, Y+5	; 0x05
    46c6:	fe 81       	ldd	r31, Y+6	; 0x06
    46c8:	91 83       	std	Z+1, r25	; 0x01
    46ca:	80 83       	st	Z, r24
    46cc:	eb 81       	ldd	r30, Y+3	; 0x03
    46ce:	fc 81       	ldd	r31, Y+4	; 0x04
    46d0:	8d 81       	ldd	r24, Y+5	; 0x05
    46d2:	9e 81       	ldd	r25, Y+6	; 0x06
    46d4:	91 83       	std	Z+1, r25	; 0x01
    46d6:	80 83       	st	Z, r24
			xFreeBytesRemaining += pxLink->xBlockSize;
    46d8:	ed 81       	ldd	r30, Y+5	; 0x05
    46da:	fe 81       	ldd	r31, Y+6	; 0x06
    46dc:	22 81       	ldd	r18, Z+2	; 0x02
    46de:	33 81       	ldd	r19, Z+3	; 0x03
    46e0:	80 91 7e 01 	lds	r24, 0x017E
    46e4:	90 91 7f 01 	lds	r25, 0x017F
    46e8:	82 0f       	add	r24, r18
    46ea:	93 1f       	adc	r25, r19
    46ec:	90 93 7f 01 	sts	0x017F, r25
    46f0:	80 93 7e 01 	sts	0x017E, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    46f4:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>
	}
}
    46f8:	2a 96       	adiw	r28, 0x0a	; 10
    46fa:	0f b6       	in	r0, 0x3f	; 63
    46fc:	f8 94       	cli
    46fe:	de bf       	out	0x3e, r29	; 62
    4700:	0f be       	out	0x3f, r0	; 63
    4702:	cd bf       	out	0x3d, r28	; 61
    4704:	cf 91       	pop	r28
    4706:	df 91       	pop	r29
    4708:	08 95       	ret

0000470a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    470a:	df 93       	push	r29
    470c:	cf 93       	push	r28
    470e:	cd b7       	in	r28, 0x3d	; 61
    4710:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
    4712:	80 91 7e 01 	lds	r24, 0x017E
    4716:	90 91 7f 01 	lds	r25, 0x017F
}
    471a:	cf 91       	pop	r28
    471c:	df 91       	pop	r29
    471e:	08 95       	ret

00004720 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    4720:	df 93       	push	r29
    4722:	cf 93       	push	r28
    4724:	cd b7       	in	r28, 0x3d	; 61
    4726:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
    4728:	cf 91       	pop	r28
    472a:	df 91       	pop	r29
    472c:	08 95       	ret

0000472e <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    472e:	df 93       	push	r29
    4730:	cf 93       	push	r28
    4732:	00 d0       	rcall	.+0      	; 0x4734 <prvHeapInit+0x6>
    4734:	00 d0       	rcall	.+0      	; 0x4736 <prvHeapInit+0x8>
    4736:	cd b7       	in	r28, 0x3d	; 61
    4738:	de b7       	in	r29, 0x3e	; 62
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    473a:	8f e9       	ldi	r24, 0x9F	; 159
    473c:	91 e0       	ldi	r25, 0x01	; 1
    473e:	9a 83       	std	Y+2, r25	; 0x02
    4740:	89 83       	std	Y+1, r24	; 0x01

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    4742:	89 81       	ldd	r24, Y+1	; 0x01
    4744:	9a 81       	ldd	r25, Y+2	; 0x02
    4746:	90 93 87 05 	sts	0x0587, r25
    474a:	80 93 86 05 	sts	0x0586, r24
	xStart.xBlockSize = ( size_t ) 0;
    474e:	10 92 89 05 	sts	0x0589, r1
    4752:	10 92 88 05 	sts	0x0588, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    4756:	87 ee       	ldi	r24, 0xE7	; 231
    4758:	93 e0       	ldi	r25, 0x03	; 3
    475a:	90 93 8d 05 	sts	0x058D, r25
    475e:	80 93 8c 05 	sts	0x058C, r24
	xEnd.pxNextFreeBlock = NULL;
    4762:	10 92 8b 05 	sts	0x058B, r1
    4766:	10 92 8a 05 	sts	0x058A, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    476a:	89 81       	ldd	r24, Y+1	; 0x01
    476c:	9a 81       	ldd	r25, Y+2	; 0x02
    476e:	9c 83       	std	Y+4, r25	; 0x04
    4770:	8b 83       	std	Y+3, r24	; 0x03
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    4772:	eb 81       	ldd	r30, Y+3	; 0x03
    4774:	fc 81       	ldd	r31, Y+4	; 0x04
    4776:	87 ee       	ldi	r24, 0xE7	; 231
    4778:	93 e0       	ldi	r25, 0x03	; 3
    477a:	93 83       	std	Z+3, r25	; 0x03
    477c:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    477e:	eb 81       	ldd	r30, Y+3	; 0x03
    4780:	fc 81       	ldd	r31, Y+4	; 0x04
    4782:	8a e8       	ldi	r24, 0x8A	; 138
    4784:	95 e0       	ldi	r25, 0x05	; 5
    4786:	91 83       	std	Z+1, r25	; 0x01
    4788:	80 83       	st	Z, r24
}
    478a:	0f 90       	pop	r0
    478c:	0f 90       	pop	r0
    478e:	0f 90       	pop	r0
    4790:	0f 90       	pop	r0
    4792:	cf 91       	pop	r28
    4794:	df 91       	pop	r29
    4796:	08 95       	ret

00004798 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    4798:	df 93       	push	r29
    479a:	cf 93       	push	r28
    479c:	00 d0       	rcall	.+0      	; 0x479e <vListInitialise+0x6>
    479e:	cd b7       	in	r28, 0x3d	; 61
    47a0:	de b7       	in	r29, 0x3e	; 62
    47a2:	9a 83       	std	Y+2, r25	; 0x02
    47a4:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    47a6:	89 81       	ldd	r24, Y+1	; 0x01
    47a8:	9a 81       	ldd	r25, Y+2	; 0x02
    47aa:	03 96       	adiw	r24, 0x03	; 3
    47ac:	e9 81       	ldd	r30, Y+1	; 0x01
    47ae:	fa 81       	ldd	r31, Y+2	; 0x02
    47b0:	92 83       	std	Z+2, r25	; 0x02
    47b2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    47b4:	e9 81       	ldd	r30, Y+1	; 0x01
    47b6:	fa 81       	ldd	r31, Y+2	; 0x02
    47b8:	8f ef       	ldi	r24, 0xFF	; 255
    47ba:	9f ef       	ldi	r25, 0xFF	; 255
    47bc:	94 83       	std	Z+4, r25	; 0x04
    47be:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    47c0:	89 81       	ldd	r24, Y+1	; 0x01
    47c2:	9a 81       	ldd	r25, Y+2	; 0x02
    47c4:	03 96       	adiw	r24, 0x03	; 3
    47c6:	e9 81       	ldd	r30, Y+1	; 0x01
    47c8:	fa 81       	ldd	r31, Y+2	; 0x02
    47ca:	96 83       	std	Z+6, r25	; 0x06
    47cc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    47ce:	89 81       	ldd	r24, Y+1	; 0x01
    47d0:	9a 81       	ldd	r25, Y+2	; 0x02
    47d2:	03 96       	adiw	r24, 0x03	; 3
    47d4:	e9 81       	ldd	r30, Y+1	; 0x01
    47d6:	fa 81       	ldd	r31, Y+2	; 0x02
    47d8:	90 87       	std	Z+8, r25	; 0x08
    47da:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    47dc:	e9 81       	ldd	r30, Y+1	; 0x01
    47de:	fa 81       	ldd	r31, Y+2	; 0x02
    47e0:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    47e2:	0f 90       	pop	r0
    47e4:	0f 90       	pop	r0
    47e6:	cf 91       	pop	r28
    47e8:	df 91       	pop	r29
    47ea:	08 95       	ret

000047ec <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    47ec:	df 93       	push	r29
    47ee:	cf 93       	push	r28
    47f0:	00 d0       	rcall	.+0      	; 0x47f2 <vListInitialiseItem+0x6>
    47f2:	cd b7       	in	r28, 0x3d	; 61
    47f4:	de b7       	in	r29, 0x3e	; 62
    47f6:	9a 83       	std	Y+2, r25	; 0x02
    47f8:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    47fa:	e9 81       	ldd	r30, Y+1	; 0x01
    47fc:	fa 81       	ldd	r31, Y+2	; 0x02
    47fe:	11 86       	std	Z+9, r1	; 0x09
    4800:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    4802:	0f 90       	pop	r0
    4804:	0f 90       	pop	r0
    4806:	cf 91       	pop	r28
    4808:	df 91       	pop	r29
    480a:	08 95       	ret

0000480c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    480c:	df 93       	push	r29
    480e:	cf 93       	push	r28
    4810:	00 d0       	rcall	.+0      	; 0x4812 <vListInsertEnd+0x6>
    4812:	00 d0       	rcall	.+0      	; 0x4814 <vListInsertEnd+0x8>
    4814:	00 d0       	rcall	.+0      	; 0x4816 <vListInsertEnd+0xa>
    4816:	cd b7       	in	r28, 0x3d	; 61
    4818:	de b7       	in	r29, 0x3e	; 62
    481a:	9c 83       	std	Y+4, r25	; 0x04
    481c:	8b 83       	std	Y+3, r24	; 0x03
    481e:	7e 83       	std	Y+6, r23	; 0x06
    4820:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    4822:	eb 81       	ldd	r30, Y+3	; 0x03
    4824:	fc 81       	ldd	r31, Y+4	; 0x04
    4826:	81 81       	ldd	r24, Z+1	; 0x01
    4828:	92 81       	ldd	r25, Z+2	; 0x02
    482a:	9a 83       	std	Y+2, r25	; 0x02
    482c:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    482e:	ed 81       	ldd	r30, Y+5	; 0x05
    4830:	fe 81       	ldd	r31, Y+6	; 0x06
    4832:	89 81       	ldd	r24, Y+1	; 0x01
    4834:	9a 81       	ldd	r25, Y+2	; 0x02
    4836:	93 83       	std	Z+3, r25	; 0x03
    4838:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    483a:	e9 81       	ldd	r30, Y+1	; 0x01
    483c:	fa 81       	ldd	r31, Y+2	; 0x02
    483e:	84 81       	ldd	r24, Z+4	; 0x04
    4840:	95 81       	ldd	r25, Z+5	; 0x05
    4842:	ed 81       	ldd	r30, Y+5	; 0x05
    4844:	fe 81       	ldd	r31, Y+6	; 0x06
    4846:	95 83       	std	Z+5, r25	; 0x05
    4848:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    484a:	e9 81       	ldd	r30, Y+1	; 0x01
    484c:	fa 81       	ldd	r31, Y+2	; 0x02
    484e:	04 80       	ldd	r0, Z+4	; 0x04
    4850:	f5 81       	ldd	r31, Z+5	; 0x05
    4852:	e0 2d       	mov	r30, r0
    4854:	8d 81       	ldd	r24, Y+5	; 0x05
    4856:	9e 81       	ldd	r25, Y+6	; 0x06
    4858:	93 83       	std	Z+3, r25	; 0x03
    485a:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    485c:	e9 81       	ldd	r30, Y+1	; 0x01
    485e:	fa 81       	ldd	r31, Y+2	; 0x02
    4860:	8d 81       	ldd	r24, Y+5	; 0x05
    4862:	9e 81       	ldd	r25, Y+6	; 0x06
    4864:	95 83       	std	Z+5, r25	; 0x05
    4866:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4868:	ed 81       	ldd	r30, Y+5	; 0x05
    486a:	fe 81       	ldd	r31, Y+6	; 0x06
    486c:	8b 81       	ldd	r24, Y+3	; 0x03
    486e:	9c 81       	ldd	r25, Y+4	; 0x04
    4870:	91 87       	std	Z+9, r25	; 0x09
    4872:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    4874:	eb 81       	ldd	r30, Y+3	; 0x03
    4876:	fc 81       	ldd	r31, Y+4	; 0x04
    4878:	80 81       	ld	r24, Z
    487a:	8f 5f       	subi	r24, 0xFF	; 255
    487c:	eb 81       	ldd	r30, Y+3	; 0x03
    487e:	fc 81       	ldd	r31, Y+4	; 0x04
    4880:	80 83       	st	Z, r24
}
    4882:	26 96       	adiw	r28, 0x06	; 6
    4884:	0f b6       	in	r0, 0x3f	; 63
    4886:	f8 94       	cli
    4888:	de bf       	out	0x3e, r29	; 62
    488a:	0f be       	out	0x3f, r0	; 63
    488c:	cd bf       	out	0x3d, r28	; 61
    488e:	cf 91       	pop	r28
    4890:	df 91       	pop	r29
    4892:	08 95       	ret

00004894 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    4894:	df 93       	push	r29
    4896:	cf 93       	push	r28
    4898:	cd b7       	in	r28, 0x3d	; 61
    489a:	de b7       	in	r29, 0x3e	; 62
    489c:	28 97       	sbiw	r28, 0x08	; 8
    489e:	0f b6       	in	r0, 0x3f	; 63
    48a0:	f8 94       	cli
    48a2:	de bf       	out	0x3e, r29	; 62
    48a4:	0f be       	out	0x3f, r0	; 63
    48a6:	cd bf       	out	0x3d, r28	; 61
    48a8:	9e 83       	std	Y+6, r25	; 0x06
    48aa:	8d 83       	std	Y+5, r24	; 0x05
    48ac:	78 87       	std	Y+8, r23	; 0x08
    48ae:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    48b0:	ef 81       	ldd	r30, Y+7	; 0x07
    48b2:	f8 85       	ldd	r31, Y+8	; 0x08
    48b4:	80 81       	ld	r24, Z
    48b6:	91 81       	ldd	r25, Z+1	; 0x01
    48b8:	9a 83       	std	Y+2, r25	; 0x02
    48ba:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    48bc:	89 81       	ldd	r24, Y+1	; 0x01
    48be:	9a 81       	ldd	r25, Y+2	; 0x02
    48c0:	2f ef       	ldi	r18, 0xFF	; 255
    48c2:	8f 3f       	cpi	r24, 0xFF	; 255
    48c4:	92 07       	cpc	r25, r18
    48c6:	39 f4       	brne	.+14     	; 0x48d6 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    48c8:	ed 81       	ldd	r30, Y+5	; 0x05
    48ca:	fe 81       	ldd	r31, Y+6	; 0x06
    48cc:	87 81       	ldd	r24, Z+7	; 0x07
    48ce:	90 85       	ldd	r25, Z+8	; 0x08
    48d0:	9c 83       	std	Y+4, r25	; 0x04
    48d2:	8b 83       	std	Y+3, r24	; 0x03
    48d4:	18 c0       	rjmp	.+48     	; 0x4906 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    48d6:	8d 81       	ldd	r24, Y+5	; 0x05
    48d8:	9e 81       	ldd	r25, Y+6	; 0x06
    48da:	03 96       	adiw	r24, 0x03	; 3
    48dc:	9c 83       	std	Y+4, r25	; 0x04
    48de:	8b 83       	std	Y+3, r24	; 0x03
    48e0:	06 c0       	rjmp	.+12     	; 0x48ee <vListInsert+0x5a>
    48e2:	eb 81       	ldd	r30, Y+3	; 0x03
    48e4:	fc 81       	ldd	r31, Y+4	; 0x04
    48e6:	82 81       	ldd	r24, Z+2	; 0x02
    48e8:	93 81       	ldd	r25, Z+3	; 0x03
    48ea:	9c 83       	std	Y+4, r25	; 0x04
    48ec:	8b 83       	std	Y+3, r24	; 0x03
    48ee:	eb 81       	ldd	r30, Y+3	; 0x03
    48f0:	fc 81       	ldd	r31, Y+4	; 0x04
    48f2:	02 80       	ldd	r0, Z+2	; 0x02
    48f4:	f3 81       	ldd	r31, Z+3	; 0x03
    48f6:	e0 2d       	mov	r30, r0
    48f8:	20 81       	ld	r18, Z
    48fa:	31 81       	ldd	r19, Z+1	; 0x01
    48fc:	89 81       	ldd	r24, Y+1	; 0x01
    48fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4900:	82 17       	cp	r24, r18
    4902:	93 07       	cpc	r25, r19
    4904:	70 f7       	brcc	.-36     	; 0x48e2 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    4906:	eb 81       	ldd	r30, Y+3	; 0x03
    4908:	fc 81       	ldd	r31, Y+4	; 0x04
    490a:	82 81       	ldd	r24, Z+2	; 0x02
    490c:	93 81       	ldd	r25, Z+3	; 0x03
    490e:	ef 81       	ldd	r30, Y+7	; 0x07
    4910:	f8 85       	ldd	r31, Y+8	; 0x08
    4912:	93 83       	std	Z+3, r25	; 0x03
    4914:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    4916:	ef 81       	ldd	r30, Y+7	; 0x07
    4918:	f8 85       	ldd	r31, Y+8	; 0x08
    491a:	02 80       	ldd	r0, Z+2	; 0x02
    491c:	f3 81       	ldd	r31, Z+3	; 0x03
    491e:	e0 2d       	mov	r30, r0
    4920:	8f 81       	ldd	r24, Y+7	; 0x07
    4922:	98 85       	ldd	r25, Y+8	; 0x08
    4924:	95 83       	std	Z+5, r25	; 0x05
    4926:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    4928:	ef 81       	ldd	r30, Y+7	; 0x07
    492a:	f8 85       	ldd	r31, Y+8	; 0x08
    492c:	8b 81       	ldd	r24, Y+3	; 0x03
    492e:	9c 81       	ldd	r25, Y+4	; 0x04
    4930:	95 83       	std	Z+5, r25	; 0x05
    4932:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    4934:	eb 81       	ldd	r30, Y+3	; 0x03
    4936:	fc 81       	ldd	r31, Y+4	; 0x04
    4938:	8f 81       	ldd	r24, Y+7	; 0x07
    493a:	98 85       	ldd	r25, Y+8	; 0x08
    493c:	93 83       	std	Z+3, r25	; 0x03
    493e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    4940:	ef 81       	ldd	r30, Y+7	; 0x07
    4942:	f8 85       	ldd	r31, Y+8	; 0x08
    4944:	8d 81       	ldd	r24, Y+5	; 0x05
    4946:	9e 81       	ldd	r25, Y+6	; 0x06
    4948:	91 87       	std	Z+9, r25	; 0x09
    494a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    494c:	ed 81       	ldd	r30, Y+5	; 0x05
    494e:	fe 81       	ldd	r31, Y+6	; 0x06
    4950:	80 81       	ld	r24, Z
    4952:	8f 5f       	subi	r24, 0xFF	; 255
    4954:	ed 81       	ldd	r30, Y+5	; 0x05
    4956:	fe 81       	ldd	r31, Y+6	; 0x06
    4958:	80 83       	st	Z, r24
}
    495a:	28 96       	adiw	r28, 0x08	; 8
    495c:	0f b6       	in	r0, 0x3f	; 63
    495e:	f8 94       	cli
    4960:	de bf       	out	0x3e, r29	; 62
    4962:	0f be       	out	0x3f, r0	; 63
    4964:	cd bf       	out	0x3d, r28	; 61
    4966:	cf 91       	pop	r28
    4968:	df 91       	pop	r29
    496a:	08 95       	ret

0000496c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    496c:	df 93       	push	r29
    496e:	cf 93       	push	r28
    4970:	00 d0       	rcall	.+0      	; 0x4972 <uxListRemove+0x6>
    4972:	00 d0       	rcall	.+0      	; 0x4974 <uxListRemove+0x8>
    4974:	cd b7       	in	r28, 0x3d	; 61
    4976:	de b7       	in	r29, 0x3e	; 62
    4978:	9c 83       	std	Y+4, r25	; 0x04
    497a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    497c:	eb 81       	ldd	r30, Y+3	; 0x03
    497e:	fc 81       	ldd	r31, Y+4	; 0x04
    4980:	80 85       	ldd	r24, Z+8	; 0x08
    4982:	91 85       	ldd	r25, Z+9	; 0x09
    4984:	9a 83       	std	Y+2, r25	; 0x02
    4986:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4988:	eb 81       	ldd	r30, Y+3	; 0x03
    498a:	fc 81       	ldd	r31, Y+4	; 0x04
    498c:	a2 81       	ldd	r26, Z+2	; 0x02
    498e:	b3 81       	ldd	r27, Z+3	; 0x03
    4990:	eb 81       	ldd	r30, Y+3	; 0x03
    4992:	fc 81       	ldd	r31, Y+4	; 0x04
    4994:	84 81       	ldd	r24, Z+4	; 0x04
    4996:	95 81       	ldd	r25, Z+5	; 0x05
    4998:	15 96       	adiw	r26, 0x05	; 5
    499a:	9c 93       	st	X, r25
    499c:	8e 93       	st	-X, r24
    499e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    49a0:	eb 81       	ldd	r30, Y+3	; 0x03
    49a2:	fc 81       	ldd	r31, Y+4	; 0x04
    49a4:	a4 81       	ldd	r26, Z+4	; 0x04
    49a6:	b5 81       	ldd	r27, Z+5	; 0x05
    49a8:	eb 81       	ldd	r30, Y+3	; 0x03
    49aa:	fc 81       	ldd	r31, Y+4	; 0x04
    49ac:	82 81       	ldd	r24, Z+2	; 0x02
    49ae:	93 81       	ldd	r25, Z+3	; 0x03
    49b0:	13 96       	adiw	r26, 0x03	; 3
    49b2:	9c 93       	st	X, r25
    49b4:	8e 93       	st	-X, r24
    49b6:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    49b8:	e9 81       	ldd	r30, Y+1	; 0x01
    49ba:	fa 81       	ldd	r31, Y+2	; 0x02
    49bc:	21 81       	ldd	r18, Z+1	; 0x01
    49be:	32 81       	ldd	r19, Z+2	; 0x02
    49c0:	8b 81       	ldd	r24, Y+3	; 0x03
    49c2:	9c 81       	ldd	r25, Y+4	; 0x04
    49c4:	28 17       	cp	r18, r24
    49c6:	39 07       	cpc	r19, r25
    49c8:	41 f4       	brne	.+16     	; 0x49da <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    49ca:	eb 81       	ldd	r30, Y+3	; 0x03
    49cc:	fc 81       	ldd	r31, Y+4	; 0x04
    49ce:	84 81       	ldd	r24, Z+4	; 0x04
    49d0:	95 81       	ldd	r25, Z+5	; 0x05
    49d2:	e9 81       	ldd	r30, Y+1	; 0x01
    49d4:	fa 81       	ldd	r31, Y+2	; 0x02
    49d6:	92 83       	std	Z+2, r25	; 0x02
    49d8:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    49da:	eb 81       	ldd	r30, Y+3	; 0x03
    49dc:	fc 81       	ldd	r31, Y+4	; 0x04
    49de:	11 86       	std	Z+9, r1	; 0x09
    49e0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    49e2:	e9 81       	ldd	r30, Y+1	; 0x01
    49e4:	fa 81       	ldd	r31, Y+2	; 0x02
    49e6:	80 81       	ld	r24, Z
    49e8:	81 50       	subi	r24, 0x01	; 1
    49ea:	e9 81       	ldd	r30, Y+1	; 0x01
    49ec:	fa 81       	ldd	r31, Y+2	; 0x02
    49ee:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    49f0:	e9 81       	ldd	r30, Y+1	; 0x01
    49f2:	fa 81       	ldd	r31, Y+2	; 0x02
    49f4:	80 81       	ld	r24, Z
}
    49f6:	0f 90       	pop	r0
    49f8:	0f 90       	pop	r0
    49fa:	0f 90       	pop	r0
    49fc:	0f 90       	pop	r0
    49fe:	cf 91       	pop	r28
    4a00:	df 91       	pop	r29
    4a02:	08 95       	ret

00004a04 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    4a04:	df 93       	push	r29
    4a06:	cf 93       	push	r28
    4a08:	cd b7       	in	r28, 0x3d	; 61
    4a0a:	de b7       	in	r29, 0x3e	; 62
    4a0c:	28 97       	sbiw	r28, 0x08	; 8
    4a0e:	0f b6       	in	r0, 0x3f	; 63
    4a10:	f8 94       	cli
    4a12:	de bf       	out	0x3e, r29	; 62
    4a14:	0f be       	out	0x3f, r0	; 63
    4a16:	cd bf       	out	0x3d, r28	; 61
    4a18:	9c 83       	std	Y+4, r25	; 0x04
    4a1a:	8b 83       	std	Y+3, r24	; 0x03
    4a1c:	7e 83       	std	Y+6, r23	; 0x06
    4a1e:	6d 83       	std	Y+5, r22	; 0x05
    4a20:	58 87       	std	Y+8, r21	; 0x08
    4a22:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    4a24:	eb 81       	ldd	r30, Y+3	; 0x03
    4a26:	fc 81       	ldd	r31, Y+4	; 0x04
    4a28:	81 e1       	ldi	r24, 0x11	; 17
    4a2a:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a30:	01 97       	sbiw	r24, 0x01	; 1
    4a32:	9c 83       	std	Y+4, r25	; 0x04
    4a34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    4a36:	eb 81       	ldd	r30, Y+3	; 0x03
    4a38:	fc 81       	ldd	r31, Y+4	; 0x04
    4a3a:	82 e2       	ldi	r24, 0x22	; 34
    4a3c:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4a40:	9c 81       	ldd	r25, Y+4	; 0x04
    4a42:	01 97       	sbiw	r24, 0x01	; 1
    4a44:	9c 83       	std	Y+4, r25	; 0x04
    4a46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    4a48:	eb 81       	ldd	r30, Y+3	; 0x03
    4a4a:	fc 81       	ldd	r31, Y+4	; 0x04
    4a4c:	83 e3       	ldi	r24, 0x33	; 51
    4a4e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a50:	8b 81       	ldd	r24, Y+3	; 0x03
    4a52:	9c 81       	ldd	r25, Y+4	; 0x04
    4a54:	01 97       	sbiw	r24, 0x01	; 1
    4a56:	9c 83       	std	Y+4, r25	; 0x04
    4a58:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    4a5a:	8d 81       	ldd	r24, Y+5	; 0x05
    4a5c:	9e 81       	ldd	r25, Y+6	; 0x06
    4a5e:	9a 83       	std	Y+2, r25	; 0x02
    4a60:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    4a62:	89 81       	ldd	r24, Y+1	; 0x01
    4a64:	eb 81       	ldd	r30, Y+3	; 0x03
    4a66:	fc 81       	ldd	r31, Y+4	; 0x04
    4a68:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a6e:	01 97       	sbiw	r24, 0x01	; 1
    4a70:	9c 83       	std	Y+4, r25	; 0x04
    4a72:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    4a74:	89 81       	ldd	r24, Y+1	; 0x01
    4a76:	9a 81       	ldd	r25, Y+2	; 0x02
    4a78:	89 2f       	mov	r24, r25
    4a7a:	99 27       	eor	r25, r25
    4a7c:	9a 83       	std	Y+2, r25	; 0x02
    4a7e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    4a80:	89 81       	ldd	r24, Y+1	; 0x01
    4a82:	eb 81       	ldd	r30, Y+3	; 0x03
    4a84:	fc 81       	ldd	r31, Y+4	; 0x04
    4a86:	80 83       	st	Z, r24
	pxTopOfStack--;
    4a88:	8b 81       	ldd	r24, Y+3	; 0x03
    4a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a8c:	01 97       	sbiw	r24, 0x01	; 1
    4a8e:	9c 83       	std	Y+4, r25	; 0x04
    4a90:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    4a92:	eb 81       	ldd	r30, Y+3	; 0x03
    4a94:	fc 81       	ldd	r31, Y+4	; 0x04
    4a96:	10 82       	st	Z, r1
	pxTopOfStack--;
    4a98:	8b 81       	ldd	r24, Y+3	; 0x03
    4a9a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a9c:	01 97       	sbiw	r24, 0x01	; 1
    4a9e:	9c 83       	std	Y+4, r25	; 0x04
    4aa0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    4aa2:	eb 81       	ldd	r30, Y+3	; 0x03
    4aa4:	fc 81       	ldd	r31, Y+4	; 0x04
    4aa6:	80 e8       	ldi	r24, 0x80	; 128
    4aa8:	80 83       	st	Z, r24
	pxTopOfStack--;
    4aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    4aac:	9c 81       	ldd	r25, Y+4	; 0x04
    4aae:	01 97       	sbiw	r24, 0x01	; 1
    4ab0:	9c 83       	std	Y+4, r25	; 0x04
    4ab2:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    4ab4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ab6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ab8:	10 82       	st	Z, r1
	pxTopOfStack--;
    4aba:	8b 81       	ldd	r24, Y+3	; 0x03
    4abc:	9c 81       	ldd	r25, Y+4	; 0x04
    4abe:	01 97       	sbiw	r24, 0x01	; 1
    4ac0:	9c 83       	std	Y+4, r25	; 0x04
    4ac2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    4ac4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ac6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ac8:	82 e0       	ldi	r24, 0x02	; 2
    4aca:	80 83       	st	Z, r24
	pxTopOfStack--;
    4acc:	8b 81       	ldd	r24, Y+3	; 0x03
    4ace:	9c 81       	ldd	r25, Y+4	; 0x04
    4ad0:	01 97       	sbiw	r24, 0x01	; 1
    4ad2:	9c 83       	std	Y+4, r25	; 0x04
    4ad4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    4ad6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ad8:	fc 81       	ldd	r31, Y+4	; 0x04
    4ada:	83 e0       	ldi	r24, 0x03	; 3
    4adc:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ade:	8b 81       	ldd	r24, Y+3	; 0x03
    4ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    4ae2:	01 97       	sbiw	r24, 0x01	; 1
    4ae4:	9c 83       	std	Y+4, r25	; 0x04
    4ae6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    4ae8:	eb 81       	ldd	r30, Y+3	; 0x03
    4aea:	fc 81       	ldd	r31, Y+4	; 0x04
    4aec:	84 e0       	ldi	r24, 0x04	; 4
    4aee:	80 83       	st	Z, r24
	pxTopOfStack--;
    4af0:	8b 81       	ldd	r24, Y+3	; 0x03
    4af2:	9c 81       	ldd	r25, Y+4	; 0x04
    4af4:	01 97       	sbiw	r24, 0x01	; 1
    4af6:	9c 83       	std	Y+4, r25	; 0x04
    4af8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    4afa:	eb 81       	ldd	r30, Y+3	; 0x03
    4afc:	fc 81       	ldd	r31, Y+4	; 0x04
    4afe:	85 e0       	ldi	r24, 0x05	; 5
    4b00:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b02:	8b 81       	ldd	r24, Y+3	; 0x03
    4b04:	9c 81       	ldd	r25, Y+4	; 0x04
    4b06:	01 97       	sbiw	r24, 0x01	; 1
    4b08:	9c 83       	std	Y+4, r25	; 0x04
    4b0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    4b0c:	eb 81       	ldd	r30, Y+3	; 0x03
    4b0e:	fc 81       	ldd	r31, Y+4	; 0x04
    4b10:	86 e0       	ldi	r24, 0x06	; 6
    4b12:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b14:	8b 81       	ldd	r24, Y+3	; 0x03
    4b16:	9c 81       	ldd	r25, Y+4	; 0x04
    4b18:	01 97       	sbiw	r24, 0x01	; 1
    4b1a:	9c 83       	std	Y+4, r25	; 0x04
    4b1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    4b1e:	eb 81       	ldd	r30, Y+3	; 0x03
    4b20:	fc 81       	ldd	r31, Y+4	; 0x04
    4b22:	87 e0       	ldi	r24, 0x07	; 7
    4b24:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b26:	8b 81       	ldd	r24, Y+3	; 0x03
    4b28:	9c 81       	ldd	r25, Y+4	; 0x04
    4b2a:	01 97       	sbiw	r24, 0x01	; 1
    4b2c:	9c 83       	std	Y+4, r25	; 0x04
    4b2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    4b30:	eb 81       	ldd	r30, Y+3	; 0x03
    4b32:	fc 81       	ldd	r31, Y+4	; 0x04
    4b34:	88 e0       	ldi	r24, 0x08	; 8
    4b36:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b38:	8b 81       	ldd	r24, Y+3	; 0x03
    4b3a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b3c:	01 97       	sbiw	r24, 0x01	; 1
    4b3e:	9c 83       	std	Y+4, r25	; 0x04
    4b40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    4b42:	eb 81       	ldd	r30, Y+3	; 0x03
    4b44:	fc 81       	ldd	r31, Y+4	; 0x04
    4b46:	89 e0       	ldi	r24, 0x09	; 9
    4b48:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b4e:	01 97       	sbiw	r24, 0x01	; 1
    4b50:	9c 83       	std	Y+4, r25	; 0x04
    4b52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    4b54:	eb 81       	ldd	r30, Y+3	; 0x03
    4b56:	fc 81       	ldd	r31, Y+4	; 0x04
    4b58:	80 e1       	ldi	r24, 0x10	; 16
    4b5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b5e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b60:	01 97       	sbiw	r24, 0x01	; 1
    4b62:	9c 83       	std	Y+4, r25	; 0x04
    4b64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    4b66:	eb 81       	ldd	r30, Y+3	; 0x03
    4b68:	fc 81       	ldd	r31, Y+4	; 0x04
    4b6a:	81 e1       	ldi	r24, 0x11	; 17
    4b6c:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b6e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b70:	9c 81       	ldd	r25, Y+4	; 0x04
    4b72:	01 97       	sbiw	r24, 0x01	; 1
    4b74:	9c 83       	std	Y+4, r25	; 0x04
    4b76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    4b78:	eb 81       	ldd	r30, Y+3	; 0x03
    4b7a:	fc 81       	ldd	r31, Y+4	; 0x04
    4b7c:	82 e1       	ldi	r24, 0x12	; 18
    4b7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b80:	8b 81       	ldd	r24, Y+3	; 0x03
    4b82:	9c 81       	ldd	r25, Y+4	; 0x04
    4b84:	01 97       	sbiw	r24, 0x01	; 1
    4b86:	9c 83       	std	Y+4, r25	; 0x04
    4b88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    4b8a:	eb 81       	ldd	r30, Y+3	; 0x03
    4b8c:	fc 81       	ldd	r31, Y+4	; 0x04
    4b8e:	83 e1       	ldi	r24, 0x13	; 19
    4b90:	80 83       	st	Z, r24
	pxTopOfStack--;
    4b92:	8b 81       	ldd	r24, Y+3	; 0x03
    4b94:	9c 81       	ldd	r25, Y+4	; 0x04
    4b96:	01 97       	sbiw	r24, 0x01	; 1
    4b98:	9c 83       	std	Y+4, r25	; 0x04
    4b9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    4b9c:	eb 81       	ldd	r30, Y+3	; 0x03
    4b9e:	fc 81       	ldd	r31, Y+4	; 0x04
    4ba0:	84 e1       	ldi	r24, 0x14	; 20
    4ba2:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ba4:	8b 81       	ldd	r24, Y+3	; 0x03
    4ba6:	9c 81       	ldd	r25, Y+4	; 0x04
    4ba8:	01 97       	sbiw	r24, 0x01	; 1
    4baa:	9c 83       	std	Y+4, r25	; 0x04
    4bac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    4bae:	eb 81       	ldd	r30, Y+3	; 0x03
    4bb0:	fc 81       	ldd	r31, Y+4	; 0x04
    4bb2:	85 e1       	ldi	r24, 0x15	; 21
    4bb4:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bb6:	8b 81       	ldd	r24, Y+3	; 0x03
    4bb8:	9c 81       	ldd	r25, Y+4	; 0x04
    4bba:	01 97       	sbiw	r24, 0x01	; 1
    4bbc:	9c 83       	std	Y+4, r25	; 0x04
    4bbe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    4bc0:	eb 81       	ldd	r30, Y+3	; 0x03
    4bc2:	fc 81       	ldd	r31, Y+4	; 0x04
    4bc4:	86 e1       	ldi	r24, 0x16	; 22
    4bc6:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    4bca:	9c 81       	ldd	r25, Y+4	; 0x04
    4bcc:	01 97       	sbiw	r24, 0x01	; 1
    4bce:	9c 83       	std	Y+4, r25	; 0x04
    4bd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    4bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    4bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    4bd6:	87 e1       	ldi	r24, 0x17	; 23
    4bd8:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bda:	8b 81       	ldd	r24, Y+3	; 0x03
    4bdc:	9c 81       	ldd	r25, Y+4	; 0x04
    4bde:	01 97       	sbiw	r24, 0x01	; 1
    4be0:	9c 83       	std	Y+4, r25	; 0x04
    4be2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    4be4:	eb 81       	ldd	r30, Y+3	; 0x03
    4be6:	fc 81       	ldd	r31, Y+4	; 0x04
    4be8:	88 e1       	ldi	r24, 0x18	; 24
    4bea:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bec:	8b 81       	ldd	r24, Y+3	; 0x03
    4bee:	9c 81       	ldd	r25, Y+4	; 0x04
    4bf0:	01 97       	sbiw	r24, 0x01	; 1
    4bf2:	9c 83       	std	Y+4, r25	; 0x04
    4bf4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    4bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    4bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    4bfa:	89 e1       	ldi	r24, 0x19	; 25
    4bfc:	80 83       	st	Z, r24
	pxTopOfStack--;
    4bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    4c00:	9c 81       	ldd	r25, Y+4	; 0x04
    4c02:	01 97       	sbiw	r24, 0x01	; 1
    4c04:	9c 83       	std	Y+4, r25	; 0x04
    4c06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    4c08:	eb 81       	ldd	r30, Y+3	; 0x03
    4c0a:	fc 81       	ldd	r31, Y+4	; 0x04
    4c0c:	80 e2       	ldi	r24, 0x20	; 32
    4c0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c10:	8b 81       	ldd	r24, Y+3	; 0x03
    4c12:	9c 81       	ldd	r25, Y+4	; 0x04
    4c14:	01 97       	sbiw	r24, 0x01	; 1
    4c16:	9c 83       	std	Y+4, r25	; 0x04
    4c18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    4c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    4c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    4c1e:	81 e2       	ldi	r24, 0x21	; 33
    4c20:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c22:	8b 81       	ldd	r24, Y+3	; 0x03
    4c24:	9c 81       	ldd	r25, Y+4	; 0x04
    4c26:	01 97       	sbiw	r24, 0x01	; 1
    4c28:	9c 83       	std	Y+4, r25	; 0x04
    4c2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    4c2c:	eb 81       	ldd	r30, Y+3	; 0x03
    4c2e:	fc 81       	ldd	r31, Y+4	; 0x04
    4c30:	82 e2       	ldi	r24, 0x22	; 34
    4c32:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c34:	8b 81       	ldd	r24, Y+3	; 0x03
    4c36:	9c 81       	ldd	r25, Y+4	; 0x04
    4c38:	01 97       	sbiw	r24, 0x01	; 1
    4c3a:	9c 83       	std	Y+4, r25	; 0x04
    4c3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    4c3e:	eb 81       	ldd	r30, Y+3	; 0x03
    4c40:	fc 81       	ldd	r31, Y+4	; 0x04
    4c42:	83 e2       	ldi	r24, 0x23	; 35
    4c44:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c46:	8b 81       	ldd	r24, Y+3	; 0x03
    4c48:	9c 81       	ldd	r25, Y+4	; 0x04
    4c4a:	01 97       	sbiw	r24, 0x01	; 1
    4c4c:	9c 83       	std	Y+4, r25	; 0x04
    4c4e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    4c50:	8f 81       	ldd	r24, Y+7	; 0x07
    4c52:	98 85       	ldd	r25, Y+8	; 0x08
    4c54:	9a 83       	std	Y+2, r25	; 0x02
    4c56:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    4c58:	89 81       	ldd	r24, Y+1	; 0x01
    4c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    4c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    4c5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c60:	8b 81       	ldd	r24, Y+3	; 0x03
    4c62:	9c 81       	ldd	r25, Y+4	; 0x04
    4c64:	01 97       	sbiw	r24, 0x01	; 1
    4c66:	9c 83       	std	Y+4, r25	; 0x04
    4c68:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    4c6a:	89 81       	ldd	r24, Y+1	; 0x01
    4c6c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c6e:	89 2f       	mov	r24, r25
    4c70:	99 27       	eor	r25, r25
    4c72:	9a 83       	std	Y+2, r25	; 0x02
    4c74:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    4c76:	89 81       	ldd	r24, Y+1	; 0x01
    4c78:	eb 81       	ldd	r30, Y+3	; 0x03
    4c7a:	fc 81       	ldd	r31, Y+4	; 0x04
    4c7c:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c80:	9c 81       	ldd	r25, Y+4	; 0x04
    4c82:	01 97       	sbiw	r24, 0x01	; 1
    4c84:	9c 83       	std	Y+4, r25	; 0x04
    4c86:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    4c88:	eb 81       	ldd	r30, Y+3	; 0x03
    4c8a:	fc 81       	ldd	r31, Y+4	; 0x04
    4c8c:	86 e2       	ldi	r24, 0x26	; 38
    4c8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    4c90:	8b 81       	ldd	r24, Y+3	; 0x03
    4c92:	9c 81       	ldd	r25, Y+4	; 0x04
    4c94:	01 97       	sbiw	r24, 0x01	; 1
    4c96:	9c 83       	std	Y+4, r25	; 0x04
    4c98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    4c9a:	eb 81       	ldd	r30, Y+3	; 0x03
    4c9c:	fc 81       	ldd	r31, Y+4	; 0x04
    4c9e:	87 e2       	ldi	r24, 0x27	; 39
    4ca0:	80 83       	st	Z, r24
	pxTopOfStack--;
    4ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    4ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    4ca6:	01 97       	sbiw	r24, 0x01	; 1
    4ca8:	9c 83       	std	Y+4, r25	; 0x04
    4caa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    4cac:	eb 81       	ldd	r30, Y+3	; 0x03
    4cae:	fc 81       	ldd	r31, Y+4	; 0x04
    4cb0:	88 e2       	ldi	r24, 0x28	; 40
    4cb2:	80 83       	st	Z, r24
	pxTopOfStack--;
    4cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    4cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    4cb8:	01 97       	sbiw	r24, 0x01	; 1
    4cba:	9c 83       	std	Y+4, r25	; 0x04
    4cbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    4cbe:	eb 81       	ldd	r30, Y+3	; 0x03
    4cc0:	fc 81       	ldd	r31, Y+4	; 0x04
    4cc2:	89 e2       	ldi	r24, 0x29	; 41
    4cc4:	80 83       	st	Z, r24
	pxTopOfStack--;
    4cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    4cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    4cca:	01 97       	sbiw	r24, 0x01	; 1
    4ccc:	9c 83       	std	Y+4, r25	; 0x04
    4cce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    4cd0:	eb 81       	ldd	r30, Y+3	; 0x03
    4cd2:	fc 81       	ldd	r31, Y+4	; 0x04
    4cd4:	80 e3       	ldi	r24, 0x30	; 48
    4cd6:	80 83       	st	Z, r24
	pxTopOfStack--;
    4cd8:	8b 81       	ldd	r24, Y+3	; 0x03
    4cda:	9c 81       	ldd	r25, Y+4	; 0x04
    4cdc:	01 97       	sbiw	r24, 0x01	; 1
    4cde:	9c 83       	std	Y+4, r25	; 0x04
    4ce0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    4ce2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ce4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ce6:	81 e3       	ldi	r24, 0x31	; 49
    4ce8:	80 83       	st	Z, r24
	pxTopOfStack--;
    4cea:	8b 81       	ldd	r24, Y+3	; 0x03
    4cec:	9c 81       	ldd	r25, Y+4	; 0x04
    4cee:	01 97       	sbiw	r24, 0x01	; 1
    4cf0:	9c 83       	std	Y+4, r25	; 0x04
    4cf2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    4cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    4cf6:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4cf8:	28 96       	adiw	r28, 0x08	; 8
    4cfa:	0f b6       	in	r0, 0x3f	; 63
    4cfc:	f8 94       	cli
    4cfe:	de bf       	out	0x3e, r29	; 62
    4d00:	0f be       	out	0x3f, r0	; 63
    4d02:	cd bf       	out	0x3d, r28	; 61
    4d04:	cf 91       	pop	r28
    4d06:	df 91       	pop	r29
    4d08:	08 95       	ret

00004d0a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    4d0a:	df 93       	push	r29
    4d0c:	cf 93       	push	r28
    4d0e:	cd b7       	in	r28, 0x3d	; 61
    4d10:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    4d12:	0e 94 77 27 	call	0x4eee	; 0x4eee <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    4d16:	a0 91 8e 05 	lds	r26, 0x058E
    4d1a:	b0 91 8f 05 	lds	r27, 0x058F
    4d1e:	cd 91       	ld	r28, X+
    4d20:	cd bf       	out	0x3d, r28	; 61
    4d22:	dd 91       	ld	r29, X+
    4d24:	de bf       	out	0x3e, r29	; 62
    4d26:	ff 91       	pop	r31
    4d28:	ef 91       	pop	r30
    4d2a:	df 91       	pop	r29
    4d2c:	cf 91       	pop	r28
    4d2e:	bf 91       	pop	r27
    4d30:	af 91       	pop	r26
    4d32:	9f 91       	pop	r25
    4d34:	8f 91       	pop	r24
    4d36:	7f 91       	pop	r23
    4d38:	6f 91       	pop	r22
    4d3a:	5f 91       	pop	r21
    4d3c:	4f 91       	pop	r20
    4d3e:	3f 91       	pop	r19
    4d40:	2f 91       	pop	r18
    4d42:	1f 91       	pop	r17
    4d44:	0f 91       	pop	r16
    4d46:	ff 90       	pop	r15
    4d48:	ef 90       	pop	r14
    4d4a:	df 90       	pop	r13
    4d4c:	cf 90       	pop	r12
    4d4e:	bf 90       	pop	r11
    4d50:	af 90       	pop	r10
    4d52:	9f 90       	pop	r9
    4d54:	8f 90       	pop	r8
    4d56:	7f 90       	pop	r7
    4d58:	6f 90       	pop	r6
    4d5a:	5f 90       	pop	r5
    4d5c:	4f 90       	pop	r4
    4d5e:	3f 90       	pop	r3
    4d60:	2f 90       	pop	r2
    4d62:	1f 90       	pop	r1
    4d64:	0f 90       	pop	r0
    4d66:	0f be       	out	0x3f, r0	; 63
    4d68:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    4d6a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    4d6c:	81 e0       	ldi	r24, 0x01	; 1
}
    4d6e:	cf 91       	pop	r28
    4d70:	df 91       	pop	r29
    4d72:	08 95       	ret

00004d74 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    4d74:	df 93       	push	r29
    4d76:	cf 93       	push	r28
    4d78:	cd b7       	in	r28, 0x3d	; 61
    4d7a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    4d7c:	cf 91       	pop	r28
    4d7e:	df 91       	pop	r29
    4d80:	08 95       	ret

00004d82 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    4d82:	0f 92       	push	r0
    4d84:	0f b6       	in	r0, 0x3f	; 63
    4d86:	f8 94       	cli
    4d88:	0f 92       	push	r0
    4d8a:	1f 92       	push	r1
    4d8c:	11 24       	eor	r1, r1
    4d8e:	2f 92       	push	r2
    4d90:	3f 92       	push	r3
    4d92:	4f 92       	push	r4
    4d94:	5f 92       	push	r5
    4d96:	6f 92       	push	r6
    4d98:	7f 92       	push	r7
    4d9a:	8f 92       	push	r8
    4d9c:	9f 92       	push	r9
    4d9e:	af 92       	push	r10
    4da0:	bf 92       	push	r11
    4da2:	cf 92       	push	r12
    4da4:	df 92       	push	r13
    4da6:	ef 92       	push	r14
    4da8:	ff 92       	push	r15
    4daa:	0f 93       	push	r16
    4dac:	1f 93       	push	r17
    4dae:	2f 93       	push	r18
    4db0:	3f 93       	push	r19
    4db2:	4f 93       	push	r20
    4db4:	5f 93       	push	r21
    4db6:	6f 93       	push	r22
    4db8:	7f 93       	push	r23
    4dba:	8f 93       	push	r24
    4dbc:	9f 93       	push	r25
    4dbe:	af 93       	push	r26
    4dc0:	bf 93       	push	r27
    4dc2:	cf 93       	push	r28
    4dc4:	df 93       	push	r29
    4dc6:	ef 93       	push	r30
    4dc8:	ff 93       	push	r31
    4dca:	a0 91 8e 05 	lds	r26, 0x058E
    4dce:	b0 91 8f 05 	lds	r27, 0x058F
    4dd2:	0d b6       	in	r0, 0x3d	; 61
    4dd4:	0d 92       	st	X+, r0
    4dd6:	0e b6       	in	r0, 0x3e	; 62
    4dd8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    4dda:	0e 94 04 35 	call	0x6a08	; 0x6a08 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    4dde:	a0 91 8e 05 	lds	r26, 0x058E
    4de2:	b0 91 8f 05 	lds	r27, 0x058F
    4de6:	cd 91       	ld	r28, X+
    4de8:	cd bf       	out	0x3d, r28	; 61
    4dea:	dd 91       	ld	r29, X+
    4dec:	de bf       	out	0x3e, r29	; 62
    4dee:	ff 91       	pop	r31
    4df0:	ef 91       	pop	r30
    4df2:	df 91       	pop	r29
    4df4:	cf 91       	pop	r28
    4df6:	bf 91       	pop	r27
    4df8:	af 91       	pop	r26
    4dfa:	9f 91       	pop	r25
    4dfc:	8f 91       	pop	r24
    4dfe:	7f 91       	pop	r23
    4e00:	6f 91       	pop	r22
    4e02:	5f 91       	pop	r21
    4e04:	4f 91       	pop	r20
    4e06:	3f 91       	pop	r19
    4e08:	2f 91       	pop	r18
    4e0a:	1f 91       	pop	r17
    4e0c:	0f 91       	pop	r16
    4e0e:	ff 90       	pop	r15
    4e10:	ef 90       	pop	r14
    4e12:	df 90       	pop	r13
    4e14:	cf 90       	pop	r12
    4e16:	bf 90       	pop	r11
    4e18:	af 90       	pop	r10
    4e1a:	9f 90       	pop	r9
    4e1c:	8f 90       	pop	r8
    4e1e:	7f 90       	pop	r7
    4e20:	6f 90       	pop	r6
    4e22:	5f 90       	pop	r5
    4e24:	4f 90       	pop	r4
    4e26:	3f 90       	pop	r3
    4e28:	2f 90       	pop	r2
    4e2a:	1f 90       	pop	r1
    4e2c:	0f 90       	pop	r0
    4e2e:	0f be       	out	0x3f, r0	; 63
    4e30:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4e32:	08 95       	ret

00004e34 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    4e34:	0f 92       	push	r0
    4e36:	0f b6       	in	r0, 0x3f	; 63
    4e38:	f8 94       	cli
    4e3a:	0f 92       	push	r0
    4e3c:	1f 92       	push	r1
    4e3e:	11 24       	eor	r1, r1
    4e40:	2f 92       	push	r2
    4e42:	3f 92       	push	r3
    4e44:	4f 92       	push	r4
    4e46:	5f 92       	push	r5
    4e48:	6f 92       	push	r6
    4e4a:	7f 92       	push	r7
    4e4c:	8f 92       	push	r8
    4e4e:	9f 92       	push	r9
    4e50:	af 92       	push	r10
    4e52:	bf 92       	push	r11
    4e54:	cf 92       	push	r12
    4e56:	df 92       	push	r13
    4e58:	ef 92       	push	r14
    4e5a:	ff 92       	push	r15
    4e5c:	0f 93       	push	r16
    4e5e:	1f 93       	push	r17
    4e60:	2f 93       	push	r18
    4e62:	3f 93       	push	r19
    4e64:	4f 93       	push	r20
    4e66:	5f 93       	push	r21
    4e68:	6f 93       	push	r22
    4e6a:	7f 93       	push	r23
    4e6c:	8f 93       	push	r24
    4e6e:	9f 93       	push	r25
    4e70:	af 93       	push	r26
    4e72:	bf 93       	push	r27
    4e74:	cf 93       	push	r28
    4e76:	df 93       	push	r29
    4e78:	ef 93       	push	r30
    4e7a:	ff 93       	push	r31
    4e7c:	a0 91 8e 05 	lds	r26, 0x058E
    4e80:	b0 91 8f 05 	lds	r27, 0x058F
    4e84:	0d b6       	in	r0, 0x3d	; 61
    4e86:	0d 92       	st	X+, r0
    4e88:	0e b6       	in	r0, 0x3e	; 62
    4e8a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    4e8c:	0e 94 38 34 	call	0x6870	; 0x6870 <xTaskIncrementTick>
    4e90:	88 23       	and	r24, r24
    4e92:	11 f0       	breq	.+4      	; 0x4e98 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    4e94:	0e 94 04 35 	call	0x6a08	; 0x6a08 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    4e98:	a0 91 8e 05 	lds	r26, 0x058E
    4e9c:	b0 91 8f 05 	lds	r27, 0x058F
    4ea0:	cd 91       	ld	r28, X+
    4ea2:	cd bf       	out	0x3d, r28	; 61
    4ea4:	dd 91       	ld	r29, X+
    4ea6:	de bf       	out	0x3e, r29	; 62
    4ea8:	ff 91       	pop	r31
    4eaa:	ef 91       	pop	r30
    4eac:	df 91       	pop	r29
    4eae:	cf 91       	pop	r28
    4eb0:	bf 91       	pop	r27
    4eb2:	af 91       	pop	r26
    4eb4:	9f 91       	pop	r25
    4eb6:	8f 91       	pop	r24
    4eb8:	7f 91       	pop	r23
    4eba:	6f 91       	pop	r22
    4ebc:	5f 91       	pop	r21
    4ebe:	4f 91       	pop	r20
    4ec0:	3f 91       	pop	r19
    4ec2:	2f 91       	pop	r18
    4ec4:	1f 91       	pop	r17
    4ec6:	0f 91       	pop	r16
    4ec8:	ff 90       	pop	r15
    4eca:	ef 90       	pop	r14
    4ecc:	df 90       	pop	r13
    4ece:	cf 90       	pop	r12
    4ed0:	bf 90       	pop	r11
    4ed2:	af 90       	pop	r10
    4ed4:	9f 90       	pop	r9
    4ed6:	8f 90       	pop	r8
    4ed8:	7f 90       	pop	r7
    4eda:	6f 90       	pop	r6
    4edc:	5f 90       	pop	r5
    4ede:	4f 90       	pop	r4
    4ee0:	3f 90       	pop	r3
    4ee2:	2f 90       	pop	r2
    4ee4:	1f 90       	pop	r1
    4ee6:	0f 90       	pop	r0
    4ee8:	0f be       	out	0x3f, r0	; 63
    4eea:	0f 90       	pop	r0

	asm volatile ( "ret" );
    4eec:	08 95       	ret

00004eee <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    4eee:	df 93       	push	r29
    4ef0:	cf 93       	push	r28
    4ef2:	00 d0       	rcall	.+0      	; 0x4ef4 <prvSetupTimerInterrupt+0x6>
    4ef4:	00 d0       	rcall	.+0      	; 0x4ef6 <prvSetupTimerInterrupt+0x8>
    4ef6:	00 d0       	rcall	.+0      	; 0x4ef8 <prvSetupTimerInterrupt+0xa>
    4ef8:	cd b7       	in	r28, 0x3d	; 61
    4efa:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    4efc:	80 e8       	ldi	r24, 0x80	; 128
    4efe:	9e e3       	ldi	r25, 0x3E	; 62
    4f00:	a0 e0       	ldi	r26, 0x00	; 0
    4f02:	b0 e0       	ldi	r27, 0x00	; 0
    4f04:	8b 83       	std	Y+3, r24	; 0x03
    4f06:	9c 83       	std	Y+4, r25	; 0x04
    4f08:	ad 83       	std	Y+5, r26	; 0x05
    4f0a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    4f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f10:	ad 81       	ldd	r26, Y+5	; 0x05
    4f12:	be 81       	ldd	r27, Y+6	; 0x06
    4f14:	68 94       	set
    4f16:	15 f8       	bld	r1, 5
    4f18:	b6 95       	lsr	r27
    4f1a:	a7 95       	ror	r26
    4f1c:	97 95       	ror	r25
    4f1e:	87 95       	ror	r24
    4f20:	16 94       	lsr	r1
    4f22:	d1 f7       	brne	.-12     	; 0x4f18 <prvSetupTimerInterrupt+0x2a>
    4f24:	8b 83       	std	Y+3, r24	; 0x03
    4f26:	9c 83       	std	Y+4, r25	; 0x04
    4f28:	ad 83       	std	Y+5, r26	; 0x05
    4f2a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    4f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f30:	ad 81       	ldd	r26, Y+5	; 0x05
    4f32:	be 81       	ldd	r27, Y+6	; 0x06
    4f34:	01 97       	sbiw	r24, 0x01	; 1
    4f36:	a1 09       	sbc	r26, r1
    4f38:	b1 09       	sbc	r27, r1
    4f3a:	8b 83       	std	Y+3, r24	; 0x03
    4f3c:	9c 83       	std	Y+4, r25	; 0x04
    4f3e:	ad 83       	std	Y+5, r26	; 0x05
    4f40:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    4f42:	8b 81       	ldd	r24, Y+3	; 0x03
    4f44:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    4f46:	8b 81       	ldd	r24, Y+3	; 0x03
    4f48:	9c 81       	ldd	r25, Y+4	; 0x04
    4f4a:	ad 81       	ldd	r26, Y+5	; 0x05
    4f4c:	be 81       	ldd	r27, Y+6	; 0x06
    4f4e:	89 2f       	mov	r24, r25
    4f50:	9a 2f       	mov	r25, r26
    4f52:	ab 2f       	mov	r26, r27
    4f54:	bb 27       	eor	r27, r27
    4f56:	8b 83       	std	Y+3, r24	; 0x03
    4f58:	9c 83       	std	Y+4, r25	; 0x04
    4f5a:	ad 83       	std	Y+5, r26	; 0x05
    4f5c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    4f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f60:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    4f62:	eb e4       	ldi	r30, 0x4B	; 75
    4f64:	f0 e0       	ldi	r31, 0x00	; 0
    4f66:	8a 81       	ldd	r24, Y+2	; 0x02
    4f68:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    4f6a:	ea e4       	ldi	r30, 0x4A	; 74
    4f6c:	f0 e0       	ldi	r31, 0x00	; 0
    4f6e:	89 81       	ldd	r24, Y+1	; 0x01
    4f70:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    4f72:	8b e0       	ldi	r24, 0x0B	; 11
    4f74:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    4f76:	ee e4       	ldi	r30, 0x4E	; 78
    4f78:	f0 e0       	ldi	r31, 0x00	; 0
    4f7a:	89 81       	ldd	r24, Y+1	; 0x01
    4f7c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    4f7e:	e9 e5       	ldi	r30, 0x59	; 89
    4f80:	f0 e0       	ldi	r31, 0x00	; 0
    4f82:	80 81       	ld	r24, Z
    4f84:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    4f86:	89 81       	ldd	r24, Y+1	; 0x01
    4f88:	80 61       	ori	r24, 0x10	; 16
    4f8a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    4f8c:	e9 e5       	ldi	r30, 0x59	; 89
    4f8e:	f0 e0       	ldi	r31, 0x00	; 0
    4f90:	89 81       	ldd	r24, Y+1	; 0x01
    4f92:	80 83       	st	Z, r24
}
    4f94:	26 96       	adiw	r28, 0x06	; 6
    4f96:	0f b6       	in	r0, 0x3f	; 63
    4f98:	f8 94       	cli
    4f9a:	de bf       	out	0x3e, r29	; 62
    4f9c:	0f be       	out	0x3f, r0	; 63
    4f9e:	cd bf       	out	0x3d, r28	; 61
    4fa0:	cf 91       	pop	r28
    4fa2:	df 91       	pop	r29
    4fa4:	08 95       	ret

00004fa6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    4fa6:	0e 94 1a 27 	call	0x4e34	; 0x4e34 <vPortYieldFromTick>
		asm volatile ( "reti" );
    4faa:	18 95       	reti

00004fac <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    4fac:	df 93       	push	r29
    4fae:	cf 93       	push	r28
    4fb0:	00 d0       	rcall	.+0      	; 0x4fb2 <xQueueGenericReset+0x6>
    4fb2:	00 d0       	rcall	.+0      	; 0x4fb4 <xQueueGenericReset+0x8>
    4fb4:	0f 92       	push	r0
    4fb6:	cd b7       	in	r28, 0x3d	; 61
    4fb8:	de b7       	in	r29, 0x3e	; 62
    4fba:	9c 83       	std	Y+4, r25	; 0x04
    4fbc:	8b 83       	std	Y+3, r24	; 0x03
    4fbe:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4fc0:	8b 81       	ldd	r24, Y+3	; 0x03
    4fc2:	9c 81       	ldd	r25, Y+4	; 0x04
    4fc4:	9a 83       	std	Y+2, r25	; 0x02
    4fc6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    4fc8:	0f b6       	in	r0, 0x3f	; 63
    4fca:	f8 94       	cli
    4fcc:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    4fce:	e9 81       	ldd	r30, Y+1	; 0x01
    4fd0:	fa 81       	ldd	r31, Y+2	; 0x02
    4fd2:	40 81       	ld	r20, Z
    4fd4:	51 81       	ldd	r21, Z+1	; 0x01
    4fd6:	e9 81       	ldd	r30, Y+1	; 0x01
    4fd8:	fa 81       	ldd	r31, Y+2	; 0x02
    4fda:	83 8d       	ldd	r24, Z+27	; 0x1b
    4fdc:	28 2f       	mov	r18, r24
    4fde:	30 e0       	ldi	r19, 0x00	; 0
    4fe0:	e9 81       	ldd	r30, Y+1	; 0x01
    4fe2:	fa 81       	ldd	r31, Y+2	; 0x02
    4fe4:	84 8d       	ldd	r24, Z+28	; 0x1c
    4fe6:	88 2f       	mov	r24, r24
    4fe8:	90 e0       	ldi	r25, 0x00	; 0
    4fea:	bc 01       	movw	r22, r24
    4fec:	26 9f       	mul	r18, r22
    4fee:	c0 01       	movw	r24, r0
    4ff0:	27 9f       	mul	r18, r23
    4ff2:	90 0d       	add	r25, r0
    4ff4:	36 9f       	mul	r19, r22
    4ff6:	90 0d       	add	r25, r0
    4ff8:	11 24       	eor	r1, r1
    4ffa:	84 0f       	add	r24, r20
    4ffc:	95 1f       	adc	r25, r21
    4ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    5000:	fa 81       	ldd	r31, Y+2	; 0x02
    5002:	93 83       	std	Z+3, r25	; 0x03
    5004:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    5006:	e9 81       	ldd	r30, Y+1	; 0x01
    5008:	fa 81       	ldd	r31, Y+2	; 0x02
    500a:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    500c:	e9 81       	ldd	r30, Y+1	; 0x01
    500e:	fa 81       	ldd	r31, Y+2	; 0x02
    5010:	80 81       	ld	r24, Z
    5012:	91 81       	ldd	r25, Z+1	; 0x01
    5014:	e9 81       	ldd	r30, Y+1	; 0x01
    5016:	fa 81       	ldd	r31, Y+2	; 0x02
    5018:	95 83       	std	Z+5, r25	; 0x05
    501a:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    501c:	e9 81       	ldd	r30, Y+1	; 0x01
    501e:	fa 81       	ldd	r31, Y+2	; 0x02
    5020:	40 81       	ld	r20, Z
    5022:	51 81       	ldd	r21, Z+1	; 0x01
    5024:	e9 81       	ldd	r30, Y+1	; 0x01
    5026:	fa 81       	ldd	r31, Y+2	; 0x02
    5028:	83 8d       	ldd	r24, Z+27	; 0x1b
    502a:	88 2f       	mov	r24, r24
    502c:	90 e0       	ldi	r25, 0x00	; 0
    502e:	9c 01       	movw	r18, r24
    5030:	21 50       	subi	r18, 0x01	; 1
    5032:	30 40       	sbci	r19, 0x00	; 0
    5034:	e9 81       	ldd	r30, Y+1	; 0x01
    5036:	fa 81       	ldd	r31, Y+2	; 0x02
    5038:	84 8d       	ldd	r24, Z+28	; 0x1c
    503a:	88 2f       	mov	r24, r24
    503c:	90 e0       	ldi	r25, 0x00	; 0
    503e:	bc 01       	movw	r22, r24
    5040:	26 9f       	mul	r18, r22
    5042:	c0 01       	movw	r24, r0
    5044:	27 9f       	mul	r18, r23
    5046:	90 0d       	add	r25, r0
    5048:	36 9f       	mul	r19, r22
    504a:	90 0d       	add	r25, r0
    504c:	11 24       	eor	r1, r1
    504e:	84 0f       	add	r24, r20
    5050:	95 1f       	adc	r25, r21
    5052:	e9 81       	ldd	r30, Y+1	; 0x01
    5054:	fa 81       	ldd	r31, Y+2	; 0x02
    5056:	97 83       	std	Z+7, r25	; 0x07
    5058:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    505a:	e9 81       	ldd	r30, Y+1	; 0x01
    505c:	fa 81       	ldd	r31, Y+2	; 0x02
    505e:	8f ef       	ldi	r24, 0xFF	; 255
    5060:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    5062:	e9 81       	ldd	r30, Y+1	; 0x01
    5064:	fa 81       	ldd	r31, Y+2	; 0x02
    5066:	8f ef       	ldi	r24, 0xFF	; 255
    5068:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    506a:	8d 81       	ldd	r24, Y+5	; 0x05
    506c:	88 23       	and	r24, r24
    506e:	79 f4       	brne	.+30     	; 0x508e <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5070:	e9 81       	ldd	r30, Y+1	; 0x01
    5072:	fa 81       	ldd	r31, Y+2	; 0x02
    5074:	80 85       	ldd	r24, Z+8	; 0x08
    5076:	88 23       	and	r24, r24
    5078:	a1 f0       	breq	.+40     	; 0x50a2 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    507a:	89 81       	ldd	r24, Y+1	; 0x01
    507c:	9a 81       	ldd	r25, Y+2	; 0x02
    507e:	08 96       	adiw	r24, 0x08	; 8
    5080:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    5084:	88 23       	and	r24, r24
    5086:	69 f0       	breq	.+26     	; 0x50a2 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    5088:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
    508c:	0a c0       	rjmp	.+20     	; 0x50a2 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    508e:	89 81       	ldd	r24, Y+1	; 0x01
    5090:	9a 81       	ldd	r25, Y+2	; 0x02
    5092:	08 96       	adiw	r24, 0x08	; 8
    5094:	0e 94 cc 23 	call	0x4798	; 0x4798 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    5098:	89 81       	ldd	r24, Y+1	; 0x01
    509a:	9a 81       	ldd	r25, Y+2	; 0x02
    509c:	41 96       	adiw	r24, 0x11	; 17
    509e:	0e 94 cc 23 	call	0x4798	; 0x4798 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    50a2:	0f 90       	pop	r0
    50a4:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    50a6:	81 e0       	ldi	r24, 0x01	; 1
}
    50a8:	0f 90       	pop	r0
    50aa:	0f 90       	pop	r0
    50ac:	0f 90       	pop	r0
    50ae:	0f 90       	pop	r0
    50b0:	0f 90       	pop	r0
    50b2:	cf 91       	pop	r28
    50b4:	df 91       	pop	r29
    50b6:	08 95       	ret

000050b8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    50b8:	0f 93       	push	r16
    50ba:	1f 93       	push	r17
    50bc:	df 93       	push	r29
    50be:	cf 93       	push	r28
    50c0:	cd b7       	in	r28, 0x3d	; 61
    50c2:	de b7       	in	r29, 0x3e	; 62
    50c4:	29 97       	sbiw	r28, 0x09	; 9
    50c6:	0f b6       	in	r0, 0x3f	; 63
    50c8:	f8 94       	cli
    50ca:	de bf       	out	0x3e, r29	; 62
    50cc:	0f be       	out	0x3f, r0	; 63
    50ce:	cd bf       	out	0x3d, r28	; 61
    50d0:	8f 83       	std	Y+7, r24	; 0x07
    50d2:	68 87       	std	Y+8, r22	; 0x08
    50d4:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    50d6:	88 85       	ldd	r24, Y+8	; 0x08
    50d8:	88 23       	and	r24, r24
    50da:	19 f4       	brne	.+6      	; 0x50e2 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    50dc:	1c 82       	std	Y+4, r1	; 0x04
    50de:	1b 82       	std	Y+3, r1	; 0x03
    50e0:	10 c0       	rjmp	.+32     	; 0x5102 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    50e2:	8f 81       	ldd	r24, Y+7	; 0x07
    50e4:	28 2f       	mov	r18, r24
    50e6:	30 e0       	ldi	r19, 0x00	; 0
    50e8:	88 85       	ldd	r24, Y+8	; 0x08
    50ea:	88 2f       	mov	r24, r24
    50ec:	90 e0       	ldi	r25, 0x00	; 0
    50ee:	ac 01       	movw	r20, r24
    50f0:	24 9f       	mul	r18, r20
    50f2:	c0 01       	movw	r24, r0
    50f4:	25 9f       	mul	r18, r21
    50f6:	90 0d       	add	r25, r0
    50f8:	34 9f       	mul	r19, r20
    50fa:	90 0d       	add	r25, r0
    50fc:	11 24       	eor	r1, r1
    50fe:	9c 83       	std	Y+4, r25	; 0x04
    5100:	8b 83       	std	Y+3, r24	; 0x03
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    5102:	8b 81       	ldd	r24, Y+3	; 0x03
    5104:	9c 81       	ldd	r25, Y+4	; 0x04
    5106:	4f 96       	adiw	r24, 0x1f	; 31
    5108:	0e 94 30 22 	call	0x4460	; 0x4460 <pvPortMalloc>
    510c:	9e 83       	std	Y+6, r25	; 0x06
    510e:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    5110:	8d 81       	ldd	r24, Y+5	; 0x05
    5112:	9e 81       	ldd	r25, Y+6	; 0x06
    5114:	00 97       	sbiw	r24, 0x00	; 0
    5116:	81 f0       	breq	.+32     	; 0x5138 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    5118:	8d 81       	ldd	r24, Y+5	; 0x05
    511a:	9e 81       	ldd	r25, Y+6	; 0x06
    511c:	4f 96       	adiw	r24, 0x1f	; 31
    511e:	9a 83       	std	Y+2, r25	; 0x02
    5120:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    5122:	29 81       	ldd	r18, Y+1	; 0x01
    5124:	3a 81       	ldd	r19, Y+2	; 0x02
    5126:	ed 81       	ldd	r30, Y+5	; 0x05
    5128:	fe 81       	ldd	r31, Y+6	; 0x06
    512a:	8f 81       	ldd	r24, Y+7	; 0x07
    512c:	68 85       	ldd	r22, Y+8	; 0x08
    512e:	a9 01       	movw	r20, r18
    5130:	29 85       	ldd	r18, Y+9	; 0x09
    5132:	8f 01       	movw	r16, r30
    5134:	0e 94 a9 28 	call	0x5152	; 0x5152 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
    5138:	8d 81       	ldd	r24, Y+5	; 0x05
    513a:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    513c:	29 96       	adiw	r28, 0x09	; 9
    513e:	0f b6       	in	r0, 0x3f	; 63
    5140:	f8 94       	cli
    5142:	de bf       	out	0x3e, r29	; 62
    5144:	0f be       	out	0x3f, r0	; 63
    5146:	cd bf       	out	0x3d, r28	; 61
    5148:	cf 91       	pop	r28
    514a:	df 91       	pop	r29
    514c:	1f 91       	pop	r17
    514e:	0f 91       	pop	r16
    5150:	08 95       	ret

00005152 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    5152:	0f 93       	push	r16
    5154:	1f 93       	push	r17
    5156:	df 93       	push	r29
    5158:	cf 93       	push	r28
    515a:	cd b7       	in	r28, 0x3d	; 61
    515c:	de b7       	in	r29, 0x3e	; 62
    515e:	27 97       	sbiw	r28, 0x07	; 7
    5160:	0f b6       	in	r0, 0x3f	; 63
    5162:	f8 94       	cli
    5164:	de bf       	out	0x3e, r29	; 62
    5166:	0f be       	out	0x3f, r0	; 63
    5168:	cd bf       	out	0x3d, r28	; 61
    516a:	89 83       	std	Y+1, r24	; 0x01
    516c:	6a 83       	std	Y+2, r22	; 0x02
    516e:	5c 83       	std	Y+4, r21	; 0x04
    5170:	4b 83       	std	Y+3, r20	; 0x03
    5172:	2d 83       	std	Y+5, r18	; 0x05
    5174:	1f 83       	std	Y+7, r17	; 0x07
    5176:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    5178:	8a 81       	ldd	r24, Y+2	; 0x02
    517a:	88 23       	and	r24, r24
    517c:	39 f4       	brne	.+14     	; 0x518c <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    517e:	8e 81       	ldd	r24, Y+6	; 0x06
    5180:	9f 81       	ldd	r25, Y+7	; 0x07
    5182:	ee 81       	ldd	r30, Y+6	; 0x06
    5184:	ff 81       	ldd	r31, Y+7	; 0x07
    5186:	91 83       	std	Z+1, r25	; 0x01
    5188:	80 83       	st	Z, r24
    518a:	06 c0       	rjmp	.+12     	; 0x5198 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    518c:	8b 81       	ldd	r24, Y+3	; 0x03
    518e:	9c 81       	ldd	r25, Y+4	; 0x04
    5190:	ee 81       	ldd	r30, Y+6	; 0x06
    5192:	ff 81       	ldd	r31, Y+7	; 0x07
    5194:	91 83       	std	Z+1, r25	; 0x01
    5196:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    5198:	ee 81       	ldd	r30, Y+6	; 0x06
    519a:	ff 81       	ldd	r31, Y+7	; 0x07
    519c:	89 81       	ldd	r24, Y+1	; 0x01
    519e:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    51a0:	ee 81       	ldd	r30, Y+6	; 0x06
    51a2:	ff 81       	ldd	r31, Y+7	; 0x07
    51a4:	8a 81       	ldd	r24, Y+2	; 0x02
    51a6:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    51a8:	8e 81       	ldd	r24, Y+6	; 0x06
    51aa:	9f 81       	ldd	r25, Y+7	; 0x07
    51ac:	61 e0       	ldi	r22, 0x01	; 1
    51ae:	0e 94 d6 27 	call	0x4fac	; 0x4fac <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    51b2:	27 96       	adiw	r28, 0x07	; 7
    51b4:	0f b6       	in	r0, 0x3f	; 63
    51b6:	f8 94       	cli
    51b8:	de bf       	out	0x3e, r29	; 62
    51ba:	0f be       	out	0x3f, r0	; 63
    51bc:	cd bf       	out	0x3d, r28	; 61
    51be:	cf 91       	pop	r28
    51c0:	df 91       	pop	r29
    51c2:	1f 91       	pop	r17
    51c4:	0f 91       	pop	r16
    51c6:	08 95       	ret

000051c8 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    51c8:	df 93       	push	r29
    51ca:	cf 93       	push	r28
    51cc:	00 d0       	rcall	.+0      	; 0x51ce <prvInitialiseMutex+0x6>
    51ce:	cd b7       	in	r28, 0x3d	; 61
    51d0:	de b7       	in	r29, 0x3e	; 62
    51d2:	9a 83       	std	Y+2, r25	; 0x02
    51d4:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    51d6:	89 81       	ldd	r24, Y+1	; 0x01
    51d8:	9a 81       	ldd	r25, Y+2	; 0x02
    51da:	00 97       	sbiw	r24, 0x00	; 0
    51dc:	a1 f0       	breq	.+40     	; 0x5206 <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    51de:	e9 81       	ldd	r30, Y+1	; 0x01
    51e0:	fa 81       	ldd	r31, Y+2	; 0x02
    51e2:	13 82       	std	Z+3, r1	; 0x03
    51e4:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    51e6:	e9 81       	ldd	r30, Y+1	; 0x01
    51e8:	fa 81       	ldd	r31, Y+2	; 0x02
    51ea:	11 82       	std	Z+1, r1	; 0x01
    51ec:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    51ee:	e9 81       	ldd	r30, Y+1	; 0x01
    51f0:	fa 81       	ldd	r31, Y+2	; 0x02
    51f2:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    51f4:	89 81       	ldd	r24, Y+1	; 0x01
    51f6:	9a 81       	ldd	r25, Y+2	; 0x02
    51f8:	60 e0       	ldi	r22, 0x00	; 0
    51fa:	70 e0       	ldi	r23, 0x00	; 0
    51fc:	40 e0       	ldi	r20, 0x00	; 0
    51fe:	50 e0       	ldi	r21, 0x00	; 0
    5200:	20 e0       	ldi	r18, 0x00	; 0
    5202:	0e 94 28 29 	call	0x5250	; 0x5250 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    5206:	0f 90       	pop	r0
    5208:	0f 90       	pop	r0
    520a:	cf 91       	pop	r28
    520c:	df 91       	pop	r29
    520e:	08 95       	ret

00005210 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    5210:	df 93       	push	r29
    5212:	cf 93       	push	r28
    5214:	00 d0       	rcall	.+0      	; 0x5216 <xQueueCreateMutex+0x6>
    5216:	00 d0       	rcall	.+0      	; 0x5218 <xQueueCreateMutex+0x8>
    5218:	0f 92       	push	r0
    521a:	cd b7       	in	r28, 0x3d	; 61
    521c:	de b7       	in	r29, 0x3e	; 62
    521e:	8d 83       	std	Y+5, r24	; 0x05
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    5220:	81 e0       	ldi	r24, 0x01	; 1
    5222:	8a 83       	std	Y+2, r24	; 0x02
    5224:	19 82       	std	Y+1, r1	; 0x01

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    5226:	8a 81       	ldd	r24, Y+2	; 0x02
    5228:	69 81       	ldd	r22, Y+1	; 0x01
    522a:	4d 81       	ldd	r20, Y+5	; 0x05
    522c:	0e 94 5c 28 	call	0x50b8	; 0x50b8 <xQueueGenericCreate>
    5230:	9c 83       	std	Y+4, r25	; 0x04
    5232:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( pxNewQueue );
    5234:	8b 81       	ldd	r24, Y+3	; 0x03
    5236:	9c 81       	ldd	r25, Y+4	; 0x04
    5238:	0e 94 e4 28 	call	0x51c8	; 0x51c8 <prvInitialiseMutex>

		return pxNewQueue;
    523c:	8b 81       	ldd	r24, Y+3	; 0x03
    523e:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    5240:	0f 90       	pop	r0
    5242:	0f 90       	pop	r0
    5244:	0f 90       	pop	r0
    5246:	0f 90       	pop	r0
    5248:	0f 90       	pop	r0
    524a:	cf 91       	pop	r28
    524c:	df 91       	pop	r29
    524e:	08 95       	ret

00005250 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    5250:	df 93       	push	r29
    5252:	cf 93       	push	r28
    5254:	cd b7       	in	r28, 0x3d	; 61
    5256:	de b7       	in	r29, 0x3e	; 62
    5258:	2f 97       	sbiw	r28, 0x0f	; 15
    525a:	0f b6       	in	r0, 0x3f	; 63
    525c:	f8 94       	cli
    525e:	de bf       	out	0x3e, r29	; 62
    5260:	0f be       	out	0x3f, r0	; 63
    5262:	cd bf       	out	0x3d, r28	; 61
    5264:	99 87       	std	Y+9, r25	; 0x09
    5266:	88 87       	std	Y+8, r24	; 0x08
    5268:	7b 87       	std	Y+11, r23	; 0x0b
    526a:	6a 87       	std	Y+10, r22	; 0x0a
    526c:	5d 87       	std	Y+13, r21	; 0x0d
    526e:	4c 87       	std	Y+12, r20	; 0x0c
    5270:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    5272:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    5274:	88 85       	ldd	r24, Y+8	; 0x08
    5276:	99 85       	ldd	r25, Y+9	; 0x09
    5278:	9a 83       	std	Y+2, r25	; 0x02
    527a:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    527c:	0f b6       	in	r0, 0x3f	; 63
    527e:	f8 94       	cli
    5280:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    5282:	e9 81       	ldd	r30, Y+1	; 0x01
    5284:	fa 81       	ldd	r31, Y+2	; 0x02
    5286:	92 8d       	ldd	r25, Z+26	; 0x1a
    5288:	e9 81       	ldd	r30, Y+1	; 0x01
    528a:	fa 81       	ldd	r31, Y+2	; 0x02
    528c:	83 8d       	ldd	r24, Z+27	; 0x1b
    528e:	98 17       	cp	r25, r24
    5290:	18 f0       	brcs	.+6      	; 0x5298 <xQueueGenericSend+0x48>
    5292:	8e 85       	ldd	r24, Y+14	; 0x0e
    5294:	82 30       	cpi	r24, 0x02	; 2
    5296:	11 f5       	brne	.+68     	; 0x52dc <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    5298:	89 81       	ldd	r24, Y+1	; 0x01
    529a:	9a 81       	ldd	r25, Y+2	; 0x02
    529c:	2a 85       	ldd	r18, Y+10	; 0x0a
    529e:	3b 85       	ldd	r19, Y+11	; 0x0b
    52a0:	b9 01       	movw	r22, r18
    52a2:	4e 85       	ldd	r20, Y+14	; 0x0e
    52a4:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <prvCopyDataToQueue>
    52a8:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    52aa:	e9 81       	ldd	r30, Y+1	; 0x01
    52ac:	fa 81       	ldd	r31, Y+2	; 0x02
    52ae:	81 89       	ldd	r24, Z+17	; 0x11
    52b0:	88 23       	and	r24, r24
    52b2:	51 f0       	breq	.+20     	; 0x52c8 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    52b4:	89 81       	ldd	r24, Y+1	; 0x01
    52b6:	9a 81       	ldd	r25, Y+2	; 0x02
    52b8:	41 96       	adiw	r24, 0x11	; 17
    52ba:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    52be:	88 23       	and	r24, r24
    52c0:	41 f0       	breq	.+16     	; 0x52d2 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    52c2:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
    52c6:	05 c0       	rjmp	.+10     	; 0x52d2 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    52c8:	8b 81       	ldd	r24, Y+3	; 0x03
    52ca:	88 23       	and	r24, r24
    52cc:	11 f0       	breq	.+4      	; 0x52d2 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    52ce:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    52d2:	0f 90       	pop	r0
    52d4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    52d6:	81 e0       	ldi	r24, 0x01	; 1
    52d8:	8f 87       	std	Y+15, r24	; 0x0f
    52da:	5c c0       	rjmp	.+184    	; 0x5394 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    52dc:	8c 85       	ldd	r24, Y+12	; 0x0c
    52de:	9d 85       	ldd	r25, Y+13	; 0x0d
    52e0:	00 97       	sbiw	r24, 0x00	; 0
    52e2:	21 f4       	brne	.+8      	; 0x52ec <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    52e4:	0f 90       	pop	r0
    52e6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    52e8:	1f 86       	std	Y+15, r1	; 0x0f
    52ea:	54 c0       	rjmp	.+168    	; 0x5394 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    52ec:	8c 81       	ldd	r24, Y+4	; 0x04
    52ee:	88 23       	and	r24, r24
    52f0:	31 f4       	brne	.+12     	; 0x52fe <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    52f2:	ce 01       	movw	r24, r28
    52f4:	05 96       	adiw	r24, 0x05	; 5
    52f6:	0e 94 93 36 	call	0x6d26	; 0x6d26 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    52fa:	81 e0       	ldi	r24, 0x01	; 1
    52fc:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    52fe:	0f 90       	pop	r0
    5300:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5302:	0e 94 3c 33 	call	0x6678	; 0x6678 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5306:	0f b6       	in	r0, 0x3f	; 63
    5308:	f8 94       	cli
    530a:	0f 92       	push	r0
    530c:	e9 81       	ldd	r30, Y+1	; 0x01
    530e:	fa 81       	ldd	r31, Y+2	; 0x02
    5310:	85 8d       	ldd	r24, Z+29	; 0x1d
    5312:	8f 3f       	cpi	r24, 0xFF	; 255
    5314:	19 f4       	brne	.+6      	; 0x531c <xQueueGenericSend+0xcc>
    5316:	e9 81       	ldd	r30, Y+1	; 0x01
    5318:	fa 81       	ldd	r31, Y+2	; 0x02
    531a:	15 8e       	std	Z+29, r1	; 0x1d
    531c:	e9 81       	ldd	r30, Y+1	; 0x01
    531e:	fa 81       	ldd	r31, Y+2	; 0x02
    5320:	86 8d       	ldd	r24, Z+30	; 0x1e
    5322:	8f 3f       	cpi	r24, 0xFF	; 255
    5324:	19 f4       	brne	.+6      	; 0x532c <xQueueGenericSend+0xdc>
    5326:	e9 81       	ldd	r30, Y+1	; 0x01
    5328:	fa 81       	ldd	r31, Y+2	; 0x02
    532a:	16 8e       	std	Z+30, r1	; 0x1e
    532c:	0f 90       	pop	r0
    532e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5330:	ce 01       	movw	r24, r28
    5332:	05 96       	adiw	r24, 0x05	; 5
    5334:	9e 01       	movw	r18, r28
    5336:	24 5f       	subi	r18, 0xF4	; 244
    5338:	3f 4f       	sbci	r19, 0xFF	; 255
    533a:	b9 01       	movw	r22, r18
    533c:	0e 94 ac 36 	call	0x6d58	; 0x6d58 <xTaskCheckForTimeOut>
    5340:	88 23       	and	r24, r24
    5342:	09 f5       	brne	.+66     	; 0x5386 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5344:	89 81       	ldd	r24, Y+1	; 0x01
    5346:	9a 81       	ldd	r25, Y+2	; 0x02
    5348:	0e 94 e3 2d 	call	0x5bc6	; 0x5bc6 <prvIsQueueFull>
    534c:	88 23       	and	r24, r24
    534e:	a1 f0       	breq	.+40     	; 0x5378 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5350:	89 81       	ldd	r24, Y+1	; 0x01
    5352:	9a 81       	ldd	r25, Y+2	; 0x02
    5354:	08 96       	adiw	r24, 0x08	; 8
    5356:	2c 85       	ldd	r18, Y+12	; 0x0c
    5358:	3d 85       	ldd	r19, Y+13	; 0x0d
    535a:	b9 01       	movw	r22, r18
    535c:	0e 94 71 35 	call	0x6ae2	; 0x6ae2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    5360:	89 81       	ldd	r24, Y+1	; 0x01
    5362:	9a 81       	ldd	r25, Y+2	; 0x02
    5364:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5368:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>
    536c:	88 23       	and	r24, r24
    536e:	09 f0       	breq	.+2      	; 0x5372 <xQueueGenericSend+0x122>
    5370:	85 cf       	rjmp	.-246    	; 0x527c <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    5372:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
    5376:	82 cf       	rjmp	.-252    	; 0x527c <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5378:	89 81       	ldd	r24, Y+1	; 0x01
    537a:	9a 81       	ldd	r25, Y+2	; 0x02
    537c:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5380:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>
    5384:	7b cf       	rjmp	.-266    	; 0x527c <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5386:	89 81       	ldd	r24, Y+1	; 0x01
    5388:	9a 81       	ldd	r25, Y+2	; 0x02
    538a:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    538e:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5392:	1f 86       	std	Y+15, r1	; 0x0f
    5394:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    5396:	2f 96       	adiw	r28, 0x0f	; 15
    5398:	0f b6       	in	r0, 0x3f	; 63
    539a:	f8 94       	cli
    539c:	de bf       	out	0x3e, r29	; 62
    539e:	0f be       	out	0x3f, r0	; 63
    53a0:	cd bf       	out	0x3d, r28	; 61
    53a2:	cf 91       	pop	r28
    53a4:	df 91       	pop	r29
    53a6:	08 95       	ret

000053a8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    53a8:	df 93       	push	r29
    53aa:	cf 93       	push	r28
    53ac:	cd b7       	in	r28, 0x3d	; 61
    53ae:	de b7       	in	r29, 0x3e	; 62
    53b0:	2c 97       	sbiw	r28, 0x0c	; 12
    53b2:	0f b6       	in	r0, 0x3f	; 63
    53b4:	f8 94       	cli
    53b6:	de bf       	out	0x3e, r29	; 62
    53b8:	0f be       	out	0x3f, r0	; 63
    53ba:	cd bf       	out	0x3d, r28	; 61
    53bc:	9f 83       	std	Y+7, r25	; 0x07
    53be:	8e 83       	std	Y+6, r24	; 0x06
    53c0:	79 87       	std	Y+9, r23	; 0x09
    53c2:	68 87       	std	Y+8, r22	; 0x08
    53c4:	5b 87       	std	Y+11, r21	; 0x0b
    53c6:	4a 87       	std	Y+10, r20	; 0x0a
    53c8:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    53ca:	8e 81       	ldd	r24, Y+6	; 0x06
    53cc:	9f 81       	ldd	r25, Y+7	; 0x07
    53ce:	9b 83       	std	Y+3, r25	; 0x03
    53d0:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    53d2:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    53d4:	ea 81       	ldd	r30, Y+2	; 0x02
    53d6:	fb 81       	ldd	r31, Y+3	; 0x03
    53d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    53da:	ea 81       	ldd	r30, Y+2	; 0x02
    53dc:	fb 81       	ldd	r31, Y+3	; 0x03
    53de:	83 8d       	ldd	r24, Z+27	; 0x1b
    53e0:	98 17       	cp	r25, r24
    53e2:	18 f0       	brcs	.+6      	; 0x53ea <xQueueGenericSendFromISR+0x42>
    53e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    53e6:	82 30       	cpi	r24, 0x02	; 2
    53e8:	61 f5       	brne	.+88     	; 0x5442 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    53ea:	ea 81       	ldd	r30, Y+2	; 0x02
    53ec:	fb 81       	ldd	r31, Y+3	; 0x03
    53ee:	86 8d       	ldd	r24, Z+30	; 0x1e
    53f0:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    53f2:	8a 81       	ldd	r24, Y+2	; 0x02
    53f4:	9b 81       	ldd	r25, Y+3	; 0x03
    53f6:	28 85       	ldd	r18, Y+8	; 0x08
    53f8:	39 85       	ldd	r19, Y+9	; 0x09
    53fa:	b9 01       	movw	r22, r18
    53fc:	4c 85       	ldd	r20, Y+12	; 0x0c
    53fe:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    5402:	89 81       	ldd	r24, Y+1	; 0x01
    5404:	8f 3f       	cpi	r24, 0xFF	; 255
    5406:	a9 f4       	brne	.+42     	; 0x5432 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5408:	ea 81       	ldd	r30, Y+2	; 0x02
    540a:	fb 81       	ldd	r31, Y+3	; 0x03
    540c:	81 89       	ldd	r24, Z+17	; 0x11
    540e:	88 23       	and	r24, r24
    5410:	a9 f0       	breq	.+42     	; 0x543c <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5412:	8a 81       	ldd	r24, Y+2	; 0x02
    5414:	9b 81       	ldd	r25, Y+3	; 0x03
    5416:	41 96       	adiw	r24, 0x11	; 17
    5418:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    541c:	88 23       	and	r24, r24
    541e:	71 f0       	breq	.+28     	; 0x543c <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    5420:	8a 85       	ldd	r24, Y+10	; 0x0a
    5422:	9b 85       	ldd	r25, Y+11	; 0x0b
    5424:	00 97       	sbiw	r24, 0x00	; 0
    5426:	51 f0       	breq	.+20     	; 0x543c <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    5428:	ea 85       	ldd	r30, Y+10	; 0x0a
    542a:	fb 85       	ldd	r31, Y+11	; 0x0b
    542c:	81 e0       	ldi	r24, 0x01	; 1
    542e:	80 83       	st	Z, r24
    5430:	05 c0       	rjmp	.+10     	; 0x543c <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    5432:	89 81       	ldd	r24, Y+1	; 0x01
    5434:	8f 5f       	subi	r24, 0xFF	; 255
    5436:	ea 81       	ldd	r30, Y+2	; 0x02
    5438:	fb 81       	ldd	r31, Y+3	; 0x03
    543a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    543c:	81 e0       	ldi	r24, 0x01	; 1
    543e:	8d 83       	std	Y+5, r24	; 0x05
    5440:	01 c0       	rjmp	.+2      	; 0x5444 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5442:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5444:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5446:	2c 96       	adiw	r28, 0x0c	; 12
    5448:	0f b6       	in	r0, 0x3f	; 63
    544a:	f8 94       	cli
    544c:	de bf       	out	0x3e, r29	; 62
    544e:	0f be       	out	0x3f, r0	; 63
    5450:	cd bf       	out	0x3d, r28	; 61
    5452:	cf 91       	pop	r28
    5454:	df 91       	pop	r29
    5456:	08 95       	ret

00005458 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    5458:	df 93       	push	r29
    545a:	cf 93       	push	r28
    545c:	cd b7       	in	r28, 0x3d	; 61
    545e:	de b7       	in	r29, 0x3e	; 62
    5460:	2a 97       	sbiw	r28, 0x0a	; 10
    5462:	0f b6       	in	r0, 0x3f	; 63
    5464:	f8 94       	cli
    5466:	de bf       	out	0x3e, r29	; 62
    5468:	0f be       	out	0x3f, r0	; 63
    546a:	cd bf       	out	0x3d, r28	; 61
    546c:	98 87       	std	Y+8, r25	; 0x08
    546e:	8f 83       	std	Y+7, r24	; 0x07
    5470:	7a 87       	std	Y+10, r23	; 0x0a
    5472:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    5474:	8f 81       	ldd	r24, Y+7	; 0x07
    5476:	98 85       	ldd	r25, Y+8	; 0x08
    5478:	9c 83       	std	Y+4, r25	; 0x04
    547a:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    547c:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    547e:	eb 81       	ldd	r30, Y+3	; 0x03
    5480:	fc 81       	ldd	r31, Y+4	; 0x04
    5482:	82 8d       	ldd	r24, Z+26	; 0x1a
    5484:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    5486:	eb 81       	ldd	r30, Y+3	; 0x03
    5488:	fc 81       	ldd	r31, Y+4	; 0x04
    548a:	93 8d       	ldd	r25, Z+27	; 0x1b
    548c:	8a 81       	ldd	r24, Y+2	; 0x02
    548e:	89 17       	cp	r24, r25
    5490:	48 f5       	brcc	.+82     	; 0x54e4 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    5492:	eb 81       	ldd	r30, Y+3	; 0x03
    5494:	fc 81       	ldd	r31, Y+4	; 0x04
    5496:	86 8d       	ldd	r24, Z+30	; 0x1e
    5498:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    549a:	8a 81       	ldd	r24, Y+2	; 0x02
    549c:	8f 5f       	subi	r24, 0xFF	; 255
    549e:	eb 81       	ldd	r30, Y+3	; 0x03
    54a0:	fc 81       	ldd	r31, Y+4	; 0x04
    54a2:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    54a4:	89 81       	ldd	r24, Y+1	; 0x01
    54a6:	8f 3f       	cpi	r24, 0xFF	; 255
    54a8:	a9 f4       	brne	.+42     	; 0x54d4 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    54aa:	eb 81       	ldd	r30, Y+3	; 0x03
    54ac:	fc 81       	ldd	r31, Y+4	; 0x04
    54ae:	81 89       	ldd	r24, Z+17	; 0x11
    54b0:	88 23       	and	r24, r24
    54b2:	a9 f0       	breq	.+42     	; 0x54de <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    54b4:	8b 81       	ldd	r24, Y+3	; 0x03
    54b6:	9c 81       	ldd	r25, Y+4	; 0x04
    54b8:	41 96       	adiw	r24, 0x11	; 17
    54ba:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    54be:	88 23       	and	r24, r24
    54c0:	71 f0       	breq	.+28     	; 0x54de <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    54c2:	89 85       	ldd	r24, Y+9	; 0x09
    54c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    54c6:	00 97       	sbiw	r24, 0x00	; 0
    54c8:	51 f0       	breq	.+20     	; 0x54de <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    54ca:	e9 85       	ldd	r30, Y+9	; 0x09
    54cc:	fa 85       	ldd	r31, Y+10	; 0x0a
    54ce:	81 e0       	ldi	r24, 0x01	; 1
    54d0:	80 83       	st	Z, r24
    54d2:	05 c0       	rjmp	.+10     	; 0x54de <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    54d4:	89 81       	ldd	r24, Y+1	; 0x01
    54d6:	8f 5f       	subi	r24, 0xFF	; 255
    54d8:	eb 81       	ldd	r30, Y+3	; 0x03
    54da:	fc 81       	ldd	r31, Y+4	; 0x04
    54dc:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    54de:	81 e0       	ldi	r24, 0x01	; 1
    54e0:	8e 83       	std	Y+6, r24	; 0x06
    54e2:	01 c0       	rjmp	.+2      	; 0x54e6 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    54e4:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    54e6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    54e8:	2a 96       	adiw	r28, 0x0a	; 10
    54ea:	0f b6       	in	r0, 0x3f	; 63
    54ec:	f8 94       	cli
    54ee:	de bf       	out	0x3e, r29	; 62
    54f0:	0f be       	out	0x3f, r0	; 63
    54f2:	cd bf       	out	0x3d, r28	; 61
    54f4:	cf 91       	pop	r28
    54f6:	df 91       	pop	r29
    54f8:	08 95       	ret

000054fa <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    54fa:	df 93       	push	r29
    54fc:	cf 93       	push	r28
    54fe:	cd b7       	in	r28, 0x3d	; 61
    5500:	de b7       	in	r29, 0x3e	; 62
    5502:	61 97       	sbiw	r28, 0x11	; 17
    5504:	0f b6       	in	r0, 0x3f	; 63
    5506:	f8 94       	cli
    5508:	de bf       	out	0x3e, r29	; 62
    550a:	0f be       	out	0x3f, r0	; 63
    550c:	cd bf       	out	0x3d, r28	; 61
    550e:	9b 87       	std	Y+11, r25	; 0x0b
    5510:	8a 87       	std	Y+10, r24	; 0x0a
    5512:	7d 87       	std	Y+13, r23	; 0x0d
    5514:	6c 87       	std	Y+12, r22	; 0x0c
    5516:	5f 87       	std	Y+15, r21	; 0x0f
    5518:	4e 87       	std	Y+14, r20	; 0x0e
    551a:	28 8b       	std	Y+16, r18	; 0x10
BaseType_t xEntryTimeSet = pdFALSE;
    551c:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    551e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5520:	9b 85       	ldd	r25, Y+11	; 0x0b
    5522:	9b 83       	std	Y+3, r25	; 0x03
    5524:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    5526:	0f b6       	in	r0, 0x3f	; 63
    5528:	f8 94       	cli
    552a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    552c:	ea 81       	ldd	r30, Y+2	; 0x02
    552e:	fb 81       	ldd	r31, Y+3	; 0x03
    5530:	82 8d       	ldd	r24, Z+26	; 0x1a
    5532:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    5534:	89 81       	ldd	r24, Y+1	; 0x01
    5536:	88 23       	and	r24, r24
    5538:	09 f4       	brne	.+2      	; 0x553c <xQueueGenericReceive+0x42>
    553a:	49 c0       	rjmp	.+146    	; 0x55ce <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    553c:	ea 81       	ldd	r30, Y+2	; 0x02
    553e:	fb 81       	ldd	r31, Y+3	; 0x03
    5540:	86 81       	ldd	r24, Z+6	; 0x06
    5542:	97 81       	ldd	r25, Z+7	; 0x07
    5544:	9d 83       	std	Y+5, r25	; 0x05
    5546:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5548:	8a 81       	ldd	r24, Y+2	; 0x02
    554a:	9b 81       	ldd	r25, Y+3	; 0x03
    554c:	2c 85       	ldd	r18, Y+12	; 0x0c
    554e:	3d 85       	ldd	r19, Y+13	; 0x0d
    5550:	b9 01       	movw	r22, r18
    5552:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    5556:	88 89       	ldd	r24, Y+16	; 0x10
    5558:	88 23       	and	r24, r24
    555a:	01 f5       	brne	.+64     	; 0x559c <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    555c:	89 81       	ldd	r24, Y+1	; 0x01
    555e:	81 50       	subi	r24, 0x01	; 1
    5560:	ea 81       	ldd	r30, Y+2	; 0x02
    5562:	fb 81       	ldd	r31, Y+3	; 0x03
    5564:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    5566:	ea 81       	ldd	r30, Y+2	; 0x02
    5568:	fb 81       	ldd	r31, Y+3	; 0x03
    556a:	80 81       	ld	r24, Z
    556c:	91 81       	ldd	r25, Z+1	; 0x01
    556e:	00 97       	sbiw	r24, 0x00	; 0
    5570:	31 f4       	brne	.+12     	; 0x557e <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    5572:	0e 94 24 39 	call	0x7248	; 0x7248 <pvTaskIncrementMutexHeldCount>
    5576:	ea 81       	ldd	r30, Y+2	; 0x02
    5578:	fb 81       	ldd	r31, Y+3	; 0x03
    557a:	93 83       	std	Z+3, r25	; 0x03
    557c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    557e:	ea 81       	ldd	r30, Y+2	; 0x02
    5580:	fb 81       	ldd	r31, Y+3	; 0x03
    5582:	80 85       	ldd	r24, Z+8	; 0x08
    5584:	88 23       	and	r24, r24
    5586:	f1 f0       	breq	.+60     	; 0x55c4 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5588:	8a 81       	ldd	r24, Y+2	; 0x02
    558a:	9b 81       	ldd	r25, Y+3	; 0x03
    558c:	08 96       	adiw	r24, 0x08	; 8
    558e:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    5592:	88 23       	and	r24, r24
    5594:	b9 f0       	breq	.+46     	; 0x55c4 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    5596:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
    559a:	14 c0       	rjmp	.+40     	; 0x55c4 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    559c:	ea 81       	ldd	r30, Y+2	; 0x02
    559e:	fb 81       	ldd	r31, Y+3	; 0x03
    55a0:	8c 81       	ldd	r24, Y+4	; 0x04
    55a2:	9d 81       	ldd	r25, Y+5	; 0x05
    55a4:	97 83       	std	Z+7, r25	; 0x07
    55a6:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    55a8:	ea 81       	ldd	r30, Y+2	; 0x02
    55aa:	fb 81       	ldd	r31, Y+3	; 0x03
    55ac:	81 89       	ldd	r24, Z+17	; 0x11
    55ae:	88 23       	and	r24, r24
    55b0:	49 f0       	breq	.+18     	; 0x55c4 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    55b2:	8a 81       	ldd	r24, Y+2	; 0x02
    55b4:	9b 81       	ldd	r25, Y+3	; 0x03
    55b6:	41 96       	adiw	r24, 0x11	; 17
    55b8:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    55bc:	88 23       	and	r24, r24
    55be:	11 f0       	breq	.+4      	; 0x55c4 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    55c0:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    55c4:	0f 90       	pop	r0
    55c6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    55c8:	81 e0       	ldi	r24, 0x01	; 1
    55ca:	89 8b       	std	Y+17, r24	; 0x11
    55cc:	74 c0       	rjmp	.+232    	; 0x56b6 <xQueueGenericReceive+0x1bc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    55ce:	8e 85       	ldd	r24, Y+14	; 0x0e
    55d0:	9f 85       	ldd	r25, Y+15	; 0x0f
    55d2:	00 97       	sbiw	r24, 0x00	; 0
    55d4:	21 f4       	brne	.+8      	; 0x55de <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    55d6:	0f 90       	pop	r0
    55d8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    55da:	19 8a       	std	Y+17, r1	; 0x11
    55dc:	6c c0       	rjmp	.+216    	; 0x56b6 <xQueueGenericReceive+0x1bc>
				}
				else if( xEntryTimeSet == pdFALSE )
    55de:	8e 81       	ldd	r24, Y+6	; 0x06
    55e0:	88 23       	and	r24, r24
    55e2:	31 f4       	brne	.+12     	; 0x55f0 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    55e4:	ce 01       	movw	r24, r28
    55e6:	07 96       	adiw	r24, 0x07	; 7
    55e8:	0e 94 93 36 	call	0x6d26	; 0x6d26 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    55ec:	81 e0       	ldi	r24, 0x01	; 1
    55ee:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    55f0:	0f 90       	pop	r0
    55f2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    55f4:	0e 94 3c 33 	call	0x6678	; 0x6678 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    55f8:	0f b6       	in	r0, 0x3f	; 63
    55fa:	f8 94       	cli
    55fc:	0f 92       	push	r0
    55fe:	ea 81       	ldd	r30, Y+2	; 0x02
    5600:	fb 81       	ldd	r31, Y+3	; 0x03
    5602:	85 8d       	ldd	r24, Z+29	; 0x1d
    5604:	8f 3f       	cpi	r24, 0xFF	; 255
    5606:	19 f4       	brne	.+6      	; 0x560e <xQueueGenericReceive+0x114>
    5608:	ea 81       	ldd	r30, Y+2	; 0x02
    560a:	fb 81       	ldd	r31, Y+3	; 0x03
    560c:	15 8e       	std	Z+29, r1	; 0x1d
    560e:	ea 81       	ldd	r30, Y+2	; 0x02
    5610:	fb 81       	ldd	r31, Y+3	; 0x03
    5612:	86 8d       	ldd	r24, Z+30	; 0x1e
    5614:	8f 3f       	cpi	r24, 0xFF	; 255
    5616:	19 f4       	brne	.+6      	; 0x561e <xQueueGenericReceive+0x124>
    5618:	ea 81       	ldd	r30, Y+2	; 0x02
    561a:	fb 81       	ldd	r31, Y+3	; 0x03
    561c:	16 8e       	std	Z+30, r1	; 0x1e
    561e:	0f 90       	pop	r0
    5620:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5622:	ce 01       	movw	r24, r28
    5624:	07 96       	adiw	r24, 0x07	; 7
    5626:	9e 01       	movw	r18, r28
    5628:	22 5f       	subi	r18, 0xF2	; 242
    562a:	3f 4f       	sbci	r19, 0xFF	; 255
    562c:	b9 01       	movw	r22, r18
    562e:	0e 94 ac 36 	call	0x6d58	; 0x6d58 <xTaskCheckForTimeOut>
    5632:	88 23       	and	r24, r24
    5634:	91 f5       	brne	.+100    	; 0x569a <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5636:	8a 81       	ldd	r24, Y+2	; 0x02
    5638:	9b 81       	ldd	r25, Y+3	; 0x03
    563a:	0e 94 ae 2d 	call	0x5b5c	; 0x5b5c <prvIsQueueEmpty>
    563e:	88 23       	and	r24, r24
    5640:	29 f1       	breq	.+74     	; 0x568c <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    5642:	ea 81       	ldd	r30, Y+2	; 0x02
    5644:	fb 81       	ldd	r31, Y+3	; 0x03
    5646:	80 81       	ld	r24, Z
    5648:	91 81       	ldd	r25, Z+1	; 0x01
    564a:	00 97       	sbiw	r24, 0x00	; 0
    564c:	59 f4       	brne	.+22     	; 0x5664 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    564e:	0f b6       	in	r0, 0x3f	; 63
    5650:	f8 94       	cli
    5652:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    5654:	ea 81       	ldd	r30, Y+2	; 0x02
    5656:	fb 81       	ldd	r31, Y+3	; 0x03
    5658:	82 81       	ldd	r24, Z+2	; 0x02
    565a:	93 81       	ldd	r25, Z+3	; 0x03
    565c:	0e 94 00 38 	call	0x7000	; 0x7000 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    5660:	0f 90       	pop	r0
    5662:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5664:	8a 81       	ldd	r24, Y+2	; 0x02
    5666:	9b 81       	ldd	r25, Y+3	; 0x03
    5668:	41 96       	adiw	r24, 0x11	; 17
    566a:	2e 85       	ldd	r18, Y+14	; 0x0e
    566c:	3f 85       	ldd	r19, Y+15	; 0x0f
    566e:	b9 01       	movw	r22, r18
    5670:	0e 94 71 35 	call	0x6ae2	; 0x6ae2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    5674:	8a 81       	ldd	r24, Y+2	; 0x02
    5676:	9b 81       	ldd	r25, Y+3	; 0x03
    5678:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    567c:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>
    5680:	88 23       	and	r24, r24
    5682:	09 f0       	breq	.+2      	; 0x5686 <xQueueGenericReceive+0x18c>
    5684:	50 cf       	rjmp	.-352    	; 0x5526 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    5686:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
    568a:	4d cf       	rjmp	.-358    	; 0x5526 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    568c:	8a 81       	ldd	r24, Y+2	; 0x02
    568e:	9b 81       	ldd	r25, Y+3	; 0x03
    5690:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5694:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>
    5698:	46 cf       	rjmp	.-372    	; 0x5526 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    569a:	8a 81       	ldd	r24, Y+2	; 0x02
    569c:	9b 81       	ldd	r25, Y+3	; 0x03
    569e:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    56a2:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    56a6:	8a 81       	ldd	r24, Y+2	; 0x02
    56a8:	9b 81       	ldd	r25, Y+3	; 0x03
    56aa:	0e 94 ae 2d 	call	0x5b5c	; 0x5b5c <prvIsQueueEmpty>
    56ae:	88 23       	and	r24, r24
    56b0:	09 f4       	brne	.+2      	; 0x56b4 <xQueueGenericReceive+0x1ba>
    56b2:	39 cf       	rjmp	.-398    	; 0x5526 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    56b4:	19 8a       	std	Y+17, r1	; 0x11
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    56b6:	89 89       	ldd	r24, Y+17	; 0x11
}
    56b8:	61 96       	adiw	r28, 0x11	; 17
    56ba:	0f b6       	in	r0, 0x3f	; 63
    56bc:	f8 94       	cli
    56be:	de bf       	out	0x3e, r29	; 62
    56c0:	0f be       	out	0x3f, r0	; 63
    56c2:	cd bf       	out	0x3d, r28	; 61
    56c4:	cf 91       	pop	r28
    56c6:	df 91       	pop	r29
    56c8:	08 95       	ret

000056ca <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    56ca:	df 93       	push	r29
    56cc:	cf 93       	push	r28
    56ce:	cd b7       	in	r28, 0x3d	; 61
    56d0:	de b7       	in	r29, 0x3e	; 62
    56d2:	2c 97       	sbiw	r28, 0x0c	; 12
    56d4:	0f b6       	in	r0, 0x3f	; 63
    56d6:	f8 94       	cli
    56d8:	de bf       	out	0x3e, r29	; 62
    56da:	0f be       	out	0x3f, r0	; 63
    56dc:	cd bf       	out	0x3d, r28	; 61
    56de:	98 87       	std	Y+8, r25	; 0x08
    56e0:	8f 83       	std	Y+7, r24	; 0x07
    56e2:	7a 87       	std	Y+10, r23	; 0x0a
    56e4:	69 87       	std	Y+9, r22	; 0x09
    56e6:	5c 87       	std	Y+12, r21	; 0x0c
    56e8:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    56ea:	8f 81       	ldd	r24, Y+7	; 0x07
    56ec:	98 85       	ldd	r25, Y+8	; 0x08
    56ee:	9c 83       	std	Y+4, r25	; 0x04
    56f0:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    56f2:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    56f4:	eb 81       	ldd	r30, Y+3	; 0x03
    56f6:	fc 81       	ldd	r31, Y+4	; 0x04
    56f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    56fa:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    56fc:	8a 81       	ldd	r24, Y+2	; 0x02
    56fe:	88 23       	and	r24, r24
    5700:	81 f1       	breq	.+96     	; 0x5762 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    5702:	eb 81       	ldd	r30, Y+3	; 0x03
    5704:	fc 81       	ldd	r31, Y+4	; 0x04
    5706:	85 8d       	ldd	r24, Z+29	; 0x1d
    5708:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    570a:	8b 81       	ldd	r24, Y+3	; 0x03
    570c:	9c 81       	ldd	r25, Y+4	; 0x04
    570e:	29 85       	ldd	r18, Y+9	; 0x09
    5710:	3a 85       	ldd	r19, Y+10	; 0x0a
    5712:	b9 01       	movw	r22, r18
    5714:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    5718:	8a 81       	ldd	r24, Y+2	; 0x02
    571a:	81 50       	subi	r24, 0x01	; 1
    571c:	eb 81       	ldd	r30, Y+3	; 0x03
    571e:	fc 81       	ldd	r31, Y+4	; 0x04
    5720:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    5722:	89 81       	ldd	r24, Y+1	; 0x01
    5724:	8f 3f       	cpi	r24, 0xFF	; 255
    5726:	a9 f4       	brne	.+42     	; 0x5752 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5728:	eb 81       	ldd	r30, Y+3	; 0x03
    572a:	fc 81       	ldd	r31, Y+4	; 0x04
    572c:	80 85       	ldd	r24, Z+8	; 0x08
    572e:	88 23       	and	r24, r24
    5730:	a9 f0       	breq	.+42     	; 0x575c <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5732:	8b 81       	ldd	r24, Y+3	; 0x03
    5734:	9c 81       	ldd	r25, Y+4	; 0x04
    5736:	08 96       	adiw	r24, 0x08	; 8
    5738:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    573c:	88 23       	and	r24, r24
    573e:	71 f0       	breq	.+28     	; 0x575c <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    5740:	8b 85       	ldd	r24, Y+11	; 0x0b
    5742:	9c 85       	ldd	r25, Y+12	; 0x0c
    5744:	00 97       	sbiw	r24, 0x00	; 0
    5746:	51 f0       	breq	.+20     	; 0x575c <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    5748:	eb 85       	ldd	r30, Y+11	; 0x0b
    574a:	fc 85       	ldd	r31, Y+12	; 0x0c
    574c:	81 e0       	ldi	r24, 0x01	; 1
    574e:	80 83       	st	Z, r24
    5750:	05 c0       	rjmp	.+10     	; 0x575c <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    5752:	89 81       	ldd	r24, Y+1	; 0x01
    5754:	8f 5f       	subi	r24, 0xFF	; 255
    5756:	eb 81       	ldd	r30, Y+3	; 0x03
    5758:	fc 81       	ldd	r31, Y+4	; 0x04
    575a:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    575c:	81 e0       	ldi	r24, 0x01	; 1
    575e:	8e 83       	std	Y+6, r24	; 0x06
    5760:	01 c0       	rjmp	.+2      	; 0x5764 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    5762:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5764:	8e 81       	ldd	r24, Y+6	; 0x06
}
    5766:	2c 96       	adiw	r28, 0x0c	; 12
    5768:	0f b6       	in	r0, 0x3f	; 63
    576a:	f8 94       	cli
    576c:	de bf       	out	0x3e, r29	; 62
    576e:	0f be       	out	0x3f, r0	; 63
    5770:	cd bf       	out	0x3d, r28	; 61
    5772:	cf 91       	pop	r28
    5774:	df 91       	pop	r29
    5776:	08 95       	ret

00005778 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    5778:	df 93       	push	r29
    577a:	cf 93       	push	r28
    577c:	cd b7       	in	r28, 0x3d	; 61
    577e:	de b7       	in	r29, 0x3e	; 62
    5780:	2a 97       	sbiw	r28, 0x0a	; 10
    5782:	0f b6       	in	r0, 0x3f	; 63
    5784:	f8 94       	cli
    5786:	de bf       	out	0x3e, r29	; 62
    5788:	0f be       	out	0x3f, r0	; 63
    578a:	cd bf       	out	0x3d, r28	; 61
    578c:	98 87       	std	Y+8, r25	; 0x08
    578e:	8f 83       	std	Y+7, r24	; 0x07
    5790:	7a 87       	std	Y+10, r23	; 0x0a
    5792:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    5794:	8f 81       	ldd	r24, Y+7	; 0x07
    5796:	98 85       	ldd	r25, Y+8	; 0x08
    5798:	9a 83       	std	Y+2, r25	; 0x02
    579a:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    579c:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    579e:	e9 81       	ldd	r30, Y+1	; 0x01
    57a0:	fa 81       	ldd	r31, Y+2	; 0x02
    57a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    57a4:	88 23       	and	r24, r24
    57a6:	b1 f0       	breq	.+44     	; 0x57d4 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    57a8:	e9 81       	ldd	r30, Y+1	; 0x01
    57aa:	fa 81       	ldd	r31, Y+2	; 0x02
    57ac:	86 81       	ldd	r24, Z+6	; 0x06
    57ae:	97 81       	ldd	r25, Z+7	; 0x07
    57b0:	9c 83       	std	Y+4, r25	; 0x04
    57b2:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    57b4:	89 81       	ldd	r24, Y+1	; 0x01
    57b6:	9a 81       	ldd	r25, Y+2	; 0x02
    57b8:	29 85       	ldd	r18, Y+9	; 0x09
    57ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    57bc:	b9 01       	movw	r22, r18
    57be:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    57c2:	e9 81       	ldd	r30, Y+1	; 0x01
    57c4:	fa 81       	ldd	r31, Y+2	; 0x02
    57c6:	8b 81       	ldd	r24, Y+3	; 0x03
    57c8:	9c 81       	ldd	r25, Y+4	; 0x04
    57ca:	97 83       	std	Z+7, r25	; 0x07
    57cc:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    57ce:	81 e0       	ldi	r24, 0x01	; 1
    57d0:	8e 83       	std	Y+6, r24	; 0x06
    57d2:	01 c0       	rjmp	.+2      	; 0x57d6 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    57d4:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    57d6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    57d8:	2a 96       	adiw	r28, 0x0a	; 10
    57da:	0f b6       	in	r0, 0x3f	; 63
    57dc:	f8 94       	cli
    57de:	de bf       	out	0x3e, r29	; 62
    57e0:	0f be       	out	0x3f, r0	; 63
    57e2:	cd bf       	out	0x3d, r28	; 61
    57e4:	cf 91       	pop	r28
    57e6:	df 91       	pop	r29
    57e8:	08 95       	ret

000057ea <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    57ea:	df 93       	push	r29
    57ec:	cf 93       	push	r28
    57ee:	00 d0       	rcall	.+0      	; 0x57f0 <uxQueueMessagesWaiting+0x6>
    57f0:	0f 92       	push	r0
    57f2:	cd b7       	in	r28, 0x3d	; 61
    57f4:	de b7       	in	r29, 0x3e	; 62
    57f6:	9b 83       	std	Y+3, r25	; 0x03
    57f8:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    57fa:	0f b6       	in	r0, 0x3f	; 63
    57fc:	f8 94       	cli
    57fe:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    5800:	ea 81       	ldd	r30, Y+2	; 0x02
    5802:	fb 81       	ldd	r31, Y+3	; 0x03
    5804:	82 8d       	ldd	r24, Z+26	; 0x1a
    5806:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5808:	0f 90       	pop	r0
    580a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    580c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    580e:	0f 90       	pop	r0
    5810:	0f 90       	pop	r0
    5812:	0f 90       	pop	r0
    5814:	cf 91       	pop	r28
    5816:	df 91       	pop	r29
    5818:	08 95       	ret

0000581a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    581a:	df 93       	push	r29
    581c:	cf 93       	push	r28
    581e:	00 d0       	rcall	.+0      	; 0x5820 <uxQueueSpacesAvailable+0x6>
    5820:	00 d0       	rcall	.+0      	; 0x5822 <uxQueueSpacesAvailable+0x8>
    5822:	0f 92       	push	r0
    5824:	cd b7       	in	r28, 0x3d	; 61
    5826:	de b7       	in	r29, 0x3e	; 62
    5828:	9d 83       	std	Y+5, r25	; 0x05
    582a:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    582c:	8c 81       	ldd	r24, Y+4	; 0x04
    582e:	9d 81       	ldd	r25, Y+5	; 0x05
    5830:	9a 83       	std	Y+2, r25	; 0x02
    5832:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    5834:	0f b6       	in	r0, 0x3f	; 63
    5836:	f8 94       	cli
    5838:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    583a:	e9 81       	ldd	r30, Y+1	; 0x01
    583c:	fa 81       	ldd	r31, Y+2	; 0x02
    583e:	93 8d       	ldd	r25, Z+27	; 0x1b
    5840:	e9 81       	ldd	r30, Y+1	; 0x01
    5842:	fa 81       	ldd	r31, Y+2	; 0x02
    5844:	82 8d       	ldd	r24, Z+26	; 0x1a
    5846:	29 2f       	mov	r18, r25
    5848:	28 1b       	sub	r18, r24
    584a:	82 2f       	mov	r24, r18
    584c:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    584e:	0f 90       	pop	r0
    5850:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    5852:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    5854:	0f 90       	pop	r0
    5856:	0f 90       	pop	r0
    5858:	0f 90       	pop	r0
    585a:	0f 90       	pop	r0
    585c:	0f 90       	pop	r0
    585e:	cf 91       	pop	r28
    5860:	df 91       	pop	r29
    5862:	08 95       	ret

00005864 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    5864:	df 93       	push	r29
    5866:	cf 93       	push	r28
    5868:	00 d0       	rcall	.+0      	; 0x586a <uxQueueMessagesWaitingFromISR+0x6>
    586a:	0f 92       	push	r0
    586c:	cd b7       	in	r28, 0x3d	; 61
    586e:	de b7       	in	r29, 0x3e	; 62
    5870:	9b 83       	std	Y+3, r25	; 0x03
    5872:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    5874:	ea 81       	ldd	r30, Y+2	; 0x02
    5876:	fb 81       	ldd	r31, Y+3	; 0x03
    5878:	82 8d       	ldd	r24, Z+26	; 0x1a
    587a:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    587c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    587e:	0f 90       	pop	r0
    5880:	0f 90       	pop	r0
    5882:	0f 90       	pop	r0
    5884:	cf 91       	pop	r28
    5886:	df 91       	pop	r29
    5888:	08 95       	ret

0000588a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    588a:	df 93       	push	r29
    588c:	cf 93       	push	r28
    588e:	00 d0       	rcall	.+0      	; 0x5890 <vQueueDelete+0x6>
    5890:	00 d0       	rcall	.+0      	; 0x5892 <vQueueDelete+0x8>
    5892:	cd b7       	in	r28, 0x3d	; 61
    5894:	de b7       	in	r29, 0x3e	; 62
    5896:	9c 83       	std	Y+4, r25	; 0x04
    5898:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    589a:	8b 81       	ldd	r24, Y+3	; 0x03
    589c:	9c 81       	ldd	r25, Y+4	; 0x04
    589e:	9a 83       	std	Y+2, r25	; 0x02
    58a0:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    58a2:	89 81       	ldd	r24, Y+1	; 0x01
    58a4:	9a 81       	ldd	r25, Y+2	; 0x02
    58a6:	0e 94 18 23 	call	0x4630	; 0x4630 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    58aa:	0f 90       	pop	r0
    58ac:	0f 90       	pop	r0
    58ae:	0f 90       	pop	r0
    58b0:	0f 90       	pop	r0
    58b2:	cf 91       	pop	r28
    58b4:	df 91       	pop	r29
    58b6:	08 95       	ret

000058b8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    58b8:	df 93       	push	r29
    58ba:	cf 93       	push	r28
    58bc:	cd b7       	in	r28, 0x3d	; 61
    58be:	de b7       	in	r29, 0x3e	; 62
    58c0:	27 97       	sbiw	r28, 0x07	; 7
    58c2:	0f b6       	in	r0, 0x3f	; 63
    58c4:	f8 94       	cli
    58c6:	de bf       	out	0x3e, r29	; 62
    58c8:	0f be       	out	0x3f, r0	; 63
    58ca:	cd bf       	out	0x3d, r28	; 61
    58cc:	9c 83       	std	Y+4, r25	; 0x04
    58ce:	8b 83       	std	Y+3, r24	; 0x03
    58d0:	7e 83       	std	Y+6, r23	; 0x06
    58d2:	6d 83       	std	Y+5, r22	; 0x05
    58d4:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    58d6:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    58d8:	eb 81       	ldd	r30, Y+3	; 0x03
    58da:	fc 81       	ldd	r31, Y+4	; 0x04
    58dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    58de:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    58e0:	eb 81       	ldd	r30, Y+3	; 0x03
    58e2:	fc 81       	ldd	r31, Y+4	; 0x04
    58e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    58e6:	88 23       	and	r24, r24
    58e8:	99 f4       	brne	.+38     	; 0x5910 <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    58ea:	eb 81       	ldd	r30, Y+3	; 0x03
    58ec:	fc 81       	ldd	r31, Y+4	; 0x04
    58ee:	80 81       	ld	r24, Z
    58f0:	91 81       	ldd	r25, Z+1	; 0x01
    58f2:	00 97       	sbiw	r24, 0x00	; 0
    58f4:	09 f0       	breq	.+2      	; 0x58f8 <prvCopyDataToQueue+0x40>
    58f6:	89 c0       	rjmp	.+274    	; 0x5a0a <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    58f8:	eb 81       	ldd	r30, Y+3	; 0x03
    58fa:	fc 81       	ldd	r31, Y+4	; 0x04
    58fc:	82 81       	ldd	r24, Z+2	; 0x02
    58fe:	93 81       	ldd	r25, Z+3	; 0x03
    5900:	0e 94 8b 38 	call	0x7116	; 0x7116 <xTaskPriorityDisinherit>
    5904:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->pxMutexHolder = NULL;
    5906:	eb 81       	ldd	r30, Y+3	; 0x03
    5908:	fc 81       	ldd	r31, Y+4	; 0x04
    590a:	13 82       	std	Z+3, r1	; 0x03
    590c:	12 82       	std	Z+2, r1	; 0x02
    590e:	7d c0       	rjmp	.+250    	; 0x5a0a <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    5910:	8f 81       	ldd	r24, Y+7	; 0x07
    5912:	88 23       	and	r24, r24
    5914:	99 f5       	brne	.+102    	; 0x597c <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    5916:	eb 81       	ldd	r30, Y+3	; 0x03
    5918:	fc 81       	ldd	r31, Y+4	; 0x04
    591a:	64 81       	ldd	r22, Z+4	; 0x04
    591c:	75 81       	ldd	r23, Z+5	; 0x05
    591e:	eb 81       	ldd	r30, Y+3	; 0x03
    5920:	fc 81       	ldd	r31, Y+4	; 0x04
    5922:	84 8d       	ldd	r24, Z+28	; 0x1c
    5924:	48 2f       	mov	r20, r24
    5926:	50 e0       	ldi	r21, 0x00	; 0
    5928:	2d 81       	ldd	r18, Y+5	; 0x05
    592a:	3e 81       	ldd	r19, Y+6	; 0x06
    592c:	cb 01       	movw	r24, r22
    592e:	b9 01       	movw	r22, r18
    5930:	0e 94 00 3e 	call	0x7c00	; 0x7c00 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    5934:	eb 81       	ldd	r30, Y+3	; 0x03
    5936:	fc 81       	ldd	r31, Y+4	; 0x04
    5938:	24 81       	ldd	r18, Z+4	; 0x04
    593a:	35 81       	ldd	r19, Z+5	; 0x05
    593c:	eb 81       	ldd	r30, Y+3	; 0x03
    593e:	fc 81       	ldd	r31, Y+4	; 0x04
    5940:	84 8d       	ldd	r24, Z+28	; 0x1c
    5942:	88 2f       	mov	r24, r24
    5944:	90 e0       	ldi	r25, 0x00	; 0
    5946:	82 0f       	add	r24, r18
    5948:	93 1f       	adc	r25, r19
    594a:	eb 81       	ldd	r30, Y+3	; 0x03
    594c:	fc 81       	ldd	r31, Y+4	; 0x04
    594e:	95 83       	std	Z+5, r25	; 0x05
    5950:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    5952:	eb 81       	ldd	r30, Y+3	; 0x03
    5954:	fc 81       	ldd	r31, Y+4	; 0x04
    5956:	24 81       	ldd	r18, Z+4	; 0x04
    5958:	35 81       	ldd	r19, Z+5	; 0x05
    595a:	eb 81       	ldd	r30, Y+3	; 0x03
    595c:	fc 81       	ldd	r31, Y+4	; 0x04
    595e:	82 81       	ldd	r24, Z+2	; 0x02
    5960:	93 81       	ldd	r25, Z+3	; 0x03
    5962:	28 17       	cp	r18, r24
    5964:	39 07       	cpc	r19, r25
    5966:	08 f4       	brcc	.+2      	; 0x596a <prvCopyDataToQueue+0xb2>
    5968:	50 c0       	rjmp	.+160    	; 0x5a0a <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    596a:	eb 81       	ldd	r30, Y+3	; 0x03
    596c:	fc 81       	ldd	r31, Y+4	; 0x04
    596e:	80 81       	ld	r24, Z
    5970:	91 81       	ldd	r25, Z+1	; 0x01
    5972:	eb 81       	ldd	r30, Y+3	; 0x03
    5974:	fc 81       	ldd	r31, Y+4	; 0x04
    5976:	95 83       	std	Z+5, r25	; 0x05
    5978:	84 83       	std	Z+4, r24	; 0x04
    597a:	47 c0       	rjmp	.+142    	; 0x5a0a <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    597c:	eb 81       	ldd	r30, Y+3	; 0x03
    597e:	fc 81       	ldd	r31, Y+4	; 0x04
    5980:	66 81       	ldd	r22, Z+6	; 0x06
    5982:	77 81       	ldd	r23, Z+7	; 0x07
    5984:	eb 81       	ldd	r30, Y+3	; 0x03
    5986:	fc 81       	ldd	r31, Y+4	; 0x04
    5988:	84 8d       	ldd	r24, Z+28	; 0x1c
    598a:	48 2f       	mov	r20, r24
    598c:	50 e0       	ldi	r21, 0x00	; 0
    598e:	2d 81       	ldd	r18, Y+5	; 0x05
    5990:	3e 81       	ldd	r19, Y+6	; 0x06
    5992:	cb 01       	movw	r24, r22
    5994:	b9 01       	movw	r22, r18
    5996:	0e 94 00 3e 	call	0x7c00	; 0x7c00 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    599a:	eb 81       	ldd	r30, Y+3	; 0x03
    599c:	fc 81       	ldd	r31, Y+4	; 0x04
    599e:	26 81       	ldd	r18, Z+6	; 0x06
    59a0:	37 81       	ldd	r19, Z+7	; 0x07
    59a2:	eb 81       	ldd	r30, Y+3	; 0x03
    59a4:	fc 81       	ldd	r31, Y+4	; 0x04
    59a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    59a8:	88 2f       	mov	r24, r24
    59aa:	90 e0       	ldi	r25, 0x00	; 0
    59ac:	90 95       	com	r25
    59ae:	81 95       	neg	r24
    59b0:	9f 4f       	sbci	r25, 0xFF	; 255
    59b2:	82 0f       	add	r24, r18
    59b4:	93 1f       	adc	r25, r19
    59b6:	eb 81       	ldd	r30, Y+3	; 0x03
    59b8:	fc 81       	ldd	r31, Y+4	; 0x04
    59ba:	97 83       	std	Z+7, r25	; 0x07
    59bc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    59be:	eb 81       	ldd	r30, Y+3	; 0x03
    59c0:	fc 81       	ldd	r31, Y+4	; 0x04
    59c2:	26 81       	ldd	r18, Z+6	; 0x06
    59c4:	37 81       	ldd	r19, Z+7	; 0x07
    59c6:	eb 81       	ldd	r30, Y+3	; 0x03
    59c8:	fc 81       	ldd	r31, Y+4	; 0x04
    59ca:	80 81       	ld	r24, Z
    59cc:	91 81       	ldd	r25, Z+1	; 0x01
    59ce:	28 17       	cp	r18, r24
    59d0:	39 07       	cpc	r19, r25
    59d2:	90 f4       	brcc	.+36     	; 0x59f8 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    59d4:	eb 81       	ldd	r30, Y+3	; 0x03
    59d6:	fc 81       	ldd	r31, Y+4	; 0x04
    59d8:	22 81       	ldd	r18, Z+2	; 0x02
    59da:	33 81       	ldd	r19, Z+3	; 0x03
    59dc:	eb 81       	ldd	r30, Y+3	; 0x03
    59de:	fc 81       	ldd	r31, Y+4	; 0x04
    59e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    59e2:	88 2f       	mov	r24, r24
    59e4:	90 e0       	ldi	r25, 0x00	; 0
    59e6:	90 95       	com	r25
    59e8:	81 95       	neg	r24
    59ea:	9f 4f       	sbci	r25, 0xFF	; 255
    59ec:	82 0f       	add	r24, r18
    59ee:	93 1f       	adc	r25, r19
    59f0:	eb 81       	ldd	r30, Y+3	; 0x03
    59f2:	fc 81       	ldd	r31, Y+4	; 0x04
    59f4:	97 83       	std	Z+7, r25	; 0x07
    59f6:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    59f8:	8f 81       	ldd	r24, Y+7	; 0x07
    59fa:	82 30       	cpi	r24, 0x02	; 2
    59fc:	31 f4       	brne	.+12     	; 0x5a0a <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    59fe:	89 81       	ldd	r24, Y+1	; 0x01
    5a00:	88 23       	and	r24, r24
    5a02:	19 f0       	breq	.+6      	; 0x5a0a <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    5a04:	89 81       	ldd	r24, Y+1	; 0x01
    5a06:	81 50       	subi	r24, 0x01	; 1
    5a08:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    5a0a:	89 81       	ldd	r24, Y+1	; 0x01
    5a0c:	8f 5f       	subi	r24, 0xFF	; 255
    5a0e:	eb 81       	ldd	r30, Y+3	; 0x03
    5a10:	fc 81       	ldd	r31, Y+4	; 0x04
    5a12:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    5a14:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5a16:	27 96       	adiw	r28, 0x07	; 7
    5a18:	0f b6       	in	r0, 0x3f	; 63
    5a1a:	f8 94       	cli
    5a1c:	de bf       	out	0x3e, r29	; 62
    5a1e:	0f be       	out	0x3f, r0	; 63
    5a20:	cd bf       	out	0x3d, r28	; 61
    5a22:	cf 91       	pop	r28
    5a24:	df 91       	pop	r29
    5a26:	08 95       	ret

00005a28 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    5a28:	df 93       	push	r29
    5a2a:	cf 93       	push	r28
    5a2c:	00 d0       	rcall	.+0      	; 0x5a2e <prvCopyDataFromQueue+0x6>
    5a2e:	00 d0       	rcall	.+0      	; 0x5a30 <prvCopyDataFromQueue+0x8>
    5a30:	cd b7       	in	r28, 0x3d	; 61
    5a32:	de b7       	in	r29, 0x3e	; 62
    5a34:	9a 83       	std	Y+2, r25	; 0x02
    5a36:	89 83       	std	Y+1, r24	; 0x01
    5a38:	7c 83       	std	Y+4, r23	; 0x04
    5a3a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    5a3c:	e9 81       	ldd	r30, Y+1	; 0x01
    5a3e:	fa 81       	ldd	r31, Y+2	; 0x02
    5a40:	84 8d       	ldd	r24, Z+28	; 0x1c
    5a42:	88 23       	and	r24, r24
    5a44:	89 f1       	breq	.+98     	; 0x5aa8 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    5a46:	e9 81       	ldd	r30, Y+1	; 0x01
    5a48:	fa 81       	ldd	r31, Y+2	; 0x02
    5a4a:	26 81       	ldd	r18, Z+6	; 0x06
    5a4c:	37 81       	ldd	r19, Z+7	; 0x07
    5a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    5a50:	fa 81       	ldd	r31, Y+2	; 0x02
    5a52:	84 8d       	ldd	r24, Z+28	; 0x1c
    5a54:	88 2f       	mov	r24, r24
    5a56:	90 e0       	ldi	r25, 0x00	; 0
    5a58:	82 0f       	add	r24, r18
    5a5a:	93 1f       	adc	r25, r19
    5a5c:	e9 81       	ldd	r30, Y+1	; 0x01
    5a5e:	fa 81       	ldd	r31, Y+2	; 0x02
    5a60:	97 83       	std	Z+7, r25	; 0x07
    5a62:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    5a64:	e9 81       	ldd	r30, Y+1	; 0x01
    5a66:	fa 81       	ldd	r31, Y+2	; 0x02
    5a68:	26 81       	ldd	r18, Z+6	; 0x06
    5a6a:	37 81       	ldd	r19, Z+7	; 0x07
    5a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    5a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    5a70:	82 81       	ldd	r24, Z+2	; 0x02
    5a72:	93 81       	ldd	r25, Z+3	; 0x03
    5a74:	28 17       	cp	r18, r24
    5a76:	39 07       	cpc	r19, r25
    5a78:	40 f0       	brcs	.+16     	; 0x5a8a <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    5a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a7e:	80 81       	ld	r24, Z
    5a80:	91 81       	ldd	r25, Z+1	; 0x01
    5a82:	e9 81       	ldd	r30, Y+1	; 0x01
    5a84:	fa 81       	ldd	r31, Y+2	; 0x02
    5a86:	97 83       	std	Z+7, r25	; 0x07
    5a88:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    5a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a8e:	46 81       	ldd	r20, Z+6	; 0x06
    5a90:	57 81       	ldd	r21, Z+7	; 0x07
    5a92:	e9 81       	ldd	r30, Y+1	; 0x01
    5a94:	fa 81       	ldd	r31, Y+2	; 0x02
    5a96:	84 8d       	ldd	r24, Z+28	; 0x1c
    5a98:	28 2f       	mov	r18, r24
    5a9a:	30 e0       	ldi	r19, 0x00	; 0
    5a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    5aa0:	ba 01       	movw	r22, r20
    5aa2:	a9 01       	movw	r20, r18
    5aa4:	0e 94 00 3e 	call	0x7c00	; 0x7c00 <memcpy>
	}
}
    5aa8:	0f 90       	pop	r0
    5aaa:	0f 90       	pop	r0
    5aac:	0f 90       	pop	r0
    5aae:	0f 90       	pop	r0
    5ab0:	cf 91       	pop	r28
    5ab2:	df 91       	pop	r29
    5ab4:	08 95       	ret

00005ab6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    5ab6:	df 93       	push	r29
    5ab8:	cf 93       	push	r28
    5aba:	00 d0       	rcall	.+0      	; 0x5abc <prvUnlockQueue+0x6>
    5abc:	00 d0       	rcall	.+0      	; 0x5abe <prvUnlockQueue+0x8>
    5abe:	cd b7       	in	r28, 0x3d	; 61
    5ac0:	de b7       	in	r29, 0x3e	; 62
    5ac2:	9c 83       	std	Y+4, r25	; 0x04
    5ac4:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    5ac6:	0f b6       	in	r0, 0x3f	; 63
    5ac8:	f8 94       	cli
    5aca:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    5acc:	eb 81       	ldd	r30, Y+3	; 0x03
    5ace:	fc 81       	ldd	r31, Y+4	; 0x04
    5ad0:	86 8d       	ldd	r24, Z+30	; 0x1e
    5ad2:	8a 83       	std	Y+2, r24	; 0x02
    5ad4:	11 c0       	rjmp	.+34     	; 0x5af8 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5ad6:	eb 81       	ldd	r30, Y+3	; 0x03
    5ad8:	fc 81       	ldd	r31, Y+4	; 0x04
    5ada:	81 89       	ldd	r24, Z+17	; 0x11
    5adc:	88 23       	and	r24, r24
    5ade:	79 f0       	breq	.+30     	; 0x5afe <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5ae0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ae2:	9c 81       	ldd	r25, Y+4	; 0x04
    5ae4:	41 96       	adiw	r24, 0x11	; 17
    5ae6:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    5aea:	88 23       	and	r24, r24
    5aec:	11 f0       	breq	.+4      	; 0x5af2 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    5aee:	0e 94 19 37 	call	0x6e32	; 0x6e32 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    5af2:	8a 81       	ldd	r24, Y+2	; 0x02
    5af4:	81 50       	subi	r24, 0x01	; 1
    5af6:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    5af8:	8a 81       	ldd	r24, Y+2	; 0x02
    5afa:	18 16       	cp	r1, r24
    5afc:	64 f3       	brlt	.-40     	; 0x5ad6 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    5afe:	eb 81       	ldd	r30, Y+3	; 0x03
    5b00:	fc 81       	ldd	r31, Y+4	; 0x04
    5b02:	8f ef       	ldi	r24, 0xFF	; 255
    5b04:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    5b06:	0f 90       	pop	r0
    5b08:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    5b0a:	0f b6       	in	r0, 0x3f	; 63
    5b0c:	f8 94       	cli
    5b0e:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    5b10:	eb 81       	ldd	r30, Y+3	; 0x03
    5b12:	fc 81       	ldd	r31, Y+4	; 0x04
    5b14:	85 8d       	ldd	r24, Z+29	; 0x1d
    5b16:	89 83       	std	Y+1, r24	; 0x01
    5b18:	11 c0       	rjmp	.+34     	; 0x5b3c <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    5b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    5b1e:	80 85       	ldd	r24, Z+8	; 0x08
    5b20:	88 23       	and	r24, r24
    5b22:	79 f0       	breq	.+30     	; 0x5b42 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5b24:	8b 81       	ldd	r24, Y+3	; 0x03
    5b26:	9c 81       	ldd	r25, Y+4	; 0x04
    5b28:	08 96       	adiw	r24, 0x08	; 8
    5b2a:	0e 94 c3 35 	call	0x6b86	; 0x6b86 <xTaskRemoveFromEventList>
    5b2e:	88 23       	and	r24, r24
    5b30:	11 f0       	breq	.+4      	; 0x5b36 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    5b32:	0e 94 19 37 	call	0x6e32	; 0x6e32 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    5b36:	89 81       	ldd	r24, Y+1	; 0x01
    5b38:	81 50       	subi	r24, 0x01	; 1
    5b3a:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    5b3c:	89 81       	ldd	r24, Y+1	; 0x01
    5b3e:	18 16       	cp	r1, r24
    5b40:	64 f3       	brlt	.-40     	; 0x5b1a <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    5b42:	eb 81       	ldd	r30, Y+3	; 0x03
    5b44:	fc 81       	ldd	r31, Y+4	; 0x04
    5b46:	8f ef       	ldi	r24, 0xFF	; 255
    5b48:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    5b4a:	0f 90       	pop	r0
    5b4c:	0f be       	out	0x3f, r0	; 63
}
    5b4e:	0f 90       	pop	r0
    5b50:	0f 90       	pop	r0
    5b52:	0f 90       	pop	r0
    5b54:	0f 90       	pop	r0
    5b56:	cf 91       	pop	r28
    5b58:	df 91       	pop	r29
    5b5a:	08 95       	ret

00005b5c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    5b5c:	df 93       	push	r29
    5b5e:	cf 93       	push	r28
    5b60:	00 d0       	rcall	.+0      	; 0x5b62 <prvIsQueueEmpty+0x6>
    5b62:	0f 92       	push	r0
    5b64:	cd b7       	in	r28, 0x3d	; 61
    5b66:	de b7       	in	r29, 0x3e	; 62
    5b68:	9b 83       	std	Y+3, r25	; 0x03
    5b6a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    5b6c:	0f b6       	in	r0, 0x3f	; 63
    5b6e:	f8 94       	cli
    5b70:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    5b72:	ea 81       	ldd	r30, Y+2	; 0x02
    5b74:	fb 81       	ldd	r31, Y+3	; 0x03
    5b76:	82 8d       	ldd	r24, Z+26	; 0x1a
    5b78:	88 23       	and	r24, r24
    5b7a:	19 f4       	brne	.+6      	; 0x5b82 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    5b7c:	81 e0       	ldi	r24, 0x01	; 1
    5b7e:	89 83       	std	Y+1, r24	; 0x01
    5b80:	01 c0       	rjmp	.+2      	; 0x5b84 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    5b82:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    5b84:	0f 90       	pop	r0
    5b86:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5b88:	89 81       	ldd	r24, Y+1	; 0x01
}
    5b8a:	0f 90       	pop	r0
    5b8c:	0f 90       	pop	r0
    5b8e:	0f 90       	pop	r0
    5b90:	cf 91       	pop	r28
    5b92:	df 91       	pop	r29
    5b94:	08 95       	ret

00005b96 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    5b96:	df 93       	push	r29
    5b98:	cf 93       	push	r28
    5b9a:	00 d0       	rcall	.+0      	; 0x5b9c <xQueueIsQueueEmptyFromISR+0x6>
    5b9c:	0f 92       	push	r0
    5b9e:	cd b7       	in	r28, 0x3d	; 61
    5ba0:	de b7       	in	r29, 0x3e	; 62
    5ba2:	9b 83       	std	Y+3, r25	; 0x03
    5ba4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    5ba6:	ea 81       	ldd	r30, Y+2	; 0x02
    5ba8:	fb 81       	ldd	r31, Y+3	; 0x03
    5baa:	82 8d       	ldd	r24, Z+26	; 0x1a
    5bac:	88 23       	and	r24, r24
    5bae:	19 f4       	brne	.+6      	; 0x5bb6 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    5bb0:	81 e0       	ldi	r24, 0x01	; 1
    5bb2:	89 83       	std	Y+1, r24	; 0x01
    5bb4:	01 c0       	rjmp	.+2      	; 0x5bb8 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    5bb6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5bb8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    5bba:	0f 90       	pop	r0
    5bbc:	0f 90       	pop	r0
    5bbe:	0f 90       	pop	r0
    5bc0:	cf 91       	pop	r28
    5bc2:	df 91       	pop	r29
    5bc4:	08 95       	ret

00005bc6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    5bc6:	df 93       	push	r29
    5bc8:	cf 93       	push	r28
    5bca:	00 d0       	rcall	.+0      	; 0x5bcc <prvIsQueueFull+0x6>
    5bcc:	0f 92       	push	r0
    5bce:	cd b7       	in	r28, 0x3d	; 61
    5bd0:	de b7       	in	r29, 0x3e	; 62
    5bd2:	9b 83       	std	Y+3, r25	; 0x03
    5bd4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    5bd6:	0f b6       	in	r0, 0x3f	; 63
    5bd8:	f8 94       	cli
    5bda:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    5bdc:	ea 81       	ldd	r30, Y+2	; 0x02
    5bde:	fb 81       	ldd	r31, Y+3	; 0x03
    5be0:	92 8d       	ldd	r25, Z+26	; 0x1a
    5be2:	ea 81       	ldd	r30, Y+2	; 0x02
    5be4:	fb 81       	ldd	r31, Y+3	; 0x03
    5be6:	83 8d       	ldd	r24, Z+27	; 0x1b
    5be8:	98 17       	cp	r25, r24
    5bea:	19 f4       	brne	.+6      	; 0x5bf2 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    5bec:	81 e0       	ldi	r24, 0x01	; 1
    5bee:	89 83       	std	Y+1, r24	; 0x01
    5bf0:	01 c0       	rjmp	.+2      	; 0x5bf4 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    5bf2:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    5bf4:	0f 90       	pop	r0
    5bf6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5bf8:	89 81       	ldd	r24, Y+1	; 0x01
}
    5bfa:	0f 90       	pop	r0
    5bfc:	0f 90       	pop	r0
    5bfe:	0f 90       	pop	r0
    5c00:	cf 91       	pop	r28
    5c02:	df 91       	pop	r29
    5c04:	08 95       	ret

00005c06 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    5c06:	df 93       	push	r29
    5c08:	cf 93       	push	r28
    5c0a:	00 d0       	rcall	.+0      	; 0x5c0c <xQueueIsQueueFullFromISR+0x6>
    5c0c:	0f 92       	push	r0
    5c0e:	cd b7       	in	r28, 0x3d	; 61
    5c10:	de b7       	in	r29, 0x3e	; 62
    5c12:	9b 83       	std	Y+3, r25	; 0x03
    5c14:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    5c16:	ea 81       	ldd	r30, Y+2	; 0x02
    5c18:	fb 81       	ldd	r31, Y+3	; 0x03
    5c1a:	92 8d       	ldd	r25, Z+26	; 0x1a
    5c1c:	ea 81       	ldd	r30, Y+2	; 0x02
    5c1e:	fb 81       	ldd	r31, Y+3	; 0x03
    5c20:	83 8d       	ldd	r24, Z+27	; 0x1b
    5c22:	98 17       	cp	r25, r24
    5c24:	19 f4       	brne	.+6      	; 0x5c2c <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    5c26:	81 e0       	ldi	r24, 0x01	; 1
    5c28:	89 83       	std	Y+1, r24	; 0x01
    5c2a:	01 c0       	rjmp	.+2      	; 0x5c2e <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    5c2c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5c2e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    5c30:	0f 90       	pop	r0
    5c32:	0f 90       	pop	r0
    5c34:	0f 90       	pop	r0
    5c36:	cf 91       	pop	r28
    5c38:	df 91       	pop	r29
    5c3a:	08 95       	ret

00005c3c <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    5c3c:	8f 92       	push	r8
    5c3e:	9f 92       	push	r9
    5c40:	af 92       	push	r10
    5c42:	bf 92       	push	r11
    5c44:	cf 92       	push	r12
    5c46:	df 92       	push	r13
    5c48:	ef 92       	push	r14
    5c4a:	ff 92       	push	r15
    5c4c:	0f 93       	push	r16
    5c4e:	1f 93       	push	r17
    5c50:	df 93       	push	r29
    5c52:	cf 93       	push	r28
    5c54:	cd b7       	in	r28, 0x3d	; 61
    5c56:	de b7       	in	r29, 0x3e	; 62
    5c58:	60 97       	sbiw	r28, 0x10	; 16
    5c5a:	0f b6       	in	r0, 0x3f	; 63
    5c5c:	f8 94       	cli
    5c5e:	de bf       	out	0x3e, r29	; 62
    5c60:	0f be       	out	0x3f, r0	; 63
    5c62:	cd bf       	out	0x3d, r28	; 61
    5c64:	9f 83       	std	Y+7, r25	; 0x07
    5c66:	8e 83       	std	Y+6, r24	; 0x06
    5c68:	79 87       	std	Y+9, r23	; 0x09
    5c6a:	68 87       	std	Y+8, r22	; 0x08
    5c6c:	5b 87       	std	Y+11, r21	; 0x0b
    5c6e:	4a 87       	std	Y+10, r20	; 0x0a
    5c70:	3d 87       	std	Y+13, r19	; 0x0d
    5c72:	2c 87       	std	Y+12, r18	; 0x0c
    5c74:	0e 87       	std	Y+14, r16	; 0x0e
    5c76:	f8 8a       	std	Y+16, r15	; 0x10
    5c78:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5c7a:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c7c:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c7e:	0e 94 30 22 	call	0x4460	; 0x4460 <pvPortMalloc>
    5c82:	9a 83       	std	Y+2, r25	; 0x02
    5c84:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    5c86:	89 81       	ldd	r24, Y+1	; 0x01
    5c88:	9a 81       	ldd	r25, Y+2	; 0x02
    5c8a:	00 97       	sbiw	r24, 0x00	; 0
    5c8c:	b1 f0       	breq	.+44     	; 0x5cba <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    5c8e:	88 e2       	ldi	r24, 0x28	; 40
    5c90:	90 e0       	ldi	r25, 0x00	; 0
    5c92:	0e 94 30 22 	call	0x4460	; 0x4460 <pvPortMalloc>
    5c96:	9d 83       	std	Y+5, r25	; 0x05
    5c98:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    5c9a:	8c 81       	ldd	r24, Y+4	; 0x04
    5c9c:	9d 81       	ldd	r25, Y+5	; 0x05
    5c9e:	00 97       	sbiw	r24, 0x00	; 0
    5ca0:	39 f0       	breq	.+14     	; 0x5cb0 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    5ca2:	ec 81       	ldd	r30, Y+4	; 0x04
    5ca4:	fd 81       	ldd	r31, Y+5	; 0x05
    5ca6:	89 81       	ldd	r24, Y+1	; 0x01
    5ca8:	9a 81       	ldd	r25, Y+2	; 0x02
    5caa:	90 8f       	std	Z+24, r25	; 0x18
    5cac:	87 8b       	std	Z+23, r24	; 0x17
    5cae:	07 c0       	rjmp	.+14     	; 0x5cbe <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    5cb0:	89 81       	ldd	r24, Y+1	; 0x01
    5cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    5cb4:	0e 94 18 23 	call	0x4630	; 0x4630 <vPortFree>
    5cb8:	02 c0       	rjmp	.+4      	; 0x5cbe <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    5cba:	1d 82       	std	Y+5, r1	; 0x05
    5cbc:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    5cbe:	8c 81       	ldd	r24, Y+4	; 0x04
    5cc0:	9d 81       	ldd	r25, Y+5	; 0x05
    5cc2:	00 97       	sbiw	r24, 0x00	; 0
    5cc4:	e9 f0       	breq	.+58     	; 0x5d00 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    5cc6:	8a 85       	ldd	r24, Y+10	; 0x0a
    5cc8:	9b 85       	ldd	r25, Y+11	; 0x0b
    5cca:	9c 01       	movw	r18, r24
    5ccc:	40 e0       	ldi	r20, 0x00	; 0
    5cce:	50 e0       	ldi	r21, 0x00	; 0
    5cd0:	8e 81       	ldd	r24, Y+6	; 0x06
    5cd2:	9f 81       	ldd	r25, Y+7	; 0x07
    5cd4:	68 85       	ldd	r22, Y+8	; 0x08
    5cd6:	79 85       	ldd	r23, Y+9	; 0x09
    5cd8:	ec 85       	ldd	r30, Y+12	; 0x0c
    5cda:	fd 85       	ldd	r31, Y+13	; 0x0d
    5cdc:	af 85       	ldd	r26, Y+15	; 0x0f
    5cde:	b8 89       	ldd	r27, Y+16	; 0x10
    5ce0:	ac 80       	ldd	r10, Y+4	; 0x04
    5ce2:	bd 80       	ldd	r11, Y+5	; 0x05
    5ce4:	8f 01       	movw	r16, r30
    5ce6:	ee 84       	ldd	r14, Y+14	; 0x0e
    5ce8:	6d 01       	movw	r12, r26
    5cea:	88 24       	eor	r8, r8
    5cec:	99 24       	eor	r9, r9
    5cee:	0e 94 96 2e 	call	0x5d2c	; 0x5d2c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    5cf2:	8c 81       	ldd	r24, Y+4	; 0x04
    5cf4:	9d 81       	ldd	r25, Y+5	; 0x05
    5cf6:	0e 94 51 2f 	call	0x5ea2	; 0x5ea2 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    5cfa:	81 e0       	ldi	r24, 0x01	; 1
    5cfc:	8b 83       	std	Y+3, r24	; 0x03
    5cfe:	02 c0       	rjmp	.+4      	; 0x5d04 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5d00:	8f ef       	ldi	r24, 0xFF	; 255
    5d02:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    5d04:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    5d06:	60 96       	adiw	r28, 0x10	; 16
    5d08:	0f b6       	in	r0, 0x3f	; 63
    5d0a:	f8 94       	cli
    5d0c:	de bf       	out	0x3e, r29	; 62
    5d0e:	0f be       	out	0x3f, r0	; 63
    5d10:	cd bf       	out	0x3d, r28	; 61
    5d12:	cf 91       	pop	r28
    5d14:	df 91       	pop	r29
    5d16:	1f 91       	pop	r17
    5d18:	0f 91       	pop	r16
    5d1a:	ff 90       	pop	r15
    5d1c:	ef 90       	pop	r14
    5d1e:	df 90       	pop	r13
    5d20:	cf 90       	pop	r12
    5d22:	bf 90       	pop	r11
    5d24:	af 90       	pop	r10
    5d26:	9f 90       	pop	r9
    5d28:	8f 90       	pop	r8
    5d2a:	08 95       	ret

00005d2c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5d2c:	8f 92       	push	r8
    5d2e:	9f 92       	push	r9
    5d30:	af 92       	push	r10
    5d32:	bf 92       	push	r11
    5d34:	cf 92       	push	r12
    5d36:	df 92       	push	r13
    5d38:	ef 92       	push	r14
    5d3a:	0f 93       	push	r16
    5d3c:	1f 93       	push	r17
    5d3e:	df 93       	push	r29
    5d40:	cf 93       	push	r28
    5d42:	cd b7       	in	r28, 0x3d	; 61
    5d44:	de b7       	in	r29, 0x3e	; 62
    5d46:	64 97       	sbiw	r28, 0x14	; 20
    5d48:	0f b6       	in	r0, 0x3f	; 63
    5d4a:	f8 94       	cli
    5d4c:	de bf       	out	0x3e, r29	; 62
    5d4e:	0f be       	out	0x3f, r0	; 63
    5d50:	cd bf       	out	0x3d, r28	; 61
    5d52:	9d 83       	std	Y+5, r25	; 0x05
    5d54:	8c 83       	std	Y+4, r24	; 0x04
    5d56:	7f 83       	std	Y+7, r23	; 0x07
    5d58:	6e 83       	std	Y+6, r22	; 0x06
    5d5a:	28 87       	std	Y+8, r18	; 0x08
    5d5c:	39 87       	std	Y+9, r19	; 0x09
    5d5e:	4a 87       	std	Y+10, r20	; 0x0a
    5d60:	5b 87       	std	Y+11, r21	; 0x0b
    5d62:	1d 87       	std	Y+13, r17	; 0x0d
    5d64:	0c 87       	std	Y+12, r16	; 0x0c
    5d66:	ee 86       	std	Y+14, r14	; 0x0e
    5d68:	d8 8a       	std	Y+16, r13	; 0x10
    5d6a:	cf 86       	std	Y+15, r12	; 0x0f
    5d6c:	ba 8a       	std	Y+18, r11	; 0x12
    5d6e:	a9 8a       	std	Y+17, r10	; 0x11
    5d70:	9c 8a       	std	Y+20, r9	; 0x14
    5d72:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    5d74:	e9 89       	ldd	r30, Y+17	; 0x11
    5d76:	fa 89       	ldd	r31, Y+18	; 0x12
    5d78:	27 89       	ldd	r18, Z+23	; 0x17
    5d7a:	30 8d       	ldd	r19, Z+24	; 0x18
    5d7c:	88 85       	ldd	r24, Y+8	; 0x08
    5d7e:	99 85       	ldd	r25, Y+9	; 0x09
    5d80:	01 97       	sbiw	r24, 0x01	; 1
    5d82:	82 0f       	add	r24, r18
    5d84:	93 1f       	adc	r25, r19
    5d86:	9b 83       	std	Y+3, r25	; 0x03
    5d88:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5d8a:	19 82       	std	Y+1, r1	; 0x01
    5d8c:	21 c0       	rjmp	.+66     	; 0x5dd0 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    5d8e:	89 81       	ldd	r24, Y+1	; 0x01
    5d90:	48 2f       	mov	r20, r24
    5d92:	50 e0       	ldi	r21, 0x00	; 0
    5d94:	89 81       	ldd	r24, Y+1	; 0x01
    5d96:	28 2f       	mov	r18, r24
    5d98:	30 e0       	ldi	r19, 0x00	; 0
    5d9a:	8e 81       	ldd	r24, Y+6	; 0x06
    5d9c:	9f 81       	ldd	r25, Y+7	; 0x07
    5d9e:	fc 01       	movw	r30, r24
    5da0:	e2 0f       	add	r30, r18
    5da2:	f3 1f       	adc	r31, r19
    5da4:	20 81       	ld	r18, Z
    5da6:	89 89       	ldd	r24, Y+17	; 0x11
    5da8:	9a 89       	ldd	r25, Y+18	; 0x12
    5daa:	84 0f       	add	r24, r20
    5dac:	95 1f       	adc	r25, r21
    5dae:	fc 01       	movw	r30, r24
    5db0:	79 96       	adiw	r30, 0x19	; 25
    5db2:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5db4:	89 81       	ldd	r24, Y+1	; 0x01
    5db6:	28 2f       	mov	r18, r24
    5db8:	30 e0       	ldi	r19, 0x00	; 0
    5dba:	8e 81       	ldd	r24, Y+6	; 0x06
    5dbc:	9f 81       	ldd	r25, Y+7	; 0x07
    5dbe:	fc 01       	movw	r30, r24
    5dc0:	e2 0f       	add	r30, r18
    5dc2:	f3 1f       	adc	r31, r19
    5dc4:	80 81       	ld	r24, Z
    5dc6:	88 23       	and	r24, r24
    5dc8:	31 f0       	breq	.+12     	; 0x5dd6 <prvInitialiseNewTask+0xaa>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5dca:	89 81       	ldd	r24, Y+1	; 0x01
    5dcc:	8f 5f       	subi	r24, 0xFF	; 255
    5dce:	89 83       	std	Y+1, r24	; 0x01
    5dd0:	89 81       	ldd	r24, Y+1	; 0x01
    5dd2:	88 30       	cpi	r24, 0x08	; 8
    5dd4:	e0 f2       	brcs	.-72     	; 0x5d8e <prvInitialiseNewTask+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5dd6:	e9 89       	ldd	r30, Y+17	; 0x11
    5dd8:	fa 89       	ldd	r31, Y+18	; 0x12
    5dda:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    5ddc:	8e 85       	ldd	r24, Y+14	; 0x0e
    5dde:	89 30       	cpi	r24, 0x09	; 9
    5de0:	10 f0       	brcs	.+4      	; 0x5de6 <prvInitialiseNewTask+0xba>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5de2:	88 e0       	ldi	r24, 0x08	; 8
    5de4:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    5de6:	e9 89       	ldd	r30, Y+17	; 0x11
    5de8:	fa 89       	ldd	r31, Y+18	; 0x12
    5dea:	8e 85       	ldd	r24, Y+14	; 0x0e
    5dec:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    5dee:	e9 89       	ldd	r30, Y+17	; 0x11
    5df0:	fa 89       	ldd	r31, Y+18	; 0x12
    5df2:	8e 85       	ldd	r24, Y+14	; 0x0e
    5df4:	81 a3       	std	Z+33, r24	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    5df6:	e9 89       	ldd	r30, Y+17	; 0x11
    5df8:	fa 89       	ldd	r31, Y+18	; 0x12
    5dfa:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    5dfc:	89 89       	ldd	r24, Y+17	; 0x11
    5dfe:	9a 89       	ldd	r25, Y+18	; 0x12
    5e00:	02 96       	adiw	r24, 0x02	; 2
    5e02:	0e 94 f6 23 	call	0x47ec	; 0x47ec <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    5e06:	89 89       	ldd	r24, Y+17	; 0x11
    5e08:	9a 89       	ldd	r25, Y+18	; 0x12
    5e0a:	0c 96       	adiw	r24, 0x0c	; 12
    5e0c:	0e 94 f6 23 	call	0x47ec	; 0x47ec <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    5e10:	e9 89       	ldd	r30, Y+17	; 0x11
    5e12:	fa 89       	ldd	r31, Y+18	; 0x12
    5e14:	89 89       	ldd	r24, Y+17	; 0x11
    5e16:	9a 89       	ldd	r25, Y+18	; 0x12
    5e18:	91 87       	std	Z+9, r25	; 0x09
    5e1a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5e1c:	8e 85       	ldd	r24, Y+14	; 0x0e
    5e1e:	28 2f       	mov	r18, r24
    5e20:	30 e0       	ldi	r19, 0x00	; 0
    5e22:	89 e0       	ldi	r24, 0x09	; 9
    5e24:	90 e0       	ldi	r25, 0x00	; 0
    5e26:	82 1b       	sub	r24, r18
    5e28:	93 0b       	sbc	r25, r19
    5e2a:	e9 89       	ldd	r30, Y+17	; 0x11
    5e2c:	fa 89       	ldd	r31, Y+18	; 0x12
    5e2e:	95 87       	std	Z+13, r25	; 0x0d
    5e30:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    5e32:	e9 89       	ldd	r30, Y+17	; 0x11
    5e34:	fa 89       	ldd	r31, Y+18	; 0x12
    5e36:	89 89       	ldd	r24, Y+17	; 0x11
    5e38:	9a 89       	ldd	r25, Y+18	; 0x12
    5e3a:	93 8b       	std	Z+19, r25	; 0x13
    5e3c:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    5e3e:	e9 89       	ldd	r30, Y+17	; 0x11
    5e40:	fa 89       	ldd	r31, Y+18	; 0x12
    5e42:	13 a2       	std	Z+35, r1	; 0x23
    5e44:	14 a2       	std	Z+36, r1	; 0x24
    5e46:	15 a2       	std	Z+37, r1	; 0x25
    5e48:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5e4a:	e9 89       	ldd	r30, Y+17	; 0x11
    5e4c:	fa 89       	ldd	r31, Y+18	; 0x12
    5e4e:	17 a2       	std	Z+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    5e50:	8a 81       	ldd	r24, Y+2	; 0x02
    5e52:	9b 81       	ldd	r25, Y+3	; 0x03
    5e54:	2c 81       	ldd	r18, Y+4	; 0x04
    5e56:	3d 81       	ldd	r19, Y+5	; 0x05
    5e58:	4c 85       	ldd	r20, Y+12	; 0x0c
    5e5a:	5d 85       	ldd	r21, Y+13	; 0x0d
    5e5c:	b9 01       	movw	r22, r18
    5e5e:	0e 94 02 25 	call	0x4a04	; 0x4a04 <pxPortInitialiseStack>
    5e62:	e9 89       	ldd	r30, Y+17	; 0x11
    5e64:	fa 89       	ldd	r31, Y+18	; 0x12
    5e66:	91 83       	std	Z+1, r25	; 0x01
    5e68:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    5e6a:	8f 85       	ldd	r24, Y+15	; 0x0f
    5e6c:	98 89       	ldd	r25, Y+16	; 0x10
    5e6e:	00 97       	sbiw	r24, 0x00	; 0
    5e70:	31 f0       	breq	.+12     	; 0x5e7e <prvInitialiseNewTask+0x152>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    5e72:	ef 85       	ldd	r30, Y+15	; 0x0f
    5e74:	f8 89       	ldd	r31, Y+16	; 0x10
    5e76:	89 89       	ldd	r24, Y+17	; 0x11
    5e78:	9a 89       	ldd	r25, Y+18	; 0x12
    5e7a:	91 83       	std	Z+1, r25	; 0x01
    5e7c:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    5e7e:	64 96       	adiw	r28, 0x14	; 20
    5e80:	0f b6       	in	r0, 0x3f	; 63
    5e82:	f8 94       	cli
    5e84:	de bf       	out	0x3e, r29	; 62
    5e86:	0f be       	out	0x3f, r0	; 63
    5e88:	cd bf       	out	0x3d, r28	; 61
    5e8a:	cf 91       	pop	r28
    5e8c:	df 91       	pop	r29
    5e8e:	1f 91       	pop	r17
    5e90:	0f 91       	pop	r16
    5e92:	ef 90       	pop	r14
    5e94:	df 90       	pop	r13
    5e96:	cf 90       	pop	r12
    5e98:	bf 90       	pop	r11
    5e9a:	af 90       	pop	r10
    5e9c:	9f 90       	pop	r9
    5e9e:	8f 90       	pop	r8
    5ea0:	08 95       	ret

00005ea2 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    5ea2:	df 93       	push	r29
    5ea4:	cf 93       	push	r28
    5ea6:	00 d0       	rcall	.+0      	; 0x5ea8 <prvAddNewTaskToReadyList+0x6>
    5ea8:	cd b7       	in	r28, 0x3d	; 61
    5eaa:	de b7       	in	r29, 0x3e	; 62
    5eac:	9a 83       	std	Y+2, r25	; 0x02
    5eae:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    5eb0:	0f b6       	in	r0, 0x3f	; 63
    5eb2:	f8 94       	cli
    5eb4:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    5eb6:	80 91 91 05 	lds	r24, 0x0591
    5eba:	8f 5f       	subi	r24, 0xFF	; 255
    5ebc:	80 93 91 05 	sts	0x0591, r24
		if( pxCurrentTCB == NULL )
    5ec0:	80 91 8e 05 	lds	r24, 0x058E
    5ec4:	90 91 8f 05 	lds	r25, 0x058F
    5ec8:	00 97       	sbiw	r24, 0x00	; 0
    5eca:	69 f4       	brne	.+26     	; 0x5ee6 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    5ecc:	89 81       	ldd	r24, Y+1	; 0x01
    5ece:	9a 81       	ldd	r25, Y+2	; 0x02
    5ed0:	90 93 8f 05 	sts	0x058F, r25
    5ed4:	80 93 8e 05 	sts	0x058E, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    5ed8:	80 91 91 05 	lds	r24, 0x0591
    5edc:	81 30       	cpi	r24, 0x01	; 1
    5ede:	b9 f4       	brne	.+46     	; 0x5f0e <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    5ee0:	0e 94 2d 37 	call	0x6e5a	; 0x6e5a <prvInitialiseTaskLists>
    5ee4:	14 c0       	rjmp	.+40     	; 0x5f0e <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    5ee6:	80 91 95 05 	lds	r24, 0x0595
    5eea:	88 23       	and	r24, r24
    5eec:	81 f4       	brne	.+32     	; 0x5f0e <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    5eee:	e0 91 8e 05 	lds	r30, 0x058E
    5ef2:	f0 91 8f 05 	lds	r31, 0x058F
    5ef6:	96 89       	ldd	r25, Z+22	; 0x16
    5ef8:	e9 81       	ldd	r30, Y+1	; 0x01
    5efa:	fa 81       	ldd	r31, Y+2	; 0x02
    5efc:	86 89       	ldd	r24, Z+22	; 0x16
    5efe:	89 17       	cp	r24, r25
    5f00:	30 f0       	brcs	.+12     	; 0x5f0e <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    5f02:	89 81       	ldd	r24, Y+1	; 0x01
    5f04:	9a 81       	ldd	r25, Y+2	; 0x02
    5f06:	90 93 8f 05 	sts	0x058F, r25
    5f0a:	80 93 8e 05 	sts	0x058E, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    5f0e:	80 91 99 05 	lds	r24, 0x0599
    5f12:	8f 5f       	subi	r24, 0xFF	; 255
    5f14:	80 93 99 05 	sts	0x0599, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    5f18:	e9 81       	ldd	r30, Y+1	; 0x01
    5f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    5f1c:	96 89       	ldd	r25, Z+22	; 0x16
    5f1e:	80 91 94 05 	lds	r24, 0x0594
    5f22:	89 17       	cp	r24, r25
    5f24:	28 f4       	brcc	.+10     	; 0x5f30 <prvAddNewTaskToReadyList+0x8e>
    5f26:	e9 81       	ldd	r30, Y+1	; 0x01
    5f28:	fa 81       	ldd	r31, Y+2	; 0x02
    5f2a:	86 89       	ldd	r24, Z+22	; 0x16
    5f2c:	80 93 94 05 	sts	0x0594, r24
    5f30:	e9 81       	ldd	r30, Y+1	; 0x01
    5f32:	fa 81       	ldd	r31, Y+2	; 0x02
    5f34:	86 89       	ldd	r24, Z+22	; 0x16
    5f36:	28 2f       	mov	r18, r24
    5f38:	30 e0       	ldi	r19, 0x00	; 0
    5f3a:	c9 01       	movw	r24, r18
    5f3c:	88 0f       	add	r24, r24
    5f3e:	99 1f       	adc	r25, r25
    5f40:	88 0f       	add	r24, r24
    5f42:	99 1f       	adc	r25, r25
    5f44:	88 0f       	add	r24, r24
    5f46:	99 1f       	adc	r25, r25
    5f48:	82 0f       	add	r24, r18
    5f4a:	93 1f       	adc	r25, r19
    5f4c:	ac 01       	movw	r20, r24
    5f4e:	41 56       	subi	r20, 0x61	; 97
    5f50:	5a 4f       	sbci	r21, 0xFA	; 250
    5f52:	89 81       	ldd	r24, Y+1	; 0x01
    5f54:	9a 81       	ldd	r25, Y+2	; 0x02
    5f56:	9c 01       	movw	r18, r24
    5f58:	2e 5f       	subi	r18, 0xFE	; 254
    5f5a:	3f 4f       	sbci	r19, 0xFF	; 255
    5f5c:	ca 01       	movw	r24, r20
    5f5e:	b9 01       	movw	r22, r18
    5f60:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    5f64:	0f 90       	pop	r0
    5f66:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    5f68:	80 91 95 05 	lds	r24, 0x0595
    5f6c:	88 23       	and	r24, r24
    5f6e:	61 f0       	breq	.+24     	; 0x5f88 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    5f70:	e0 91 8e 05 	lds	r30, 0x058E
    5f74:	f0 91 8f 05 	lds	r31, 0x058F
    5f78:	96 89       	ldd	r25, Z+22	; 0x16
    5f7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5f7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5f7e:	86 89       	ldd	r24, Z+22	; 0x16
    5f80:	98 17       	cp	r25, r24
    5f82:	10 f4       	brcc	.+4      	; 0x5f88 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    5f84:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    5f88:	0f 90       	pop	r0
    5f8a:	0f 90       	pop	r0
    5f8c:	cf 91       	pop	r28
    5f8e:	df 91       	pop	r29
    5f90:	08 95       	ret

00005f92 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    5f92:	df 93       	push	r29
    5f94:	cf 93       	push	r28
    5f96:	00 d0       	rcall	.+0      	; 0x5f98 <vTaskDelete+0x6>
    5f98:	00 d0       	rcall	.+0      	; 0x5f9a <vTaskDelete+0x8>
    5f9a:	00 d0       	rcall	.+0      	; 0x5f9c <vTaskDelete+0xa>
    5f9c:	cd b7       	in	r28, 0x3d	; 61
    5f9e:	de b7       	in	r29, 0x3e	; 62
    5fa0:	9c 83       	std	Y+4, r25	; 0x04
    5fa2:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    5fa4:	0f b6       	in	r0, 0x3f	; 63
    5fa6:	f8 94       	cli
    5fa8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    5faa:	8b 81       	ldd	r24, Y+3	; 0x03
    5fac:	9c 81       	ldd	r25, Y+4	; 0x04
    5fae:	00 97       	sbiw	r24, 0x00	; 0
    5fb0:	39 f4       	brne	.+14     	; 0x5fc0 <vTaskDelete+0x2e>
    5fb2:	80 91 8e 05 	lds	r24, 0x058E
    5fb6:	90 91 8f 05 	lds	r25, 0x058F
    5fba:	9e 83       	std	Y+6, r25	; 0x06
    5fbc:	8d 83       	std	Y+5, r24	; 0x05
    5fbe:	04 c0       	rjmp	.+8      	; 0x5fc8 <vTaskDelete+0x36>
    5fc0:	8b 81       	ldd	r24, Y+3	; 0x03
    5fc2:	9c 81       	ldd	r25, Y+4	; 0x04
    5fc4:	9e 83       	std	Y+6, r25	; 0x06
    5fc6:	8d 83       	std	Y+5, r24	; 0x05
    5fc8:	8d 81       	ldd	r24, Y+5	; 0x05
    5fca:	9e 81       	ldd	r25, Y+6	; 0x06
    5fcc:	9a 83       	std	Y+2, r25	; 0x02
    5fce:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5fd0:	89 81       	ldd	r24, Y+1	; 0x01
    5fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    5fd4:	02 96       	adiw	r24, 0x02	; 2
    5fd6:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5fda:	e9 81       	ldd	r30, Y+1	; 0x01
    5fdc:	fa 81       	ldd	r31, Y+2	; 0x02
    5fde:	84 89       	ldd	r24, Z+20	; 0x14
    5fe0:	95 89       	ldd	r25, Z+21	; 0x15
    5fe2:	00 97       	sbiw	r24, 0x00	; 0
    5fe4:	29 f0       	breq	.+10     	; 0x5ff0 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5fe6:	89 81       	ldd	r24, Y+1	; 0x01
    5fe8:	9a 81       	ldd	r25, Y+2	; 0x02
    5fea:	0c 96       	adiw	r24, 0x0c	; 12
    5fec:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    5ff0:	80 91 99 05 	lds	r24, 0x0599
    5ff4:	8f 5f       	subi	r24, 0xFF	; 255
    5ff6:	80 93 99 05 	sts	0x0599, r24

			if( pxTCB == pxCurrentTCB )
    5ffa:	20 91 8e 05 	lds	r18, 0x058E
    5ffe:	30 91 8f 05 	lds	r19, 0x058F
    6002:	89 81       	ldd	r24, Y+1	; 0x01
    6004:	9a 81       	ldd	r25, Y+2	; 0x02
    6006:	82 17       	cp	r24, r18
    6008:	93 07       	cpc	r25, r19
    600a:	81 f4       	brne	.+32     	; 0x602c <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    600c:	89 81       	ldd	r24, Y+1	; 0x01
    600e:	9a 81       	ldd	r25, Y+2	; 0x02
    6010:	9c 01       	movw	r18, r24
    6012:	2e 5f       	subi	r18, 0xFE	; 254
    6014:	3f 4f       	sbci	r19, 0xFF	; 255
    6016:	8f e0       	ldi	r24, 0x0F	; 15
    6018:	96 e0       	ldi	r25, 0x06	; 6
    601a:	b9 01       	movw	r22, r18
    601c:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    6020:	80 91 90 05 	lds	r24, 0x0590
    6024:	8f 5f       	subi	r24, 0xFF	; 255
    6026:	80 93 90 05 	sts	0x0590, r24
    602a:	0b c0       	rjmp	.+22     	; 0x6042 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    602c:	80 91 91 05 	lds	r24, 0x0591
    6030:	81 50       	subi	r24, 0x01	; 1
    6032:	80 93 91 05 	sts	0x0591, r24
				prvDeleteTCB( pxTCB );
    6036:	89 81       	ldd	r24, Y+1	; 0x01
    6038:	9a 81       	ldd	r25, Y+2	; 0x02
    603a:	0e 94 ad 37 	call	0x6f5a	; 0x6f5a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    603e:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    6042:	0f 90       	pop	r0
    6044:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    6046:	80 91 95 05 	lds	r24, 0x0595
    604a:	88 23       	and	r24, r24
    604c:	59 f0       	breq	.+22     	; 0x6064 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    604e:	20 91 8e 05 	lds	r18, 0x058E
    6052:	30 91 8f 05 	lds	r19, 0x058F
    6056:	89 81       	ldd	r24, Y+1	; 0x01
    6058:	9a 81       	ldd	r25, Y+2	; 0x02
    605a:	82 17       	cp	r24, r18
    605c:	93 07       	cpc	r25, r19
    605e:	11 f4       	brne	.+4      	; 0x6064 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    6060:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    6064:	26 96       	adiw	r28, 0x06	; 6
    6066:	0f b6       	in	r0, 0x3f	; 63
    6068:	f8 94       	cli
    606a:	de bf       	out	0x3e, r29	; 62
    606c:	0f be       	out	0x3f, r0	; 63
    606e:	cd bf       	out	0x3d, r28	; 61
    6070:	cf 91       	pop	r28
    6072:	df 91       	pop	r29
    6074:	08 95       	ret

00006076 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    6076:	df 93       	push	r29
    6078:	cf 93       	push	r28
    607a:	cd b7       	in	r28, 0x3d	; 61
    607c:	de b7       	in	r29, 0x3e	; 62
    607e:	2a 97       	sbiw	r28, 0x0a	; 10
    6080:	0f b6       	in	r0, 0x3f	; 63
    6082:	f8 94       	cli
    6084:	de bf       	out	0x3e, r29	; 62
    6086:	0f be       	out	0x3f, r0	; 63
    6088:	cd bf       	out	0x3d, r28	; 61
    608a:	98 87       	std	Y+8, r25	; 0x08
    608c:	8f 83       	std	Y+7, r24	; 0x07
    608e:	7a 87       	std	Y+10, r23	; 0x0a
    6090:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    6092:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    6094:	0e 94 3c 33 	call	0x6678	; 0x6678 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    6098:	80 91 92 05 	lds	r24, 0x0592
    609c:	90 91 93 05 	lds	r25, 0x0593
    60a0:	9a 83       	std	Y+2, r25	; 0x02
    60a2:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    60a4:	ef 81       	ldd	r30, Y+7	; 0x07
    60a6:	f8 85       	ldd	r31, Y+8	; 0x08
    60a8:	20 81       	ld	r18, Z
    60aa:	31 81       	ldd	r19, Z+1	; 0x01
    60ac:	89 85       	ldd	r24, Y+9	; 0x09
    60ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    60b0:	82 0f       	add	r24, r18
    60b2:	93 1f       	adc	r25, r19
    60b4:	9e 83       	std	Y+6, r25	; 0x06
    60b6:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    60b8:	ef 81       	ldd	r30, Y+7	; 0x07
    60ba:	f8 85       	ldd	r31, Y+8	; 0x08
    60bc:	20 81       	ld	r18, Z
    60be:	31 81       	ldd	r19, Z+1	; 0x01
    60c0:	89 81       	ldd	r24, Y+1	; 0x01
    60c2:	9a 81       	ldd	r25, Y+2	; 0x02
    60c4:	82 17       	cp	r24, r18
    60c6:	93 07       	cpc	r25, r19
    60c8:	98 f4       	brcc	.+38     	; 0x60f0 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    60ca:	ef 81       	ldd	r30, Y+7	; 0x07
    60cc:	f8 85       	ldd	r31, Y+8	; 0x08
    60ce:	20 81       	ld	r18, Z
    60d0:	31 81       	ldd	r19, Z+1	; 0x01
    60d2:	8d 81       	ldd	r24, Y+5	; 0x05
    60d4:	9e 81       	ldd	r25, Y+6	; 0x06
    60d6:	82 17       	cp	r24, r18
    60d8:	93 07       	cpc	r25, r19
    60da:	e0 f4       	brcc	.+56     	; 0x6114 <vTaskDelayUntil+0x9e>
    60dc:	2d 81       	ldd	r18, Y+5	; 0x05
    60de:	3e 81       	ldd	r19, Y+6	; 0x06
    60e0:	89 81       	ldd	r24, Y+1	; 0x01
    60e2:	9a 81       	ldd	r25, Y+2	; 0x02
    60e4:	82 17       	cp	r24, r18
    60e6:	93 07       	cpc	r25, r19
    60e8:	a8 f4       	brcc	.+42     	; 0x6114 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    60ea:	81 e0       	ldi	r24, 0x01	; 1
    60ec:	8b 83       	std	Y+3, r24	; 0x03
    60ee:	12 c0       	rjmp	.+36     	; 0x6114 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    60f0:	ef 81       	ldd	r30, Y+7	; 0x07
    60f2:	f8 85       	ldd	r31, Y+8	; 0x08
    60f4:	20 81       	ld	r18, Z
    60f6:	31 81       	ldd	r19, Z+1	; 0x01
    60f8:	8d 81       	ldd	r24, Y+5	; 0x05
    60fa:	9e 81       	ldd	r25, Y+6	; 0x06
    60fc:	82 17       	cp	r24, r18
    60fe:	93 07       	cpc	r25, r19
    6100:	38 f0       	brcs	.+14     	; 0x6110 <vTaskDelayUntil+0x9a>
    6102:	2d 81       	ldd	r18, Y+5	; 0x05
    6104:	3e 81       	ldd	r19, Y+6	; 0x06
    6106:	89 81       	ldd	r24, Y+1	; 0x01
    6108:	9a 81       	ldd	r25, Y+2	; 0x02
    610a:	82 17       	cp	r24, r18
    610c:	93 07       	cpc	r25, r19
    610e:	10 f4       	brcc	.+4      	; 0x6114 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    6110:	81 e0       	ldi	r24, 0x01	; 1
    6112:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    6114:	ef 81       	ldd	r30, Y+7	; 0x07
    6116:	f8 85       	ldd	r31, Y+8	; 0x08
    6118:	8d 81       	ldd	r24, Y+5	; 0x05
    611a:	9e 81       	ldd	r25, Y+6	; 0x06
    611c:	91 83       	std	Z+1, r25	; 0x01
    611e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    6120:	8b 81       	ldd	r24, Y+3	; 0x03
    6122:	88 23       	and	r24, r24
    6124:	49 f0       	breq	.+18     	; 0x6138 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    6126:	8d 81       	ldd	r24, Y+5	; 0x05
    6128:	9e 81       	ldd	r25, Y+6	; 0x06
    612a:	29 81       	ldd	r18, Y+1	; 0x01
    612c:	3a 81       	ldd	r19, Y+2	; 0x02
    612e:	82 1b       	sub	r24, r18
    6130:	93 0b       	sbc	r25, r19
    6132:	60 e0       	ldi	r22, 0x00	; 0
    6134:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    6138:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>
    613c:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    613e:	8c 81       	ldd	r24, Y+4	; 0x04
    6140:	88 23       	and	r24, r24
    6142:	11 f4       	brne	.+4      	; 0x6148 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    6144:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    6148:	2a 96       	adiw	r28, 0x0a	; 10
    614a:	0f b6       	in	r0, 0x3f	; 63
    614c:	f8 94       	cli
    614e:	de bf       	out	0x3e, r29	; 62
    6150:	0f be       	out	0x3f, r0	; 63
    6152:	cd bf       	out	0x3d, r28	; 61
    6154:	cf 91       	pop	r28
    6156:	df 91       	pop	r29
    6158:	08 95       	ret

0000615a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    615a:	df 93       	push	r29
    615c:	cf 93       	push	r28
    615e:	00 d0       	rcall	.+0      	; 0x6160 <vTaskDelay+0x6>
    6160:	0f 92       	push	r0
    6162:	cd b7       	in	r28, 0x3d	; 61
    6164:	de b7       	in	r29, 0x3e	; 62
    6166:	9b 83       	std	Y+3, r25	; 0x03
    6168:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    616a:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    616c:	8a 81       	ldd	r24, Y+2	; 0x02
    616e:	9b 81       	ldd	r25, Y+3	; 0x03
    6170:	00 97       	sbiw	r24, 0x00	; 0
    6172:	51 f0       	breq	.+20     	; 0x6188 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    6174:	0e 94 3c 33 	call	0x6678	; 0x6678 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    6178:	8a 81       	ldd	r24, Y+2	; 0x02
    617a:	9b 81       	ldd	r25, Y+3	; 0x03
    617c:	60 e0       	ldi	r22, 0x00	; 0
    617e:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    6182:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>
    6186:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    6188:	89 81       	ldd	r24, Y+1	; 0x01
    618a:	88 23       	and	r24, r24
    618c:	11 f4       	brne	.+4      	; 0x6192 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    618e:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    6192:	0f 90       	pop	r0
    6194:	0f 90       	pop	r0
    6196:	0f 90       	pop	r0
    6198:	cf 91       	pop	r28
    619a:	df 91       	pop	r29
    619c:	08 95       	ret

0000619e <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    619e:	df 93       	push	r29
    61a0:	cf 93       	push	r28
    61a2:	cd b7       	in	r28, 0x3d	; 61
    61a4:	de b7       	in	r29, 0x3e	; 62
    61a6:	2a 97       	sbiw	r28, 0x0a	; 10
    61a8:	0f b6       	in	r0, 0x3f	; 63
    61aa:	f8 94       	cli
    61ac:	de bf       	out	0x3e, r29	; 62
    61ae:	0f be       	out	0x3f, r0	; 63
    61b0:	cd bf       	out	0x3d, r28	; 61
    61b2:	9f 83       	std	Y+7, r25	; 0x07
    61b4:	8e 83       	std	Y+6, r24	; 0x06
    61b6:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    61b8:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    61ba:	88 85       	ldd	r24, Y+8	; 0x08
    61bc:	89 30       	cpi	r24, 0x09	; 9
    61be:	10 f0       	brcs	.+4      	; 0x61c4 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    61c0:	88 e0       	ldi	r24, 0x08	; 8
    61c2:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    61c4:	0f b6       	in	r0, 0x3f	; 63
    61c6:	f8 94       	cli
    61c8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    61ca:	8e 81       	ldd	r24, Y+6	; 0x06
    61cc:	9f 81       	ldd	r25, Y+7	; 0x07
    61ce:	00 97       	sbiw	r24, 0x00	; 0
    61d0:	39 f4       	brne	.+14     	; 0x61e0 <vTaskPrioritySet+0x42>
    61d2:	80 91 8e 05 	lds	r24, 0x058E
    61d6:	90 91 8f 05 	lds	r25, 0x058F
    61da:	9a 87       	std	Y+10, r25	; 0x0a
    61dc:	89 87       	std	Y+9, r24	; 0x09
    61de:	04 c0       	rjmp	.+8      	; 0x61e8 <vTaskPrioritySet+0x4a>
    61e0:	8e 81       	ldd	r24, Y+6	; 0x06
    61e2:	9f 81       	ldd	r25, Y+7	; 0x07
    61e4:	9a 87       	std	Y+10, r25	; 0x0a
    61e6:	89 87       	std	Y+9, r24	; 0x09
    61e8:	89 85       	ldd	r24, Y+9	; 0x09
    61ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    61ec:	9d 83       	std	Y+5, r25	; 0x05
    61ee:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    61f0:	ec 81       	ldd	r30, Y+4	; 0x04
    61f2:	fd 81       	ldd	r31, Y+5	; 0x05
    61f4:	81 a1       	ldd	r24, Z+33	; 0x21
    61f6:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    61f8:	9b 81       	ldd	r25, Y+3	; 0x03
    61fa:	88 85       	ldd	r24, Y+8	; 0x08
    61fc:	98 17       	cp	r25, r24
    61fe:	09 f4       	brne	.+2      	; 0x6202 <vTaskPrioritySet+0x64>
    6200:	8d c0       	rjmp	.+282    	; 0x631c <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    6202:	98 85       	ldd	r25, Y+8	; 0x08
    6204:	8b 81       	ldd	r24, Y+3	; 0x03
    6206:	89 17       	cp	r24, r25
    6208:	a0 f4       	brcc	.+40     	; 0x6232 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    620a:	20 91 8e 05 	lds	r18, 0x058E
    620e:	30 91 8f 05 	lds	r19, 0x058F
    6212:	8c 81       	ldd	r24, Y+4	; 0x04
    6214:	9d 81       	ldd	r25, Y+5	; 0x05
    6216:	82 17       	cp	r24, r18
    6218:	93 07       	cpc	r25, r19
    621a:	b1 f0       	breq	.+44     	; 0x6248 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    621c:	e0 91 8e 05 	lds	r30, 0x058E
    6220:	f0 91 8f 05 	lds	r31, 0x058F
    6224:	96 89       	ldd	r25, Z+22	; 0x16
    6226:	88 85       	ldd	r24, Y+8	; 0x08
    6228:	89 17       	cp	r24, r25
    622a:	70 f0       	brcs	.+28     	; 0x6248 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    622c:	81 e0       	ldi	r24, 0x01	; 1
    622e:	89 83       	std	Y+1, r24	; 0x01
    6230:	0b c0       	rjmp	.+22     	; 0x6248 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    6232:	20 91 8e 05 	lds	r18, 0x058E
    6236:	30 91 8f 05 	lds	r19, 0x058F
    623a:	8c 81       	ldd	r24, Y+4	; 0x04
    623c:	9d 81       	ldd	r25, Y+5	; 0x05
    623e:	82 17       	cp	r24, r18
    6240:	93 07       	cpc	r25, r19
    6242:	11 f4       	brne	.+4      	; 0x6248 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    6244:	81 e0       	ldi	r24, 0x01	; 1
    6246:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    6248:	ec 81       	ldd	r30, Y+4	; 0x04
    624a:	fd 81       	ldd	r31, Y+5	; 0x05
    624c:	86 89       	ldd	r24, Z+22	; 0x16
    624e:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    6250:	ec 81       	ldd	r30, Y+4	; 0x04
    6252:	fd 81       	ldd	r31, Y+5	; 0x05
    6254:	91 a1       	ldd	r25, Z+33	; 0x21
    6256:	ec 81       	ldd	r30, Y+4	; 0x04
    6258:	fd 81       	ldd	r31, Y+5	; 0x05
    625a:	86 89       	ldd	r24, Z+22	; 0x16
    625c:	98 17       	cp	r25, r24
    625e:	21 f4       	brne	.+8      	; 0x6268 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    6260:	ec 81       	ldd	r30, Y+4	; 0x04
    6262:	fd 81       	ldd	r31, Y+5	; 0x05
    6264:	88 85       	ldd	r24, Y+8	; 0x08
    6266:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    6268:	ec 81       	ldd	r30, Y+4	; 0x04
    626a:	fd 81       	ldd	r31, Y+5	; 0x05
    626c:	88 85       	ldd	r24, Y+8	; 0x08
    626e:	81 a3       	std	Z+33, r24	; 0x21
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    6270:	ec 81       	ldd	r30, Y+4	; 0x04
    6272:	fd 81       	ldd	r31, Y+5	; 0x05
    6274:	84 85       	ldd	r24, Z+12	; 0x0c
    6276:	95 85       	ldd	r25, Z+13	; 0x0d
    6278:	99 23       	and	r25, r25
    627a:	5c f0       	brlt	.+22     	; 0x6292 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    627c:	88 85       	ldd	r24, Y+8	; 0x08
    627e:	28 2f       	mov	r18, r24
    6280:	30 e0       	ldi	r19, 0x00	; 0
    6282:	89 e0       	ldi	r24, 0x09	; 9
    6284:	90 e0       	ldi	r25, 0x00	; 0
    6286:	82 1b       	sub	r24, r18
    6288:	93 0b       	sbc	r25, r19
    628a:	ec 81       	ldd	r30, Y+4	; 0x04
    628c:	fd 81       	ldd	r31, Y+5	; 0x05
    628e:	95 87       	std	Z+13, r25	; 0x0d
    6290:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    6292:	ec 81       	ldd	r30, Y+4	; 0x04
    6294:	fd 81       	ldd	r31, Y+5	; 0x05
    6296:	42 85       	ldd	r20, Z+10	; 0x0a
    6298:	53 85       	ldd	r21, Z+11	; 0x0b
    629a:	8a 81       	ldd	r24, Y+2	; 0x02
    629c:	28 2f       	mov	r18, r24
    629e:	30 e0       	ldi	r19, 0x00	; 0
    62a0:	c9 01       	movw	r24, r18
    62a2:	88 0f       	add	r24, r24
    62a4:	99 1f       	adc	r25, r25
    62a6:	88 0f       	add	r24, r24
    62a8:	99 1f       	adc	r25, r25
    62aa:	88 0f       	add	r24, r24
    62ac:	99 1f       	adc	r25, r25
    62ae:	82 0f       	add	r24, r18
    62b0:	93 1f       	adc	r25, r19
    62b2:	81 56       	subi	r24, 0x61	; 97
    62b4:	9a 4f       	sbci	r25, 0xFA	; 250
    62b6:	48 17       	cp	r20, r24
    62b8:	59 07       	cpc	r21, r25
    62ba:	59 f5       	brne	.+86     	; 0x6312 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    62bc:	8c 81       	ldd	r24, Y+4	; 0x04
    62be:	9d 81       	ldd	r25, Y+5	; 0x05
    62c0:	02 96       	adiw	r24, 0x02	; 2
    62c2:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    62c6:	ec 81       	ldd	r30, Y+4	; 0x04
    62c8:	fd 81       	ldd	r31, Y+5	; 0x05
    62ca:	96 89       	ldd	r25, Z+22	; 0x16
    62cc:	80 91 94 05 	lds	r24, 0x0594
    62d0:	89 17       	cp	r24, r25
    62d2:	28 f4       	brcc	.+10     	; 0x62de <vTaskPrioritySet+0x140>
    62d4:	ec 81       	ldd	r30, Y+4	; 0x04
    62d6:	fd 81       	ldd	r31, Y+5	; 0x05
    62d8:	86 89       	ldd	r24, Z+22	; 0x16
    62da:	80 93 94 05 	sts	0x0594, r24
    62de:	ec 81       	ldd	r30, Y+4	; 0x04
    62e0:	fd 81       	ldd	r31, Y+5	; 0x05
    62e2:	86 89       	ldd	r24, Z+22	; 0x16
    62e4:	28 2f       	mov	r18, r24
    62e6:	30 e0       	ldi	r19, 0x00	; 0
    62e8:	c9 01       	movw	r24, r18
    62ea:	88 0f       	add	r24, r24
    62ec:	99 1f       	adc	r25, r25
    62ee:	88 0f       	add	r24, r24
    62f0:	99 1f       	adc	r25, r25
    62f2:	88 0f       	add	r24, r24
    62f4:	99 1f       	adc	r25, r25
    62f6:	82 0f       	add	r24, r18
    62f8:	93 1f       	adc	r25, r19
    62fa:	ac 01       	movw	r20, r24
    62fc:	41 56       	subi	r20, 0x61	; 97
    62fe:	5a 4f       	sbci	r21, 0xFA	; 250
    6300:	8c 81       	ldd	r24, Y+4	; 0x04
    6302:	9d 81       	ldd	r25, Y+5	; 0x05
    6304:	9c 01       	movw	r18, r24
    6306:	2e 5f       	subi	r18, 0xFE	; 254
    6308:	3f 4f       	sbci	r19, 0xFF	; 255
    630a:	ca 01       	movw	r24, r20
    630c:	b9 01       	movw	r22, r18
    630e:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    6312:	89 81       	ldd	r24, Y+1	; 0x01
    6314:	88 23       	and	r24, r24
    6316:	11 f0       	breq	.+4      	; 0x631c <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    6318:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    631c:	0f 90       	pop	r0
    631e:	0f be       	out	0x3f, r0	; 63
	}
    6320:	2a 96       	adiw	r28, 0x0a	; 10
    6322:	0f b6       	in	r0, 0x3f	; 63
    6324:	f8 94       	cli
    6326:	de bf       	out	0x3e, r29	; 62
    6328:	0f be       	out	0x3f, r0	; 63
    632a:	cd bf       	out	0x3d, r28	; 61
    632c:	cf 91       	pop	r28
    632e:	df 91       	pop	r29
    6330:	08 95       	ret

00006332 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    6332:	df 93       	push	r29
    6334:	cf 93       	push	r28
    6336:	00 d0       	rcall	.+0      	; 0x6338 <vTaskSuspend+0x6>
    6338:	00 d0       	rcall	.+0      	; 0x633a <vTaskSuspend+0x8>
    633a:	00 d0       	rcall	.+0      	; 0x633c <vTaskSuspend+0xa>
    633c:	cd b7       	in	r28, 0x3d	; 61
    633e:	de b7       	in	r29, 0x3e	; 62
    6340:	9c 83       	std	Y+4, r25	; 0x04
    6342:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    6344:	0f b6       	in	r0, 0x3f	; 63
    6346:	f8 94       	cli
    6348:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    634a:	8b 81       	ldd	r24, Y+3	; 0x03
    634c:	9c 81       	ldd	r25, Y+4	; 0x04
    634e:	00 97       	sbiw	r24, 0x00	; 0
    6350:	39 f4       	brne	.+14     	; 0x6360 <vTaskSuspend+0x2e>
    6352:	80 91 8e 05 	lds	r24, 0x058E
    6356:	90 91 8f 05 	lds	r25, 0x058F
    635a:	9e 83       	std	Y+6, r25	; 0x06
    635c:	8d 83       	std	Y+5, r24	; 0x05
    635e:	04 c0       	rjmp	.+8      	; 0x6368 <vTaskSuspend+0x36>
    6360:	8b 81       	ldd	r24, Y+3	; 0x03
    6362:	9c 81       	ldd	r25, Y+4	; 0x04
    6364:	9e 83       	std	Y+6, r25	; 0x06
    6366:	8d 83       	std	Y+5, r24	; 0x05
    6368:	8d 81       	ldd	r24, Y+5	; 0x05
    636a:	9e 81       	ldd	r25, Y+6	; 0x06
    636c:	9a 83       	std	Y+2, r25	; 0x02
    636e:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6370:	89 81       	ldd	r24, Y+1	; 0x01
    6372:	9a 81       	ldd	r25, Y+2	; 0x02
    6374:	02 96       	adiw	r24, 0x02	; 2
    6376:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    637a:	e9 81       	ldd	r30, Y+1	; 0x01
    637c:	fa 81       	ldd	r31, Y+2	; 0x02
    637e:	84 89       	ldd	r24, Z+20	; 0x14
    6380:	95 89       	ldd	r25, Z+21	; 0x15
    6382:	00 97       	sbiw	r24, 0x00	; 0
    6384:	29 f0       	breq	.+10     	; 0x6390 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    6386:	89 81       	ldd	r24, Y+1	; 0x01
    6388:	9a 81       	ldd	r25, Y+2	; 0x02
    638a:	0c 96       	adiw	r24, 0x0c	; 12
    638c:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    6390:	89 81       	ldd	r24, Y+1	; 0x01
    6392:	9a 81       	ldd	r25, Y+2	; 0x02
    6394:	9c 01       	movw	r18, r24
    6396:	2e 5f       	subi	r18, 0xFE	; 254
    6398:	3f 4f       	sbci	r19, 0xFF	; 255
    639a:	88 e1       	ldi	r24, 0x18	; 24
    639c:	96 e0       	ldi	r25, 0x06	; 6
    639e:	b9 01       	movw	r22, r18
    63a0:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    63a4:	0f 90       	pop	r0
    63a6:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    63a8:	80 91 95 05 	lds	r24, 0x0595
    63ac:	88 23       	and	r24, r24
    63ae:	39 f0       	breq	.+14     	; 0x63be <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    63b0:	0f b6       	in	r0, 0x3f	; 63
    63b2:	f8 94       	cli
    63b4:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    63b6:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    63ba:	0f 90       	pop	r0
    63bc:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    63be:	20 91 8e 05 	lds	r18, 0x058E
    63c2:	30 91 8f 05 	lds	r19, 0x058F
    63c6:	89 81       	ldd	r24, Y+1	; 0x01
    63c8:	9a 81       	ldd	r25, Y+2	; 0x02
    63ca:	82 17       	cp	r24, r18
    63cc:	93 07       	cpc	r25, r19
    63ce:	a1 f4       	brne	.+40     	; 0x63f8 <vTaskSuspend+0xc6>
		{
			if( xSchedulerRunning != pdFALSE )
    63d0:	80 91 95 05 	lds	r24, 0x0595
    63d4:	88 23       	and	r24, r24
    63d6:	19 f0       	breq	.+6      	; 0x63de <vTaskSuspend+0xac>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    63d8:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
    63dc:	0d c0       	rjmp	.+26     	; 0x63f8 <vTaskSuspend+0xc6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    63de:	90 91 18 06 	lds	r25, 0x0618
    63e2:	80 91 91 05 	lds	r24, 0x0591
    63e6:	98 17       	cp	r25, r24
    63e8:	29 f4       	brne	.+10     	; 0x63f4 <vTaskSuspend+0xc2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    63ea:	10 92 8f 05 	sts	0x058F, r1
    63ee:	10 92 8e 05 	sts	0x058E, r1
    63f2:	02 c0       	rjmp	.+4      	; 0x63f8 <vTaskSuspend+0xc6>
				}
				else
				{
					vTaskSwitchContext();
    63f4:	0e 94 04 35 	call	0x6a08	; 0x6a08 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    63f8:	26 96       	adiw	r28, 0x06	; 6
    63fa:	0f b6       	in	r0, 0x3f	; 63
    63fc:	f8 94       	cli
    63fe:	de bf       	out	0x3e, r29	; 62
    6400:	0f be       	out	0x3f, r0	; 63
    6402:	cd bf       	out	0x3d, r28	; 61
    6404:	cf 91       	pop	r28
    6406:	df 91       	pop	r29
    6408:	08 95       	ret

0000640a <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    640a:	df 93       	push	r29
    640c:	cf 93       	push	r28
    640e:	00 d0       	rcall	.+0      	; 0x6410 <prvTaskIsTaskSuspended+0x6>
    6410:	00 d0       	rcall	.+0      	; 0x6412 <prvTaskIsTaskSuspended+0x8>
    6412:	0f 92       	push	r0
    6414:	cd b7       	in	r28, 0x3d	; 61
    6416:	de b7       	in	r29, 0x3e	; 62
    6418:	9d 83       	std	Y+5, r25	; 0x05
    641a:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    641c:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    641e:	8c 81       	ldd	r24, Y+4	; 0x04
    6420:	9d 81       	ldd	r25, Y+5	; 0x05
    6422:	9a 83       	std	Y+2, r25	; 0x02
    6424:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    6426:	e9 81       	ldd	r30, Y+1	; 0x01
    6428:	fa 81       	ldd	r31, Y+2	; 0x02
    642a:	82 85       	ldd	r24, Z+10	; 0x0a
    642c:	93 85       	ldd	r25, Z+11	; 0x0b
    642e:	26 e0       	ldi	r18, 0x06	; 6
    6430:	88 31       	cpi	r24, 0x18	; 24
    6432:	92 07       	cpc	r25, r18
    6434:	81 f4       	brne	.+32     	; 0x6456 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    6436:	e9 81       	ldd	r30, Y+1	; 0x01
    6438:	fa 81       	ldd	r31, Y+2	; 0x02
    643a:	84 89       	ldd	r24, Z+20	; 0x14
    643c:	95 89       	ldd	r25, Z+21	; 0x15
    643e:	26 e0       	ldi	r18, 0x06	; 6
    6440:	86 30       	cpi	r24, 0x06	; 6
    6442:	92 07       	cpc	r25, r18
    6444:	41 f0       	breq	.+16     	; 0x6456 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    6446:	e9 81       	ldd	r30, Y+1	; 0x01
    6448:	fa 81       	ldd	r31, Y+2	; 0x02
    644a:	84 89       	ldd	r24, Z+20	; 0x14
    644c:	95 89       	ldd	r25, Z+21	; 0x15
    644e:	00 97       	sbiw	r24, 0x00	; 0
    6450:	11 f4       	brne	.+4      	; 0x6456 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    6452:	81 e0       	ldi	r24, 0x01	; 1
    6454:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    6456:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    6458:	0f 90       	pop	r0
    645a:	0f 90       	pop	r0
    645c:	0f 90       	pop	r0
    645e:	0f 90       	pop	r0
    6460:	0f 90       	pop	r0
    6462:	cf 91       	pop	r28
    6464:	df 91       	pop	r29
    6466:	08 95       	ret

00006468 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    6468:	df 93       	push	r29
    646a:	cf 93       	push	r28
    646c:	00 d0       	rcall	.+0      	; 0x646e <vTaskResume+0x6>
    646e:	00 d0       	rcall	.+0      	; 0x6470 <vTaskResume+0x8>
    6470:	cd b7       	in	r28, 0x3d	; 61
    6472:	de b7       	in	r29, 0x3e	; 62
    6474:	9c 83       	std	Y+4, r25	; 0x04
    6476:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    6478:	8b 81       	ldd	r24, Y+3	; 0x03
    647a:	9c 81       	ldd	r25, Y+4	; 0x04
    647c:	9a 83       	std	Y+2, r25	; 0x02
    647e:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    6480:	89 81       	ldd	r24, Y+1	; 0x01
    6482:	9a 81       	ldd	r25, Y+2	; 0x02
    6484:	00 97       	sbiw	r24, 0x00	; 0
    6486:	09 f4       	brne	.+2      	; 0x648a <vTaskResume+0x22>
    6488:	4c c0       	rjmp	.+152    	; 0x6522 <vTaskResume+0xba>
    648a:	20 91 8e 05 	lds	r18, 0x058E
    648e:	30 91 8f 05 	lds	r19, 0x058F
    6492:	89 81       	ldd	r24, Y+1	; 0x01
    6494:	9a 81       	ldd	r25, Y+2	; 0x02
    6496:	82 17       	cp	r24, r18
    6498:	93 07       	cpc	r25, r19
    649a:	09 f4       	brne	.+2      	; 0x649e <vTaskResume+0x36>
    649c:	42 c0       	rjmp	.+132    	; 0x6522 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    649e:	0f b6       	in	r0, 0x3f	; 63
    64a0:	f8 94       	cli
    64a2:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    64a4:	89 81       	ldd	r24, Y+1	; 0x01
    64a6:	9a 81       	ldd	r25, Y+2	; 0x02
    64a8:	0e 94 05 32 	call	0x640a	; 0x640a <prvTaskIsTaskSuspended>
    64ac:	88 23       	and	r24, r24
    64ae:	b9 f1       	breq	.+110    	; 0x651e <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    64b0:	89 81       	ldd	r24, Y+1	; 0x01
    64b2:	9a 81       	ldd	r25, Y+2	; 0x02
    64b4:	02 96       	adiw	r24, 0x02	; 2
    64b6:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    64ba:	e9 81       	ldd	r30, Y+1	; 0x01
    64bc:	fa 81       	ldd	r31, Y+2	; 0x02
    64be:	96 89       	ldd	r25, Z+22	; 0x16
    64c0:	80 91 94 05 	lds	r24, 0x0594
    64c4:	89 17       	cp	r24, r25
    64c6:	28 f4       	brcc	.+10     	; 0x64d2 <vTaskResume+0x6a>
    64c8:	e9 81       	ldd	r30, Y+1	; 0x01
    64ca:	fa 81       	ldd	r31, Y+2	; 0x02
    64cc:	86 89       	ldd	r24, Z+22	; 0x16
    64ce:	80 93 94 05 	sts	0x0594, r24
    64d2:	e9 81       	ldd	r30, Y+1	; 0x01
    64d4:	fa 81       	ldd	r31, Y+2	; 0x02
    64d6:	86 89       	ldd	r24, Z+22	; 0x16
    64d8:	28 2f       	mov	r18, r24
    64da:	30 e0       	ldi	r19, 0x00	; 0
    64dc:	c9 01       	movw	r24, r18
    64de:	88 0f       	add	r24, r24
    64e0:	99 1f       	adc	r25, r25
    64e2:	88 0f       	add	r24, r24
    64e4:	99 1f       	adc	r25, r25
    64e6:	88 0f       	add	r24, r24
    64e8:	99 1f       	adc	r25, r25
    64ea:	82 0f       	add	r24, r18
    64ec:	93 1f       	adc	r25, r19
    64ee:	ac 01       	movw	r20, r24
    64f0:	41 56       	subi	r20, 0x61	; 97
    64f2:	5a 4f       	sbci	r21, 0xFA	; 250
    64f4:	89 81       	ldd	r24, Y+1	; 0x01
    64f6:	9a 81       	ldd	r25, Y+2	; 0x02
    64f8:	9c 01       	movw	r18, r24
    64fa:	2e 5f       	subi	r18, 0xFE	; 254
    64fc:	3f 4f       	sbci	r19, 0xFF	; 255
    64fe:	ca 01       	movw	r24, r20
    6500:	b9 01       	movw	r22, r18
    6502:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6506:	e9 81       	ldd	r30, Y+1	; 0x01
    6508:	fa 81       	ldd	r31, Y+2	; 0x02
    650a:	96 89       	ldd	r25, Z+22	; 0x16
    650c:	e0 91 8e 05 	lds	r30, 0x058E
    6510:	f0 91 8f 05 	lds	r31, 0x058F
    6514:	86 89       	ldd	r24, Z+22	; 0x16
    6516:	98 17       	cp	r25, r24
    6518:	10 f0       	brcs	.+4      	; 0x651e <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    651a:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    651e:	0f 90       	pop	r0
    6520:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    6522:	0f 90       	pop	r0
    6524:	0f 90       	pop	r0
    6526:	0f 90       	pop	r0
    6528:	0f 90       	pop	r0
    652a:	cf 91       	pop	r28
    652c:	df 91       	pop	r29
    652e:	08 95       	ret

00006530 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    6530:	df 93       	push	r29
    6532:	cf 93       	push	r28
    6534:	00 d0       	rcall	.+0      	; 0x6536 <xTaskResumeFromISR+0x6>
    6536:	00 d0       	rcall	.+0      	; 0x6538 <xTaskResumeFromISR+0x8>
    6538:	00 d0       	rcall	.+0      	; 0x653a <xTaskResumeFromISR+0xa>
    653a:	cd b7       	in	r28, 0x3d	; 61
    653c:	de b7       	in	r29, 0x3e	; 62
    653e:	9e 83       	std	Y+6, r25	; 0x06
    6540:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    6542:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    6544:	8d 81       	ldd	r24, Y+5	; 0x05
    6546:	9e 81       	ldd	r25, Y+6	; 0x06
    6548:	9b 83       	std	Y+3, r25	; 0x03
    654a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    654c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    654e:	8a 81       	ldd	r24, Y+2	; 0x02
    6550:	9b 81       	ldd	r25, Y+3	; 0x03
    6552:	0e 94 05 32 	call	0x640a	; 0x640a <prvTaskIsTaskSuspended>
    6556:	88 23       	and	r24, r24
    6558:	09 f4       	brne	.+2      	; 0x655c <xTaskResumeFromISR+0x2c>
    655a:	46 c0       	rjmp	.+140    	; 0x65e8 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    655c:	80 91 9e 05 	lds	r24, 0x059E
    6560:	88 23       	and	r24, r24
    6562:	c1 f5       	brne	.+112    	; 0x65d4 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6564:	ea 81       	ldd	r30, Y+2	; 0x02
    6566:	fb 81       	ldd	r31, Y+3	; 0x03
    6568:	96 89       	ldd	r25, Z+22	; 0x16
    656a:	e0 91 8e 05 	lds	r30, 0x058E
    656e:	f0 91 8f 05 	lds	r31, 0x058F
    6572:	86 89       	ldd	r24, Z+22	; 0x16
    6574:	98 17       	cp	r25, r24
    6576:	10 f0       	brcs	.+4      	; 0x657c <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    6578:	81 e0       	ldi	r24, 0x01	; 1
    657a:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    657c:	8a 81       	ldd	r24, Y+2	; 0x02
    657e:	9b 81       	ldd	r25, Y+3	; 0x03
    6580:	02 96       	adiw	r24, 0x02	; 2
    6582:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6586:	ea 81       	ldd	r30, Y+2	; 0x02
    6588:	fb 81       	ldd	r31, Y+3	; 0x03
    658a:	96 89       	ldd	r25, Z+22	; 0x16
    658c:	80 91 94 05 	lds	r24, 0x0594
    6590:	89 17       	cp	r24, r25
    6592:	28 f4       	brcc	.+10     	; 0x659e <xTaskResumeFromISR+0x6e>
    6594:	ea 81       	ldd	r30, Y+2	; 0x02
    6596:	fb 81       	ldd	r31, Y+3	; 0x03
    6598:	86 89       	ldd	r24, Z+22	; 0x16
    659a:	80 93 94 05 	sts	0x0594, r24
    659e:	ea 81       	ldd	r30, Y+2	; 0x02
    65a0:	fb 81       	ldd	r31, Y+3	; 0x03
    65a2:	86 89       	ldd	r24, Z+22	; 0x16
    65a4:	28 2f       	mov	r18, r24
    65a6:	30 e0       	ldi	r19, 0x00	; 0
    65a8:	c9 01       	movw	r24, r18
    65aa:	88 0f       	add	r24, r24
    65ac:	99 1f       	adc	r25, r25
    65ae:	88 0f       	add	r24, r24
    65b0:	99 1f       	adc	r25, r25
    65b2:	88 0f       	add	r24, r24
    65b4:	99 1f       	adc	r25, r25
    65b6:	82 0f       	add	r24, r18
    65b8:	93 1f       	adc	r25, r19
    65ba:	ac 01       	movw	r20, r24
    65bc:	41 56       	subi	r20, 0x61	; 97
    65be:	5a 4f       	sbci	r21, 0xFA	; 250
    65c0:	8a 81       	ldd	r24, Y+2	; 0x02
    65c2:	9b 81       	ldd	r25, Y+3	; 0x03
    65c4:	9c 01       	movw	r18, r24
    65c6:	2e 5f       	subi	r18, 0xFE	; 254
    65c8:	3f 4f       	sbci	r19, 0xFF	; 255
    65ca:	ca 01       	movw	r24, r20
    65cc:	b9 01       	movw	r22, r18
    65ce:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
    65d2:	0a c0       	rjmp	.+20     	; 0x65e8 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    65d4:	8a 81       	ldd	r24, Y+2	; 0x02
    65d6:	9b 81       	ldd	r25, Y+3	; 0x03
    65d8:	9c 01       	movw	r18, r24
    65da:	24 5f       	subi	r18, 0xF4	; 244
    65dc:	3f 4f       	sbci	r19, 0xFF	; 255
    65de:	86 e0       	ldi	r24, 0x06	; 6
    65e0:	96 e0       	ldi	r25, 0x06	; 6
    65e2:	b9 01       	movw	r22, r18
    65e4:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    65e8:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    65ea:	26 96       	adiw	r28, 0x06	; 6
    65ec:	0f b6       	in	r0, 0x3f	; 63
    65ee:	f8 94       	cli
    65f0:	de bf       	out	0x3e, r29	; 62
    65f2:	0f be       	out	0x3f, r0	; 63
    65f4:	cd bf       	out	0x3d, r28	; 61
    65f6:	cf 91       	pop	r28
    65f8:	df 91       	pop	r29
    65fa:	08 95       	ret

000065fc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    65fc:	ef 92       	push	r14
    65fe:	ff 92       	push	r15
    6600:	0f 93       	push	r16
    6602:	df 93       	push	r29
    6604:	cf 93       	push	r28
    6606:	0f 92       	push	r0
    6608:	cd b7       	in	r28, 0x3d	; 61
    660a:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    660c:	83 e2       	ldi	r24, 0x23	; 35
    660e:	97 e3       	ldi	r25, 0x37	; 55
    6610:	20 e6       	ldi	r18, 0x60	; 96
    6612:	30 e0       	ldi	r19, 0x00	; 0
    6614:	ec e9       	ldi	r30, 0x9C	; 156
    6616:	f5 e0       	ldi	r31, 0x05	; 5
    6618:	b9 01       	movw	r22, r18
    661a:	40 e5       	ldi	r20, 0x50	; 80
    661c:	50 e0       	ldi	r21, 0x00	; 0
    661e:	20 e0       	ldi	r18, 0x00	; 0
    6620:	30 e0       	ldi	r19, 0x00	; 0
    6622:	00 e0       	ldi	r16, 0x00	; 0
    6624:	7f 01       	movw	r14, r30
    6626:	0e 94 1e 2e 	call	0x5c3c	; 0x5c3c <xTaskCreate>
    662a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    662c:	89 81       	ldd	r24, Y+1	; 0x01
    662e:	81 30       	cpi	r24, 0x01	; 1
    6630:	81 f4       	brne	.+32     	; 0x6652 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    6632:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    6634:	8f ef       	ldi	r24, 0xFF	; 255
    6636:	9f ef       	ldi	r25, 0xFF	; 255
    6638:	90 93 9b 05 	sts	0x059B, r25
    663c:	80 93 9a 05 	sts	0x059A, r24
		xSchedulerRunning = pdTRUE;
    6640:	81 e0       	ldi	r24, 0x01	; 1
    6642:	80 93 95 05 	sts	0x0595, r24
		xTickCount = ( TickType_t ) 0U;
    6646:	10 92 93 05 	sts	0x0593, r1
    664a:	10 92 92 05 	sts	0x0592, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    664e:	0e 94 85 26 	call	0x4d0a	; 0x4d0a <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    6652:	0f 90       	pop	r0
    6654:	cf 91       	pop	r28
    6656:	df 91       	pop	r29
    6658:	0f 91       	pop	r16
    665a:	ff 90       	pop	r15
    665c:	ef 90       	pop	r14
    665e:	08 95       	ret

00006660 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    6660:	df 93       	push	r29
    6662:	cf 93       	push	r28
    6664:	cd b7       	in	r28, 0x3d	; 61
    6666:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    6668:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    666a:	10 92 95 05 	sts	0x0595, r1
	vPortEndScheduler();
    666e:	0e 94 ba 26 	call	0x4d74	; 0x4d74 <vPortEndScheduler>
}
    6672:	cf 91       	pop	r28
    6674:	df 91       	pop	r29
    6676:	08 95       	ret

00006678 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    6678:	df 93       	push	r29
    667a:	cf 93       	push	r28
    667c:	cd b7       	in	r28, 0x3d	; 61
    667e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    6680:	80 91 9e 05 	lds	r24, 0x059E
    6684:	8f 5f       	subi	r24, 0xFF	; 255
    6686:	80 93 9e 05 	sts	0x059E, r24
}
    668a:	cf 91       	pop	r28
    668c:	df 91       	pop	r29
    668e:	08 95       	ret

00006690 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    6690:	df 93       	push	r29
    6692:	cf 93       	push	r28
    6694:	00 d0       	rcall	.+0      	; 0x6696 <xTaskResumeAll+0x6>
    6696:	00 d0       	rcall	.+0      	; 0x6698 <xTaskResumeAll+0x8>
    6698:	cd b7       	in	r28, 0x3d	; 61
    669a:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    669c:	1c 82       	std	Y+4, r1	; 0x04
    669e:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    66a0:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    66a2:	0f b6       	in	r0, 0x3f	; 63
    66a4:	f8 94       	cli
    66a6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    66a8:	80 91 9e 05 	lds	r24, 0x059E
    66ac:	81 50       	subi	r24, 0x01	; 1
    66ae:	80 93 9e 05 	sts	0x059E, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    66b2:	80 91 9e 05 	lds	r24, 0x059E
    66b6:	88 23       	and	r24, r24
    66b8:	09 f0       	breq	.+2      	; 0x66bc <xTaskResumeAll+0x2c>
    66ba:	73 c0       	rjmp	.+230    	; 0x67a2 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    66bc:	80 91 91 05 	lds	r24, 0x0591
    66c0:	88 23       	and	r24, r24
    66c2:	09 f4       	brne	.+2      	; 0x66c6 <xTaskResumeAll+0x36>
    66c4:	6e c0       	rjmp	.+220    	; 0x67a2 <xTaskResumeAll+0x112>
    66c6:	45 c0       	rjmp	.+138    	; 0x6752 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    66c8:	e0 91 0b 06 	lds	r30, 0x060B
    66cc:	f0 91 0c 06 	lds	r31, 0x060C
    66d0:	86 81       	ldd	r24, Z+6	; 0x06
    66d2:	97 81       	ldd	r25, Z+7	; 0x07
    66d4:	9c 83       	std	Y+4, r25	; 0x04
    66d6:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    66d8:	8b 81       	ldd	r24, Y+3	; 0x03
    66da:	9c 81       	ldd	r25, Y+4	; 0x04
    66dc:	0c 96       	adiw	r24, 0x0c	; 12
    66de:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    66e2:	8b 81       	ldd	r24, Y+3	; 0x03
    66e4:	9c 81       	ldd	r25, Y+4	; 0x04
    66e6:	02 96       	adiw	r24, 0x02	; 2
    66e8:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    66ec:	eb 81       	ldd	r30, Y+3	; 0x03
    66ee:	fc 81       	ldd	r31, Y+4	; 0x04
    66f0:	96 89       	ldd	r25, Z+22	; 0x16
    66f2:	80 91 94 05 	lds	r24, 0x0594
    66f6:	89 17       	cp	r24, r25
    66f8:	28 f4       	brcc	.+10     	; 0x6704 <xTaskResumeAll+0x74>
    66fa:	eb 81       	ldd	r30, Y+3	; 0x03
    66fc:	fc 81       	ldd	r31, Y+4	; 0x04
    66fe:	86 89       	ldd	r24, Z+22	; 0x16
    6700:	80 93 94 05 	sts	0x0594, r24
    6704:	eb 81       	ldd	r30, Y+3	; 0x03
    6706:	fc 81       	ldd	r31, Y+4	; 0x04
    6708:	86 89       	ldd	r24, Z+22	; 0x16
    670a:	28 2f       	mov	r18, r24
    670c:	30 e0       	ldi	r19, 0x00	; 0
    670e:	c9 01       	movw	r24, r18
    6710:	88 0f       	add	r24, r24
    6712:	99 1f       	adc	r25, r25
    6714:	88 0f       	add	r24, r24
    6716:	99 1f       	adc	r25, r25
    6718:	88 0f       	add	r24, r24
    671a:	99 1f       	adc	r25, r25
    671c:	82 0f       	add	r24, r18
    671e:	93 1f       	adc	r25, r19
    6720:	ac 01       	movw	r20, r24
    6722:	41 56       	subi	r20, 0x61	; 97
    6724:	5a 4f       	sbci	r21, 0xFA	; 250
    6726:	8b 81       	ldd	r24, Y+3	; 0x03
    6728:	9c 81       	ldd	r25, Y+4	; 0x04
    672a:	9c 01       	movw	r18, r24
    672c:	2e 5f       	subi	r18, 0xFE	; 254
    672e:	3f 4f       	sbci	r19, 0xFF	; 255
    6730:	ca 01       	movw	r24, r20
    6732:	b9 01       	movw	r22, r18
    6734:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6738:	eb 81       	ldd	r30, Y+3	; 0x03
    673a:	fc 81       	ldd	r31, Y+4	; 0x04
    673c:	96 89       	ldd	r25, Z+22	; 0x16
    673e:	e0 91 8e 05 	lds	r30, 0x058E
    6742:	f0 91 8f 05 	lds	r31, 0x058F
    6746:	86 89       	ldd	r24, Z+22	; 0x16
    6748:	98 17       	cp	r25, r24
    674a:	18 f0       	brcs	.+6      	; 0x6752 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    674c:	81 e0       	ldi	r24, 0x01	; 1
    674e:	80 93 97 05 	sts	0x0597, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    6752:	80 91 06 06 	lds	r24, 0x0606
    6756:	88 23       	and	r24, r24
    6758:	09 f0       	breq	.+2      	; 0x675c <xTaskResumeAll+0xcc>
    675a:	b6 cf       	rjmp	.-148    	; 0x66c8 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    675c:	8b 81       	ldd	r24, Y+3	; 0x03
    675e:	9c 81       	ldd	r25, Y+4	; 0x04
    6760:	00 97       	sbiw	r24, 0x00	; 0
    6762:	11 f0       	breq	.+4      	; 0x6768 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    6764:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    6768:	80 91 96 05 	lds	r24, 0x0596
    676c:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    676e:	89 81       	ldd	r24, Y+1	; 0x01
    6770:	88 23       	and	r24, r24
    6772:	79 f0       	breq	.+30     	; 0x6792 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    6774:	0e 94 38 34 	call	0x6870	; 0x6870 <xTaskIncrementTick>
    6778:	88 23       	and	r24, r24
    677a:	19 f0       	breq	.+6      	; 0x6782 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    677c:	81 e0       	ldi	r24, 0x01	; 1
    677e:	80 93 97 05 	sts	0x0597, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    6782:	89 81       	ldd	r24, Y+1	; 0x01
    6784:	81 50       	subi	r24, 0x01	; 1
    6786:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    6788:	89 81       	ldd	r24, Y+1	; 0x01
    678a:	88 23       	and	r24, r24
    678c:	99 f7       	brne	.-26     	; 0x6774 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    678e:	10 92 96 05 	sts	0x0596, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    6792:	80 91 97 05 	lds	r24, 0x0597
    6796:	88 23       	and	r24, r24
    6798:	21 f0       	breq	.+8      	; 0x67a2 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    679a:	81 e0       	ldi	r24, 0x01	; 1
    679c:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    679e:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    67a2:	0f 90       	pop	r0
    67a4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    67a6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    67a8:	0f 90       	pop	r0
    67aa:	0f 90       	pop	r0
    67ac:	0f 90       	pop	r0
    67ae:	0f 90       	pop	r0
    67b0:	cf 91       	pop	r28
    67b2:	df 91       	pop	r29
    67b4:	08 95       	ret

000067b6 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    67b6:	df 93       	push	r29
    67b8:	cf 93       	push	r28
    67ba:	00 d0       	rcall	.+0      	; 0x67bc <xTaskGetTickCount+0x6>
    67bc:	cd b7       	in	r28, 0x3d	; 61
    67be:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    67c0:	0f b6       	in	r0, 0x3f	; 63
    67c2:	f8 94       	cli
    67c4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    67c6:	80 91 92 05 	lds	r24, 0x0592
    67ca:	90 91 93 05 	lds	r25, 0x0593
    67ce:	9a 83       	std	Y+2, r25	; 0x02
    67d0:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    67d2:	0f 90       	pop	r0
    67d4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    67d6:	89 81       	ldd	r24, Y+1	; 0x01
    67d8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    67da:	0f 90       	pop	r0
    67dc:	0f 90       	pop	r0
    67de:	cf 91       	pop	r28
    67e0:	df 91       	pop	r29
    67e2:	08 95       	ret

000067e4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    67e4:	df 93       	push	r29
    67e6:	cf 93       	push	r28
    67e8:	00 d0       	rcall	.+0      	; 0x67ea <xTaskGetTickCountFromISR+0x6>
    67ea:	0f 92       	push	r0
    67ec:	cd b7       	in	r28, 0x3d	; 61
    67ee:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    67f0:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    67f2:	80 91 92 05 	lds	r24, 0x0592
    67f6:	90 91 93 05 	lds	r25, 0x0593
    67fa:	9b 83       	std	Y+3, r25	; 0x03
    67fc:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    67fe:	8a 81       	ldd	r24, Y+2	; 0x02
    6800:	9b 81       	ldd	r25, Y+3	; 0x03
}
    6802:	0f 90       	pop	r0
    6804:	0f 90       	pop	r0
    6806:	0f 90       	pop	r0
    6808:	cf 91       	pop	r28
    680a:	df 91       	pop	r29
    680c:	08 95       	ret

0000680e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    680e:	df 93       	push	r29
    6810:	cf 93       	push	r28
    6812:	cd b7       	in	r28, 0x3d	; 61
    6814:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    6816:	80 91 91 05 	lds	r24, 0x0591
}
    681a:	cf 91       	pop	r28
    681c:	df 91       	pop	r29
    681e:	08 95       	ret

00006820 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    6820:	df 93       	push	r29
    6822:	cf 93       	push	r28
    6824:	00 d0       	rcall	.+0      	; 0x6826 <pcTaskGetName+0x6>
    6826:	00 d0       	rcall	.+0      	; 0x6828 <pcTaskGetName+0x8>
    6828:	00 d0       	rcall	.+0      	; 0x682a <pcTaskGetName+0xa>
    682a:	cd b7       	in	r28, 0x3d	; 61
    682c:	de b7       	in	r29, 0x3e	; 62
    682e:	9c 83       	std	Y+4, r25	; 0x04
    6830:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    6832:	8b 81       	ldd	r24, Y+3	; 0x03
    6834:	9c 81       	ldd	r25, Y+4	; 0x04
    6836:	00 97       	sbiw	r24, 0x00	; 0
    6838:	39 f4       	brne	.+14     	; 0x6848 <pcTaskGetName+0x28>
    683a:	80 91 8e 05 	lds	r24, 0x058E
    683e:	90 91 8f 05 	lds	r25, 0x058F
    6842:	9e 83       	std	Y+6, r25	; 0x06
    6844:	8d 83       	std	Y+5, r24	; 0x05
    6846:	04 c0       	rjmp	.+8      	; 0x6850 <pcTaskGetName+0x30>
    6848:	8b 81       	ldd	r24, Y+3	; 0x03
    684a:	9c 81       	ldd	r25, Y+4	; 0x04
    684c:	9e 83       	std	Y+6, r25	; 0x06
    684e:	8d 83       	std	Y+5, r24	; 0x05
    6850:	8d 81       	ldd	r24, Y+5	; 0x05
    6852:	9e 81       	ldd	r25, Y+6	; 0x06
    6854:	9a 83       	std	Y+2, r25	; 0x02
    6856:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    6858:	89 81       	ldd	r24, Y+1	; 0x01
    685a:	9a 81       	ldd	r25, Y+2	; 0x02
    685c:	49 96       	adiw	r24, 0x19	; 25
}
    685e:	26 96       	adiw	r28, 0x06	; 6
    6860:	0f b6       	in	r0, 0x3f	; 63
    6862:	f8 94       	cli
    6864:	de bf       	out	0x3e, r29	; 62
    6866:	0f be       	out	0x3f, r0	; 63
    6868:	cd bf       	out	0x3d, r28	; 61
    686a:	cf 91       	pop	r28
    686c:	df 91       	pop	r29
    686e:	08 95       	ret

00006870 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    6870:	df 93       	push	r29
    6872:	cf 93       	push	r28
    6874:	cd b7       	in	r28, 0x3d	; 61
    6876:	de b7       	in	r29, 0x3e	; 62
    6878:	29 97       	sbiw	r28, 0x09	; 9
    687a:	0f b6       	in	r0, 0x3f	; 63
    687c:	f8 94       	cli
    687e:	de bf       	out	0x3e, r29	; 62
    6880:	0f be       	out	0x3f, r0	; 63
    6882:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    6884:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6886:	80 91 9e 05 	lds	r24, 0x059E
    688a:	88 23       	and	r24, r24
    688c:	09 f0       	breq	.+2      	; 0x6890 <xTaskIncrementTick+0x20>
    688e:	a7 c0       	rjmp	.+334    	; 0x69de <xTaskIncrementTick+0x16e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    6890:	80 91 92 05 	lds	r24, 0x0592
    6894:	90 91 93 05 	lds	r25, 0x0593
    6898:	01 96       	adiw	r24, 0x01	; 1
    689a:	9c 83       	std	Y+4, r25	; 0x04
    689c:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    689e:	8b 81       	ldd	r24, Y+3	; 0x03
    68a0:	9c 81       	ldd	r25, Y+4	; 0x04
    68a2:	90 93 93 05 	sts	0x0593, r25
    68a6:	80 93 92 05 	sts	0x0592, r24

		if( xConstTickCount == ( TickType_t ) 0U )
    68aa:	8b 81       	ldd	r24, Y+3	; 0x03
    68ac:	9c 81       	ldd	r25, Y+4	; 0x04
    68ae:	00 97       	sbiw	r24, 0x00	; 0
    68b0:	d9 f4       	brne	.+54     	; 0x68e8 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    68b2:	80 91 02 06 	lds	r24, 0x0602
    68b6:	90 91 03 06 	lds	r25, 0x0603
    68ba:	9a 83       	std	Y+2, r25	; 0x02
    68bc:	89 83       	std	Y+1, r24	; 0x01
    68be:	80 91 04 06 	lds	r24, 0x0604
    68c2:	90 91 05 06 	lds	r25, 0x0605
    68c6:	90 93 03 06 	sts	0x0603, r25
    68ca:	80 93 02 06 	sts	0x0602, r24
    68ce:	89 81       	ldd	r24, Y+1	; 0x01
    68d0:	9a 81       	ldd	r25, Y+2	; 0x02
    68d2:	90 93 05 06 	sts	0x0605, r25
    68d6:	80 93 04 06 	sts	0x0604, r24
    68da:	80 91 98 05 	lds	r24, 0x0598
    68de:	8f 5f       	subi	r24, 0xFF	; 255
    68e0:	80 93 98 05 	sts	0x0598, r24
    68e4:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    68e8:	20 91 9a 05 	lds	r18, 0x059A
    68ec:	30 91 9b 05 	lds	r19, 0x059B
    68f0:	8b 81       	ldd	r24, Y+3	; 0x03
    68f2:	9c 81       	ldd	r25, Y+4	; 0x04
    68f4:	82 17       	cp	r24, r18
    68f6:	93 07       	cpc	r25, r19
    68f8:	08 f4       	brcc	.+2      	; 0x68fc <xTaskIncrementTick+0x8c>
    68fa:	76 c0       	rjmp	.+236    	; 0x69e8 <xTaskIncrementTick+0x178>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    68fc:	e0 91 02 06 	lds	r30, 0x0602
    6900:	f0 91 03 06 	lds	r31, 0x0603
    6904:	80 81       	ld	r24, Z
    6906:	88 23       	and	r24, r24
    6908:	39 f4       	brne	.+14     	; 0x6918 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    690a:	8f ef       	ldi	r24, 0xFF	; 255
    690c:	9f ef       	ldi	r25, 0xFF	; 255
    690e:	90 93 9b 05 	sts	0x059B, r25
    6912:	80 93 9a 05 	sts	0x059A, r24
    6916:	68 c0       	rjmp	.+208    	; 0x69e8 <xTaskIncrementTick+0x178>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    6918:	e0 91 02 06 	lds	r30, 0x0602
    691c:	f0 91 03 06 	lds	r31, 0x0603
    6920:	05 80       	ldd	r0, Z+5	; 0x05
    6922:	f6 81       	ldd	r31, Z+6	; 0x06
    6924:	e0 2d       	mov	r30, r0
    6926:	86 81       	ldd	r24, Z+6	; 0x06
    6928:	97 81       	ldd	r25, Z+7	; 0x07
    692a:	99 87       	std	Y+9, r25	; 0x09
    692c:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    692e:	e8 85       	ldd	r30, Y+8	; 0x08
    6930:	f9 85       	ldd	r31, Y+9	; 0x09
    6932:	82 81       	ldd	r24, Z+2	; 0x02
    6934:	93 81       	ldd	r25, Z+3	; 0x03
    6936:	9f 83       	std	Y+7, r25	; 0x07
    6938:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    693a:	2b 81       	ldd	r18, Y+3	; 0x03
    693c:	3c 81       	ldd	r19, Y+4	; 0x04
    693e:	8e 81       	ldd	r24, Y+6	; 0x06
    6940:	9f 81       	ldd	r25, Y+7	; 0x07
    6942:	28 17       	cp	r18, r24
    6944:	39 07       	cpc	r19, r25
    6946:	38 f4       	brcc	.+14     	; 0x6956 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    6948:	8e 81       	ldd	r24, Y+6	; 0x06
    694a:	9f 81       	ldd	r25, Y+7	; 0x07
    694c:	90 93 9b 05 	sts	0x059B, r25
    6950:	80 93 9a 05 	sts	0x059A, r24
    6954:	49 c0       	rjmp	.+146    	; 0x69e8 <xTaskIncrementTick+0x178>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6956:	88 85       	ldd	r24, Y+8	; 0x08
    6958:	99 85       	ldd	r25, Y+9	; 0x09
    695a:	02 96       	adiw	r24, 0x02	; 2
    695c:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    6960:	e8 85       	ldd	r30, Y+8	; 0x08
    6962:	f9 85       	ldd	r31, Y+9	; 0x09
    6964:	84 89       	ldd	r24, Z+20	; 0x14
    6966:	95 89       	ldd	r25, Z+21	; 0x15
    6968:	00 97       	sbiw	r24, 0x00	; 0
    696a:	29 f0       	breq	.+10     	; 0x6976 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    696c:	88 85       	ldd	r24, Y+8	; 0x08
    696e:	99 85       	ldd	r25, Y+9	; 0x09
    6970:	0c 96       	adiw	r24, 0x0c	; 12
    6972:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    6976:	e8 85       	ldd	r30, Y+8	; 0x08
    6978:	f9 85       	ldd	r31, Y+9	; 0x09
    697a:	96 89       	ldd	r25, Z+22	; 0x16
    697c:	80 91 94 05 	lds	r24, 0x0594
    6980:	89 17       	cp	r24, r25
    6982:	28 f4       	brcc	.+10     	; 0x698e <xTaskIncrementTick+0x11e>
    6984:	e8 85       	ldd	r30, Y+8	; 0x08
    6986:	f9 85       	ldd	r31, Y+9	; 0x09
    6988:	86 89       	ldd	r24, Z+22	; 0x16
    698a:	80 93 94 05 	sts	0x0594, r24
    698e:	e8 85       	ldd	r30, Y+8	; 0x08
    6990:	f9 85       	ldd	r31, Y+9	; 0x09
    6992:	86 89       	ldd	r24, Z+22	; 0x16
    6994:	28 2f       	mov	r18, r24
    6996:	30 e0       	ldi	r19, 0x00	; 0
    6998:	c9 01       	movw	r24, r18
    699a:	88 0f       	add	r24, r24
    699c:	99 1f       	adc	r25, r25
    699e:	88 0f       	add	r24, r24
    69a0:	99 1f       	adc	r25, r25
    69a2:	88 0f       	add	r24, r24
    69a4:	99 1f       	adc	r25, r25
    69a6:	82 0f       	add	r24, r18
    69a8:	93 1f       	adc	r25, r19
    69aa:	ac 01       	movw	r20, r24
    69ac:	41 56       	subi	r20, 0x61	; 97
    69ae:	5a 4f       	sbci	r21, 0xFA	; 250
    69b0:	88 85       	ldd	r24, Y+8	; 0x08
    69b2:	99 85       	ldd	r25, Y+9	; 0x09
    69b4:	9c 01       	movw	r18, r24
    69b6:	2e 5f       	subi	r18, 0xFE	; 254
    69b8:	3f 4f       	sbci	r19, 0xFF	; 255
    69ba:	ca 01       	movw	r24, r20
    69bc:	b9 01       	movw	r22, r18
    69be:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    69c2:	e8 85       	ldd	r30, Y+8	; 0x08
    69c4:	f9 85       	ldd	r31, Y+9	; 0x09
    69c6:	96 89       	ldd	r25, Z+22	; 0x16
    69c8:	e0 91 8e 05 	lds	r30, 0x058E
    69cc:	f0 91 8f 05 	lds	r31, 0x058F
    69d0:	86 89       	ldd	r24, Z+22	; 0x16
    69d2:	98 17       	cp	r25, r24
    69d4:	08 f4       	brcc	.+2      	; 0x69d8 <xTaskIncrementTick+0x168>
    69d6:	92 cf       	rjmp	.-220    	; 0x68fc <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    69d8:	81 e0       	ldi	r24, 0x01	; 1
    69da:	8d 83       	std	Y+5, r24	; 0x05
    69dc:	8f cf       	rjmp	.-226    	; 0x68fc <xTaskIncrementTick+0x8c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    69de:	80 91 96 05 	lds	r24, 0x0596
    69e2:	8f 5f       	subi	r24, 0xFF	; 255
    69e4:	80 93 96 05 	sts	0x0596, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    69e8:	80 91 97 05 	lds	r24, 0x0597
    69ec:	88 23       	and	r24, r24
    69ee:	11 f0       	breq	.+4      	; 0x69f4 <xTaskIncrementTick+0x184>
		{
			xSwitchRequired = pdTRUE;
    69f0:	81 e0       	ldi	r24, 0x01	; 1
    69f2:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    69f4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    69f6:	29 96       	adiw	r28, 0x09	; 9
    69f8:	0f b6       	in	r0, 0x3f	; 63
    69fa:	f8 94       	cli
    69fc:	de bf       	out	0x3e, r29	; 62
    69fe:	0f be       	out	0x3f, r0	; 63
    6a00:	cd bf       	out	0x3d, r28	; 61
    6a02:	cf 91       	pop	r28
    6a04:	df 91       	pop	r29
    6a06:	08 95       	ret

00006a08 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    6a08:	df 93       	push	r29
    6a0a:	cf 93       	push	r28
    6a0c:	00 d0       	rcall	.+0      	; 0x6a0e <vTaskSwitchContext+0x6>
    6a0e:	0f 92       	push	r0
    6a10:	cd b7       	in	r28, 0x3d	; 61
    6a12:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    6a14:	80 91 9e 05 	lds	r24, 0x059E
    6a18:	88 23       	and	r24, r24
    6a1a:	21 f0       	breq	.+8      	; 0x6a24 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    6a1c:	81 e0       	ldi	r24, 0x01	; 1
    6a1e:	80 93 97 05 	sts	0x0597, r24
    6a22:	59 c0       	rjmp	.+178    	; 0x6ad6 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    6a24:	10 92 97 05 	sts	0x0597, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    6a28:	80 91 94 05 	lds	r24, 0x0594
    6a2c:	8b 83       	std	Y+3, r24	; 0x03
    6a2e:	03 c0       	rjmp	.+6      	; 0x6a36 <vTaskSwitchContext+0x2e>
    6a30:	8b 81       	ldd	r24, Y+3	; 0x03
    6a32:	81 50       	subi	r24, 0x01	; 1
    6a34:	8b 83       	std	Y+3, r24	; 0x03
    6a36:	8b 81       	ldd	r24, Y+3	; 0x03
    6a38:	28 2f       	mov	r18, r24
    6a3a:	30 e0       	ldi	r19, 0x00	; 0
    6a3c:	c9 01       	movw	r24, r18
    6a3e:	88 0f       	add	r24, r24
    6a40:	99 1f       	adc	r25, r25
    6a42:	88 0f       	add	r24, r24
    6a44:	99 1f       	adc	r25, r25
    6a46:	88 0f       	add	r24, r24
    6a48:	99 1f       	adc	r25, r25
    6a4a:	82 0f       	add	r24, r18
    6a4c:	93 1f       	adc	r25, r19
    6a4e:	fc 01       	movw	r30, r24
    6a50:	e1 56       	subi	r30, 0x61	; 97
    6a52:	fa 4f       	sbci	r31, 0xFA	; 250
    6a54:	80 81       	ld	r24, Z
    6a56:	88 23       	and	r24, r24
    6a58:	59 f3       	breq	.-42     	; 0x6a30 <vTaskSwitchContext+0x28>
    6a5a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a5c:	28 2f       	mov	r18, r24
    6a5e:	30 e0       	ldi	r19, 0x00	; 0
    6a60:	c9 01       	movw	r24, r18
    6a62:	88 0f       	add	r24, r24
    6a64:	99 1f       	adc	r25, r25
    6a66:	88 0f       	add	r24, r24
    6a68:	99 1f       	adc	r25, r25
    6a6a:	88 0f       	add	r24, r24
    6a6c:	99 1f       	adc	r25, r25
    6a6e:	82 0f       	add	r24, r18
    6a70:	93 1f       	adc	r25, r19
    6a72:	81 56       	subi	r24, 0x61	; 97
    6a74:	9a 4f       	sbci	r25, 0xFA	; 250
    6a76:	9a 83       	std	Y+2, r25	; 0x02
    6a78:	89 83       	std	Y+1, r24	; 0x01
    6a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    6a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    6a7e:	01 80       	ldd	r0, Z+1	; 0x01
    6a80:	f2 81       	ldd	r31, Z+2	; 0x02
    6a82:	e0 2d       	mov	r30, r0
    6a84:	82 81       	ldd	r24, Z+2	; 0x02
    6a86:	93 81       	ldd	r25, Z+3	; 0x03
    6a88:	e9 81       	ldd	r30, Y+1	; 0x01
    6a8a:	fa 81       	ldd	r31, Y+2	; 0x02
    6a8c:	92 83       	std	Z+2, r25	; 0x02
    6a8e:	81 83       	std	Z+1, r24	; 0x01
    6a90:	e9 81       	ldd	r30, Y+1	; 0x01
    6a92:	fa 81       	ldd	r31, Y+2	; 0x02
    6a94:	21 81       	ldd	r18, Z+1	; 0x01
    6a96:	32 81       	ldd	r19, Z+2	; 0x02
    6a98:	89 81       	ldd	r24, Y+1	; 0x01
    6a9a:	9a 81       	ldd	r25, Y+2	; 0x02
    6a9c:	03 96       	adiw	r24, 0x03	; 3
    6a9e:	28 17       	cp	r18, r24
    6aa0:	39 07       	cpc	r19, r25
    6aa2:	59 f4       	brne	.+22     	; 0x6aba <vTaskSwitchContext+0xb2>
    6aa4:	e9 81       	ldd	r30, Y+1	; 0x01
    6aa6:	fa 81       	ldd	r31, Y+2	; 0x02
    6aa8:	01 80       	ldd	r0, Z+1	; 0x01
    6aaa:	f2 81       	ldd	r31, Z+2	; 0x02
    6aac:	e0 2d       	mov	r30, r0
    6aae:	82 81       	ldd	r24, Z+2	; 0x02
    6ab0:	93 81       	ldd	r25, Z+3	; 0x03
    6ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    6ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    6ab6:	92 83       	std	Z+2, r25	; 0x02
    6ab8:	81 83       	std	Z+1, r24	; 0x01
    6aba:	e9 81       	ldd	r30, Y+1	; 0x01
    6abc:	fa 81       	ldd	r31, Y+2	; 0x02
    6abe:	01 80       	ldd	r0, Z+1	; 0x01
    6ac0:	f2 81       	ldd	r31, Z+2	; 0x02
    6ac2:	e0 2d       	mov	r30, r0
    6ac4:	86 81       	ldd	r24, Z+6	; 0x06
    6ac6:	97 81       	ldd	r25, Z+7	; 0x07
    6ac8:	90 93 8f 05 	sts	0x058F, r25
    6acc:	80 93 8e 05 	sts	0x058E, r24
    6ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    6ad2:	80 93 94 05 	sts	0x0594, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    6ad6:	0f 90       	pop	r0
    6ad8:	0f 90       	pop	r0
    6ada:	0f 90       	pop	r0
    6adc:	cf 91       	pop	r28
    6ade:	df 91       	pop	r29
    6ae0:	08 95       	ret

00006ae2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    6ae2:	df 93       	push	r29
    6ae4:	cf 93       	push	r28
    6ae6:	00 d0       	rcall	.+0      	; 0x6ae8 <vTaskPlaceOnEventList+0x6>
    6ae8:	00 d0       	rcall	.+0      	; 0x6aea <vTaskPlaceOnEventList+0x8>
    6aea:	cd b7       	in	r28, 0x3d	; 61
    6aec:	de b7       	in	r29, 0x3e	; 62
    6aee:	9a 83       	std	Y+2, r25	; 0x02
    6af0:	89 83       	std	Y+1, r24	; 0x01
    6af2:	7c 83       	std	Y+4, r23	; 0x04
    6af4:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6af6:	80 91 8e 05 	lds	r24, 0x058E
    6afa:	90 91 8f 05 	lds	r25, 0x058F
    6afe:	9c 01       	movw	r18, r24
    6b00:	24 5f       	subi	r18, 0xF4	; 244
    6b02:	3f 4f       	sbci	r19, 0xFF	; 255
    6b04:	89 81       	ldd	r24, Y+1	; 0x01
    6b06:	9a 81       	ldd	r25, Y+2	; 0x02
    6b08:	b9 01       	movw	r22, r18
    6b0a:	0e 94 4a 24 	call	0x4894	; 0x4894 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    6b10:	9c 81       	ldd	r25, Y+4	; 0x04
    6b12:	61 e0       	ldi	r22, 0x01	; 1
    6b14:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <prvAddCurrentTaskToDelayedList>
}
    6b18:	0f 90       	pop	r0
    6b1a:	0f 90       	pop	r0
    6b1c:	0f 90       	pop	r0
    6b1e:	0f 90       	pop	r0
    6b20:	cf 91       	pop	r28
    6b22:	df 91       	pop	r29
    6b24:	08 95       	ret

00006b26 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    6b26:	df 93       	push	r29
    6b28:	cf 93       	push	r28
    6b2a:	00 d0       	rcall	.+0      	; 0x6b2c <vTaskPlaceOnUnorderedEventList+0x6>
    6b2c:	00 d0       	rcall	.+0      	; 0x6b2e <vTaskPlaceOnUnorderedEventList+0x8>
    6b2e:	00 d0       	rcall	.+0      	; 0x6b30 <vTaskPlaceOnUnorderedEventList+0xa>
    6b30:	cd b7       	in	r28, 0x3d	; 61
    6b32:	de b7       	in	r29, 0x3e	; 62
    6b34:	9a 83       	std	Y+2, r25	; 0x02
    6b36:	89 83       	std	Y+1, r24	; 0x01
    6b38:	7c 83       	std	Y+4, r23	; 0x04
    6b3a:	6b 83       	std	Y+3, r22	; 0x03
    6b3c:	5e 83       	std	Y+6, r21	; 0x06
    6b3e:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    6b40:	e0 91 8e 05 	lds	r30, 0x058E
    6b44:	f0 91 8f 05 	lds	r31, 0x058F
    6b48:	8b 81       	ldd	r24, Y+3	; 0x03
    6b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    6b4c:	90 68       	ori	r25, 0x80	; 128
    6b4e:	95 87       	std	Z+13, r25	; 0x0d
    6b50:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6b52:	80 91 8e 05 	lds	r24, 0x058E
    6b56:	90 91 8f 05 	lds	r25, 0x058F
    6b5a:	9c 01       	movw	r18, r24
    6b5c:	24 5f       	subi	r18, 0xF4	; 244
    6b5e:	3f 4f       	sbci	r19, 0xFF	; 255
    6b60:	89 81       	ldd	r24, Y+1	; 0x01
    6b62:	9a 81       	ldd	r25, Y+2	; 0x02
    6b64:	b9 01       	movw	r22, r18
    6b66:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6b6a:	8d 81       	ldd	r24, Y+5	; 0x05
    6b6c:	9e 81       	ldd	r25, Y+6	; 0x06
    6b6e:	61 e0       	ldi	r22, 0x01	; 1
    6b70:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <prvAddCurrentTaskToDelayedList>
}
    6b74:	26 96       	adiw	r28, 0x06	; 6
    6b76:	0f b6       	in	r0, 0x3f	; 63
    6b78:	f8 94       	cli
    6b7a:	de bf       	out	0x3e, r29	; 62
    6b7c:	0f be       	out	0x3f, r0	; 63
    6b7e:	cd bf       	out	0x3d, r28	; 61
    6b80:	cf 91       	pop	r28
    6b82:	df 91       	pop	r29
    6b84:	08 95       	ret

00006b86 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    6b86:	df 93       	push	r29
    6b88:	cf 93       	push	r28
    6b8a:	00 d0       	rcall	.+0      	; 0x6b8c <xTaskRemoveFromEventList+0x6>
    6b8c:	00 d0       	rcall	.+0      	; 0x6b8e <xTaskRemoveFromEventList+0x8>
    6b8e:	0f 92       	push	r0
    6b90:	cd b7       	in	r28, 0x3d	; 61
    6b92:	de b7       	in	r29, 0x3e	; 62
    6b94:	9d 83       	std	Y+5, r25	; 0x05
    6b96:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    6b98:	ec 81       	ldd	r30, Y+4	; 0x04
    6b9a:	fd 81       	ldd	r31, Y+5	; 0x05
    6b9c:	05 80       	ldd	r0, Z+5	; 0x05
    6b9e:	f6 81       	ldd	r31, Z+6	; 0x06
    6ba0:	e0 2d       	mov	r30, r0
    6ba2:	86 81       	ldd	r24, Z+6	; 0x06
    6ba4:	97 81       	ldd	r25, Z+7	; 0x07
    6ba6:	9b 83       	std	Y+3, r25	; 0x03
    6ba8:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    6baa:	8a 81       	ldd	r24, Y+2	; 0x02
    6bac:	9b 81       	ldd	r25, Y+3	; 0x03
    6bae:	0c 96       	adiw	r24, 0x0c	; 12
    6bb0:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6bb4:	80 91 9e 05 	lds	r24, 0x059E
    6bb8:	88 23       	and	r24, r24
    6bba:	61 f5       	brne	.+88     	; 0x6c14 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    6bbc:	8a 81       	ldd	r24, Y+2	; 0x02
    6bbe:	9b 81       	ldd	r25, Y+3	; 0x03
    6bc0:	02 96       	adiw	r24, 0x02	; 2
    6bc2:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    6bc6:	ea 81       	ldd	r30, Y+2	; 0x02
    6bc8:	fb 81       	ldd	r31, Y+3	; 0x03
    6bca:	96 89       	ldd	r25, Z+22	; 0x16
    6bcc:	80 91 94 05 	lds	r24, 0x0594
    6bd0:	89 17       	cp	r24, r25
    6bd2:	28 f4       	brcc	.+10     	; 0x6bde <xTaskRemoveFromEventList+0x58>
    6bd4:	ea 81       	ldd	r30, Y+2	; 0x02
    6bd6:	fb 81       	ldd	r31, Y+3	; 0x03
    6bd8:	86 89       	ldd	r24, Z+22	; 0x16
    6bda:	80 93 94 05 	sts	0x0594, r24
    6bde:	ea 81       	ldd	r30, Y+2	; 0x02
    6be0:	fb 81       	ldd	r31, Y+3	; 0x03
    6be2:	86 89       	ldd	r24, Z+22	; 0x16
    6be4:	28 2f       	mov	r18, r24
    6be6:	30 e0       	ldi	r19, 0x00	; 0
    6be8:	c9 01       	movw	r24, r18
    6bea:	88 0f       	add	r24, r24
    6bec:	99 1f       	adc	r25, r25
    6bee:	88 0f       	add	r24, r24
    6bf0:	99 1f       	adc	r25, r25
    6bf2:	88 0f       	add	r24, r24
    6bf4:	99 1f       	adc	r25, r25
    6bf6:	82 0f       	add	r24, r18
    6bf8:	93 1f       	adc	r25, r19
    6bfa:	ac 01       	movw	r20, r24
    6bfc:	41 56       	subi	r20, 0x61	; 97
    6bfe:	5a 4f       	sbci	r21, 0xFA	; 250
    6c00:	8a 81       	ldd	r24, Y+2	; 0x02
    6c02:	9b 81       	ldd	r25, Y+3	; 0x03
    6c04:	9c 01       	movw	r18, r24
    6c06:	2e 5f       	subi	r18, 0xFE	; 254
    6c08:	3f 4f       	sbci	r19, 0xFF	; 255
    6c0a:	ca 01       	movw	r24, r20
    6c0c:	b9 01       	movw	r22, r18
    6c0e:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
    6c12:	0a c0       	rjmp	.+20     	; 0x6c28 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    6c14:	8a 81       	ldd	r24, Y+2	; 0x02
    6c16:	9b 81       	ldd	r25, Y+3	; 0x03
    6c18:	9c 01       	movw	r18, r24
    6c1a:	24 5f       	subi	r18, 0xF4	; 244
    6c1c:	3f 4f       	sbci	r19, 0xFF	; 255
    6c1e:	86 e0       	ldi	r24, 0x06	; 6
    6c20:	96 e0       	ldi	r25, 0x06	; 6
    6c22:	b9 01       	movw	r22, r18
    6c24:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    6c28:	ea 81       	ldd	r30, Y+2	; 0x02
    6c2a:	fb 81       	ldd	r31, Y+3	; 0x03
    6c2c:	96 89       	ldd	r25, Z+22	; 0x16
    6c2e:	e0 91 8e 05 	lds	r30, 0x058E
    6c32:	f0 91 8f 05 	lds	r31, 0x058F
    6c36:	86 89       	ldd	r24, Z+22	; 0x16
    6c38:	89 17       	cp	r24, r25
    6c3a:	30 f4       	brcc	.+12     	; 0x6c48 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    6c3c:	81 e0       	ldi	r24, 0x01	; 1
    6c3e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    6c40:	81 e0       	ldi	r24, 0x01	; 1
    6c42:	80 93 97 05 	sts	0x0597, r24
    6c46:	01 c0       	rjmp	.+2      	; 0x6c4a <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    6c48:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    6c4a:	89 81       	ldd	r24, Y+1	; 0x01
}
    6c4c:	0f 90       	pop	r0
    6c4e:	0f 90       	pop	r0
    6c50:	0f 90       	pop	r0
    6c52:	0f 90       	pop	r0
    6c54:	0f 90       	pop	r0
    6c56:	cf 91       	pop	r28
    6c58:	df 91       	pop	r29
    6c5a:	08 95       	ret

00006c5c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    6c5c:	df 93       	push	r29
    6c5e:	cf 93       	push	r28
    6c60:	cd b7       	in	r28, 0x3d	; 61
    6c62:	de b7       	in	r29, 0x3e	; 62
    6c64:	27 97       	sbiw	r28, 0x07	; 7
    6c66:	0f b6       	in	r0, 0x3f	; 63
    6c68:	f8 94       	cli
    6c6a:	de bf       	out	0x3e, r29	; 62
    6c6c:	0f be       	out	0x3f, r0	; 63
    6c6e:	cd bf       	out	0x3d, r28	; 61
    6c70:	9d 83       	std	Y+5, r25	; 0x05
    6c72:	8c 83       	std	Y+4, r24	; 0x04
    6c74:	7f 83       	std	Y+7, r23	; 0x07
    6c76:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    6c78:	8e 81       	ldd	r24, Y+6	; 0x06
    6c7a:	9f 81       	ldd	r25, Y+7	; 0x07
    6c7c:	90 68       	ori	r25, 0x80	; 128
    6c7e:	ec 81       	ldd	r30, Y+4	; 0x04
    6c80:	fd 81       	ldd	r31, Y+5	; 0x05
    6c82:	91 83       	std	Z+1, r25	; 0x01
    6c84:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    6c86:	ec 81       	ldd	r30, Y+4	; 0x04
    6c88:	fd 81       	ldd	r31, Y+5	; 0x05
    6c8a:	86 81       	ldd	r24, Z+6	; 0x06
    6c8c:	97 81       	ldd	r25, Z+7	; 0x07
    6c8e:	9b 83       	std	Y+3, r25	; 0x03
    6c90:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    6c92:	8c 81       	ldd	r24, Y+4	; 0x04
    6c94:	9d 81       	ldd	r25, Y+5	; 0x05
    6c96:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    6c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    6c9c:	9b 81       	ldd	r25, Y+3	; 0x03
    6c9e:	02 96       	adiw	r24, 0x02	; 2
    6ca0:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    6ca4:	ea 81       	ldd	r30, Y+2	; 0x02
    6ca6:	fb 81       	ldd	r31, Y+3	; 0x03
    6ca8:	96 89       	ldd	r25, Z+22	; 0x16
    6caa:	80 91 94 05 	lds	r24, 0x0594
    6cae:	89 17       	cp	r24, r25
    6cb0:	28 f4       	brcc	.+10     	; 0x6cbc <xTaskRemoveFromUnorderedEventList+0x60>
    6cb2:	ea 81       	ldd	r30, Y+2	; 0x02
    6cb4:	fb 81       	ldd	r31, Y+3	; 0x03
    6cb6:	86 89       	ldd	r24, Z+22	; 0x16
    6cb8:	80 93 94 05 	sts	0x0594, r24
    6cbc:	ea 81       	ldd	r30, Y+2	; 0x02
    6cbe:	fb 81       	ldd	r31, Y+3	; 0x03
    6cc0:	86 89       	ldd	r24, Z+22	; 0x16
    6cc2:	28 2f       	mov	r18, r24
    6cc4:	30 e0       	ldi	r19, 0x00	; 0
    6cc6:	c9 01       	movw	r24, r18
    6cc8:	88 0f       	add	r24, r24
    6cca:	99 1f       	adc	r25, r25
    6ccc:	88 0f       	add	r24, r24
    6cce:	99 1f       	adc	r25, r25
    6cd0:	88 0f       	add	r24, r24
    6cd2:	99 1f       	adc	r25, r25
    6cd4:	82 0f       	add	r24, r18
    6cd6:	93 1f       	adc	r25, r19
    6cd8:	ac 01       	movw	r20, r24
    6cda:	41 56       	subi	r20, 0x61	; 97
    6cdc:	5a 4f       	sbci	r21, 0xFA	; 250
    6cde:	8a 81       	ldd	r24, Y+2	; 0x02
    6ce0:	9b 81       	ldd	r25, Y+3	; 0x03
    6ce2:	9c 01       	movw	r18, r24
    6ce4:	2e 5f       	subi	r18, 0xFE	; 254
    6ce6:	3f 4f       	sbci	r19, 0xFF	; 255
    6ce8:	ca 01       	movw	r24, r20
    6cea:	b9 01       	movw	r22, r18
    6cec:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    6cf0:	ea 81       	ldd	r30, Y+2	; 0x02
    6cf2:	fb 81       	ldd	r31, Y+3	; 0x03
    6cf4:	96 89       	ldd	r25, Z+22	; 0x16
    6cf6:	e0 91 8e 05 	lds	r30, 0x058E
    6cfa:	f0 91 8f 05 	lds	r31, 0x058F
    6cfe:	86 89       	ldd	r24, Z+22	; 0x16
    6d00:	89 17       	cp	r24, r25
    6d02:	30 f4       	brcc	.+12     	; 0x6d10 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    6d04:	81 e0       	ldi	r24, 0x01	; 1
    6d06:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    6d08:	81 e0       	ldi	r24, 0x01	; 1
    6d0a:	80 93 97 05 	sts	0x0597, r24
    6d0e:	01 c0       	rjmp	.+2      	; 0x6d12 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    6d10:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    6d12:	89 81       	ldd	r24, Y+1	; 0x01
}
    6d14:	27 96       	adiw	r28, 0x07	; 7
    6d16:	0f b6       	in	r0, 0x3f	; 63
    6d18:	f8 94       	cli
    6d1a:	de bf       	out	0x3e, r29	; 62
    6d1c:	0f be       	out	0x3f, r0	; 63
    6d1e:	cd bf       	out	0x3d, r28	; 61
    6d20:	cf 91       	pop	r28
    6d22:	df 91       	pop	r29
    6d24:	08 95       	ret

00006d26 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    6d26:	df 93       	push	r29
    6d28:	cf 93       	push	r28
    6d2a:	00 d0       	rcall	.+0      	; 0x6d2c <vTaskSetTimeOutState+0x6>
    6d2c:	cd b7       	in	r28, 0x3d	; 61
    6d2e:	de b7       	in	r29, 0x3e	; 62
    6d30:	9a 83       	std	Y+2, r25	; 0x02
    6d32:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    6d34:	80 91 98 05 	lds	r24, 0x0598
    6d38:	e9 81       	ldd	r30, Y+1	; 0x01
    6d3a:	fa 81       	ldd	r31, Y+2	; 0x02
    6d3c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    6d3e:	80 91 92 05 	lds	r24, 0x0592
    6d42:	90 91 93 05 	lds	r25, 0x0593
    6d46:	e9 81       	ldd	r30, Y+1	; 0x01
    6d48:	fa 81       	ldd	r31, Y+2	; 0x02
    6d4a:	92 83       	std	Z+2, r25	; 0x02
    6d4c:	81 83       	std	Z+1, r24	; 0x01
}
    6d4e:	0f 90       	pop	r0
    6d50:	0f 90       	pop	r0
    6d52:	cf 91       	pop	r28
    6d54:	df 91       	pop	r29
    6d56:	08 95       	ret

00006d58 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    6d58:	df 93       	push	r29
    6d5a:	cf 93       	push	r28
    6d5c:	cd b7       	in	r28, 0x3d	; 61
    6d5e:	de b7       	in	r29, 0x3e	; 62
    6d60:	27 97       	sbiw	r28, 0x07	; 7
    6d62:	0f b6       	in	r0, 0x3f	; 63
    6d64:	f8 94       	cli
    6d66:	de bf       	out	0x3e, r29	; 62
    6d68:	0f be       	out	0x3f, r0	; 63
    6d6a:	cd bf       	out	0x3d, r28	; 61
    6d6c:	9d 83       	std	Y+5, r25	; 0x05
    6d6e:	8c 83       	std	Y+4, r24	; 0x04
    6d70:	7f 83       	std	Y+7, r23	; 0x07
    6d72:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    6d74:	0f b6       	in	r0, 0x3f	; 63
    6d76:	f8 94       	cli
    6d78:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    6d7a:	80 91 92 05 	lds	r24, 0x0592
    6d7e:	90 91 93 05 	lds	r25, 0x0593
    6d82:	9a 83       	std	Y+2, r25	; 0x02
    6d84:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    6d86:	ee 81       	ldd	r30, Y+6	; 0x06
    6d88:	ff 81       	ldd	r31, Y+7	; 0x07
    6d8a:	80 81       	ld	r24, Z
    6d8c:	91 81       	ldd	r25, Z+1	; 0x01
    6d8e:	2f ef       	ldi	r18, 0xFF	; 255
    6d90:	8f 3f       	cpi	r24, 0xFF	; 255
    6d92:	92 07       	cpc	r25, r18
    6d94:	11 f4       	brne	.+4      	; 0x6d9a <xTaskCheckForTimeOut+0x42>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    6d96:	1b 82       	std	Y+3, r1	; 0x03
    6d98:	40 c0       	rjmp	.+128    	; 0x6e1a <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    6d9a:	ec 81       	ldd	r30, Y+4	; 0x04
    6d9c:	fd 81       	ldd	r31, Y+5	; 0x05
    6d9e:	90 81       	ld	r25, Z
    6da0:	80 91 98 05 	lds	r24, 0x0598
    6da4:	98 17       	cp	r25, r24
    6da6:	61 f0       	breq	.+24     	; 0x6dc0 <xTaskCheckForTimeOut+0x68>
    6da8:	ec 81       	ldd	r30, Y+4	; 0x04
    6daa:	fd 81       	ldd	r31, Y+5	; 0x05
    6dac:	21 81       	ldd	r18, Z+1	; 0x01
    6dae:	32 81       	ldd	r19, Z+2	; 0x02
    6db0:	89 81       	ldd	r24, Y+1	; 0x01
    6db2:	9a 81       	ldd	r25, Y+2	; 0x02
    6db4:	82 17       	cp	r24, r18
    6db6:	93 07       	cpc	r25, r19
    6db8:	18 f0       	brcs	.+6      	; 0x6dc0 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    6dba:	81 e0       	ldi	r24, 0x01	; 1
    6dbc:	8b 83       	std	Y+3, r24	; 0x03
    6dbe:	2d c0       	rjmp	.+90     	; 0x6e1a <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    6dc0:	ec 81       	ldd	r30, Y+4	; 0x04
    6dc2:	fd 81       	ldd	r31, Y+5	; 0x05
    6dc4:	21 81       	ldd	r18, Z+1	; 0x01
    6dc6:	32 81       	ldd	r19, Z+2	; 0x02
    6dc8:	89 81       	ldd	r24, Y+1	; 0x01
    6dca:	9a 81       	ldd	r25, Y+2	; 0x02
    6dcc:	ac 01       	movw	r20, r24
    6dce:	42 1b       	sub	r20, r18
    6dd0:	53 0b       	sbc	r21, r19
    6dd2:	9a 01       	movw	r18, r20
    6dd4:	ee 81       	ldd	r30, Y+6	; 0x06
    6dd6:	ff 81       	ldd	r31, Y+7	; 0x07
    6dd8:	80 81       	ld	r24, Z
    6dda:	91 81       	ldd	r25, Z+1	; 0x01
    6ddc:	28 17       	cp	r18, r24
    6dde:	39 07       	cpc	r19, r25
    6de0:	d0 f4       	brcc	.+52     	; 0x6e16 <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    6de2:	ee 81       	ldd	r30, Y+6	; 0x06
    6de4:	ff 81       	ldd	r31, Y+7	; 0x07
    6de6:	40 81       	ld	r20, Z
    6de8:	51 81       	ldd	r21, Z+1	; 0x01
    6dea:	ec 81       	ldd	r30, Y+4	; 0x04
    6dec:	fd 81       	ldd	r31, Y+5	; 0x05
    6dee:	21 81       	ldd	r18, Z+1	; 0x01
    6df0:	32 81       	ldd	r19, Z+2	; 0x02
    6df2:	89 81       	ldd	r24, Y+1	; 0x01
    6df4:	9a 81       	ldd	r25, Y+2	; 0x02
    6df6:	b9 01       	movw	r22, r18
    6df8:	68 1b       	sub	r22, r24
    6dfa:	79 0b       	sbc	r23, r25
    6dfc:	cb 01       	movw	r24, r22
    6dfe:	84 0f       	add	r24, r20
    6e00:	95 1f       	adc	r25, r21
    6e02:	ee 81       	ldd	r30, Y+6	; 0x06
    6e04:	ff 81       	ldd	r31, Y+7	; 0x07
    6e06:	91 83       	std	Z+1, r25	; 0x01
    6e08:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    6e0a:	8c 81       	ldd	r24, Y+4	; 0x04
    6e0c:	9d 81       	ldd	r25, Y+5	; 0x05
    6e0e:	0e 94 93 36 	call	0x6d26	; 0x6d26 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    6e12:	1b 82       	std	Y+3, r1	; 0x03
    6e14:	02 c0       	rjmp	.+4      	; 0x6e1a <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    6e16:	81 e0       	ldi	r24, 0x01	; 1
    6e18:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    6e1a:	0f 90       	pop	r0
    6e1c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6e1e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    6e20:	27 96       	adiw	r28, 0x07	; 7
    6e22:	0f b6       	in	r0, 0x3f	; 63
    6e24:	f8 94       	cli
    6e26:	de bf       	out	0x3e, r29	; 62
    6e28:	0f be       	out	0x3f, r0	; 63
    6e2a:	cd bf       	out	0x3d, r28	; 61
    6e2c:	cf 91       	pop	r28
    6e2e:	df 91       	pop	r29
    6e30:	08 95       	ret

00006e32 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    6e32:	df 93       	push	r29
    6e34:	cf 93       	push	r28
    6e36:	cd b7       	in	r28, 0x3d	; 61
    6e38:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    6e3a:	81 e0       	ldi	r24, 0x01	; 1
    6e3c:	80 93 97 05 	sts	0x0597, r24
}
    6e40:	cf 91       	pop	r28
    6e42:	df 91       	pop	r29
    6e44:	08 95       	ret

00006e46 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    6e46:	df 93       	push	r29
    6e48:	cf 93       	push	r28
    6e4a:	00 d0       	rcall	.+0      	; 0x6e4c <prvIdleTask+0x6>
    6e4c:	cd b7       	in	r28, 0x3d	; 61
    6e4e:	de b7       	in	r29, 0x3e	; 62
    6e50:	9a 83       	std	Y+2, r25	; 0x02
    6e52:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    6e54:	0e 94 6e 37 	call	0x6edc	; 0x6edc <prvCheckTasksWaitingTermination>
    6e58:	fd cf       	rjmp	.-6      	; 0x6e54 <prvIdleTask+0xe>

00006e5a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    6e5a:	df 93       	push	r29
    6e5c:	cf 93       	push	r28
    6e5e:	0f 92       	push	r0
    6e60:	cd b7       	in	r28, 0x3d	; 61
    6e62:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6e64:	19 82       	std	Y+1, r1	; 0x01
    6e66:	13 c0       	rjmp	.+38     	; 0x6e8e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    6e68:	89 81       	ldd	r24, Y+1	; 0x01
    6e6a:	28 2f       	mov	r18, r24
    6e6c:	30 e0       	ldi	r19, 0x00	; 0
    6e6e:	c9 01       	movw	r24, r18
    6e70:	88 0f       	add	r24, r24
    6e72:	99 1f       	adc	r25, r25
    6e74:	88 0f       	add	r24, r24
    6e76:	99 1f       	adc	r25, r25
    6e78:	88 0f       	add	r24, r24
    6e7a:	99 1f       	adc	r25, r25
    6e7c:	82 0f       	add	r24, r18
    6e7e:	93 1f       	adc	r25, r19
    6e80:	81 56       	subi	r24, 0x61	; 97
    6e82:	9a 4f       	sbci	r25, 0xFA	; 250
    6e84:	0e 94 cc 23 	call	0x4798	; 0x4798 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6e88:	89 81       	ldd	r24, Y+1	; 0x01
    6e8a:	8f 5f       	subi	r24, 0xFF	; 255
    6e8c:	89 83       	std	Y+1, r24	; 0x01
    6e8e:	89 81       	ldd	r24, Y+1	; 0x01
    6e90:	89 30       	cpi	r24, 0x09	; 9
    6e92:	50 f3       	brcs	.-44     	; 0x6e68 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    6e94:	80 ef       	ldi	r24, 0xF0	; 240
    6e96:	95 e0       	ldi	r25, 0x05	; 5
    6e98:	0e 94 cc 23 	call	0x4798	; 0x4798 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    6e9c:	89 ef       	ldi	r24, 0xF9	; 249
    6e9e:	95 e0       	ldi	r25, 0x05	; 5
    6ea0:	0e 94 cc 23 	call	0x4798	; 0x4798 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    6ea4:	86 e0       	ldi	r24, 0x06	; 6
    6ea6:	96 e0       	ldi	r25, 0x06	; 6
    6ea8:	0e 94 cc 23 	call	0x4798	; 0x4798 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    6eac:	8f e0       	ldi	r24, 0x0F	; 15
    6eae:	96 e0       	ldi	r25, 0x06	; 6
    6eb0:	0e 94 cc 23 	call	0x4798	; 0x4798 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    6eb4:	88 e1       	ldi	r24, 0x18	; 24
    6eb6:	96 e0       	ldi	r25, 0x06	; 6
    6eb8:	0e 94 cc 23 	call	0x4798	; 0x4798 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    6ebc:	80 ef       	ldi	r24, 0xF0	; 240
    6ebe:	95 e0       	ldi	r25, 0x05	; 5
    6ec0:	90 93 03 06 	sts	0x0603, r25
    6ec4:	80 93 02 06 	sts	0x0602, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6ec8:	89 ef       	ldi	r24, 0xF9	; 249
    6eca:	95 e0       	ldi	r25, 0x05	; 5
    6ecc:	90 93 05 06 	sts	0x0605, r25
    6ed0:	80 93 04 06 	sts	0x0604, r24
}
    6ed4:	0f 90       	pop	r0
    6ed6:	cf 91       	pop	r28
    6ed8:	df 91       	pop	r29
    6eda:	08 95       	ret

00006edc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    6edc:	df 93       	push	r29
    6ede:	cf 93       	push	r28
    6ee0:	00 d0       	rcall	.+0      	; 0x6ee2 <prvCheckTasksWaitingTermination+0x6>
    6ee2:	0f 92       	push	r0
    6ee4:	cd b7       	in	r28, 0x3d	; 61
    6ee6:	de b7       	in	r29, 0x3e	; 62
    6ee8:	2e c0       	rjmp	.+92     	; 0x6f46 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    6eea:	0e 94 3c 33 	call	0x6678	; 0x6678 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    6eee:	80 91 0f 06 	lds	r24, 0x060F
    6ef2:	1b 82       	std	Y+3, r1	; 0x03
    6ef4:	88 23       	and	r24, r24
    6ef6:	11 f4       	brne	.+4      	; 0x6efc <prvCheckTasksWaitingTermination+0x20>
    6ef8:	81 e0       	ldi	r24, 0x01	; 1
    6efa:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    6efc:	0e 94 48 33 	call	0x6690	; 0x6690 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    6f00:	8b 81       	ldd	r24, Y+3	; 0x03
    6f02:	88 23       	and	r24, r24
    6f04:	01 f5       	brne	.+64     	; 0x6f46 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    6f06:	0f b6       	in	r0, 0x3f	; 63
    6f08:	f8 94       	cli
    6f0a:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    6f0c:	e0 91 14 06 	lds	r30, 0x0614
    6f10:	f0 91 15 06 	lds	r31, 0x0615
    6f14:	86 81       	ldd	r24, Z+6	; 0x06
    6f16:	97 81       	ldd	r25, Z+7	; 0x07
    6f18:	9a 83       	std	Y+2, r25	; 0x02
    6f1a:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6f1c:	89 81       	ldd	r24, Y+1	; 0x01
    6f1e:	9a 81       	ldd	r25, Y+2	; 0x02
    6f20:	02 96       	adiw	r24, 0x02	; 2
    6f22:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					--uxCurrentNumberOfTasks;
    6f26:	80 91 91 05 	lds	r24, 0x0591
    6f2a:	81 50       	subi	r24, 0x01	; 1
    6f2c:	80 93 91 05 	sts	0x0591, r24
					--uxDeletedTasksWaitingCleanUp;
    6f30:	80 91 90 05 	lds	r24, 0x0590
    6f34:	81 50       	subi	r24, 0x01	; 1
    6f36:	80 93 90 05 	sts	0x0590, r24
				}
				taskEXIT_CRITICAL();
    6f3a:	0f 90       	pop	r0
    6f3c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    6f3e:	89 81       	ldd	r24, Y+1	; 0x01
    6f40:	9a 81       	ldd	r25, Y+2	; 0x02
    6f42:	0e 94 ad 37 	call	0x6f5a	; 0x6f5a <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    6f46:	80 91 90 05 	lds	r24, 0x0590
    6f4a:	88 23       	and	r24, r24
    6f4c:	71 f6       	brne	.-100    	; 0x6eea <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    6f4e:	0f 90       	pop	r0
    6f50:	0f 90       	pop	r0
    6f52:	0f 90       	pop	r0
    6f54:	cf 91       	pop	r28
    6f56:	df 91       	pop	r29
    6f58:	08 95       	ret

00006f5a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    6f5a:	df 93       	push	r29
    6f5c:	cf 93       	push	r28
    6f5e:	00 d0       	rcall	.+0      	; 0x6f60 <prvDeleteTCB+0x6>
    6f60:	cd b7       	in	r28, 0x3d	; 61
    6f62:	de b7       	in	r29, 0x3e	; 62
    6f64:	9a 83       	std	Y+2, r25	; 0x02
    6f66:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    6f68:	e9 81       	ldd	r30, Y+1	; 0x01
    6f6a:	fa 81       	ldd	r31, Y+2	; 0x02
    6f6c:	87 89       	ldd	r24, Z+23	; 0x17
    6f6e:	90 8d       	ldd	r25, Z+24	; 0x18
    6f70:	0e 94 18 23 	call	0x4630	; 0x4630 <vPortFree>
			vPortFree( pxTCB );
    6f74:	89 81       	ldd	r24, Y+1	; 0x01
    6f76:	9a 81       	ldd	r25, Y+2	; 0x02
    6f78:	0e 94 18 23 	call	0x4630	; 0x4630 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    6f7c:	0f 90       	pop	r0
    6f7e:	0f 90       	pop	r0
    6f80:	cf 91       	pop	r28
    6f82:	df 91       	pop	r29
    6f84:	08 95       	ret

00006f86 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    6f86:	df 93       	push	r29
    6f88:	cf 93       	push	r28
    6f8a:	00 d0       	rcall	.+0      	; 0x6f8c <prvResetNextTaskUnblockTime+0x6>
    6f8c:	cd b7       	in	r28, 0x3d	; 61
    6f8e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6f90:	e0 91 02 06 	lds	r30, 0x0602
    6f94:	f0 91 03 06 	lds	r31, 0x0603
    6f98:	80 81       	ld	r24, Z
    6f9a:	88 23       	and	r24, r24
    6f9c:	39 f4       	brne	.+14     	; 0x6fac <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    6f9e:	8f ef       	ldi	r24, 0xFF	; 255
    6fa0:	9f ef       	ldi	r25, 0xFF	; 255
    6fa2:	90 93 9b 05 	sts	0x059B, r25
    6fa6:	80 93 9a 05 	sts	0x059A, r24
    6faa:	13 c0       	rjmp	.+38     	; 0x6fd2 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    6fac:	e0 91 02 06 	lds	r30, 0x0602
    6fb0:	f0 91 03 06 	lds	r31, 0x0603
    6fb4:	05 80       	ldd	r0, Z+5	; 0x05
    6fb6:	f6 81       	ldd	r31, Z+6	; 0x06
    6fb8:	e0 2d       	mov	r30, r0
    6fba:	86 81       	ldd	r24, Z+6	; 0x06
    6fbc:	97 81       	ldd	r25, Z+7	; 0x07
    6fbe:	9a 83       	std	Y+2, r25	; 0x02
    6fc0:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    6fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    6fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    6fc6:	82 81       	ldd	r24, Z+2	; 0x02
    6fc8:	93 81       	ldd	r25, Z+3	; 0x03
    6fca:	90 93 9b 05 	sts	0x059B, r25
    6fce:	80 93 9a 05 	sts	0x059A, r24
	}
}
    6fd2:	0f 90       	pop	r0
    6fd4:	0f 90       	pop	r0
    6fd6:	cf 91       	pop	r28
    6fd8:	df 91       	pop	r29
    6fda:	08 95       	ret

00006fdc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    6fdc:	df 93       	push	r29
    6fde:	cf 93       	push	r28
    6fe0:	00 d0       	rcall	.+0      	; 0x6fe2 <xTaskGetCurrentTaskHandle+0x6>
    6fe2:	cd b7       	in	r28, 0x3d	; 61
    6fe4:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    6fe6:	80 91 8e 05 	lds	r24, 0x058E
    6fea:	90 91 8f 05 	lds	r25, 0x058F
    6fee:	9a 83       	std	Y+2, r25	; 0x02
    6ff0:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    6ff2:	89 81       	ldd	r24, Y+1	; 0x01
    6ff4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    6ff6:	0f 90       	pop	r0
    6ff8:	0f 90       	pop	r0
    6ffa:	cf 91       	pop	r28
    6ffc:	df 91       	pop	r29
    6ffe:	08 95       	ret

00007000 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    7000:	df 93       	push	r29
    7002:	cf 93       	push	r28
    7004:	00 d0       	rcall	.+0      	; 0x7006 <vTaskPriorityInherit+0x6>
    7006:	00 d0       	rcall	.+0      	; 0x7008 <vTaskPriorityInherit+0x8>
    7008:	cd b7       	in	r28, 0x3d	; 61
    700a:	de b7       	in	r29, 0x3e	; 62
    700c:	9c 83       	std	Y+4, r25	; 0x04
    700e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    7010:	8b 81       	ldd	r24, Y+3	; 0x03
    7012:	9c 81       	ldd	r25, Y+4	; 0x04
    7014:	9a 83       	std	Y+2, r25	; 0x02
    7016:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    7018:	8b 81       	ldd	r24, Y+3	; 0x03
    701a:	9c 81       	ldd	r25, Y+4	; 0x04
    701c:	00 97       	sbiw	r24, 0x00	; 0
    701e:	09 f4       	brne	.+2      	; 0x7022 <vTaskPriorityInherit+0x22>
    7020:	73 c0       	rjmp	.+230    	; 0x7108 <vTaskPriorityInherit+0x108>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    7022:	e9 81       	ldd	r30, Y+1	; 0x01
    7024:	fa 81       	ldd	r31, Y+2	; 0x02
    7026:	96 89       	ldd	r25, Z+22	; 0x16
    7028:	e0 91 8e 05 	lds	r30, 0x058E
    702c:	f0 91 8f 05 	lds	r31, 0x058F
    7030:	86 89       	ldd	r24, Z+22	; 0x16
    7032:	98 17       	cp	r25, r24
    7034:	08 f0       	brcs	.+2      	; 0x7038 <vTaskPriorityInherit+0x38>
    7036:	68 c0       	rjmp	.+208    	; 0x7108 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    7038:	e9 81       	ldd	r30, Y+1	; 0x01
    703a:	fa 81       	ldd	r31, Y+2	; 0x02
    703c:	84 85       	ldd	r24, Z+12	; 0x0c
    703e:	95 85       	ldd	r25, Z+13	; 0x0d
    7040:	99 23       	and	r25, r25
    7042:	7c f0       	brlt	.+30     	; 0x7062 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7044:	e0 91 8e 05 	lds	r30, 0x058E
    7048:	f0 91 8f 05 	lds	r31, 0x058F
    704c:	86 89       	ldd	r24, Z+22	; 0x16
    704e:	28 2f       	mov	r18, r24
    7050:	30 e0       	ldi	r19, 0x00	; 0
    7052:	89 e0       	ldi	r24, 0x09	; 9
    7054:	90 e0       	ldi	r25, 0x00	; 0
    7056:	82 1b       	sub	r24, r18
    7058:	93 0b       	sbc	r25, r19
    705a:	e9 81       	ldd	r30, Y+1	; 0x01
    705c:	fa 81       	ldd	r31, Y+2	; 0x02
    705e:	95 87       	std	Z+13, r25	; 0x0d
    7060:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    7062:	e9 81       	ldd	r30, Y+1	; 0x01
    7064:	fa 81       	ldd	r31, Y+2	; 0x02
    7066:	42 85       	ldd	r20, Z+10	; 0x0a
    7068:	53 85       	ldd	r21, Z+11	; 0x0b
    706a:	e9 81       	ldd	r30, Y+1	; 0x01
    706c:	fa 81       	ldd	r31, Y+2	; 0x02
    706e:	86 89       	ldd	r24, Z+22	; 0x16
    7070:	28 2f       	mov	r18, r24
    7072:	30 e0       	ldi	r19, 0x00	; 0
    7074:	c9 01       	movw	r24, r18
    7076:	88 0f       	add	r24, r24
    7078:	99 1f       	adc	r25, r25
    707a:	88 0f       	add	r24, r24
    707c:	99 1f       	adc	r25, r25
    707e:	88 0f       	add	r24, r24
    7080:	99 1f       	adc	r25, r25
    7082:	82 0f       	add	r24, r18
    7084:	93 1f       	adc	r25, r19
    7086:	81 56       	subi	r24, 0x61	; 97
    7088:	9a 4f       	sbci	r25, 0xFA	; 250
    708a:	48 17       	cp	r20, r24
    708c:	59 07       	cpc	r21, r25
    708e:	a1 f5       	brne	.+104    	; 0x70f8 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7090:	89 81       	ldd	r24, Y+1	; 0x01
    7092:	9a 81       	ldd	r25, Y+2	; 0x02
    7094:	02 96       	adiw	r24, 0x02	; 2
    7096:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    709a:	e0 91 8e 05 	lds	r30, 0x058E
    709e:	f0 91 8f 05 	lds	r31, 0x058F
    70a2:	86 89       	ldd	r24, Z+22	; 0x16
    70a4:	e9 81       	ldd	r30, Y+1	; 0x01
    70a6:	fa 81       	ldd	r31, Y+2	; 0x02
    70a8:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    70aa:	e9 81       	ldd	r30, Y+1	; 0x01
    70ac:	fa 81       	ldd	r31, Y+2	; 0x02
    70ae:	96 89       	ldd	r25, Z+22	; 0x16
    70b0:	80 91 94 05 	lds	r24, 0x0594
    70b4:	89 17       	cp	r24, r25
    70b6:	28 f4       	brcc	.+10     	; 0x70c2 <vTaskPriorityInherit+0xc2>
    70b8:	e9 81       	ldd	r30, Y+1	; 0x01
    70ba:	fa 81       	ldd	r31, Y+2	; 0x02
    70bc:	86 89       	ldd	r24, Z+22	; 0x16
    70be:	80 93 94 05 	sts	0x0594, r24
    70c2:	e9 81       	ldd	r30, Y+1	; 0x01
    70c4:	fa 81       	ldd	r31, Y+2	; 0x02
    70c6:	86 89       	ldd	r24, Z+22	; 0x16
    70c8:	28 2f       	mov	r18, r24
    70ca:	30 e0       	ldi	r19, 0x00	; 0
    70cc:	c9 01       	movw	r24, r18
    70ce:	88 0f       	add	r24, r24
    70d0:	99 1f       	adc	r25, r25
    70d2:	88 0f       	add	r24, r24
    70d4:	99 1f       	adc	r25, r25
    70d6:	88 0f       	add	r24, r24
    70d8:	99 1f       	adc	r25, r25
    70da:	82 0f       	add	r24, r18
    70dc:	93 1f       	adc	r25, r19
    70de:	ac 01       	movw	r20, r24
    70e0:	41 56       	subi	r20, 0x61	; 97
    70e2:	5a 4f       	sbci	r21, 0xFA	; 250
    70e4:	89 81       	ldd	r24, Y+1	; 0x01
    70e6:	9a 81       	ldd	r25, Y+2	; 0x02
    70e8:	9c 01       	movw	r18, r24
    70ea:	2e 5f       	subi	r18, 0xFE	; 254
    70ec:	3f 4f       	sbci	r19, 0xFF	; 255
    70ee:	ca 01       	movw	r24, r20
    70f0:	b9 01       	movw	r22, r18
    70f2:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
    70f6:	08 c0       	rjmp	.+16     	; 0x7108 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    70f8:	e0 91 8e 05 	lds	r30, 0x058E
    70fc:	f0 91 8f 05 	lds	r31, 0x058F
    7100:	86 89       	ldd	r24, Z+22	; 0x16
    7102:	e9 81       	ldd	r30, Y+1	; 0x01
    7104:	fa 81       	ldd	r31, Y+2	; 0x02
    7106:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    7108:	0f 90       	pop	r0
    710a:	0f 90       	pop	r0
    710c:	0f 90       	pop	r0
    710e:	0f 90       	pop	r0
    7110:	cf 91       	pop	r28
    7112:	df 91       	pop	r29
    7114:	08 95       	ret

00007116 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    7116:	df 93       	push	r29
    7118:	cf 93       	push	r28
    711a:	00 d0       	rcall	.+0      	; 0x711c <xTaskPriorityDisinherit+0x6>
    711c:	00 d0       	rcall	.+0      	; 0x711e <xTaskPriorityDisinherit+0x8>
    711e:	0f 92       	push	r0
    7120:	cd b7       	in	r28, 0x3d	; 61
    7122:	de b7       	in	r29, 0x3e	; 62
    7124:	9d 83       	std	Y+5, r25	; 0x05
    7126:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    7128:	8c 81       	ldd	r24, Y+4	; 0x04
    712a:	9d 81       	ldd	r25, Y+5	; 0x05
    712c:	9b 83       	std	Y+3, r25	; 0x03
    712e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    7130:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    7132:	8c 81       	ldd	r24, Y+4	; 0x04
    7134:	9d 81       	ldd	r25, Y+5	; 0x05
    7136:	00 97       	sbiw	r24, 0x00	; 0
    7138:	09 f4       	brne	.+2      	; 0x713c <xTaskPriorityDisinherit+0x26>
    713a:	56 c0       	rjmp	.+172    	; 0x71e8 <xTaskPriorityDisinherit+0xd2>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    713c:	ea 81       	ldd	r30, Y+2	; 0x02
    713e:	fb 81       	ldd	r31, Y+3	; 0x03
    7140:	82 a1       	ldd	r24, Z+34	; 0x22
    7142:	81 50       	subi	r24, 0x01	; 1
    7144:	ea 81       	ldd	r30, Y+2	; 0x02
    7146:	fb 81       	ldd	r31, Y+3	; 0x03
    7148:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    714a:	ea 81       	ldd	r30, Y+2	; 0x02
    714c:	fb 81       	ldd	r31, Y+3	; 0x03
    714e:	96 89       	ldd	r25, Z+22	; 0x16
    7150:	ea 81       	ldd	r30, Y+2	; 0x02
    7152:	fb 81       	ldd	r31, Y+3	; 0x03
    7154:	81 a1       	ldd	r24, Z+33	; 0x21
    7156:	98 17       	cp	r25, r24
    7158:	09 f4       	brne	.+2      	; 0x715c <xTaskPriorityDisinherit+0x46>
    715a:	46 c0       	rjmp	.+140    	; 0x71e8 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    715c:	ea 81       	ldd	r30, Y+2	; 0x02
    715e:	fb 81       	ldd	r31, Y+3	; 0x03
    7160:	82 a1       	ldd	r24, Z+34	; 0x22
    7162:	88 23       	and	r24, r24
    7164:	09 f0       	breq	.+2      	; 0x7168 <xTaskPriorityDisinherit+0x52>
    7166:	40 c0       	rjmp	.+128    	; 0x71e8 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7168:	8a 81       	ldd	r24, Y+2	; 0x02
    716a:	9b 81       	ldd	r25, Y+3	; 0x03
    716c:	02 96       	adiw	r24, 0x02	; 2
    716e:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    7172:	ea 81       	ldd	r30, Y+2	; 0x02
    7174:	fb 81       	ldd	r31, Y+3	; 0x03
    7176:	81 a1       	ldd	r24, Z+33	; 0x21
    7178:	ea 81       	ldd	r30, Y+2	; 0x02
    717a:	fb 81       	ldd	r31, Y+3	; 0x03
    717c:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    717e:	ea 81       	ldd	r30, Y+2	; 0x02
    7180:	fb 81       	ldd	r31, Y+3	; 0x03
    7182:	86 89       	ldd	r24, Z+22	; 0x16
    7184:	28 2f       	mov	r18, r24
    7186:	30 e0       	ldi	r19, 0x00	; 0
    7188:	89 e0       	ldi	r24, 0x09	; 9
    718a:	90 e0       	ldi	r25, 0x00	; 0
    718c:	82 1b       	sub	r24, r18
    718e:	93 0b       	sbc	r25, r19
    7190:	ea 81       	ldd	r30, Y+2	; 0x02
    7192:	fb 81       	ldd	r31, Y+3	; 0x03
    7194:	95 87       	std	Z+13, r25	; 0x0d
    7196:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    7198:	ea 81       	ldd	r30, Y+2	; 0x02
    719a:	fb 81       	ldd	r31, Y+3	; 0x03
    719c:	96 89       	ldd	r25, Z+22	; 0x16
    719e:	80 91 94 05 	lds	r24, 0x0594
    71a2:	89 17       	cp	r24, r25
    71a4:	28 f4       	brcc	.+10     	; 0x71b0 <xTaskPriorityDisinherit+0x9a>
    71a6:	ea 81       	ldd	r30, Y+2	; 0x02
    71a8:	fb 81       	ldd	r31, Y+3	; 0x03
    71aa:	86 89       	ldd	r24, Z+22	; 0x16
    71ac:	80 93 94 05 	sts	0x0594, r24
    71b0:	ea 81       	ldd	r30, Y+2	; 0x02
    71b2:	fb 81       	ldd	r31, Y+3	; 0x03
    71b4:	86 89       	ldd	r24, Z+22	; 0x16
    71b6:	28 2f       	mov	r18, r24
    71b8:	30 e0       	ldi	r19, 0x00	; 0
    71ba:	c9 01       	movw	r24, r18
    71bc:	88 0f       	add	r24, r24
    71be:	99 1f       	adc	r25, r25
    71c0:	88 0f       	add	r24, r24
    71c2:	99 1f       	adc	r25, r25
    71c4:	88 0f       	add	r24, r24
    71c6:	99 1f       	adc	r25, r25
    71c8:	82 0f       	add	r24, r18
    71ca:	93 1f       	adc	r25, r19
    71cc:	ac 01       	movw	r20, r24
    71ce:	41 56       	subi	r20, 0x61	; 97
    71d0:	5a 4f       	sbci	r21, 0xFA	; 250
    71d2:	8a 81       	ldd	r24, Y+2	; 0x02
    71d4:	9b 81       	ldd	r25, Y+3	; 0x03
    71d6:	9c 01       	movw	r18, r24
    71d8:	2e 5f       	subi	r18, 0xFE	; 254
    71da:	3f 4f       	sbci	r19, 0xFF	; 255
    71dc:	ca 01       	movw	r24, r20
    71de:	b9 01       	movw	r22, r18
    71e0:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    71e4:	81 e0       	ldi	r24, 0x01	; 1
    71e6:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    71e8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    71ea:	0f 90       	pop	r0
    71ec:	0f 90       	pop	r0
    71ee:	0f 90       	pop	r0
    71f0:	0f 90       	pop	r0
    71f2:	0f 90       	pop	r0
    71f4:	cf 91       	pop	r28
    71f6:	df 91       	pop	r29
    71f8:	08 95       	ret

000071fa <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    71fa:	df 93       	push	r29
    71fc:	cf 93       	push	r28
    71fe:	00 d0       	rcall	.+0      	; 0x7200 <uxTaskResetEventItemValue+0x6>
    7200:	cd b7       	in	r28, 0x3d	; 61
    7202:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    7204:	e0 91 8e 05 	lds	r30, 0x058E
    7208:	f0 91 8f 05 	lds	r31, 0x058F
    720c:	84 85       	ldd	r24, Z+12	; 0x0c
    720e:	95 85       	ldd	r25, Z+13	; 0x0d
    7210:	9a 83       	std	Y+2, r25	; 0x02
    7212:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7214:	a0 91 8e 05 	lds	r26, 0x058E
    7218:	b0 91 8f 05 	lds	r27, 0x058F
    721c:	e0 91 8e 05 	lds	r30, 0x058E
    7220:	f0 91 8f 05 	lds	r31, 0x058F
    7224:	86 89       	ldd	r24, Z+22	; 0x16
    7226:	28 2f       	mov	r18, r24
    7228:	30 e0       	ldi	r19, 0x00	; 0
    722a:	89 e0       	ldi	r24, 0x09	; 9
    722c:	90 e0       	ldi	r25, 0x00	; 0
    722e:	82 1b       	sub	r24, r18
    7230:	93 0b       	sbc	r25, r19
    7232:	1d 96       	adiw	r26, 0x0d	; 13
    7234:	9c 93       	st	X, r25
    7236:	8e 93       	st	-X, r24
    7238:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    723a:	89 81       	ldd	r24, Y+1	; 0x01
    723c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    723e:	0f 90       	pop	r0
    7240:	0f 90       	pop	r0
    7242:	cf 91       	pop	r28
    7244:	df 91       	pop	r29
    7246:	08 95       	ret

00007248 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    7248:	df 93       	push	r29
    724a:	cf 93       	push	r28
    724c:	cd b7       	in	r28, 0x3d	; 61
    724e:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    7250:	80 91 8e 05 	lds	r24, 0x058E
    7254:	90 91 8f 05 	lds	r25, 0x058F
    7258:	00 97       	sbiw	r24, 0x00	; 0
    725a:	39 f0       	breq	.+14     	; 0x726a <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    725c:	e0 91 8e 05 	lds	r30, 0x058E
    7260:	f0 91 8f 05 	lds	r31, 0x058F
    7264:	82 a1       	ldd	r24, Z+34	; 0x22
    7266:	8f 5f       	subi	r24, 0xFF	; 255
    7268:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    726a:	80 91 8e 05 	lds	r24, 0x058E
    726e:	90 91 8f 05 	lds	r25, 0x058F
	}
    7272:	cf 91       	pop	r28
    7274:	df 91       	pop	r29
    7276:	08 95       	ret

00007278 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    7278:	df 93       	push	r29
    727a:	cf 93       	push	r28
    727c:	cd b7       	in	r28, 0x3d	; 61
    727e:	de b7       	in	r29, 0x3e	; 62
    7280:	27 97       	sbiw	r28, 0x07	; 7
    7282:	0f b6       	in	r0, 0x3f	; 63
    7284:	f8 94       	cli
    7286:	de bf       	out	0x3e, r29	; 62
    7288:	0f be       	out	0x3f, r0	; 63
    728a:	cd bf       	out	0x3d, r28	; 61
    728c:	8d 83       	std	Y+5, r24	; 0x05
    728e:	7f 83       	std	Y+7, r23	; 0x07
    7290:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    7292:	0f b6       	in	r0, 0x3f	; 63
    7294:	f8 94       	cli
    7296:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    7298:	e0 91 8e 05 	lds	r30, 0x058E
    729c:	f0 91 8f 05 	lds	r31, 0x058F
    72a0:	83 a1       	ldd	r24, Z+35	; 0x23
    72a2:	94 a1       	ldd	r25, Z+36	; 0x24
    72a4:	a5 a1       	ldd	r26, Z+37	; 0x25
    72a6:	b6 a1       	ldd	r27, Z+38	; 0x26
    72a8:	00 97       	sbiw	r24, 0x00	; 0
    72aa:	a1 05       	cpc	r26, r1
    72ac:	b1 05       	cpc	r27, r1
    72ae:	89 f4       	brne	.+34     	; 0x72d2 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    72b0:	e0 91 8e 05 	lds	r30, 0x058E
    72b4:	f0 91 8f 05 	lds	r31, 0x058F
    72b8:	81 e0       	ldi	r24, 0x01	; 1
    72ba:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    72bc:	8e 81       	ldd	r24, Y+6	; 0x06
    72be:	9f 81       	ldd	r25, Y+7	; 0x07
    72c0:	00 97       	sbiw	r24, 0x00	; 0
    72c2:	39 f0       	breq	.+14     	; 0x72d2 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    72c4:	8e 81       	ldd	r24, Y+6	; 0x06
    72c6:	9f 81       	ldd	r25, Y+7	; 0x07
    72c8:	61 e0       	ldi	r22, 0x01	; 1
    72ca:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    72ce:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    72d2:	0f 90       	pop	r0
    72d4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    72d6:	0f b6       	in	r0, 0x3f	; 63
    72d8:	f8 94       	cli
    72da:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    72dc:	e0 91 8e 05 	lds	r30, 0x058E
    72e0:	f0 91 8f 05 	lds	r31, 0x058F
    72e4:	83 a1       	ldd	r24, Z+35	; 0x23
    72e6:	94 a1       	ldd	r25, Z+36	; 0x24
    72e8:	a5 a1       	ldd	r26, Z+37	; 0x25
    72ea:	b6 a1       	ldd	r27, Z+38	; 0x26
    72ec:	89 83       	std	Y+1, r24	; 0x01
    72ee:	9a 83       	std	Y+2, r25	; 0x02
    72f0:	ab 83       	std	Y+3, r26	; 0x03
    72f2:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    72f4:	89 81       	ldd	r24, Y+1	; 0x01
    72f6:	9a 81       	ldd	r25, Y+2	; 0x02
    72f8:	ab 81       	ldd	r26, Y+3	; 0x03
    72fa:	bc 81       	ldd	r27, Y+4	; 0x04
    72fc:	00 97       	sbiw	r24, 0x00	; 0
    72fe:	a1 05       	cpc	r26, r1
    7300:	b1 05       	cpc	r27, r1
    7302:	d9 f0       	breq	.+54     	; 0x733a <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    7304:	8d 81       	ldd	r24, Y+5	; 0x05
    7306:	88 23       	and	r24, r24
    7308:	49 f0       	breq	.+18     	; 0x731c <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    730a:	e0 91 8e 05 	lds	r30, 0x058E
    730e:	f0 91 8f 05 	lds	r31, 0x058F
    7312:	13 a2       	std	Z+35, r1	; 0x23
    7314:	14 a2       	std	Z+36, r1	; 0x24
    7316:	15 a2       	std	Z+37, r1	; 0x25
    7318:	16 a2       	std	Z+38, r1	; 0x26
    731a:	0f c0       	rjmp	.+30     	; 0x733a <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    731c:	e0 91 8e 05 	lds	r30, 0x058E
    7320:	f0 91 8f 05 	lds	r31, 0x058F
    7324:	89 81       	ldd	r24, Y+1	; 0x01
    7326:	9a 81       	ldd	r25, Y+2	; 0x02
    7328:	ab 81       	ldd	r26, Y+3	; 0x03
    732a:	bc 81       	ldd	r27, Y+4	; 0x04
    732c:	01 97       	sbiw	r24, 0x01	; 1
    732e:	a1 09       	sbc	r26, r1
    7330:	b1 09       	sbc	r27, r1
    7332:	83 a3       	std	Z+35, r24	; 0x23
    7334:	94 a3       	std	Z+36, r25	; 0x24
    7336:	a5 a3       	std	Z+37, r26	; 0x25
    7338:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    733a:	e0 91 8e 05 	lds	r30, 0x058E
    733e:	f0 91 8f 05 	lds	r31, 0x058F
    7342:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    7344:	0f 90       	pop	r0
    7346:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    7348:	89 81       	ldd	r24, Y+1	; 0x01
    734a:	9a 81       	ldd	r25, Y+2	; 0x02
    734c:	ab 81       	ldd	r26, Y+3	; 0x03
    734e:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    7350:	bc 01       	movw	r22, r24
    7352:	cd 01       	movw	r24, r26
    7354:	27 96       	adiw	r28, 0x07	; 7
    7356:	0f b6       	in	r0, 0x3f	; 63
    7358:	f8 94       	cli
    735a:	de bf       	out	0x3e, r29	; 62
    735c:	0f be       	out	0x3f, r0	; 63
    735e:	cd bf       	out	0x3d, r28	; 61
    7360:	cf 91       	pop	r28
    7362:	df 91       	pop	r29
    7364:	08 95       	ret

00007366 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    7366:	ef 92       	push	r14
    7368:	ff 92       	push	r15
    736a:	0f 93       	push	r16
    736c:	1f 93       	push	r17
    736e:	df 93       	push	r29
    7370:	cf 93       	push	r28
    7372:	cd b7       	in	r28, 0x3d	; 61
    7374:	de b7       	in	r29, 0x3e	; 62
    7376:	2d 97       	sbiw	r28, 0x0d	; 13
    7378:	0f b6       	in	r0, 0x3f	; 63
    737a:	f8 94       	cli
    737c:	de bf       	out	0x3e, r29	; 62
    737e:	0f be       	out	0x3f, r0	; 63
    7380:	cd bf       	out	0x3d, r28	; 61
    7382:	6a 83       	std	Y+2, r22	; 0x02
    7384:	7b 83       	std	Y+3, r23	; 0x03
    7386:	8c 83       	std	Y+4, r24	; 0x04
    7388:	9d 83       	std	Y+5, r25	; 0x05
    738a:	2e 83       	std	Y+6, r18	; 0x06
    738c:	3f 83       	std	Y+7, r19	; 0x07
    738e:	48 87       	std	Y+8, r20	; 0x08
    7390:	59 87       	std	Y+9, r21	; 0x09
    7392:	1b 87       	std	Y+11, r17	; 0x0b
    7394:	0a 87       	std	Y+10, r16	; 0x0a
    7396:	fd 86       	std	Y+13, r15	; 0x0d
    7398:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    739a:	0f b6       	in	r0, 0x3f	; 63
    739c:	f8 94       	cli
    739e:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    73a0:	e0 91 8e 05 	lds	r30, 0x058E
    73a4:	f0 91 8f 05 	lds	r31, 0x058F
    73a8:	87 a1       	ldd	r24, Z+39	; 0x27
    73aa:	82 30       	cpi	r24, 0x02	; 2
    73ac:	49 f1       	breq	.+82     	; 0x7400 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    73ae:	e0 91 8e 05 	lds	r30, 0x058E
    73b2:	f0 91 8f 05 	lds	r31, 0x058F
    73b6:	23 a1       	ldd	r18, Z+35	; 0x23
    73b8:	34 a1       	ldd	r19, Z+36	; 0x24
    73ba:	45 a1       	ldd	r20, Z+37	; 0x25
    73bc:	56 a1       	ldd	r21, Z+38	; 0x26
    73be:	8a 81       	ldd	r24, Y+2	; 0x02
    73c0:	9b 81       	ldd	r25, Y+3	; 0x03
    73c2:	ac 81       	ldd	r26, Y+4	; 0x04
    73c4:	bd 81       	ldd	r27, Y+5	; 0x05
    73c6:	80 95       	com	r24
    73c8:	90 95       	com	r25
    73ca:	a0 95       	com	r26
    73cc:	b0 95       	com	r27
    73ce:	82 23       	and	r24, r18
    73d0:	93 23       	and	r25, r19
    73d2:	a4 23       	and	r26, r20
    73d4:	b5 23       	and	r27, r21
    73d6:	83 a3       	std	Z+35, r24	; 0x23
    73d8:	94 a3       	std	Z+36, r25	; 0x24
    73da:	a5 a3       	std	Z+37, r26	; 0x25
    73dc:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    73de:	e0 91 8e 05 	lds	r30, 0x058E
    73e2:	f0 91 8f 05 	lds	r31, 0x058F
    73e6:	81 e0       	ldi	r24, 0x01	; 1
    73e8:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    73ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    73ec:	9d 85       	ldd	r25, Y+13	; 0x0d
    73ee:	00 97       	sbiw	r24, 0x00	; 0
    73f0:	39 f0       	breq	.+14     	; 0x7400 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    73f2:	8c 85       	ldd	r24, Y+12	; 0x0c
    73f4:	9d 85       	ldd	r25, Y+13	; 0x0d
    73f6:	61 e0       	ldi	r22, 0x01	; 1
    73f8:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    73fc:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    7400:	0f 90       	pop	r0
    7402:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    7404:	0f b6       	in	r0, 0x3f	; 63
    7406:	f8 94       	cli
    7408:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    740a:	8a 85       	ldd	r24, Y+10	; 0x0a
    740c:	9b 85       	ldd	r25, Y+11	; 0x0b
    740e:	00 97       	sbiw	r24, 0x00	; 0
    7410:	71 f0       	breq	.+28     	; 0x742e <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    7412:	e0 91 8e 05 	lds	r30, 0x058E
    7416:	f0 91 8f 05 	lds	r31, 0x058F
    741a:	83 a1       	ldd	r24, Z+35	; 0x23
    741c:	94 a1       	ldd	r25, Z+36	; 0x24
    741e:	a5 a1       	ldd	r26, Z+37	; 0x25
    7420:	b6 a1       	ldd	r27, Z+38	; 0x26
    7422:	ea 85       	ldd	r30, Y+10	; 0x0a
    7424:	fb 85       	ldd	r31, Y+11	; 0x0b
    7426:	80 83       	st	Z, r24
    7428:	91 83       	std	Z+1, r25	; 0x01
    742a:	a2 83       	std	Z+2, r26	; 0x02
    742c:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    742e:	e0 91 8e 05 	lds	r30, 0x058E
    7432:	f0 91 8f 05 	lds	r31, 0x058F
    7436:	87 a1       	ldd	r24, Z+39	; 0x27
    7438:	81 30       	cpi	r24, 0x01	; 1
    743a:	11 f4       	brne	.+4      	; 0x7440 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    743c:	19 82       	std	Y+1, r1	; 0x01
    743e:	1a c0       	rjmp	.+52     	; 0x7474 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    7440:	e0 91 8e 05 	lds	r30, 0x058E
    7444:	f0 91 8f 05 	lds	r31, 0x058F
    7448:	23 a1       	ldd	r18, Z+35	; 0x23
    744a:	34 a1       	ldd	r19, Z+36	; 0x24
    744c:	45 a1       	ldd	r20, Z+37	; 0x25
    744e:	56 a1       	ldd	r21, Z+38	; 0x26
    7450:	8e 81       	ldd	r24, Y+6	; 0x06
    7452:	9f 81       	ldd	r25, Y+7	; 0x07
    7454:	a8 85       	ldd	r26, Y+8	; 0x08
    7456:	b9 85       	ldd	r27, Y+9	; 0x09
    7458:	80 95       	com	r24
    745a:	90 95       	com	r25
    745c:	a0 95       	com	r26
    745e:	b0 95       	com	r27
    7460:	82 23       	and	r24, r18
    7462:	93 23       	and	r25, r19
    7464:	a4 23       	and	r26, r20
    7466:	b5 23       	and	r27, r21
    7468:	83 a3       	std	Z+35, r24	; 0x23
    746a:	94 a3       	std	Z+36, r25	; 0x24
    746c:	a5 a3       	std	Z+37, r26	; 0x25
    746e:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    7470:	81 e0       	ldi	r24, 0x01	; 1
    7472:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    7474:	e0 91 8e 05 	lds	r30, 0x058E
    7478:	f0 91 8f 05 	lds	r31, 0x058F
    747c:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    747e:	0f 90       	pop	r0
    7480:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    7482:	89 81       	ldd	r24, Y+1	; 0x01
	}
    7484:	2d 96       	adiw	r28, 0x0d	; 13
    7486:	0f b6       	in	r0, 0x3f	; 63
    7488:	f8 94       	cli
    748a:	de bf       	out	0x3e, r29	; 62
    748c:	0f be       	out	0x3f, r0	; 63
    748e:	cd bf       	out	0x3d, r28	; 61
    7490:	cf 91       	pop	r28
    7492:	df 91       	pop	r29
    7494:	1f 91       	pop	r17
    7496:	0f 91       	pop	r16
    7498:	ff 90       	pop	r15
    749a:	ef 90       	pop	r14
    749c:	08 95       	ret

0000749e <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    749e:	0f 93       	push	r16
    74a0:	1f 93       	push	r17
    74a2:	df 93       	push	r29
    74a4:	cf 93       	push	r28
    74a6:	cd b7       	in	r28, 0x3d	; 61
    74a8:	de b7       	in	r29, 0x3e	; 62
    74aa:	2f 97       	sbiw	r28, 0x0f	; 15
    74ac:	0f b6       	in	r0, 0x3f	; 63
    74ae:	f8 94       	cli
    74b0:	de bf       	out	0x3e, r29	; 62
    74b2:	0f be       	out	0x3f, r0	; 63
    74b4:	cd bf       	out	0x3d, r28	; 61
    74b6:	9e 83       	std	Y+6, r25	; 0x06
    74b8:	8d 83       	std	Y+5, r24	; 0x05
    74ba:	4f 83       	std	Y+7, r20	; 0x07
    74bc:	58 87       	std	Y+8, r21	; 0x08
    74be:	69 87       	std	Y+9, r22	; 0x09
    74c0:	7a 87       	std	Y+10, r23	; 0x0a
    74c2:	2b 87       	std	Y+11, r18	; 0x0b
    74c4:	1d 87       	std	Y+13, r17	; 0x0d
    74c6:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    74c8:	81 e0       	ldi	r24, 0x01	; 1
    74ca:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    74cc:	8d 81       	ldd	r24, Y+5	; 0x05
    74ce:	9e 81       	ldd	r25, Y+6	; 0x06
    74d0:	9c 83       	std	Y+4, r25	; 0x04
    74d2:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    74d4:	0f b6       	in	r0, 0x3f	; 63
    74d6:	f8 94       	cli
    74d8:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    74da:	8c 85       	ldd	r24, Y+12	; 0x0c
    74dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    74de:	00 97       	sbiw	r24, 0x00	; 0
    74e0:	61 f0       	breq	.+24     	; 0x74fa <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    74e2:	eb 81       	ldd	r30, Y+3	; 0x03
    74e4:	fc 81       	ldd	r31, Y+4	; 0x04
    74e6:	83 a1       	ldd	r24, Z+35	; 0x23
    74e8:	94 a1       	ldd	r25, Z+36	; 0x24
    74ea:	a5 a1       	ldd	r26, Z+37	; 0x25
    74ec:	b6 a1       	ldd	r27, Z+38	; 0x26
    74ee:	ec 85       	ldd	r30, Y+12	; 0x0c
    74f0:	fd 85       	ldd	r31, Y+13	; 0x0d
    74f2:	80 83       	st	Z, r24
    74f4:	91 83       	std	Z+1, r25	; 0x01
    74f6:	a2 83       	std	Z+2, r26	; 0x02
    74f8:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    74fa:	eb 81       	ldd	r30, Y+3	; 0x03
    74fc:	fc 81       	ldd	r31, Y+4	; 0x04
    74fe:	87 a1       	ldd	r24, Z+39	; 0x27
    7500:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    7502:	eb 81       	ldd	r30, Y+3	; 0x03
    7504:	fc 81       	ldd	r31, Y+4	; 0x04
    7506:	82 e0       	ldi	r24, 0x02	; 2
    7508:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    750a:	8b 85       	ldd	r24, Y+11	; 0x0b
    750c:	28 2f       	mov	r18, r24
    750e:	30 e0       	ldi	r19, 0x00	; 0
    7510:	3f 87       	std	Y+15, r19	; 0x0f
    7512:	2e 87       	std	Y+14, r18	; 0x0e
    7514:	8e 85       	ldd	r24, Y+14	; 0x0e
    7516:	9f 85       	ldd	r25, Y+15	; 0x0f
    7518:	82 30       	cpi	r24, 0x02	; 2
    751a:	91 05       	cpc	r25, r1
    751c:	59 f1       	breq	.+86     	; 0x7574 <xTaskGenericNotify+0xd6>
    751e:	2e 85       	ldd	r18, Y+14	; 0x0e
    7520:	3f 85       	ldd	r19, Y+15	; 0x0f
    7522:	23 30       	cpi	r18, 0x03	; 3
    7524:	31 05       	cpc	r19, r1
    7526:	34 f4       	brge	.+12     	; 0x7534 <xTaskGenericNotify+0x96>
    7528:	8e 85       	ldd	r24, Y+14	; 0x0e
    752a:	9f 85       	ldd	r25, Y+15	; 0x0f
    752c:	81 30       	cpi	r24, 0x01	; 1
    752e:	91 05       	cpc	r25, r1
    7530:	61 f0       	breq	.+24     	; 0x754a <xTaskGenericNotify+0xac>
    7532:	4a c0       	rjmp	.+148    	; 0x75c8 <xTaskGenericNotify+0x12a>
    7534:	2e 85       	ldd	r18, Y+14	; 0x0e
    7536:	3f 85       	ldd	r19, Y+15	; 0x0f
    7538:	23 30       	cpi	r18, 0x03	; 3
    753a:	31 05       	cpc	r19, r1
    753c:	59 f1       	breq	.+86     	; 0x7594 <xTaskGenericNotify+0xf6>
    753e:	8e 85       	ldd	r24, Y+14	; 0x0e
    7540:	9f 85       	ldd	r25, Y+15	; 0x0f
    7542:	84 30       	cpi	r24, 0x04	; 4
    7544:	91 05       	cpc	r25, r1
    7546:	89 f1       	breq	.+98     	; 0x75aa <xTaskGenericNotify+0x10c>
    7548:	3f c0       	rjmp	.+126    	; 0x75c8 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    754a:	eb 81       	ldd	r30, Y+3	; 0x03
    754c:	fc 81       	ldd	r31, Y+4	; 0x04
    754e:	23 a1       	ldd	r18, Z+35	; 0x23
    7550:	34 a1       	ldd	r19, Z+36	; 0x24
    7552:	45 a1       	ldd	r20, Z+37	; 0x25
    7554:	56 a1       	ldd	r21, Z+38	; 0x26
    7556:	8f 81       	ldd	r24, Y+7	; 0x07
    7558:	98 85       	ldd	r25, Y+8	; 0x08
    755a:	a9 85       	ldd	r26, Y+9	; 0x09
    755c:	ba 85       	ldd	r27, Y+10	; 0x0a
    755e:	82 2b       	or	r24, r18
    7560:	93 2b       	or	r25, r19
    7562:	a4 2b       	or	r26, r20
    7564:	b5 2b       	or	r27, r21
    7566:	eb 81       	ldd	r30, Y+3	; 0x03
    7568:	fc 81       	ldd	r31, Y+4	; 0x04
    756a:	83 a3       	std	Z+35, r24	; 0x23
    756c:	94 a3       	std	Z+36, r25	; 0x24
    756e:	a5 a3       	std	Z+37, r26	; 0x25
    7570:	b6 a3       	std	Z+38, r27	; 0x26
    7572:	2a c0       	rjmp	.+84     	; 0x75c8 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    7574:	eb 81       	ldd	r30, Y+3	; 0x03
    7576:	fc 81       	ldd	r31, Y+4	; 0x04
    7578:	83 a1       	ldd	r24, Z+35	; 0x23
    757a:	94 a1       	ldd	r25, Z+36	; 0x24
    757c:	a5 a1       	ldd	r26, Z+37	; 0x25
    757e:	b6 a1       	ldd	r27, Z+38	; 0x26
    7580:	01 96       	adiw	r24, 0x01	; 1
    7582:	a1 1d       	adc	r26, r1
    7584:	b1 1d       	adc	r27, r1
    7586:	eb 81       	ldd	r30, Y+3	; 0x03
    7588:	fc 81       	ldd	r31, Y+4	; 0x04
    758a:	83 a3       	std	Z+35, r24	; 0x23
    758c:	94 a3       	std	Z+36, r25	; 0x24
    758e:	a5 a3       	std	Z+37, r26	; 0x25
    7590:	b6 a3       	std	Z+38, r27	; 0x26
    7592:	1a c0       	rjmp	.+52     	; 0x75c8 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    7594:	eb 81       	ldd	r30, Y+3	; 0x03
    7596:	fc 81       	ldd	r31, Y+4	; 0x04
    7598:	8f 81       	ldd	r24, Y+7	; 0x07
    759a:	98 85       	ldd	r25, Y+8	; 0x08
    759c:	a9 85       	ldd	r26, Y+9	; 0x09
    759e:	ba 85       	ldd	r27, Y+10	; 0x0a
    75a0:	83 a3       	std	Z+35, r24	; 0x23
    75a2:	94 a3       	std	Z+36, r25	; 0x24
    75a4:	a5 a3       	std	Z+37, r26	; 0x25
    75a6:	b6 a3       	std	Z+38, r27	; 0x26
    75a8:	0f c0       	rjmp	.+30     	; 0x75c8 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    75aa:	89 81       	ldd	r24, Y+1	; 0x01
    75ac:	82 30       	cpi	r24, 0x02	; 2
    75ae:	59 f0       	breq	.+22     	; 0x75c6 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    75b0:	eb 81       	ldd	r30, Y+3	; 0x03
    75b2:	fc 81       	ldd	r31, Y+4	; 0x04
    75b4:	8f 81       	ldd	r24, Y+7	; 0x07
    75b6:	98 85       	ldd	r25, Y+8	; 0x08
    75b8:	a9 85       	ldd	r26, Y+9	; 0x09
    75ba:	ba 85       	ldd	r27, Y+10	; 0x0a
    75bc:	83 a3       	std	Z+35, r24	; 0x23
    75be:	94 a3       	std	Z+36, r25	; 0x24
    75c0:	a5 a3       	std	Z+37, r26	; 0x25
    75c2:	b6 a3       	std	Z+38, r27	; 0x26
    75c4:	01 c0       	rjmp	.+2      	; 0x75c8 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    75c6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    75c8:	89 81       	ldd	r24, Y+1	; 0x01
    75ca:	81 30       	cpi	r24, 0x01	; 1
    75cc:	b9 f5       	brne	.+110    	; 0x763c <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    75ce:	8b 81       	ldd	r24, Y+3	; 0x03
    75d0:	9c 81       	ldd	r25, Y+4	; 0x04
    75d2:	02 96       	adiw	r24, 0x02	; 2
    75d4:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    75d8:	eb 81       	ldd	r30, Y+3	; 0x03
    75da:	fc 81       	ldd	r31, Y+4	; 0x04
    75dc:	96 89       	ldd	r25, Z+22	; 0x16
    75de:	80 91 94 05 	lds	r24, 0x0594
    75e2:	89 17       	cp	r24, r25
    75e4:	28 f4       	brcc	.+10     	; 0x75f0 <xTaskGenericNotify+0x152>
    75e6:	eb 81       	ldd	r30, Y+3	; 0x03
    75e8:	fc 81       	ldd	r31, Y+4	; 0x04
    75ea:	86 89       	ldd	r24, Z+22	; 0x16
    75ec:	80 93 94 05 	sts	0x0594, r24
    75f0:	eb 81       	ldd	r30, Y+3	; 0x03
    75f2:	fc 81       	ldd	r31, Y+4	; 0x04
    75f4:	86 89       	ldd	r24, Z+22	; 0x16
    75f6:	28 2f       	mov	r18, r24
    75f8:	30 e0       	ldi	r19, 0x00	; 0
    75fa:	c9 01       	movw	r24, r18
    75fc:	88 0f       	add	r24, r24
    75fe:	99 1f       	adc	r25, r25
    7600:	88 0f       	add	r24, r24
    7602:	99 1f       	adc	r25, r25
    7604:	88 0f       	add	r24, r24
    7606:	99 1f       	adc	r25, r25
    7608:	82 0f       	add	r24, r18
    760a:	93 1f       	adc	r25, r19
    760c:	ac 01       	movw	r20, r24
    760e:	41 56       	subi	r20, 0x61	; 97
    7610:	5a 4f       	sbci	r21, 0xFA	; 250
    7612:	8b 81       	ldd	r24, Y+3	; 0x03
    7614:	9c 81       	ldd	r25, Y+4	; 0x04
    7616:	9c 01       	movw	r18, r24
    7618:	2e 5f       	subi	r18, 0xFE	; 254
    761a:	3f 4f       	sbci	r19, 0xFF	; 255
    761c:	ca 01       	movw	r24, r20
    761e:	b9 01       	movw	r22, r18
    7620:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    7624:	eb 81       	ldd	r30, Y+3	; 0x03
    7626:	fc 81       	ldd	r31, Y+4	; 0x04
    7628:	96 89       	ldd	r25, Z+22	; 0x16
    762a:	e0 91 8e 05 	lds	r30, 0x058E
    762e:	f0 91 8f 05 	lds	r31, 0x058F
    7632:	86 89       	ldd	r24, Z+22	; 0x16
    7634:	89 17       	cp	r24, r25
    7636:	10 f4       	brcc	.+4      	; 0x763c <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    7638:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    763c:	0f 90       	pop	r0
    763e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    7640:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    7642:	2f 96       	adiw	r28, 0x0f	; 15
    7644:	0f b6       	in	r0, 0x3f	; 63
    7646:	f8 94       	cli
    7648:	de bf       	out	0x3e, r29	; 62
    764a:	0f be       	out	0x3f, r0	; 63
    764c:	cd bf       	out	0x3d, r28	; 61
    764e:	cf 91       	pop	r28
    7650:	df 91       	pop	r29
    7652:	1f 91       	pop	r17
    7654:	0f 91       	pop	r16
    7656:	08 95       	ret

00007658 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    7658:	ef 92       	push	r14
    765a:	ff 92       	push	r15
    765c:	0f 93       	push	r16
    765e:	1f 93       	push	r17
    7660:	df 93       	push	r29
    7662:	cf 93       	push	r28
    7664:	cd b7       	in	r28, 0x3d	; 61
    7666:	de b7       	in	r29, 0x3e	; 62
    7668:	62 97       	sbiw	r28, 0x12	; 18
    766a:	0f b6       	in	r0, 0x3f	; 63
    766c:	f8 94       	cli
    766e:	de bf       	out	0x3e, r29	; 62
    7670:	0f be       	out	0x3f, r0	; 63
    7672:	cd bf       	out	0x3d, r28	; 61
    7674:	9f 83       	std	Y+7, r25	; 0x07
    7676:	8e 83       	std	Y+6, r24	; 0x06
    7678:	48 87       	std	Y+8, r20	; 0x08
    767a:	59 87       	std	Y+9, r21	; 0x09
    767c:	6a 87       	std	Y+10, r22	; 0x0a
    767e:	7b 87       	std	Y+11, r23	; 0x0b
    7680:	2c 87       	std	Y+12, r18	; 0x0c
    7682:	1e 87       	std	Y+14, r17	; 0x0e
    7684:	0d 87       	std	Y+13, r16	; 0x0d
    7686:	f8 8a       	std	Y+16, r15	; 0x10
    7688:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    768a:	81 e0       	ldi	r24, 0x01	; 1
    768c:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    768e:	8e 81       	ldd	r24, Y+6	; 0x06
    7690:	9f 81       	ldd	r25, Y+7	; 0x07
    7692:	9d 83       	std	Y+5, r25	; 0x05
    7694:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    7696:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    7698:	8d 85       	ldd	r24, Y+13	; 0x0d
    769a:	9e 85       	ldd	r25, Y+14	; 0x0e
    769c:	00 97       	sbiw	r24, 0x00	; 0
    769e:	61 f0       	breq	.+24     	; 0x76b8 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    76a0:	ec 81       	ldd	r30, Y+4	; 0x04
    76a2:	fd 81       	ldd	r31, Y+5	; 0x05
    76a4:	83 a1       	ldd	r24, Z+35	; 0x23
    76a6:	94 a1       	ldd	r25, Z+36	; 0x24
    76a8:	a5 a1       	ldd	r26, Z+37	; 0x25
    76aa:	b6 a1       	ldd	r27, Z+38	; 0x26
    76ac:	ed 85       	ldd	r30, Y+13	; 0x0d
    76ae:	fe 85       	ldd	r31, Y+14	; 0x0e
    76b0:	80 83       	st	Z, r24
    76b2:	91 83       	std	Z+1, r25	; 0x01
    76b4:	a2 83       	std	Z+2, r26	; 0x02
    76b6:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    76b8:	ec 81       	ldd	r30, Y+4	; 0x04
    76ba:	fd 81       	ldd	r31, Y+5	; 0x05
    76bc:	87 a1       	ldd	r24, Z+39	; 0x27
    76be:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    76c0:	ec 81       	ldd	r30, Y+4	; 0x04
    76c2:	fd 81       	ldd	r31, Y+5	; 0x05
    76c4:	82 e0       	ldi	r24, 0x02	; 2
    76c6:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    76c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    76ca:	28 2f       	mov	r18, r24
    76cc:	30 e0       	ldi	r19, 0x00	; 0
    76ce:	3a 8b       	std	Y+18, r19	; 0x12
    76d0:	29 8b       	std	Y+17, r18	; 0x11
    76d2:	89 89       	ldd	r24, Y+17	; 0x11
    76d4:	9a 89       	ldd	r25, Y+18	; 0x12
    76d6:	82 30       	cpi	r24, 0x02	; 2
    76d8:	91 05       	cpc	r25, r1
    76da:	59 f1       	breq	.+86     	; 0x7732 <xTaskGenericNotifyFromISR+0xda>
    76dc:	29 89       	ldd	r18, Y+17	; 0x11
    76de:	3a 89       	ldd	r19, Y+18	; 0x12
    76e0:	23 30       	cpi	r18, 0x03	; 3
    76e2:	31 05       	cpc	r19, r1
    76e4:	34 f4       	brge	.+12     	; 0x76f2 <xTaskGenericNotifyFromISR+0x9a>
    76e6:	89 89       	ldd	r24, Y+17	; 0x11
    76e8:	9a 89       	ldd	r25, Y+18	; 0x12
    76ea:	81 30       	cpi	r24, 0x01	; 1
    76ec:	91 05       	cpc	r25, r1
    76ee:	61 f0       	breq	.+24     	; 0x7708 <xTaskGenericNotifyFromISR+0xb0>
    76f0:	4a c0       	rjmp	.+148    	; 0x7786 <xTaskGenericNotifyFromISR+0x12e>
    76f2:	29 89       	ldd	r18, Y+17	; 0x11
    76f4:	3a 89       	ldd	r19, Y+18	; 0x12
    76f6:	23 30       	cpi	r18, 0x03	; 3
    76f8:	31 05       	cpc	r19, r1
    76fa:	59 f1       	breq	.+86     	; 0x7752 <xTaskGenericNotifyFromISR+0xfa>
    76fc:	89 89       	ldd	r24, Y+17	; 0x11
    76fe:	9a 89       	ldd	r25, Y+18	; 0x12
    7700:	84 30       	cpi	r24, 0x04	; 4
    7702:	91 05       	cpc	r25, r1
    7704:	89 f1       	breq	.+98     	; 0x7768 <xTaskGenericNotifyFromISR+0x110>
    7706:	3f c0       	rjmp	.+126    	; 0x7786 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    7708:	ec 81       	ldd	r30, Y+4	; 0x04
    770a:	fd 81       	ldd	r31, Y+5	; 0x05
    770c:	23 a1       	ldd	r18, Z+35	; 0x23
    770e:	34 a1       	ldd	r19, Z+36	; 0x24
    7710:	45 a1       	ldd	r20, Z+37	; 0x25
    7712:	56 a1       	ldd	r21, Z+38	; 0x26
    7714:	88 85       	ldd	r24, Y+8	; 0x08
    7716:	99 85       	ldd	r25, Y+9	; 0x09
    7718:	aa 85       	ldd	r26, Y+10	; 0x0a
    771a:	bb 85       	ldd	r27, Y+11	; 0x0b
    771c:	82 2b       	or	r24, r18
    771e:	93 2b       	or	r25, r19
    7720:	a4 2b       	or	r26, r20
    7722:	b5 2b       	or	r27, r21
    7724:	ec 81       	ldd	r30, Y+4	; 0x04
    7726:	fd 81       	ldd	r31, Y+5	; 0x05
    7728:	83 a3       	std	Z+35, r24	; 0x23
    772a:	94 a3       	std	Z+36, r25	; 0x24
    772c:	a5 a3       	std	Z+37, r26	; 0x25
    772e:	b6 a3       	std	Z+38, r27	; 0x26
    7730:	2a c0       	rjmp	.+84     	; 0x7786 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    7732:	ec 81       	ldd	r30, Y+4	; 0x04
    7734:	fd 81       	ldd	r31, Y+5	; 0x05
    7736:	83 a1       	ldd	r24, Z+35	; 0x23
    7738:	94 a1       	ldd	r25, Z+36	; 0x24
    773a:	a5 a1       	ldd	r26, Z+37	; 0x25
    773c:	b6 a1       	ldd	r27, Z+38	; 0x26
    773e:	01 96       	adiw	r24, 0x01	; 1
    7740:	a1 1d       	adc	r26, r1
    7742:	b1 1d       	adc	r27, r1
    7744:	ec 81       	ldd	r30, Y+4	; 0x04
    7746:	fd 81       	ldd	r31, Y+5	; 0x05
    7748:	83 a3       	std	Z+35, r24	; 0x23
    774a:	94 a3       	std	Z+36, r25	; 0x24
    774c:	a5 a3       	std	Z+37, r26	; 0x25
    774e:	b6 a3       	std	Z+38, r27	; 0x26
    7750:	1a c0       	rjmp	.+52     	; 0x7786 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    7752:	ec 81       	ldd	r30, Y+4	; 0x04
    7754:	fd 81       	ldd	r31, Y+5	; 0x05
    7756:	88 85       	ldd	r24, Y+8	; 0x08
    7758:	99 85       	ldd	r25, Y+9	; 0x09
    775a:	aa 85       	ldd	r26, Y+10	; 0x0a
    775c:	bb 85       	ldd	r27, Y+11	; 0x0b
    775e:	83 a3       	std	Z+35, r24	; 0x23
    7760:	94 a3       	std	Z+36, r25	; 0x24
    7762:	a5 a3       	std	Z+37, r26	; 0x25
    7764:	b6 a3       	std	Z+38, r27	; 0x26
    7766:	0f c0       	rjmp	.+30     	; 0x7786 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    7768:	8b 81       	ldd	r24, Y+3	; 0x03
    776a:	82 30       	cpi	r24, 0x02	; 2
    776c:	59 f0       	breq	.+22     	; 0x7784 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    776e:	ec 81       	ldd	r30, Y+4	; 0x04
    7770:	fd 81       	ldd	r31, Y+5	; 0x05
    7772:	88 85       	ldd	r24, Y+8	; 0x08
    7774:	99 85       	ldd	r25, Y+9	; 0x09
    7776:	aa 85       	ldd	r26, Y+10	; 0x0a
    7778:	bb 85       	ldd	r27, Y+11	; 0x0b
    777a:	83 a3       	std	Z+35, r24	; 0x23
    777c:	94 a3       	std	Z+36, r25	; 0x24
    777e:	a5 a3       	std	Z+37, r26	; 0x25
    7780:	b6 a3       	std	Z+38, r27	; 0x26
    7782:	01 c0       	rjmp	.+2      	; 0x7786 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    7784:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    7786:	8b 81       	ldd	r24, Y+3	; 0x03
    7788:	81 30       	cpi	r24, 0x01	; 1
    778a:	09 f0       	breq	.+2      	; 0x778e <xTaskGenericNotifyFromISR+0x136>
    778c:	50 c0       	rjmp	.+160    	; 0x782e <xTaskGenericNotifyFromISR+0x1d6>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    778e:	80 91 9e 05 	lds	r24, 0x059E
    7792:	88 23       	and	r24, r24
    7794:	61 f5       	brne	.+88     	; 0x77ee <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7796:	8c 81       	ldd	r24, Y+4	; 0x04
    7798:	9d 81       	ldd	r25, Y+5	; 0x05
    779a:	02 96       	adiw	r24, 0x02	; 2
    779c:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    77a0:	ec 81       	ldd	r30, Y+4	; 0x04
    77a2:	fd 81       	ldd	r31, Y+5	; 0x05
    77a4:	96 89       	ldd	r25, Z+22	; 0x16
    77a6:	80 91 94 05 	lds	r24, 0x0594
    77aa:	89 17       	cp	r24, r25
    77ac:	28 f4       	brcc	.+10     	; 0x77b8 <xTaskGenericNotifyFromISR+0x160>
    77ae:	ec 81       	ldd	r30, Y+4	; 0x04
    77b0:	fd 81       	ldd	r31, Y+5	; 0x05
    77b2:	86 89       	ldd	r24, Z+22	; 0x16
    77b4:	80 93 94 05 	sts	0x0594, r24
    77b8:	ec 81       	ldd	r30, Y+4	; 0x04
    77ba:	fd 81       	ldd	r31, Y+5	; 0x05
    77bc:	86 89       	ldd	r24, Z+22	; 0x16
    77be:	28 2f       	mov	r18, r24
    77c0:	30 e0       	ldi	r19, 0x00	; 0
    77c2:	c9 01       	movw	r24, r18
    77c4:	88 0f       	add	r24, r24
    77c6:	99 1f       	adc	r25, r25
    77c8:	88 0f       	add	r24, r24
    77ca:	99 1f       	adc	r25, r25
    77cc:	88 0f       	add	r24, r24
    77ce:	99 1f       	adc	r25, r25
    77d0:	82 0f       	add	r24, r18
    77d2:	93 1f       	adc	r25, r19
    77d4:	ac 01       	movw	r20, r24
    77d6:	41 56       	subi	r20, 0x61	; 97
    77d8:	5a 4f       	sbci	r21, 0xFA	; 250
    77da:	8c 81       	ldd	r24, Y+4	; 0x04
    77dc:	9d 81       	ldd	r25, Y+5	; 0x05
    77de:	9c 01       	movw	r18, r24
    77e0:	2e 5f       	subi	r18, 0xFE	; 254
    77e2:	3f 4f       	sbci	r19, 0xFF	; 255
    77e4:	ca 01       	movw	r24, r20
    77e6:	b9 01       	movw	r22, r18
    77e8:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
    77ec:	0a c0       	rjmp	.+20     	; 0x7802 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    77ee:	8c 81       	ldd	r24, Y+4	; 0x04
    77f0:	9d 81       	ldd	r25, Y+5	; 0x05
    77f2:	9c 01       	movw	r18, r24
    77f4:	24 5f       	subi	r18, 0xF4	; 244
    77f6:	3f 4f       	sbci	r19, 0xFF	; 255
    77f8:	86 e0       	ldi	r24, 0x06	; 6
    77fa:	96 e0       	ldi	r25, 0x06	; 6
    77fc:	b9 01       	movw	r22, r18
    77fe:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    7802:	ec 81       	ldd	r30, Y+4	; 0x04
    7804:	fd 81       	ldd	r31, Y+5	; 0x05
    7806:	96 89       	ldd	r25, Z+22	; 0x16
    7808:	e0 91 8e 05 	lds	r30, 0x058E
    780c:	f0 91 8f 05 	lds	r31, 0x058F
    7810:	86 89       	ldd	r24, Z+22	; 0x16
    7812:	89 17       	cp	r24, r25
    7814:	60 f4       	brcc	.+24     	; 0x782e <xTaskGenericNotifyFromISR+0x1d6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    7816:	8f 85       	ldd	r24, Y+15	; 0x0f
    7818:	98 89       	ldd	r25, Y+16	; 0x10
    781a:	00 97       	sbiw	r24, 0x00	; 0
    781c:	29 f0       	breq	.+10     	; 0x7828 <xTaskGenericNotifyFromISR+0x1d0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    781e:	ef 85       	ldd	r30, Y+15	; 0x0f
    7820:	f8 89       	ldd	r31, Y+16	; 0x10
    7822:	81 e0       	ldi	r24, 0x01	; 1
    7824:	80 83       	st	Z, r24
    7826:	03 c0       	rjmp	.+6      	; 0x782e <xTaskGenericNotifyFromISR+0x1d6>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    7828:	81 e0       	ldi	r24, 0x01	; 1
    782a:	80 93 97 05 	sts	0x0597, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    782e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    7830:	62 96       	adiw	r28, 0x12	; 18
    7832:	0f b6       	in	r0, 0x3f	; 63
    7834:	f8 94       	cli
    7836:	de bf       	out	0x3e, r29	; 62
    7838:	0f be       	out	0x3f, r0	; 63
    783a:	cd bf       	out	0x3d, r28	; 61
    783c:	cf 91       	pop	r28
    783e:	df 91       	pop	r29
    7840:	1f 91       	pop	r17
    7842:	0f 91       	pop	r16
    7844:	ff 90       	pop	r15
    7846:	ef 90       	pop	r14
    7848:	08 95       	ret

0000784a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    784a:	df 93       	push	r29
    784c:	cf 93       	push	r28
    784e:	cd b7       	in	r28, 0x3d	; 61
    7850:	de b7       	in	r29, 0x3e	; 62
    7852:	28 97       	sbiw	r28, 0x08	; 8
    7854:	0f b6       	in	r0, 0x3f	; 63
    7856:	f8 94       	cli
    7858:	de bf       	out	0x3e, r29	; 62
    785a:	0f be       	out	0x3f, r0	; 63
    785c:	cd bf       	out	0x3d, r28	; 61
    785e:	9e 83       	std	Y+6, r25	; 0x06
    7860:	8d 83       	std	Y+5, r24	; 0x05
    7862:	78 87       	std	Y+8, r23	; 0x08
    7864:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    7866:	8d 81       	ldd	r24, Y+5	; 0x05
    7868:	9e 81       	ldd	r25, Y+6	; 0x06
    786a:	9c 83       	std	Y+4, r25	; 0x04
    786c:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    786e:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    7870:	eb 81       	ldd	r30, Y+3	; 0x03
    7872:	fc 81       	ldd	r31, Y+4	; 0x04
    7874:	87 a1       	ldd	r24, Z+39	; 0x27
    7876:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    7878:	eb 81       	ldd	r30, Y+3	; 0x03
    787a:	fc 81       	ldd	r31, Y+4	; 0x04
    787c:	82 e0       	ldi	r24, 0x02	; 2
    787e:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    7880:	eb 81       	ldd	r30, Y+3	; 0x03
    7882:	fc 81       	ldd	r31, Y+4	; 0x04
    7884:	83 a1       	ldd	r24, Z+35	; 0x23
    7886:	94 a1       	ldd	r25, Z+36	; 0x24
    7888:	a5 a1       	ldd	r26, Z+37	; 0x25
    788a:	b6 a1       	ldd	r27, Z+38	; 0x26
    788c:	01 96       	adiw	r24, 0x01	; 1
    788e:	a1 1d       	adc	r26, r1
    7890:	b1 1d       	adc	r27, r1
    7892:	eb 81       	ldd	r30, Y+3	; 0x03
    7894:	fc 81       	ldd	r31, Y+4	; 0x04
    7896:	83 a3       	std	Z+35, r24	; 0x23
    7898:	94 a3       	std	Z+36, r25	; 0x24
    789a:	a5 a3       	std	Z+37, r26	; 0x25
    789c:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    789e:	8a 81       	ldd	r24, Y+2	; 0x02
    78a0:	81 30       	cpi	r24, 0x01	; 1
    78a2:	09 f0       	breq	.+2      	; 0x78a6 <vTaskNotifyGiveFromISR+0x5c>
    78a4:	50 c0       	rjmp	.+160    	; 0x7946 <vTaskNotifyGiveFromISR+0xfc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    78a6:	80 91 9e 05 	lds	r24, 0x059E
    78aa:	88 23       	and	r24, r24
    78ac:	61 f5       	brne	.+88     	; 0x7906 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    78ae:	8b 81       	ldd	r24, Y+3	; 0x03
    78b0:	9c 81       	ldd	r25, Y+4	; 0x04
    78b2:	02 96       	adiw	r24, 0x02	; 2
    78b4:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    78b8:	eb 81       	ldd	r30, Y+3	; 0x03
    78ba:	fc 81       	ldd	r31, Y+4	; 0x04
    78bc:	96 89       	ldd	r25, Z+22	; 0x16
    78be:	80 91 94 05 	lds	r24, 0x0594
    78c2:	89 17       	cp	r24, r25
    78c4:	28 f4       	brcc	.+10     	; 0x78d0 <vTaskNotifyGiveFromISR+0x86>
    78c6:	eb 81       	ldd	r30, Y+3	; 0x03
    78c8:	fc 81       	ldd	r31, Y+4	; 0x04
    78ca:	86 89       	ldd	r24, Z+22	; 0x16
    78cc:	80 93 94 05 	sts	0x0594, r24
    78d0:	eb 81       	ldd	r30, Y+3	; 0x03
    78d2:	fc 81       	ldd	r31, Y+4	; 0x04
    78d4:	86 89       	ldd	r24, Z+22	; 0x16
    78d6:	28 2f       	mov	r18, r24
    78d8:	30 e0       	ldi	r19, 0x00	; 0
    78da:	c9 01       	movw	r24, r18
    78dc:	88 0f       	add	r24, r24
    78de:	99 1f       	adc	r25, r25
    78e0:	88 0f       	add	r24, r24
    78e2:	99 1f       	adc	r25, r25
    78e4:	88 0f       	add	r24, r24
    78e6:	99 1f       	adc	r25, r25
    78e8:	82 0f       	add	r24, r18
    78ea:	93 1f       	adc	r25, r19
    78ec:	ac 01       	movw	r20, r24
    78ee:	41 56       	subi	r20, 0x61	; 97
    78f0:	5a 4f       	sbci	r21, 0xFA	; 250
    78f2:	8b 81       	ldd	r24, Y+3	; 0x03
    78f4:	9c 81       	ldd	r25, Y+4	; 0x04
    78f6:	9c 01       	movw	r18, r24
    78f8:	2e 5f       	subi	r18, 0xFE	; 254
    78fa:	3f 4f       	sbci	r19, 0xFF	; 255
    78fc:	ca 01       	movw	r24, r20
    78fe:	b9 01       	movw	r22, r18
    7900:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
    7904:	0a c0       	rjmp	.+20     	; 0x791a <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    7906:	8b 81       	ldd	r24, Y+3	; 0x03
    7908:	9c 81       	ldd	r25, Y+4	; 0x04
    790a:	9c 01       	movw	r18, r24
    790c:	24 5f       	subi	r18, 0xF4	; 244
    790e:	3f 4f       	sbci	r19, 0xFF	; 255
    7910:	86 e0       	ldi	r24, 0x06	; 6
    7912:	96 e0       	ldi	r25, 0x06	; 6
    7914:	b9 01       	movw	r22, r18
    7916:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    791a:	eb 81       	ldd	r30, Y+3	; 0x03
    791c:	fc 81       	ldd	r31, Y+4	; 0x04
    791e:	96 89       	ldd	r25, Z+22	; 0x16
    7920:	e0 91 8e 05 	lds	r30, 0x058E
    7924:	f0 91 8f 05 	lds	r31, 0x058F
    7928:	86 89       	ldd	r24, Z+22	; 0x16
    792a:	89 17       	cp	r24, r25
    792c:	60 f4       	brcc	.+24     	; 0x7946 <vTaskNotifyGiveFromISR+0xfc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    792e:	8f 81       	ldd	r24, Y+7	; 0x07
    7930:	98 85       	ldd	r25, Y+8	; 0x08
    7932:	00 97       	sbiw	r24, 0x00	; 0
    7934:	29 f0       	breq	.+10     	; 0x7940 <vTaskNotifyGiveFromISR+0xf6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    7936:	ef 81       	ldd	r30, Y+7	; 0x07
    7938:	f8 85       	ldd	r31, Y+8	; 0x08
    793a:	81 e0       	ldi	r24, 0x01	; 1
    793c:	80 83       	st	Z, r24
    793e:	03 c0       	rjmp	.+6      	; 0x7946 <vTaskNotifyGiveFromISR+0xfc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    7940:	81 e0       	ldi	r24, 0x01	; 1
    7942:	80 93 97 05 	sts	0x0597, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    7946:	28 96       	adiw	r28, 0x08	; 8
    7948:	0f b6       	in	r0, 0x3f	; 63
    794a:	f8 94       	cli
    794c:	de bf       	out	0x3e, r29	; 62
    794e:	0f be       	out	0x3f, r0	; 63
    7950:	cd bf       	out	0x3d, r28	; 61
    7952:	cf 91       	pop	r28
    7954:	df 91       	pop	r29
    7956:	08 95       	ret

00007958 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    7958:	df 93       	push	r29
    795a:	cf 93       	push	r28
    795c:	cd b7       	in	r28, 0x3d	; 61
    795e:	de b7       	in	r29, 0x3e	; 62
    7960:	27 97       	sbiw	r28, 0x07	; 7
    7962:	0f b6       	in	r0, 0x3f	; 63
    7964:	f8 94       	cli
    7966:	de bf       	out	0x3e, r29	; 62
    7968:	0f be       	out	0x3f, r0	; 63
    796a:	cd bf       	out	0x3d, r28	; 61
    796c:	9d 83       	std	Y+5, r25	; 0x05
    796e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    7970:	8c 81       	ldd	r24, Y+4	; 0x04
    7972:	9d 81       	ldd	r25, Y+5	; 0x05
    7974:	00 97       	sbiw	r24, 0x00	; 0
    7976:	39 f4       	brne	.+14     	; 0x7986 <xTaskNotifyStateClear+0x2e>
    7978:	80 91 8e 05 	lds	r24, 0x058E
    797c:	90 91 8f 05 	lds	r25, 0x058F
    7980:	9f 83       	std	Y+7, r25	; 0x07
    7982:	8e 83       	std	Y+6, r24	; 0x06
    7984:	04 c0       	rjmp	.+8      	; 0x798e <xTaskNotifyStateClear+0x36>
    7986:	8c 81       	ldd	r24, Y+4	; 0x04
    7988:	9d 81       	ldd	r25, Y+5	; 0x05
    798a:	9f 83       	std	Y+7, r25	; 0x07
    798c:	8e 83       	std	Y+6, r24	; 0x06
    798e:	8e 81       	ldd	r24, Y+6	; 0x06
    7990:	9f 81       	ldd	r25, Y+7	; 0x07
    7992:	9b 83       	std	Y+3, r25	; 0x03
    7994:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    7996:	0f b6       	in	r0, 0x3f	; 63
    7998:	f8 94       	cli
    799a:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    799c:	ea 81       	ldd	r30, Y+2	; 0x02
    799e:	fb 81       	ldd	r31, Y+3	; 0x03
    79a0:	87 a1       	ldd	r24, Z+39	; 0x27
    79a2:	82 30       	cpi	r24, 0x02	; 2
    79a4:	31 f4       	brne	.+12     	; 0x79b2 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    79a6:	ea 81       	ldd	r30, Y+2	; 0x02
    79a8:	fb 81       	ldd	r31, Y+3	; 0x03
    79aa:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    79ac:	81 e0       	ldi	r24, 0x01	; 1
    79ae:	89 83       	std	Y+1, r24	; 0x01
    79b0:	01 c0       	rjmp	.+2      	; 0x79b4 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    79b2:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    79b4:	0f 90       	pop	r0
    79b6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    79b8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    79ba:	27 96       	adiw	r28, 0x07	; 7
    79bc:	0f b6       	in	r0, 0x3f	; 63
    79be:	f8 94       	cli
    79c0:	de bf       	out	0x3e, r29	; 62
    79c2:	0f be       	out	0x3f, r0	; 63
    79c4:	cd bf       	out	0x3d, r28	; 61
    79c6:	cf 91       	pop	r28
    79c8:	df 91       	pop	r29
    79ca:	08 95       	ret

000079cc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    79cc:	df 93       	push	r29
    79ce:	cf 93       	push	r28
    79d0:	cd b7       	in	r28, 0x3d	; 61
    79d2:	de b7       	in	r29, 0x3e	; 62
    79d4:	27 97       	sbiw	r28, 0x07	; 7
    79d6:	0f b6       	in	r0, 0x3f	; 63
    79d8:	f8 94       	cli
    79da:	de bf       	out	0x3e, r29	; 62
    79dc:	0f be       	out	0x3f, r0	; 63
    79de:	cd bf       	out	0x3d, r28	; 61
    79e0:	9e 83       	std	Y+6, r25	; 0x06
    79e2:	8d 83       	std	Y+5, r24	; 0x05
    79e4:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    79e6:	80 91 92 05 	lds	r24, 0x0592
    79ea:	90 91 93 05 	lds	r25, 0x0593
    79ee:	9a 83       	std	Y+2, r25	; 0x02
    79f0:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    79f2:	80 91 8e 05 	lds	r24, 0x058E
    79f6:	90 91 8f 05 	lds	r25, 0x058F
    79fa:	02 96       	adiw	r24, 0x02	; 2
    79fc:	0e 94 b6 24 	call	0x496c	; 0x496c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    7a00:	8d 81       	ldd	r24, Y+5	; 0x05
    7a02:	9e 81       	ldd	r25, Y+6	; 0x06
    7a04:	2f ef       	ldi	r18, 0xFF	; 255
    7a06:	8f 3f       	cpi	r24, 0xFF	; 255
    7a08:	92 07       	cpc	r25, r18
    7a0a:	81 f4       	brne	.+32     	; 0x7a2c <prvAddCurrentTaskToDelayedList+0x60>
    7a0c:	8f 81       	ldd	r24, Y+7	; 0x07
    7a0e:	88 23       	and	r24, r24
    7a10:	69 f0       	breq	.+26     	; 0x7a2c <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7a12:	80 91 8e 05 	lds	r24, 0x058E
    7a16:	90 91 8f 05 	lds	r25, 0x058F
    7a1a:	9c 01       	movw	r18, r24
    7a1c:	2e 5f       	subi	r18, 0xFE	; 254
    7a1e:	3f 4f       	sbci	r19, 0xFF	; 255
    7a20:	88 e1       	ldi	r24, 0x18	; 24
    7a22:	96 e0       	ldi	r25, 0x06	; 6
    7a24:	b9 01       	movw	r22, r18
    7a26:	0e 94 06 24 	call	0x480c	; 0x480c <vListInsertEnd>
    7a2a:	43 c0       	rjmp	.+134    	; 0x7ab2 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    7a2c:	29 81       	ldd	r18, Y+1	; 0x01
    7a2e:	3a 81       	ldd	r19, Y+2	; 0x02
    7a30:	8d 81       	ldd	r24, Y+5	; 0x05
    7a32:	9e 81       	ldd	r25, Y+6	; 0x06
    7a34:	82 0f       	add	r24, r18
    7a36:	93 1f       	adc	r25, r19
    7a38:	9c 83       	std	Y+4, r25	; 0x04
    7a3a:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    7a3c:	e0 91 8e 05 	lds	r30, 0x058E
    7a40:	f0 91 8f 05 	lds	r31, 0x058F
    7a44:	8b 81       	ldd	r24, Y+3	; 0x03
    7a46:	9c 81       	ldd	r25, Y+4	; 0x04
    7a48:	93 83       	std	Z+3, r25	; 0x03
    7a4a:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    7a4c:	2b 81       	ldd	r18, Y+3	; 0x03
    7a4e:	3c 81       	ldd	r19, Y+4	; 0x04
    7a50:	89 81       	ldd	r24, Y+1	; 0x01
    7a52:	9a 81       	ldd	r25, Y+2	; 0x02
    7a54:	28 17       	cp	r18, r24
    7a56:	39 07       	cpc	r19, r25
    7a58:	70 f4       	brcc	.+28     	; 0x7a76 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7a5a:	80 91 04 06 	lds	r24, 0x0604
    7a5e:	90 91 05 06 	lds	r25, 0x0605
    7a62:	20 91 8e 05 	lds	r18, 0x058E
    7a66:	30 91 8f 05 	lds	r19, 0x058F
    7a6a:	2e 5f       	subi	r18, 0xFE	; 254
    7a6c:	3f 4f       	sbci	r19, 0xFF	; 255
    7a6e:	b9 01       	movw	r22, r18
    7a70:	0e 94 4a 24 	call	0x4894	; 0x4894 <vListInsert>
    7a74:	1e c0       	rjmp	.+60     	; 0x7ab2 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7a76:	40 91 02 06 	lds	r20, 0x0602
    7a7a:	50 91 03 06 	lds	r21, 0x0603
    7a7e:	80 91 8e 05 	lds	r24, 0x058E
    7a82:	90 91 8f 05 	lds	r25, 0x058F
    7a86:	9c 01       	movw	r18, r24
    7a88:	2e 5f       	subi	r18, 0xFE	; 254
    7a8a:	3f 4f       	sbci	r19, 0xFF	; 255
    7a8c:	ca 01       	movw	r24, r20
    7a8e:	b9 01       	movw	r22, r18
    7a90:	0e 94 4a 24 	call	0x4894	; 0x4894 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    7a94:	20 91 9a 05 	lds	r18, 0x059A
    7a98:	30 91 9b 05 	lds	r19, 0x059B
    7a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    7a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    7aa0:	82 17       	cp	r24, r18
    7aa2:	93 07       	cpc	r25, r19
    7aa4:	30 f4       	brcc	.+12     	; 0x7ab2 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    7aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    7aa8:	9c 81       	ldd	r25, Y+4	; 0x04
    7aaa:	90 93 9b 05 	sts	0x059B, r25
    7aae:	80 93 9a 05 	sts	0x059A, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    7ab2:	27 96       	adiw	r28, 0x07	; 7
    7ab4:	0f b6       	in	r0, 0x3f	; 63
    7ab6:	f8 94       	cli
    7ab8:	de bf       	out	0x3e, r29	; 62
    7aba:	0f be       	out	0x3f, r0	; 63
    7abc:	cd bf       	out	0x3d, r28	; 61
    7abe:	cf 91       	pop	r28
    7ac0:	df 91       	pop	r29
    7ac2:	08 95       	ret

00007ac4 <main>:
#include "../MCAL/DIO/DIO.h"
#include "../MCAL/Timer 0/Timer_0.h"
#include "../SERVICE/ICU_Interface.h"
#include "../HAL/Ultrasonic_Sensor/Ultrasonic_Sensor.h"
#define stop 30
int main(void) {
    7ac4:	df 93       	push	r29
    7ac6:	cf 93       	push	r28
    7ac8:	00 d0       	rcall	.+0      	; 0x7aca <main+0x6>
    7aca:	00 d0       	rcall	.+0      	; 0x7acc <main+0x8>
    7acc:	cd b7       	in	r28, 0x3d	; 61
    7ace:	de b7       	in	r29, 0x3e	; 62
	f32 x=0;
    7ad0:	80 e0       	ldi	r24, 0x00	; 0
    7ad2:	90 e0       	ldi	r25, 0x00	; 0
    7ad4:	a0 e0       	ldi	r26, 0x00	; 0
    7ad6:	b0 e0       	ldi	r27, 0x00	; 0
    7ad8:	89 83       	std	Y+1, r24	; 0x01
    7ada:	9a 83       	std	Y+2, r25	; 0x02
    7adc:	ab 83       	std	Y+3, r26	; 0x03
    7ade:	bc 83       	std	Y+4, r27	; 0x04
	    SET_BIT(DDRD,Pin3);
    7ae0:	a1 e3       	ldi	r26, 0x31	; 49
    7ae2:	b0 e0       	ldi	r27, 0x00	; 0
    7ae4:	e1 e3       	ldi	r30, 0x31	; 49
    7ae6:	f0 e0       	ldi	r31, 0x00	; 0
    7ae8:	80 81       	ld	r24, Z
    7aea:	88 60       	ori	r24, 0x08	; 8
    7aec:	8c 93       	st	X, r24
	  	 SET_BIT(SREG,Pin7);
    7aee:	af e5       	ldi	r26, 0x5F	; 95
    7af0:	b0 e0       	ldi	r27, 0x00	; 0
    7af2:	ef e5       	ldi	r30, 0x5F	; 95
    7af4:	f0 e0       	ldi	r31, 0x00	; 0
    7af6:	80 81       	ld	r24, Z
    7af8:	80 68       	ori	r24, 0x80	; 128
    7afa:	8c 93       	st	X, r24
	    ultrasonic_init();
    7afc:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <ultrasonic_init>
	    MCAL_Timer0_Init(Normal_Mode,Prescaller_64,Non_Inverted);
    7b00:	80 e0       	ldi	r24, 0x00	; 0
    7b02:	63 e0       	ldi	r22, 0x03	; 3
    7b04:	42 e0       	ldi	r20, 0x02	; 2
    7b06:	0e 94 70 08 	call	0x10e0	; 0x10e0 <MCAL_Timer0_Init>
	    MCAL_Timer0_SetPreloadValue(113);
    7b0a:	81 e7       	ldi	r24, 0x71	; 113
    7b0c:	0e 94 37 0a 	call	0x146e	; 0x146e <MCAL_Timer0_SetPreloadValue>
	    while(1){
	    	ultrasonic_get_Distance(&x);
    7b10:	ce 01       	movw	r24, r28
    7b12:	01 96       	adiw	r24, 0x01	; 1
    7b14:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <ultrasonic_get_Distance>
	    	if(x>100){
    7b18:	89 81       	ldd	r24, Y+1	; 0x01
    7b1a:	9a 81       	ldd	r25, Y+2	; 0x02
    7b1c:	ab 81       	ldd	r26, Y+3	; 0x03
    7b1e:	bc 81       	ldd	r27, Y+4	; 0x04
    7b20:	bc 01       	movw	r22, r24
    7b22:	cd 01       	movw	r24, r26
    7b24:	20 e0       	ldi	r18, 0x00	; 0
    7b26:	30 e0       	ldi	r19, 0x00	; 0
    7b28:	48 ec       	ldi	r20, 0xC8	; 200
    7b2a:	52 e4       	ldi	r21, 0x42	; 66
    7b2c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7b30:	18 16       	cp	r1, r24
    7b32:	44 f4       	brge	.+16     	; 0x7b44 <main+0x80>
	    		SET_BIT(PORTD,Pin3);
    7b34:	a2 e3       	ldi	r26, 0x32	; 50
    7b36:	b0 e0       	ldi	r27, 0x00	; 0
    7b38:	e2 e3       	ldi	r30, 0x32	; 50
    7b3a:	f0 e0       	ldi	r31, 0x00	; 0
    7b3c:	80 81       	ld	r24, Z
    7b3e:	88 60       	ori	r24, 0x08	; 8
    7b40:	8c 93       	st	X, r24
    7b42:	e6 cf       	rjmp	.-52     	; 0x7b10 <main+0x4c>
	    	}else {
	    		CLR_BIT(PORTD,Pin3);
    7b44:	a2 e3       	ldi	r26, 0x32	; 50
    7b46:	b0 e0       	ldi	r27, 0x00	; 0
    7b48:	e2 e3       	ldi	r30, 0x32	; 50
    7b4a:	f0 e0       	ldi	r31, 0x00	; 0
    7b4c:	80 81       	ld	r24, Z
    7b4e:	87 7f       	andi	r24, 0xF7	; 247
    7b50:	8c 93       	st	X, r24
    7b52:	de cf       	rjmp	.-68     	; 0x7b10 <main+0x4c>

00007b54 <__mulsi3>:
    7b54:	62 9f       	mul	r22, r18
    7b56:	d0 01       	movw	r26, r0
    7b58:	73 9f       	mul	r23, r19
    7b5a:	f0 01       	movw	r30, r0
    7b5c:	82 9f       	mul	r24, r18
    7b5e:	e0 0d       	add	r30, r0
    7b60:	f1 1d       	adc	r31, r1
    7b62:	64 9f       	mul	r22, r20
    7b64:	e0 0d       	add	r30, r0
    7b66:	f1 1d       	adc	r31, r1
    7b68:	92 9f       	mul	r25, r18
    7b6a:	f0 0d       	add	r31, r0
    7b6c:	83 9f       	mul	r24, r19
    7b6e:	f0 0d       	add	r31, r0
    7b70:	74 9f       	mul	r23, r20
    7b72:	f0 0d       	add	r31, r0
    7b74:	65 9f       	mul	r22, r21
    7b76:	f0 0d       	add	r31, r0
    7b78:	99 27       	eor	r25, r25
    7b7a:	72 9f       	mul	r23, r18
    7b7c:	b0 0d       	add	r27, r0
    7b7e:	e1 1d       	adc	r30, r1
    7b80:	f9 1f       	adc	r31, r25
    7b82:	63 9f       	mul	r22, r19
    7b84:	b0 0d       	add	r27, r0
    7b86:	e1 1d       	adc	r30, r1
    7b88:	f9 1f       	adc	r31, r25
    7b8a:	bd 01       	movw	r22, r26
    7b8c:	cf 01       	movw	r24, r30
    7b8e:	11 24       	eor	r1, r1
    7b90:	08 95       	ret

00007b92 <__prologue_saves__>:
    7b92:	2f 92       	push	r2
    7b94:	3f 92       	push	r3
    7b96:	4f 92       	push	r4
    7b98:	5f 92       	push	r5
    7b9a:	6f 92       	push	r6
    7b9c:	7f 92       	push	r7
    7b9e:	8f 92       	push	r8
    7ba0:	9f 92       	push	r9
    7ba2:	af 92       	push	r10
    7ba4:	bf 92       	push	r11
    7ba6:	cf 92       	push	r12
    7ba8:	df 92       	push	r13
    7baa:	ef 92       	push	r14
    7bac:	ff 92       	push	r15
    7bae:	0f 93       	push	r16
    7bb0:	1f 93       	push	r17
    7bb2:	cf 93       	push	r28
    7bb4:	df 93       	push	r29
    7bb6:	cd b7       	in	r28, 0x3d	; 61
    7bb8:	de b7       	in	r29, 0x3e	; 62
    7bba:	ca 1b       	sub	r28, r26
    7bbc:	db 0b       	sbc	r29, r27
    7bbe:	0f b6       	in	r0, 0x3f	; 63
    7bc0:	f8 94       	cli
    7bc2:	de bf       	out	0x3e, r29	; 62
    7bc4:	0f be       	out	0x3f, r0	; 63
    7bc6:	cd bf       	out	0x3d, r28	; 61
    7bc8:	09 94       	ijmp

00007bca <__epilogue_restores__>:
    7bca:	2a 88       	ldd	r2, Y+18	; 0x12
    7bcc:	39 88       	ldd	r3, Y+17	; 0x11
    7bce:	48 88       	ldd	r4, Y+16	; 0x10
    7bd0:	5f 84       	ldd	r5, Y+15	; 0x0f
    7bd2:	6e 84       	ldd	r6, Y+14	; 0x0e
    7bd4:	7d 84       	ldd	r7, Y+13	; 0x0d
    7bd6:	8c 84       	ldd	r8, Y+12	; 0x0c
    7bd8:	9b 84       	ldd	r9, Y+11	; 0x0b
    7bda:	aa 84       	ldd	r10, Y+10	; 0x0a
    7bdc:	b9 84       	ldd	r11, Y+9	; 0x09
    7bde:	c8 84       	ldd	r12, Y+8	; 0x08
    7be0:	df 80       	ldd	r13, Y+7	; 0x07
    7be2:	ee 80       	ldd	r14, Y+6	; 0x06
    7be4:	fd 80       	ldd	r15, Y+5	; 0x05
    7be6:	0c 81       	ldd	r16, Y+4	; 0x04
    7be8:	1b 81       	ldd	r17, Y+3	; 0x03
    7bea:	aa 81       	ldd	r26, Y+2	; 0x02
    7bec:	b9 81       	ldd	r27, Y+1	; 0x01
    7bee:	ce 0f       	add	r28, r30
    7bf0:	d1 1d       	adc	r29, r1
    7bf2:	0f b6       	in	r0, 0x3f	; 63
    7bf4:	f8 94       	cli
    7bf6:	de bf       	out	0x3e, r29	; 62
    7bf8:	0f be       	out	0x3f, r0	; 63
    7bfa:	cd bf       	out	0x3d, r28	; 61
    7bfc:	ed 01       	movw	r28, r26
    7bfe:	08 95       	ret

00007c00 <memcpy>:
    7c00:	fb 01       	movw	r30, r22
    7c02:	dc 01       	movw	r26, r24
    7c04:	02 c0       	rjmp	.+4      	; 0x7c0a <memcpy+0xa>
    7c06:	01 90       	ld	r0, Z+
    7c08:	0d 92       	st	X+, r0
    7c0a:	41 50       	subi	r20, 0x01	; 1
    7c0c:	50 40       	sbci	r21, 0x00	; 0
    7c0e:	d8 f7       	brcc	.-10     	; 0x7c06 <memcpy+0x6>
    7c10:	08 95       	ret

00007c12 <itoa>:
    7c12:	fb 01       	movw	r30, r22
    7c14:	9f 01       	movw	r18, r30
    7c16:	e8 94       	clt
    7c18:	42 30       	cpi	r20, 0x02	; 2
    7c1a:	c4 f0       	brlt	.+48     	; 0x7c4c <itoa+0x3a>
    7c1c:	45 32       	cpi	r20, 0x25	; 37
    7c1e:	b4 f4       	brge	.+44     	; 0x7c4c <itoa+0x3a>
    7c20:	4a 30       	cpi	r20, 0x0A	; 10
    7c22:	29 f4       	brne	.+10     	; 0x7c2e <itoa+0x1c>
    7c24:	97 fb       	bst	r25, 7
    7c26:	1e f4       	brtc	.+6      	; 0x7c2e <itoa+0x1c>
    7c28:	90 95       	com	r25
    7c2a:	81 95       	neg	r24
    7c2c:	9f 4f       	sbci	r25, 0xFF	; 255
    7c2e:	64 2f       	mov	r22, r20
    7c30:	77 27       	eor	r23, r23
    7c32:	0e 94 3a 3e 	call	0x7c74	; 0x7c74 <__udivmodhi4>
    7c36:	80 5d       	subi	r24, 0xD0	; 208
    7c38:	8a 33       	cpi	r24, 0x3A	; 58
    7c3a:	0c f0       	brlt	.+2      	; 0x7c3e <itoa+0x2c>
    7c3c:	89 5d       	subi	r24, 0xD9	; 217
    7c3e:	81 93       	st	Z+, r24
    7c40:	cb 01       	movw	r24, r22
    7c42:	00 97       	sbiw	r24, 0x00	; 0
    7c44:	a1 f7       	brne	.-24     	; 0x7c2e <itoa+0x1c>
    7c46:	16 f4       	brtc	.+4      	; 0x7c4c <itoa+0x3a>
    7c48:	5d e2       	ldi	r21, 0x2D	; 45
    7c4a:	51 93       	st	Z+, r21
    7c4c:	10 82       	st	Z, r1
    7c4e:	c9 01       	movw	r24, r18
    7c50:	0c 94 2a 3e 	jmp	0x7c54	; 0x7c54 <strrev>

00007c54 <strrev>:
    7c54:	dc 01       	movw	r26, r24
    7c56:	fc 01       	movw	r30, r24
    7c58:	67 2f       	mov	r22, r23
    7c5a:	71 91       	ld	r23, Z+
    7c5c:	77 23       	and	r23, r23
    7c5e:	e1 f7       	brne	.-8      	; 0x7c58 <strrev+0x4>
    7c60:	32 97       	sbiw	r30, 0x02	; 2
    7c62:	04 c0       	rjmp	.+8      	; 0x7c6c <strrev+0x18>
    7c64:	7c 91       	ld	r23, X
    7c66:	6d 93       	st	X+, r22
    7c68:	70 83       	st	Z, r23
    7c6a:	62 91       	ld	r22, -Z
    7c6c:	ae 17       	cp	r26, r30
    7c6e:	bf 07       	cpc	r27, r31
    7c70:	c8 f3       	brcs	.-14     	; 0x7c64 <strrev+0x10>
    7c72:	08 95       	ret

00007c74 <__udivmodhi4>:
    7c74:	aa 1b       	sub	r26, r26
    7c76:	bb 1b       	sub	r27, r27
    7c78:	51 e1       	ldi	r21, 0x11	; 17
    7c7a:	07 c0       	rjmp	.+14     	; 0x7c8a <__udivmodhi4_ep>

00007c7c <__udivmodhi4_loop>:
    7c7c:	aa 1f       	adc	r26, r26
    7c7e:	bb 1f       	adc	r27, r27
    7c80:	a6 17       	cp	r26, r22
    7c82:	b7 07       	cpc	r27, r23
    7c84:	10 f0       	brcs	.+4      	; 0x7c8a <__udivmodhi4_ep>
    7c86:	a6 1b       	sub	r26, r22
    7c88:	b7 0b       	sbc	r27, r23

00007c8a <__udivmodhi4_ep>:
    7c8a:	88 1f       	adc	r24, r24
    7c8c:	99 1f       	adc	r25, r25
    7c8e:	5a 95       	dec	r21
    7c90:	a9 f7       	brne	.-22     	; 0x7c7c <__udivmodhi4_loop>
    7c92:	80 95       	com	r24
    7c94:	90 95       	com	r25
    7c96:	bc 01       	movw	r22, r24
    7c98:	cd 01       	movw	r24, r26
    7c9a:	08 95       	ret

00007c9c <_exit>:
    7c9c:	f8 94       	cli

00007c9e <__stop_program>:
    7c9e:	ff cf       	rjmp	.-2      	; 0x7c9e <__stop_program>
